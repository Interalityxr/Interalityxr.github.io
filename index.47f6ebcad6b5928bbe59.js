(function(){var __webpack_modules__={862:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,{Xv:function(){return wO}});function s(u,a){return a.forEach(function(c){c&&typeof c!="string"&&!Array.isArray(c)&&Object.keys(c).forEach(function(p){if(p!=="default"&&!(p in u)){var m=Object.getOwnPropertyDescriptor(c,p);Object.defineProperty(u,p,m.get?m:{enumerable:!0,get:function(){return c[p]}})}})}),Object.freeze(u)}const E=1e-7,f=1e-4;class Z{constructor(a,c){this.backend=a,this.dataMover=c,this.data=new WeakMap,this.dataIdsCount=0}get(a){return this.data.has(a)||this.dataMover.moveData(this.backend,a),this.data.get(a)}set(a,c){this.dataIdsCount++,this.data.set(a,c)}has(a){return this.data.has(a)}delete(a){return this.dataIdsCount--,this.data.delete(a)}numDataIds(){return this.dataIdsCount}}class L{refCount(a){return F("refCount")}incRef(a){return F("incRef")}timerAvailable(){return!0}time(a){return F("time")}read(a){return F("read")}readSync(a){return F("readSync")}readToGPU(a,c){return F("readToGPU")}numDataIds(){return F("numDataIds")}disposeData(a,c){return F("disposeData")}write(a,c,p){return F("write")}move(a,c,p,m,v){return F("move")}createTensorFromGPUData(a,c,p){return F("createTensorFromGPUData")}memory(){return F("memory")}floatPrecision(){return F("floatPrecision")}epsilon(){return this.floatPrecision()===32?E:f}dispose(){return F("dispose")}}function F(u){throw new Error("'"+u+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function o(u,a,c){return Math.max(u,Math.min(a,c))}function n(u){return u%2===0?u:u+1}function l(u,a,c){const p=u[a];u[a]=u[c],u[c]=p}function h(u){let a=0;for(let c=0;c<u.length;c++)a+=u[c];return a}function i(u,a){if(!u)throw new Error(typeof a=="string"?a:a())}function t(u,a,c=""){i(z(u,a),()=>c+(" Shapes "+u+" and "+a+" must match"))}function U(u){i(u!=null,()=>"The input to the tensor constructor must be a non-null value.")}function G(u){if(u.length===0)return 1;let a=u[0];for(let c=1;c<u.length;c++)a*=u[c];return a}function z(u,a){if(u===a)return!0;if(u==null||a==null||u.length!==a.length)return!1;for(let c=0;c<u.length;c++)if(u[c]!==a[c])return!1;return!0}function W(u){return u%1===0}function C(u){const a=Math.ceil(Math.sqrt(u));return[a,Math.ceil(u/a)]}function x(u,a){return a<=u.length?u:u+" ".repeat(a-u.length)}function M(u,a=m=>0,c,p){return new Promise((m,v)=>{let b=0;const w=()=>{if(u()){m();return}b++;const S=a(b);if(c!=null&&b>=c){v();return}p!=null?p(w,S):setTimeout(w,S)};w()})}function V(u,a){let c=1,p=-1;for(let v=0;v<u.length;++v)if(u[v]>=0)c*=u[v];else if(u[v]===-1){if(p!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+p+" and dim "+v);p=v}else if(u[v]<0)throw Error("Shapes can not be < 0. Found "+u[v]+" at dim "+v);if(p===-1){if(a>0&&a!==c)throw Error("Size("+a+") must match the product of shape "+u);return u}if(c===0)throw Error("Cannot infer the missing size in ["+u+"] when there are 0 elements");if(a%c!==0)throw Error("The implicit shape can't be a fractional number. Got "+a+" / "+c);const m=u.slice();return m[p]=a/c,m}function P(u,a){const c=a.length;return u=u==null?a.map((p,m)=>m):[].concat(u),i(u.every(p=>p>=-c&&p<c),()=>"All values in axis param must be in range [-"+c+", "+c+") but got axis "+u),i(u.every(p=>W(p)),()=>"All values in axis param must be integers but got axis "+u),u.map(p=>p<0?c+p:p)}function T(u,a){const c=[],p=[],m=a!=null&&Array.isArray(a)&&a.length===0,v=a==null||m?null:P(a,u).sort();let b=0;for(let w=0;w<u.length;++w){if(v!=null){if(v[b]===w&&u[w]!==1)throw new Error("Can't squeeze axis "+w+" since its dim '"+u[w]+"' is not 1");(v[b]==null||v[b]>w)&&u[w]===1&&(c.push(u[w]),p.push(w)),v[b]<=w&&b++}u[w]!==1&&(c.push(u[w]),p.push(w))}return{newShape:c,keptDims:p}}function e(u,a){return N(u,a)}function N(u,a){let c=null;if(u==null||u==="float32")c=new Float32Array(a);else if(u==="int32")c=new Int32Array(a);else if(u==="bool")c=new Uint8Array(a);else if(u==="string")c=new Array(a);else throw new Error("Unknown data type "+u);return c}function H0(u,a){for(let c=0;c<u.length;c++){const p=u[c];if(isNaN(p)||!isFinite(p))throw Error("A tensor of type "+a+" being uploaded contains "+p+".")}}function H1(u){return u==="bool"||u==="complex64"||u==="float32"||u==="int32"||u==="string"}function H2(u,a){return!(a==="complex64"||a==="float32"&&u!=="complex64"||a==="int32"&&u!=="float32"&&u!=="complex64"||a==="bool"&&u==="bool")}function H3(u){if(u==="float32"||u==="int32")return 4;if(u==="complex64")return 8;if(u==="bool")return 1;throw new Error("Unknown dtype "+u)}function H4(u){if(u==null)return 0;let a=0;return u.forEach(c=>a+=c.length),a}function H5(u){return typeof u=="string"||u instanceof String}function H6(u){return typeof u=="boolean"}function H7(u){return typeof u=="number"}function H8(u){return Array.isArray(u)?H8(u[0]):u instanceof Float32Array?"float32":u instanceof Int32Array||u instanceof Uint8Array||u instanceof Uint8ClampedArray?"int32":H7(u)?"float32":H5(u)?"string":H6(u)?"bool":"float32"}function H9(u){return!!(u&&u.constructor&&u.call&&u.apply)}function HH(u,a){for(let c=a;c<u;++c)if(u%c===0)return c;return u}function HD(u){const a=u.length;if(a<2)return[];const c=new Array(a-1);c[a-2]=u[a-1];for(let p=a-3;p>=0;--p)c[p]=c[p+1]*u[p+1];return c}function Hy(u,a,c,p=!1){const m=new Array;if(a.length===1){const v=a[0]*(p?2:1);for(let b=0;b<v;b++)m[b]=c[u+b]}else{const v=a[0],b=a.slice(1),w=b.reduce((S,O)=>S*O)*(p?2:1);for(let S=0;S<v;S++)m[S]=Hy(u+S*w,b,c,p)}return m}function Ha(u,a,c=!1){if(u.length===0)return a[0];const p=u.reduce((m,v)=>m*v)*(c?2:1);if(p===0)return[];if(p!==a.length)throw new Error("["+u+"] does not match the input size "+a.length+(c?" for a complex tensor":"")+".");return Hy(0,u,a,c)}function Hs(u,a){if(Array.isArray(u))return u;if(a==="float32")return u instanceof Float32Array?u:new Float32Array(u);if(a==="int32")return u instanceof Int32Array?u:new Int32Array(u);if(a==="bool"||a==="string")return Uint8Array.from(new Int32Array(u));throw new Error("Unknown dtype "+a)}function HI(u,a){const c=HE(u,a);for(let p=0;p<c.length;p++)c[p]=1;return c}function HE(u,a){if(a==null||a==="float32"||a==="complex64")return new Float32Array(u);if(a==="int32")return new Int32Array(u);if(a==="bool")return new Uint8Array(u);throw new Error("Unknown data type "+a)}function Hf(u){u.forEach(a=>{i(Number.isInteger(a)&&a>=0,()=>"Tensor must have a shape comprised of positive integers but got shape ["+u+"].")})}function HO(u,a,c){if(a===0)return 0;if(a===1)return u[0];let p=u[u.length-1];for(let m=0;m<u.length-1;++m)p+=c[m]*u[m];return p}function Hc(u,a,c){if(a===0)return[];if(a===1)return[u];const p=new Array(a);for(let m=0;m<p.length-1;++m)p[m]=Math.floor(u/c[m]),u-=p[m]*c[m];return p[p.length-1]=u,p}function HZ(u){return u&&u.then&&typeof u.then=="function"}const HL="tfjsflags";class Hq{constructor(a){this.global=a,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=HF,this.populateURLFlags()}setPlatform(a,c){this.platform!=null&&(Hn().getBool("IS_TEST")||Hn().getBool("PROD")||console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+a+".")),this.platformName=a,this.platform=c}registerFlag(a,c,p){if(this.flagRegistry[a]={evaluationFn:c,setHook:p},this.urlFlags[a]!=null){const m=this.urlFlags[a];Hn().getBool("IS_TEST")||Hn().getBool("PROD")||console.warn("Setting feature override from URL "+a+": "+m+"."),this.set(a,m)}}async getAsync(a){return a in this.flags?this.flags[a]:(this.flags[a]=await this.evaluateFlag(a),this.flags[a])}get(a){if(a in this.flags)return this.flags[a];const c=this.evaluateFlag(a);if(HZ(c))throw new Error("Flag "+a+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[a]=c,this.flags[a]}getNumber(a){return this.get(a)}getBool(a){return this.get(a)}getString(a){return this.get(a)}getFlags(){return this.flags}get features(){return this.flags}set(a,c){if(this.flagRegistry[a]==null)throw new Error("Cannot set flag "+a+" as it has not been registered.");this.flags[a]=c,this.flagRegistry[a].setHook!=null&&this.flagRegistry[a].setHook(c)}evaluateFlag(a){if(this.flagRegistry[a]==null)throw new Error("Cannot evaluate flag '"+a+"': no evaluation function found.");return this.flagRegistry[a].evaluationFn()}setFlags(a){this.flags=Object.assign({},a)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const a=this.getQueryParams(this.global.location.search);HL in a&&a[HL].split(",").forEach(c=>{const[p,m]=c.split(":");this.urlFlags[p]=Ho(p,m)})}}function HF(u){const a={};return u.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(c,...p)=>(HY(a,p[0],p[1]),p.join("="))),a}function HY(u,a,c){u[decodeURIComponent(a)]=decodeURIComponent(c||"")}function Ho(u,a){const c=a.toLowerCase();return c==="true"||c==="false"?c==="true":""+ +c===c?+c:a}function Hn(){return Hp}let Hp=null;function HS(u){Hp=u}let Hl;function Hh(){if(Hl==null){let u;if(typeof window<"u")u=window;else if(typeof __webpack_require__.g<"u")u=__webpack_require__.g;else if(typeof process<"u")u=process;else if(typeof self<"u")u=self;else throw new Error("Could not find a global object");Hl=u}return Hl}function Hi(){const u=Hh();return u._tfGlobals==null&&(u._tfGlobals=new Map),u._tfGlobals}function Hm(u,a){const c=Hi();if(c.has(u))return c.get(u);{const p=a();return c.set(u,p),c.get(u)}}const Ht="Abs",Hk="Add",Hw="AddN",HU="Atan2",HG="AvgPool",HW="BatchMatMul",HR="BatchToSpaceND",Hj="Bincount",HA="Cast",HC="ClipByValue",Hu="Complex",HQ="ComplexAbs",HJ="Concat",Hx="Conv2D",HM="Conv2DBackpropFilter",HX="Conv2DBackpropInput",Hg="Cos",HK="CropAndResize",Hb="DepthToSpace",HV="DepthwiseConv2dNative",Hd="DepthwiseConv2dNativeBackpropFilter",HP="DepthwiseConv2dNativeBackpropInput",Hv="RealDiv",HT="Einsum",Hr="Elu",He="ExpandDims",HB="Fill",HN="FlipLeftRight",D0="Floor",D1="FloorDiv",D2="GatherV2",D3="Greater",D4="GreaterEqual",D5="Identity",D6="Imag",D7="LeakyRelu",D8="Less",D9="LessEqual",DH="LogicalAnd",DD="LogicalOr",Dy="Max",Da="Maximum",Ds="MaxPool",DI="Mean",DE="Min",Df="Minimum",DO="Multiply",Dc="Neg",DZ="NonMaxSuppressionV3",DL="NonMaxSuppressionV4",Dq="NonMaxSuppressionV5",DF="Pack",DY="PadV2",Do="Pow",Dn="Prelu",Dp="Range",DS="Real",Dl="Relu",Dh="Reshape",Di="ResizeNearestNeighbor",Dm="ResizeBilinear",Dt="Relu6",Dk="Round",Dw="TensorScatterUpdate",DU="Select",DG="Slice",Dz="Sin",DW="Sigmoid",DR="Sqrt",Dj="Sum",DA="SpaceToBatchND",DC="SplitV",Du="Square",DQ="StridedSlice",DJ="Sub",Dx="Tile",DM="Transform",DX="Transpose",Dg="Unpack",DK="ZerosLike",Db="Step",DV="FromPixels",Dd="RotateWithOffset",DP="_FusedMatMul",Dv="FusedConv2D",DT="FusedDepthwiseConv2D";function Dr(...u){Hn().getBool("IS_TEST")||Hn().getBool("PROD")||console.warn(...u)}function De(...u){Hn().getBool("IS_TEST")||Hn().getBool("PROD")||console.log(...u)}const DB=Hm("kernelRegistry",()=>new Map),DN=Hm("gradRegistry",()=>new Map);function y0(u,a){const c=y4(u,a);return DB.get(c)}function y1(u){return DN.get(u)}function y2(u){const a=DB.entries(),c=[];for(;;){const{done:p,value:m}=a.next();if(p)break;const[v,b]=m,[w]=v.split("_");w===u&&c.push(b)}return c}function y3(u){const{kernelName:a,backendName:c}=u,p=y4(a,c);DB.has(p)&&Dr("The kernel '"+a+"' for backend '"+c+"' is already registered"),DB.set(p,u)}function y4(u,a){return a+"_"+u}function y5(u){return u instanceof Float32Array||u instanceof Int32Array||u instanceof Uint8Array||u instanceof Uint8ClampedArray}var y6=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof __webpack_require__.g<"u"?__webpack_require__.g:typeof self<"u"?self:{};function y7(u){return u&&u.__esModule&&Object.prototype.hasOwnProperty.call(u,"default")?u.default:u}var y8=yH,y9=null;try{y9=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(u){}function yH(u,a,c){this.low=u|0,this.high=a|0,this.unsigned=!!c}yH.prototype.__isLong__,Object.defineProperty(yH.prototype,"__isLong__",{value:!0});function yD(u){return(u&&u.__isLong__)===!0}yH.isLong=yD;var yy={},ya={};function ys(u,a){var c,p,m;return a?(u>>>=0,(m=0<=u&&u<256)&&(p=ya[u],p)?p:(c=yE(u,(u|0)<0?-1:0,!0),m&&(ya[u]=c),c)):(u|=0,(m=-128<=u&&u<128)&&(p=yy[u],p)?p:(c=yE(u,u<0?-1:0,!1),m&&(yy[u]=c),c))}yH.fromInt=ys;function yI(u,a){if(isNaN(u))return a?yp:yn;if(a){if(u<0)return yp;if(u>=yF)return ym}else{if(u<=-yY)return yt;if(u+1>=yY)return yi}return u<0?yI(-u,a).neg():yE(u%yq|0,u/yq|0,a)}yH.fromNumber=yI;function yE(u,a,c){return new yH(u,a,c)}yH.fromBits=yE;var yf=Math.pow;function yO(u,a,c){if(u.length===0)throw Error("empty string");if(u==="NaN"||u==="Infinity"||u==="+Infinity"||u==="-Infinity")return yn;if(typeof a=="number"?(c=a,a=!1):a=!!a,c=c||10,c<2||36<c)throw RangeError("radix");var p;if((p=u.indexOf("-"))>0)throw Error("interior hyphen");if(p===0)return yO(u.substring(1),a,c).neg();for(var m=yI(yf(c,8)),v=yn,b=0;b<u.length;b+=8){var w=Math.min(8,u.length-b),S=parseInt(u.substring(b,b+w),c);if(w<8){var O=yI(yf(c,w));v=v.mul(O).add(yI(S))}else v=v.mul(m),v=v.add(yI(S))}return v.unsigned=a,v}yH.fromString=yO;function yc(u,a){return typeof u=="number"?yI(u,a):typeof u=="string"?yO(u,a):yE(u.low,u.high,typeof a=="boolean"?a:u.unsigned)}yH.fromValue=yc;var yZ=65536,yL=1<<24,yq=yZ*yZ,yF=yq*yq,yY=yF/2,yo=ys(yL),yn=ys(0);yH.ZERO=yn;var yp=ys(0,!0);yH.UZERO=yp;var yS=ys(1);yH.ONE=yS;var yl=ys(1,!0);yH.UONE=yl;var yh=ys(-1);yH.NEG_ONE=yh;var yi=yE(-1,2147483647,!1);yH.MAX_VALUE=yi;var ym=yE(-1,-1,!0);yH.MAX_UNSIGNED_VALUE=ym;var yt=yE(0,-2147483648,!1);yH.MIN_VALUE=yt;var yk=yH.prototype;yk.toInt=function(){return this.unsigned?this.low>>>0:this.low},yk.toNumber=function(){return this.unsigned?(this.high>>>0)*yq+(this.low>>>0):this.high*yq+(this.low>>>0)},yk.toString=function(u){if(u=u||10,u<2||36<u)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(yt)){var a=yI(u),c=this.div(a),p=c.mul(a).sub(this);return c.toString(u)+p.toInt().toString(u)}else return"-"+this.neg().toString(u);for(var m=yI(yf(u,6),this.unsigned),v=this,b="";;){var w=v.div(m),S=v.sub(w.mul(m)).toInt()>>>0,O=S.toString(u);if(v=w,v.isZero())return O+b;for(;O.length<6;)O="0"+O;b=""+O+b}},yk.getHighBits=function(){return this.high},yk.getHighBitsUnsigned=function(){return this.high>>>0},yk.getLowBits=function(){return this.low},yk.getLowBitsUnsigned=function(){return this.low>>>0},yk.getNumBitsAbs=function(){if(this.isNegative())return this.eq(yt)?64:this.neg().getNumBitsAbs();for(var u=this.high!=0?this.high:this.low,a=31;a>0&&!(u&1<<a);a--);return this.high!=0?a+33:a+1},yk.isZero=function(){return this.high===0&&this.low===0},yk.eqz=yk.isZero,yk.isNegative=function(){return!this.unsigned&&this.high<0},yk.isPositive=function(){return this.unsigned||this.high>=0},yk.isOdd=function(){return(this.low&1)===1},yk.isEven=function(){return(this.low&1)===0},yk.equals=function(u){return yD(u)||(u=yc(u)),this.unsigned!==u.unsigned&&this.high>>>31===1&&u.high>>>31===1?!1:this.high===u.high&&this.low===u.low},yk.eq=yk.equals,yk.notEquals=function(u){return!this.eq(u)},yk.neq=yk.notEquals,yk.ne=yk.notEquals,yk.lessThan=function(u){return this.comp(u)<0},yk.lt=yk.lessThan,yk.lessThanOrEqual=function(u){return this.comp(u)<=0},yk.lte=yk.lessThanOrEqual,yk.le=yk.lessThanOrEqual,yk.greaterThan=function(u){return this.comp(u)>0},yk.gt=yk.greaterThan,yk.greaterThanOrEqual=function(u){return this.comp(u)>=0},yk.gte=yk.greaterThanOrEqual,yk.ge=yk.greaterThanOrEqual,yk.compare=function(u){if(yD(u)||(u=yc(u)),this.eq(u))return 0;var a=this.isNegative(),c=u.isNegative();return a&&!c?-1:!a&&c?1:this.unsigned?u.high>>>0>this.high>>>0||u.high===this.high&&u.low>>>0>this.low>>>0?-1:1:this.sub(u).isNegative()?-1:1},yk.comp=yk.compare,yk.negate=function(){return!this.unsigned&&this.eq(yt)?yt:this.not().add(yS)},yk.neg=yk.negate,yk.add=function(u){yD(u)||(u=yc(u));var a=this.high>>>16,c=this.high&65535,p=this.low>>>16,m=this.low&65535,v=u.high>>>16,b=u.high&65535,w=u.low>>>16,S=u.low&65535,O=0,q=0,H=0,j=0;return j+=m+S,H+=j>>>16,j&=65535,H+=p+w,q+=H>>>16,H&=65535,q+=c+b,O+=q>>>16,q&=65535,O+=a+v,O&=65535,yE(H<<16|j,O<<16|q,this.unsigned)},yk.subtract=function(u){return yD(u)||(u=yc(u)),this.add(u.neg())},yk.sub=yk.subtract,yk.multiply=function(u){if(this.isZero())return yn;if(yD(u)||(u=yc(u)),y9){var a=y9.mul(this.low,this.high,u.low,u.high);return yE(a,y9.get_high(),this.unsigned)}if(u.isZero())return yn;if(this.eq(yt))return u.isOdd()?yt:yn;if(u.eq(yt))return this.isOdd()?yt:yn;if(this.isNegative())return u.isNegative()?this.neg().mul(u.neg()):this.neg().mul(u).neg();if(u.isNegative())return this.mul(u.neg()).neg();if(this.lt(yo)&&u.lt(yo))return yI(this.toNumber()*u.toNumber(),this.unsigned);var c=this.high>>>16,p=this.high&65535,m=this.low>>>16,v=this.low&65535,b=u.high>>>16,w=u.high&65535,S=u.low>>>16,O=u.low&65535,q=0,H=0,j=0,$=0;return $+=v*O,j+=$>>>16,$&=65535,j+=m*O,H+=j>>>16,j&=65535,j+=v*S,H+=j>>>16,j&=65535,H+=p*O,q+=H>>>16,H&=65535,H+=m*S,q+=H>>>16,H&=65535,H+=v*w,q+=H>>>16,H&=65535,q+=c*O+p*S+m*w+v*b,q&=65535,yE(j<<16|$,q<<16|H,this.unsigned)},yk.mul=yk.multiply,yk.divide=function(u){if(yD(u)||(u=yc(u)),u.isZero())throw Error("division by zero");if(y9){if(!this.unsigned&&this.high===-2147483648&&u.low===-1&&u.high===-1)return this;var a=(this.unsigned?y9.div_u:y9.div_s)(this.low,this.high,u.low,u.high);return yE(a,y9.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?yp:yn;var c,p,m;if(this.unsigned){if(u.unsigned||(u=u.toUnsigned()),u.gt(this))return yp;if(u.gt(this.shru(1)))return yl;m=yp}else{if(this.eq(yt)){if(u.eq(yS)||u.eq(yh))return yt;if(u.eq(yt))return yS;var v=this.shr(1);return c=v.div(u).shl(1),c.eq(yn)?u.isNegative()?yS:yh:(p=this.sub(u.mul(c)),m=c.add(p.div(u)),m)}else if(u.eq(yt))return this.unsigned?yp:yn;if(this.isNegative())return u.isNegative()?this.neg().div(u.neg()):this.neg().div(u).neg();if(u.isNegative())return this.div(u.neg()).neg();m=yn}for(p=this;p.gte(u);){c=Math.max(1,Math.floor(p.toNumber()/u.toNumber()));for(var b=Math.ceil(Math.log(c)/Math.LN2),w=b<=48?1:yf(2,b-48),S=yI(c),O=S.mul(u);O.isNegative()||O.gt(p);)c-=w,S=yI(c,this.unsigned),O=S.mul(u);S.isZero()&&(S=yS),m=m.add(S),p=p.sub(O)}return m},yk.div=yk.divide,yk.modulo=function(u){if(yD(u)||(u=yc(u)),y9){var a=(this.unsigned?y9.rem_u:y9.rem_s)(this.low,this.high,u.low,u.high);return yE(a,y9.get_high(),this.unsigned)}return this.sub(this.div(u).mul(u))},yk.mod=yk.modulo,yk.rem=yk.modulo,yk.not=function(){return yE(~this.low,~this.high,this.unsigned)},yk.and=function(u){return yD(u)||(u=yc(u)),yE(this.low&u.low,this.high&u.high,this.unsigned)},yk.or=function(u){return yD(u)||(u=yc(u)),yE(this.low|u.low,this.high|u.high,this.unsigned)},yk.xor=function(u){return yD(u)||(u=yc(u)),yE(this.low^u.low,this.high^u.high,this.unsigned)},yk.shiftLeft=function(u){return yD(u)&&(u=u.toInt()),(u&=63)===0?this:u<32?yE(this.low<<u,this.high<<u|this.low>>>32-u,this.unsigned):yE(0,this.low<<u-32,this.unsigned)},yk.shl=yk.shiftLeft,yk.shiftRight=function(u){return yD(u)&&(u=u.toInt()),(u&=63)===0?this:u<32?yE(this.low>>>u|this.high<<32-u,this.high>>u,this.unsigned):yE(this.high>>u-32,this.high>=0?0:-1,this.unsigned)},yk.shr=yk.shiftRight,yk.shiftRightUnsigned=function(u){if(yD(u)&&(u=u.toInt()),u&=63,u===0)return this;var a=this.high;if(u<32){var c=this.low;return yE(c>>>u|a<<32-u,a>>>u,this.unsigned)}else return u===32?yE(a,0,this.unsigned):yE(a>>>u-32,0,this.unsigned)},yk.shru=yk.shiftRightUnsigned,yk.shr_u=yk.shiftRightUnsigned,yk.toSigned=function(){return this.unsigned?yE(this.low,this.high,!1):this},yk.toUnsigned=function(){return this.unsigned?this:yE(this.low,this.high,!0)},yk.toBytes=function(u){return u?this.toBytesLE():this.toBytesBE()},yk.toBytesLE=function(){var u=this.high,a=this.low;return[a&255,a>>>8&255,a>>>16&255,a>>>24,u&255,u>>>8&255,u>>>16&255,u>>>24]},yk.toBytesBE=function(){var u=this.high,a=this.low;return[u>>>24,u>>>16&255,u>>>8&255,u&255,a>>>24,a>>>16&255,a>>>8&255,a&255]},yH.fromBytes=function(u,a,c){return c?yH.fromBytesLE(u,a):yH.fromBytesBE(u,a)},yH.fromBytesLE=function(u,a){return new yH(u[0]|u[1]<<8|u[2]<<16|u[3]<<24,u[4]|u[5]<<8|u[6]<<16|u[7]<<24,a)},yH.fromBytesBE=function(u,a){return new yH(u[4]<<24|u[5]<<16|u[6]<<8|u[7],u[0]<<24|u[1]<<16|u[2]<<8|u[3],a)};var yw=y7(y8),yU=s({__proto__:null,default:yw},[y8]);const yG=yw||yU;function yz(u){return yG.fromString(u,!0,16)}const yW=yz("c3a5c85c97cb3127"),yR=yz("b492b66fbe98f273"),yj=yz("9ae16a3b2f90404f");function yA(u){return u.xor(u.shru(47))}function yC(u,a,c){const p=u.slice(a,a+c);return yG.fromBytes(Array.from(p),!0,!0)}function yu(u,a){return yC(u,a,8)}function yQ(u,a){return yC(u,a,4)}function yJ(u,a){return a===0?u:u.shru(a).or(u.shl(64-a))}function yx(u,a,c=yz("9ddfea08eb382d69")){let p=u.xor(a).mul(c);p=p.xor(p.shru(47));let m=a.xor(p).mul(c);return m=m.xor(m.shru(47)),m=m.mul(c),m}function yM(u,a,c,p,m,v){m=m.add(u),v=yJ(v.add(m).add(p),21);const b=m;return m=m.add(a),m=m.add(c),v=v.add(yJ(m,44)),[m.add(p),v.add(b)]}function yX(u,a,c,p){return yM(yu(u,a),yu(u,a+8),yu(u,a+16),yu(u,a+24),c,p)}function yg(u,a=u.length){if(a>=8){const c=yj.add(a*2),p=yu(u,0).add(yj),m=yu(u,a-8),v=yJ(m,37).mul(c).add(p),b=yJ(p,25).add(m).mul(c);return yx(v,b,c)}if(a>=4){const c=yj.add(a*2),p=yQ(u,0);return yx(p.shl(3).add(a),yQ(u,a-4),c)}if(a>0){const c=u[0],p=u[a>>1],m=u[a-1],v=c+(p<<8),b=a+(m<<2);return yA(yj.mul(v).xor(yW.mul(b))).mul(yj)}return yj}function yK(u,a=u.length){const c=yj.add(a*2),p=yu(u,0).mul(yR),m=yu(u,8),v=yu(u,a-8).mul(c),b=yu(u,a-16).mul(yj);return yx(yJ(p.add(m),43).add(yJ(v,30)).add(b),p.add(yJ(m.add(yj),18)).add(v),c)}function yb(u,a=u.length){const c=yj.add(a*2),p=yu(u,0).mul(yj),m=yu(u,8),v=yu(u,a-8).mul(c),b=yu(u,a-16).mul(yj),w=yJ(p.add(m),43).add(yJ(v,30)).add(b),S=yx(w,p.add(yJ(m.add(yj),18)).add(v),c),O=yu(u,16).mul(c),q=yu(u,24),H=w.add(yu(u,a-32)).mul(c),j=S.add(yu(u,a-24)).mul(c);return yx(yJ(O.add(q),43).add(yJ(H,30)).add(j),O.add(yJ(q.add(p),18)).add(H),c)}function yV(u,a=u.length){const c=yG.fromNumber(81,!0);if(a<=32)return a<=16?yg(u,a):yK(u,a);if(a<=64)return yb(u,a);let p=c,m=c.mul(yR).add(113),v=yA(m.mul(yj).add(113)).mul(yj),b=[yG.UZERO,yG.UZERO],w=[yG.UZERO,yG.UZERO];p=p.mul(yj).add(yu(u,0));let S=0;const O=(a-1>>6)*64,q=O+(a-1&63)-63;do p=yJ(p.add(m).add(b[0]).add(yu(u,S+8)),37).mul(yR),m=yJ(m.add(b[1]).add(yu(u,S+48)),42).mul(yR),p=p.xor(w[1]),m=m.add(b[0]).add(yu(u,S+40)),v=yJ(v.add(w[0]),33).mul(yR),b=yX(u,S,b[1].mul(yR),p.add(w[0])),w=yX(u,S+32,v.add(w[1]),m.add(yu(u,S+16))),[v,p]=[p,v],S+=64;while(S!==O);const H=yR.add(v.and(255).shl(1));return S=q,w[0]=w[0].add(a-1&63),b[0]=b[0].add(w[0]),w[0]=w[0].add(b[0]),p=yJ(p.add(m).add(b[0]).add(yu(u,S+8)),37).mul(H),m=yJ(m.add(b[1]).add(yu(u,S+48)),42).mul(H),p=p.xor(w[1].mul(9)),m=m.add(b[0].mul(9).add(yu(u,S+40))),v=yJ(v.add(w[0]),33).mul(H),b=yX(u,S,b[1].mul(H),p.add(w[0])),w=yX(u,S+32,v.add(w[1]),m.add(yu(u,S+16))),[v,p]=[p,v],yx(yx(b[0],w[0],H).add(yA(m).mul(yW)).add(v),yx(b[1],w[1],H).add(p),H)}function yd(u,a){return a==="string"?yr(u):yv([u],a)}function yP(u,a){return u instanceof Float32Array&&a==="float32"||u instanceof Int32Array&&a==="int32"||u instanceof Uint8Array&&a==="bool"}function yv(u,a){if(a==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(u)&&(u=yN(u)),Hn().getBool("DEBUG")&&H0(u,a),yP(u,a))return u;if(a==null||a==="float32"||a==="complex64")return new Float32Array(u);if(a==="int32")return new Int32Array(u);if(a==="bool"){const c=new Uint8Array(u.length);for(let p=0;p<c.length;++p)Math.round(u[p])!==0&&(c[p]=1);return c}else throw new Error("Unknown data type "+a)}function yT(){return Hn().platform.now()}function yr(u,a="utf-8"){return a=a||"utf-8",Hn().platform.encode(u,a)}function ye(u,a="utf-8"){return a=a||"utf-8",Hn().platform.decode(u,a)}function yB(u){return Hn().platform.isTypedArray!=null?Hn().platform.isTypedArray(u):y5(u)}function yN(u,a=[],c=!1){if(a==null&&(a=[]),typeof u=="boolean"||typeof u=="number"||typeof u=="string"||HZ(u)||u==null||yB(u)&&c)a.push(u);else if(Array.isArray(u)||yB(u))for(let p=0;p<u.length;++p)yN(u[p],a,c);else{let p=-1;for(const m of Object.keys(u))/^([1-9]+[0-9]*|0)$/.test(m)&&(p=Math.max(p,Number(m)));for(let m=0;m<=p;m++)yN(u[m],a,c)}return a}class a0{constructor(a,c){this.backendTimer=a,this.logger=c,c==null&&(this.logger=new a2)}profileKernel(a,c,p){let m;const v=()=>{m=p()};let b;const w=yT();if(this.backendTimer.timerAvailable())b=this.backendTimer.time(v);else{v();for(const S of m)S.dataSync();b=Promise.resolve({kernelMs:yT()-w})}if(Hn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let S=0;S<m.length;S++){const O=m[S];O.data().then(q=>{a1(q,O.dtype,a)})}return{kernelName:a,outputs:m,inputs:c,timeMs:b.then(S=>S.kernelMs),extraInfo:b.then(S=>S.getExtraProfileInfo!=null?S.getExtraProfileInfo():"")}}logKernelProfile(a){const{kernelName:c,outputs:p,timeMs:m,inputs:v,extraInfo:b}=a;p.forEach(w=>{Promise.all([w.data(),m,b]).then(S=>{this.logger.logKernelProfile(c,w,S[0],S[1],v,S[2])})})}}function a1(u,a,c){if(a!=="float32")return!1;for(let p=0;p<u.length;p++){const m=u[p];if(isNaN(m)||!isFinite(m))return console.warn("Found "+m+" in the result of '"+c+"'"),!0}return!1}class a2{logKernelProfile(a,c,p,m,v,b){const w=typeof m=="number"?x(m+"ms",9):m.error,S=x(a,25),O=c.rank,q=c.size,H=x(c.shape.toString(),14);let j="";for(const $ in v){const J=v[$];if(J!=null){const ee=J.shape||c.shape,re=ee.length;j+=$+": "+re+"D "+(re>0?ee:"")+" "}}console.log("%c"+S+"	%c"+w+"	%c"+O+"D "+H+"	%c"+q+"	%c"+j+"	%c"+b,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function a3(u,a,c){const p={},m={};for(let S=0;S<a.length;S++)p[a[S].id]=!0;for(let S=0;S<u.length;S++){const O=u[S],q=O.inputs;for(const H in q){const j=q[H];let $=!1;for(let J=0;J<a.length;J++)if(p[j.id]){O.outputs.forEach(ee=>p[ee.id]=!0),$=!0,m[O.id]=!0;break}if($)break}}const v={};v[c.id]=!0;const b={};for(let S=u.length-1;S>=0;S--){const O=u[S],q=O.inputs;for(let H=0;H<O.outputs.length;H++)if(v[O.outputs[H].id]){for(const j in q)v[q[j].id]=!0,b[O.id]=!0;break}}const w=[];for(let S=0;S<u.length;S++){const O=u[S];if(m[O.id]&&b[O.id]){const q={};for(const j in O.inputs){const $=O.inputs[j];p[$.id]&&(q[j]=$)}const H=Object.assign({},O);H.inputs=q,H.outputs=O.outputs,w.push(H)}}return w}function a4(u,a,c,p){for(let m=a.length-1;m>=0;m--){const v=a[m],b=[];if(v.outputs.forEach(S=>{const O=u[S.id];O!=null?b.push(O):b.push(null)}),v.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+v.kernelName+".");const w=v.gradient(b);for(const S in v.inputs){if(!(S in w))throw new Error("Cannot backprop through input "+S+". Available gradients found: "+Object.keys(w)+".");const O=c(()=>w[S]());if(O.dtype!=="float32")throw new Error("Error in gradient for op "+v.kernelName+". The gradient of input "+S+" must have 'float32' dtype, but has '"+O.dtype+"'");const q=v.inputs[S];if(!z(O.shape,q.shape))throw new Error("Error in gradient for op "+v.kernelName+". The gradient of input '"+S+"' has shape '"+O.shape+"', which does not match the shape of the input '"+q.shape+"'");if(u[q.id]==null)u[q.id]=O;else{const H=u[q.id];u[q.id]=p(H,O),H.dispose()}}}}const a5=20,a6=3,a7=7;function a8(u,a,c,p){const m=HD(a),v=a9(u,a,c,m),b=a.length,w=ay(u,a,c,m,v),S=["Tensor"];return p&&(S.push("  dtype: "+c),S.push("  rank: "+b),S.push("  shape: ["+a+"]"),S.push("  values:")),S.push(w.map(O=>"    "+O).join(`
`)),S.join(`
`)}function a9(u,a,c,p){const m=G(a),v=p[p.length-1],b=new Array(v).fill(0),w=a.length,S=c==="complex64"?aa(u):u;if(w>1)for(let O=0;O<m/v;O++){const q=O*v;for(let H=0;H<v;H++)b[H]=Math.max(b[H],aH(S[q+H],0,c).length)}return b}function aH(u,a,c){let p;return Array.isArray(u)?p=parseFloat(u[0].toFixed(a7))+" + "+parseFloat(u[1].toFixed(a7))+"j":H5(u)?p="'"+u+"'":c==="bool"?p=aD(u):p=parseFloat(u.toFixed(a7)).toString(),x(p,a)}function aD(u){return u===0?"false":"true"}function ay(u,a,c,p,m,v=!0){const b=c==="complex64"?2:1,w=a[0],S=a.length;if(S===0){if(c==="complex64"){const ee=aa(u);return[aH(ee[0],0,c)]}return c==="bool"?[aD(u[0])]:[u[0].toString()]}if(S===1){if(w>a5){const ee=a6*b;let re=Array.from(u.slice(0,ee)),de=Array.from(u.slice((w-a6)*b,w*b));return c==="complex64"&&(re=aa(re),de=aa(de)),["["+re.map((Te,Me)=>aH(Te,m[Me],c)).join(", ")+", ..., "+de.map((Te,Me)=>aH(Te,m[w-a6+Me],c)).join(", ")+"]"]}return["["+(c==="complex64"?aa(u):Array.from(u)).map((ee,re)=>aH(ee,m[re],c)).join(", ")+"]"]}const O=a.slice(1),q=p.slice(1),H=p[0]*b,j=[];if(w>a5){for(let ee=0;ee<a6;ee++){const re=ee*H,de=re+H;j.push(...ay(u.slice(re,de),O,c,q,m,!1))}j.push("...");for(let ee=w-a6;ee<w;ee++){const re=ee*H,de=re+H;j.push(...ay(u.slice(re,de),O,c,q,m,ee===w-1))}}else for(let ee=0;ee<w;ee++){const re=ee*H,de=re+H;j.push(...ay(u.slice(re,de),O,c,q,m,ee===w-1))}const $=S===2?",":"";j[0]="["+(w>0?j[0]+$:"");for(let ee=1;ee<j.length-1;ee++)j[ee]=" "+j[ee]+$;let J=`,
`;for(let ee=2;ee<S;ee++)J+=`
`;return j[j.length-1]=" "+j[j.length-1]+"]"+(v?"":J),j}function aa(u){const a=[];for(let c=0;c<u.length;c+=2)a.push([u[c],u[c+1]]);return a}class as{constructor(a,c,p){if(this.dtype=c,this.shape=a.slice(),this.size=G(a),p!=null){const m=p.length;i(m===this.size,()=>"Length of values '"+m+"' does not match the size inferred by the shape '"+this.size+"'.")}if(c==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=p||N(c,this.size),this.strides=HD(a)}set(a,...c){c.length===0&&(c=[0]),i(c.length===this.rank,()=>"The number of provided coordinates ("+c.length+") must match the rank ("+this.rank+")");const p=this.locToIndex(c);this.values[p]=a}get(...a){a.length===0&&(a=[0]);let c=0;for(const m of a){if(m<0||m>=this.shape[c]){const v="Requested out of range element at "+a+".   Buffer shape="+this.shape;throw new Error(v)}c++}let p=a[a.length-1];for(let m=0;m<a.length-1;++m)p+=this.strides[m]*a[m];return this.values[p]}locToIndex(a){if(this.rank===0)return 0;if(this.rank===1)return a[0];let c=a[a.length-1];for(let p=0;p<a.length-1;++p)c+=this.strides[p]*a[p];return c}indexToLoc(a){if(this.rank===0)return[];if(this.rank===1)return[a];const c=new Array(this.shape.length);for(let p=0;p<c.length-1;++p)c[p]=Math.floor(a/this.strides[p]),a-=c[p]*this.strides[p];return c[c.length-1]=a,c}get rank(){return this.shape.length}toTensor(){return aI().makeTensor(this.values,this.shape,this.dtype)}}let aI=null,aE=null;function af(u){aI=u}function aO(u){aE=u}class ac{constructor(a,c,p,m){this.kept=!1,this.isDisposedInternal=!1,this.shape=a.slice(),this.dtype=c||"float32",this.size=G(a),this.strides=HD(a),this.dataId=p,this.id=m,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const a=await this.data();return aE.buffer(this.shape,this.dtype,a)}bufferSync(){return aE.buffer(this.shape,this.dtype,this.dataSync())}async array(){const a=await this.data();return Ha(this.shape,a,this.dtype==="complex64")}arraySync(){return Ha(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const a=aI().read(this.dataId);if(this.dtype==="string"){const c=await a;try{return c.map(p=>ye(p))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return a}dataToGPU(a){return this.throwIfDisposed(),aI().readToGPU(this.dataId,a)}dataSync(){this.throwIfDisposed();const a=aI().readSync(this.dataId);if(this.dtype==="string")try{return a.map(c=>ye(c))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return a}async bytes(){this.throwIfDisposed();const a=await aI().read(this.dataId);return this.dtype==="string"?a:new Uint8Array(a.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),aI().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(a=!1){return aE.print(this,a)}clone(){return this.throwIfDisposed(),aE.clone(this)}toString(a=!1){const c=this.dataSync();return a8(c,this.shape,this.dtype,a)}cast(a){return this.throwIfDisposed(),aE.cast(this,a)}variable(a=!0,c,p){return this.throwIfDisposed(),aI().makeVariable(this,a,c,p)}}Object.defineProperty(ac,Symbol.hasInstance,{value:u=>!!u&&u.data!=null&&u.dataSync!=null&&u.throwIfDisposed!=null});function aZ(){return Hm("Tensor",()=>ac)}aZ();class aL extends ac{constructor(a,c,p,m){super(a.shape,a.dtype,a.dataId,m),this.trainable=c,this.name=p}assign(a){if(a.dtype!==this.dtype)throw new Error("dtype of the new value ("+a.dtype+") and previous value ("+this.dtype+") must match");if(!z(a.shape,this.shape))throw new Error("shape of the new value ("+a.shape+") and previous value ("+this.shape+") must match");aI().disposeTensor(this),this.dataId=a.dataId,aI().incRef(this,null)}dispose(){aI().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(aL,Symbol.hasInstance,{value:u=>u instanceof ac&&u.assign!=null&&u.assign instanceof Function});var aq;(function(u){u.R0="R0",u.R1="R1",u.R2="R2",u.R3="R3",u.R4="R4",u.R5="R5",u.R6="R6"})(aq||(aq={}));var aF;(function(u){u.float32="float32",u.int32="int32",u.bool="int32",u.complex64="complex64"})(aF||(aF={}));var aY;(function(u){u.float32="float32",u.int32="int32",u.bool="bool",u.complex64="complex64"})(aY||(aY={}));var ao;(function(u){u.float32="float32",u.int32="float32",u.bool="float32",u.complex64="complex64"})(ao||(ao={}));var ap;(function(u){u.float32="complex64",u.int32="complex64",u.bool="complex64",u.complex64="complex64"})(ap||(ap={}));const aS={float32:ao,int32:aF,bool:aY,complex64:ap};function al(u,a){if(u==="string"||a==="string"){if(u==="string"&&a==="string")return"string";throw new Error("Can not upcast "+u+" with "+a)}return aS[u][a]}function ah(u){return al(u,"int32")}function ai(u){return u!=null&&typeof u=="object"&&"texture"in u&&u.texture instanceof WebGLTexture}function am(u){return typeof GPUBuffer<"u"&&u!=null&&typeof u=="object"&&"buffer"in u&&u.buffer instanceof GPUBuffer}function at(u,a){if(u.dtype===a.dtype)return[u,a];const c=al(u.dtype,a.dtype);return[u.cast(c),a.cast(c)]}function ak(u){const a=[];return aw(u,a,new Set),a}function aw(u,a,c){if(u==null)return;if(u instanceof ac){a.push(u);return}if(!aU(u))return;const p=u;for(const m in p){const v=p[m];c.has(v)||(c.add(v),aw(v,a,c))}}function aU(u){return Array.isArray(u)||typeof u=="object"}function aG(u){return u.kernelName!=null}class az{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(a=>a.name)))}}}dispose(){for(const a in this.registeredVariables)this.registeredVariables[a].dispose()}}class aW{constructor(a){this.ENV=a,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new az}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const a=this.getSortedBackends();for(let c=0;c<a.length;c++){const p=a[c];if(await this.initializeBackend(p).success){await this.setBackend(p);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){const{name:a,asyncInit:c}=this.initializeBackendsAndReturnBest();if(c)throw new Error("The highest priority backend '"+a+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(a)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(a){if(!(a in this.registry))if(a in this.registryFactory){const{asyncInit:c}=this.initializeBackend(a);if(c)return null}else return null;return this.registry[a]}findBackendFactory(a){return a in this.registryFactory?this.registryFactory[a].factory:null}registerBackend(a,c,p=1){return a in this.registryFactory?(Dr(a+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[a]={factory:c,priority:p},!0)}async setBackend(a){if(this.registryFactory[a]==null)throw new Error("Backend name '"+a+"' not found in registry");if(this.backendName=a,this.registry[a]==null){this.backendInstance=null;const{success:c,asyncInit:p}=this.initializeBackend(a);if(!(p?await c:c))return!1}return this.backendInstance=this.registry[a],this.setupRegisteredKernels(),this.profiler=new a0(this.backendInstance),!0}setupRegisteredKernels(){y2(this.backendName).forEach(a=>{a.setupFunc!=null&&a.setupFunc(this.backendInstance)})}disposeRegisteredKernels(a){y2(a).forEach(c=>{c.disposeFunc!=null&&c.disposeFunc(this.registry[a])})}initializeBackend(a){const c=this.registryFactory[a];if(c==null)throw new Error("Cannot initialize backend "+a+", no registration found.");try{const p=c.factory();if(p&&!(p instanceof L)&&typeof p.then=="function"){const m=++this.pendingBackendInitId,v=p.then(b=>m<this.pendingBackendInitId?!1:(this.registry[a]=b,this.pendingBackendInit=null,!0)).catch(b=>(m<this.pendingBackendInitId||(this.pendingBackendInit=null,Dr("Initialization of backend "+a+" failed"),Dr(b.stack||b.message)),!1));return this.pendingBackendInit=v,{success:v,asyncInit:!0}}else return this.registry[a]=p,{success:!0,asyncInit:!1}}catch(p){return Dr("Initialization of backend "+a+" failed"),Dr(p.stack||p.message),{success:!1,asyncInit:!1}}}removeBackend(a){if(!(a in this.registryFactory))throw new Error(a+" backend not found in registry");this.backendName===a&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,a in this.registry&&(this.disposeRegisteredKernels(a),this.registry[a].dispose(),delete this.registry[a]),delete this.registryFactory[a],this.backendName===a&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((a,c)=>this.registryFactory[c].priority-this.registryFactory[a].priority)}initializeBackendsAndReturnBest(){const a=this.getSortedBackends();for(let c=0;c<a.length;c++){const p=a[c],{success:m,asyncInit:v}=this.initializeBackend(p);if(v||m)return{name:p,asyncInit:v}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(a,c){const p=this.state.tensorInfo.get(c),m=p.backend,v=this.readSync(c),b=m.refCount(c);m.disposeData(c,!0),p.backend=a,a.move(c,v,p.shape,p.dtype,b),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(a,c){let p=null;if(c==null){if(typeof a!="function")throw new Error("Please provide a function to tidy()");c=a}else{if(typeof a!="string"&&!(a instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof c!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");p=a}let m;return this.scopedRun(()=>this.startScope(p),()=>this.endScope(m),()=>(m=c(),m instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),m))}scopedRun(a,c,p){a();try{const m=p();return c(),m}catch(m){throw c(),m}}nextTensorId(){return aW.nextTensorId++}nextVariableId(){return aW.nextVariableId++}clone(a){const c=aA.runKernel(D5,{x:a}),p={x:a},m=b=>({x:()=>{const w="float32",S={x:b},O={dtype:w};return aA.runKernel(HA,S,O)}}),v=[];return this.addTapeNode(this.state.activeScope.name,p,[c],m,v,{}),c}runKernel(a,c,p){if(this.backendName==null&&this.backend,y0(a,this.backendName)==null)throw new Error("Kernel '"+a+"' not registered for backend '"+this.backendName+"'");return this.runKernelFunc({kernelName:a,inputs:c,attrs:p})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(a,c,p){const m=this.backend.numDataIds();let v=0;p.forEach(S=>{v+=S.dtype==="complex64"?3:1});const b=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],w=m-c-v-b;if(w>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+w+" data ids) after running '"+a+"'")}runKernelFunc(a){let c,p=[];const m=this.isTapeOn(),v=this.state.numBytes,b=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let w;this.backendName==null&&this.backend;let S;const O=aG(a)?a.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(aG(a)){const{kernelName:J,inputs:ee,attrs:re}=a;this.backendName==null&&this.backend;const de=y0(J,this.backendName);i(de!=null,()=>"Cannot find registered kernel '"+J+"' for backend '"+this.backendName+"'"),w=()=>{const Te=this.backend.numDataIds();S=de.kernelFunc({inputs:ee,attrs:re,backend:this.backend});const Me=Array.isArray(S)?S:[S];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(J,Te,Me);const Ae=Me.map(Ce=>Ce.rank!=null?Ce:this.makeTensorFromTensorInfo(Ce));if(m){const Ce=this.getTensorsForGradient(J,ee,Ae);p=this.saveTensorsForBackwardMode(Ce)}return Ae}}else{const{forwardFunc:J}=a,ee=re=>{m&&(p=re.map(de=>this.keep(this.clone(de))))};w=()=>{const re=this.backend.numDataIds();S=this.tidy(()=>J(this.backend,ee));const de=Array.isArray(S)?S:[S];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(O,re,de),de}}const{inputs:q,attrs:H}=a,j=aG(a)?null:a.backwardsFunc;let $;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?c=w():($=this.profiler.profileKernel(O,q,()=>w()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile($),c=$.outputs)}),m&&this.addTapeNode(O,q,c,j,p,H),this.state.profiling&&this.state.activeProfile.kernels.push({name:O,bytesAdded:this.state.numBytes-v,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-b,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(q).map(J=>q[J]!=null?q[J].shape:null),outputShapes:c.map(J=>J.shape),kernelTimeMs:$.timeMs,extraInfo:$.extraInfo}),Array.isArray(S)?c:c[0]}saveTensorsForBackwardMode(a){return a.map(c=>this.keep(this.clone(c)))}getTensorsForGradient(a,c,p){const m=y1(a);if(m!=null){const v=m.inputsToSave||[],b=m.outputsToSave||[];let w;m.saveAllInputs?(i(Array.isArray(c),()=>"saveAllInputs is true, expected inputs to be an array."),w=Object.keys(c).map(O=>c[O])):w=v.map(O=>c[O]);const S=p.filter((O,q)=>b[q]);return w.concat(S)}return[]}makeTensor(a,c,p,m){if(a==null)throw new Error("Values passed to engine.makeTensor() are null");p=p||"float32",m=m||this.backend;let v=a;p==="string"&&H5(a[0])&&(v=a.map(S=>yr(S)));const b=m.write(v,c,p),w=new ac(c,p,b,this.nextTensorId());if(this.trackTensor(w,m),p==="string"){const S=this.state.tensorInfo.get(b),O=H4(v);this.state.numBytes+=O-S.bytes,S.bytes=O}return w}makeTensorFromDataId(a,c,p,m){p=p||"float32";const v={dataId:a,shape:c,dtype:p};return this.makeTensorFromTensorInfo(v,m)}makeTensorFromTensorInfo(a,c){const{dataId:p,shape:m,dtype:v}=a,b=new ac(m,v,p,this.nextTensorId());return this.trackTensor(b,c),b}makeVariable(a,c=!0,p,m){p=p||this.nextVariableId().toString(),m!=null&&m!==a.dtype&&(a=a.cast(m));const v=new aL(a,c,p,this.nextTensorId());if(this.state.registeredVariables[v.name]!=null)throw new Error("Variable with name "+v.name+" was already registered");return this.state.registeredVariables[v.name]=v,this.incRef(v,this.backend),v}trackTensor(a,c){this.state.numTensors++,a.dtype==="string"&&this.state.numStringTensors++;let p=0;a.dtype!=="complex64"&&a.dtype!=="string"&&(p=a.size*H3(a.dtype)),this.state.numBytes+=p,this.state.tensorInfo.has(a.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(a.dataId,{backend:c||this.backend,dtype:a.dtype,shape:a.shape,bytes:p})),a instanceof aL||this.track(a)}incRef(a,c){this.trackTensor(a,c),this.backend.incRef(a.dataId)}removeDataId(a,c){this.state.tensorInfo.has(a)&&this.state.tensorInfo.get(a).backend===c&&(this.state.tensorInfo.delete(a),this.state.numDataBuffers--)}disposeTensor(a){if(!this.state.tensorInfo.has(a.dataId))return;const c=this.state.tensorInfo.get(a.dataId);if(this.state.numTensors--,a.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=c.bytes),a.dtype!=="complex64"&&a.dtype!=="string"){const p=a.size*H3(a.dtype);this.state.numBytes-=p}c.backend.disposeData(a.dataId)&&this.removeDataId(a.dataId,c.backend)}disposeVariables(){for(const a in this.state.registeredVariables){const c=this.state.registeredVariables[a];this.disposeVariable(c)}}disposeVariable(a){this.disposeTensor(a),this.state.registeredVariables[a.name]!=null&&delete this.state.registeredVariables[a.name]}memory(){const a=this.backend.memory();return a.numTensors=this.state.numTensors,a.numDataBuffers=this.state.numDataBuffers,a.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(a.unreliable=!0,a.reasons==null&&(a.reasons=[]),a.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),a}async profile(a){this.state.profiling=!0;const c=this.state.numBytes,p=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await a(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(m=>m.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-c,this.state.activeProfile.newTensors=this.state.numTensors-p;for(const m of this.state.activeProfile.kernels)m.kernelTimeMs=await m.kernelTimeMs,m.extraInfo=await m.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(a,c,p,m,v,b){const w={id:this.state.nextTapeNodeId++,kernelName:a,inputs:c,outputs:p,saved:v},S=y1(a);S!=null&&(m=S.gradFunc),m!=null&&(w.gradient=O=>(O=O.map((q,H)=>{if(q==null){const j=p[H],$=HE(j.size,j.dtype);return this.makeTensor($,j.shape,j.dtype)}return q}),m(O.length>1?O:O[0],v,b))),this.state.activeTape.push(w)}keep(a){return a.kept=!0,a}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(a){const c={track:[],name:"unnamed scope",id:this.state.nextScopeId++};a&&(c.name=a),this.state.scopeStack.push(c),this.state.activeScope=c}endScope(a){const c=ak(a),p=new Set(c.map(v=>v.id));for(let v=0;v<this.state.activeScope.track.length;v++){const b=this.state.activeScope.track[v];!b.kept&&!p.has(b.id)&&b.dispose()}const m=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],c.forEach(v=>{!v.kept&&v.scopeId===m.id&&this.track(v)})}gradients(a,c,p,m=!1){if(i(c.length>0,()=>"gradients() received an empty list of xs."),p!=null&&p.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+p.dtype+"'");const v=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",a));i(v instanceof ac,()=>"The result y returned by f() must be a tensor.");const b=a3(this.state.activeTape,c,v);if(!m&&b.length===0&&c.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const w={};w[v.id]=p??aR(v.shape),a4(w,b,O=>this.tidy(O),aC);const S=c.map(O=>w[O.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(O=>{for(const q of O.saved)q.dispose()}),this.state.activeTape=null),{value:v,grads:S}})}customGrad(a){return i(H9(a),()=>"The f passed in customGrad(f) must be a function."),(...c)=>{i(c.every(w=>w instanceof ac),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let p;const m={};c.forEach((w,S)=>{m[S]=w});const v=(w,S)=>(p=a(...c,S),i(p.value instanceof ac,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),i(H9(p.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),p.value),b=(w,S)=>{const O=p.gradFunc(w,S),q=Array.isArray(O)?O:[O];i(q.length===c.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),i(q.every(j=>j instanceof ac),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const H={};return q.forEach((j,$)=>{H[$]=()=>j}),H};return this.runKernelFunc({forwardFunc:v,backwardsFunc:b,inputs:m})}}readSync(a){return this.state.tensorInfo.get(a).backend.readSync(a)}read(a){return this.state.tensorInfo.get(a).backend.read(a)}readToGPU(a,c){return this.state.tensorInfo.get(a).backend.readToGPU(a,c)}async time(a){const c=yT(),p=await this.backend.time(a);return p.wallMs=yT()-c,p}track(a){return this.state.activeScope!=null&&(a.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(a)),a}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new az;for(const a in this.registry)this.disposeRegisteredKernels(a),this.registry[a].dispose(),delete this.registry[a];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}aW.nextTensorId=0,aW.nextVariableId=0;function aR(u){const a=HI(G(u),"float32");return aA.makeTensor(a,u,"float32")}function aj(){const u=Hh();if(u._tfengine==null){const a=new Hq(u);u._tfengine=new aW(a)}return HS(u._tfengine.ENV),af(()=>u._tfengine),u._tfengine}const aA=aj();function aC(u,a){const c={a:u,b:a};return aA.runKernel(Hk,c)}function au(){return typeof navigator<"u"&&navigator!=null}function aQ(u){if(u||au()){if(u||(u=navigator),u.product==="ReactNative")return!0;const a=u.userAgent||u.vendor||(typeof window<"u"?window.opera:"");if(!a){const c=u;return c.userAgentData&&c.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))}return!1}function aJ(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const ax=Hn();ax.registerFlag("DEBUG",()=>!1,u=>{u&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ax.registerFlag("IS_BROWSER",()=>aJ()),ax.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),ax.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ax.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),ax.registerFlag("PROD",()=>!1),ax.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ax.getBool("DEBUG")),ax.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ax.registerFlag("IS_TEST",()=>!1),ax.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>ax.getBool("DEBUG")),ax.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),ax.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),ax.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function aM(u,a){let c=u;if(yB(u))return a==="string"?[]:[u.length];if(ai(u)){const m=u.channels||"RGBA";return[u.height,u.width*m.length]}else if(am(u))return[u.buffer.size/(a==null?4:H3(a))];if(!Array.isArray(u))return[];const p=[];for(;Array.isArray(c)||yB(c)&&a!=="string";)p.push(c.length),c=c[0];return Array.isArray(u)&&Hn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&aX(u,p,[]),p}function aX(u,a,c){if(c=c||[],!Array.isArray(u)&&!yB(u)){i(a.length===0,()=>"Element arr["+c.join("][")+"] is a primitive, but should be an array/TypedArray of "+a[0]+" elements");return}i(a.length>0,()=>"Element arr["+c.join("][")+"] should be a primitive, but is an array of "+u.length+" elements"),i(u.length===a[0],()=>"Element arr["+c.join("][")+"] should have "+a[0]+" elements, but has "+u.length+" elements");const p=a.slice(1);for(let m=0;m<u.length;++m)aX(u[m],p,c.concat(m))}function ag(u,a,c,p){if(u!=="string_or_numeric"){if(u==null)throw new Error("Expected dtype cannot be null.");if(u!=="numeric"&&u!==a||u==="numeric"&&a==="string")throw new Error("Argument '"+c+"' passed to '"+p+"' must be "+u+" tensor, but got "+a+" tensor")}}function aK(u,a,c,p="numeric"){if(u instanceof aZ())return ag(p,u.dtype,a,c),u;let m=H8(u);if(m!=="string"&&["bool","int32","float32"].indexOf(p)>=0&&(m=p),ag(p,m,a,c),u==null||!yB(u)&&!Array.isArray(u)&&typeof u!="number"&&typeof u!="boolean"&&typeof u!="string"){const w=u==null?"null":u.constructor.name;throw new Error("Argument '"+a+"' passed to '"+c+"' must be a Tensor or TensorLike, but got '"+w+"'")}const v=aM(u,m);!yB(u)&&!Array.isArray(u)&&(u=[u]);const b=m!=="string"?yv(u,m):yN(u,[],!0);return aA.makeTensor(b,v,m)}function ab(u,a,c,p="numeric"){if(!Array.isArray(u))throw new Error("Argument "+a+" passed to "+c+" must be a `Tensor[]` or `TensorLike[]`");return u.map((m,v)=>aK(m,a+"["+v+"]",c,p))}const aV="__op";function ad(u){const a=Object.keys(u);if(a.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+a.length+" keys.");let c=a[0];const p=u[c];c.endsWith("_")&&(c=c.substring(0,c.length-1)),c=c+aV;const m=(...v)=>{aA.startScope(c);try{const b=p(...v);return HZ(b)&&console.error("Cannot return a Promise inside of tidy."),aA.endScope(b),b}catch(b){throw aA.endScope(null),b}};return Object.defineProperty(m,"name",{value:c,configurable:!0}),m}function aP(u,a){const c=aK(u,"real","complex"),p=aK(a,"imag","complex");t(c.shape,p.shape,"real and imag shapes, "+c.shape+" and "+p.shape+", must match in call to tf.complex().");const m={real:c,imag:p};return aA.runKernel(Hu,m)}const av=ad({complex_:aP});function aT(u,a,c,p){if(p==null)p=H8(u);else if(p==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(am(u)||ai(u)){if(p!=="float32"&&p!=="int32")throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is "+p+".");return aA.backend.createTensorFromGPUData(u,a||c,p)}if(!yB(u)&&!Array.isArray(u)&&typeof u!="number"&&typeof u!="boolean"&&typeof u!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(a!=null){Hf(a);const m=G(a),v=G(c);i(m===v,()=>"Based on the provided shape, ["+a+"], the tensor should have "+m+" values but has "+v);for(let b=0;b<c.length;++b){const w=c[b],S=b===c.length-1?w!==G(a.slice(b)):!0;i(c[b]===a[b]||!S,()=>"Error creating a new Tensor. Inferred shape ("+c+") does not match the provided shape ("+a+"). ")}}return!yB(u)&&!Array.isArray(u)&&(u=[u]),a=a||c,u=p!=="string"?yv(u,p):yN(u,[],!0),aA.makeTensor(u,a,p)}function ar(u,a,c){const p=aM(u,c);return aT(u,a,p,c)}const ae={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class aB{static join(a){return new aB(a).slice()}constructor(a){if(this.shards=[],this.previousShardIndex=0,a==null||(a instanceof Array||(a=[a]),a=a.map(p=>yB(p)?p.buffer:p),a.length===0))return;this.bufferUniformSize=a[0].byteLength;let c=0;for(let p=0;p<a.length;p++){const m=a[p];p!==a.length-1&&m.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const v=c+m.byteLength;this.shards.push({buffer:m,start:c,end:v}),c=v}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(a=0,c=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(a=isNaN(Number(a))?0:a,c=isNaN(Number(c))?0:c,a=Math.max(0,a),c=Math.min(this.byteLength,c),c<=a)return new ArrayBuffer(0);const p=this.findShardForByte(a);if(p===-1)throw new Error("Could not find start shard for byte "+a);const m=c-a,v=new ArrayBuffer(m),b=new Uint8Array(v);let w=0;for(let S=p;S<this.shards.length;S++){const O=this.shards[S],q=a+w-O.start,H=w,j=Math.min(c,O.end)-O.start,$=new Uint8Array(O.buffer,q,j-q);if(b.set($,H),w+=$.length,c<O.end)break}return v}findShardForByte(a){if(this.shards.length===0||a<0||a>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(a/this.bufferUniformSize),this.previousShardIndex;function c(m){return a<m.start?-1:a>=m.end?1:0}if(c(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const p=aN(this.shards,c);return p===-1?-1:(this.previousShardIndex=p,this.previousShardIndex)}}function aN(u,a){let c=0,p=u.length;for(;c<=p;){const m=Math.floor((p-c)/2)+c,v=a(u[m]);if(v===0)return m;v<0?p=m:c=m+1}return-1}function s0(){Hn().set("PROD",!0)}function s1(){return aA}function s2(u,a){return aA.tidy(u,a)}function s3(u){ak(u).forEach(a=>a.dispose())}function s4(u){return aA.keep(u)}function s5(u){return aA.setBackend(u)}function s6(){return aA.backendName}function s7(u,a,c=1){return aA.registerBackend(u,a,c)}function s8(){return aA.backend}const s9=4;async function sH(u,a){const c=[],p=[],m=Array.isArray(u)?u.map(b=>b.name):Object.keys(u);for(let b=0;b<m.length;++b){const w=m[b],S=Array.isArray(u)?u[b].tensor:u[w];if(S.dtype!=="float32"&&S.dtype!=="int32"&&S.dtype!=="bool"&&S.dtype!=="string"&&S.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+w+"': "+S.dtype);const O={name:w,shape:S.shape,dtype:S.dtype};if(S.dtype==="string"){const q=new Promise(async H=>{const j=await S.bytes(),$=j.reduce((re,de)=>re+de.length,0)+s9*j.length,J=new Uint8Array($);let ee=0;for(let re=0;re<j.length;re++){const de=j[re],Te=new Uint8Array(new Uint32Array([de.length]).buffer);J.set(Te,ee),ee+=s9,J.set(de,ee),ee+=de.length}H(J)});p.push(q)}else p.push(S.data());a!=null&&(O.group=a),c.push(O)}const v=await Promise.all(p);return{data:sf(v),specs:c}}function sD(u,a){const c=new aB(u),p={};let m=0;for(const v of a){const b=sy(v,(w,S)=>c.slice(m+w,m+S));p[v.name]=ss(v,c.slice(m,m+b)),m+=b}return p}function sy(u,a){const c=G(u.shape);let p;if("quantization"in u){const m=u.quantization;p=ae[m.dtype]}else if(u.dtype==="string"){let m=0;for(let v=0;v<c;v++)m+=s9+new Uint32Array(a(m,m+s9))[0];return m}else p=ae[u.dtype];return c*p}async function sa(u,a){const c=G(u.shape);let p;if("quantization"in u){const m=u.quantization;p=ae[m.dtype]}else if(u.dtype==="string"){let m=0;for(let v=0;v<c;v++)m+=s9+new Uint32Array(await a(m,m+s9))[0];return m}else p=ae[u.dtype];return c*p}function ss(u,a){const c=u.name,p=u.dtype,m=u.shape,v=G(m);let b,w=0;if("quantization"in u){const S=u.quantization;if(S.dtype==="uint8"||S.dtype==="uint16"){if(!("min"in S&&"scale"in S))throw new Error("Weight "+u.name+" with quantization "+S.dtype+" doesn't have corresponding metadata min and scale.")}else if(S.dtype==="float16"){if(p!=="float32")throw new Error("Weight "+u.name+" is quantized with "+S.dtype+" which only supports weights of type float32 not "+p+".")}else throw new Error("Weight "+u.name+" has unknown quantization dtype "+S.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");const O=ae[S.dtype],q=S.dtype==="uint8"?new Uint8Array(a):new Uint16Array(a);if(p==="float32")if(S.dtype==="uint8"||S.dtype==="uint16"){b=new Float32Array(q.length);for(let H=0;H<q.length;H++){const j=q[H];b[H]=j*S.scale+S.min}}else if(S.dtype==="float16")b=sm()(q);else throw new Error("Unsupported quantization type "+S.dtype+" for weight type float32.");else if(p==="int32"){if(S.dtype!=="uint8"&&S.dtype!=="uint16")throw new Error("Unsupported quantization type "+S.dtype+" for weight type int32.");b=new Int32Array(q.length);for(let H=0;H<q.length;H++){const j=q[H];b[H]=Math.round(j*S.scale+S.min)}}else throw new Error("Unsupported dtype in weight '"+c+"': "+p);w+=v*O}else if(p==="string"){const S=G(u.shape);b=[];for(let O=0;O<S;O++){const q=new Uint32Array(a.slice(w,w+s9))[0];w+=s9;const H=new Uint8Array(a.slice(w,w+q));b.push(H),w+=q}}else{const S=ae[p];if(p==="float32")b=new Float32Array(a);else if(p==="int32")b=new Int32Array(a);else if(p==="bool")b=new Uint8Array(a);else if(p==="complex64"){b=new Float32Array(a);const O=new Float32Array(b.length/2),q=new Float32Array(b.length/2);for(let J=0;J<O.length;J++)O[J]=b[J*2],q[J]=b[J*2+1];const H=ar(O,m,"float32"),j=ar(q,m,"float32"),$=av(H,j);return H.dispose(),j.dispose(),$}else throw new Error("Unsupported dtype in weight '"+c+"': "+p);w+=v*S}return ar(b,m,p)}async function sI(u,a,c){let p=new Uint8Array(a);for(;p.byteLength<c;){const{done:m,value:v}=await u.read();if(m&&v==null){const w=c-p.byteLength;throw new Error("Reader is done but "+w+" bytes are still expected")}const b=new Uint8Array(p.length+v.byteLength);b.set(p,0),b.set(new Uint8Array(v),p.length),p=b}return p.buffer}async function sE(u,a){const c={},p=u.getReader();let m=new ArrayBuffer(0);for(const v of a){const b=await sa(v,async(O,q)=>(m=await sI(p,m,q),m.slice(O,q)));m=await sI(p,m,b);const w=m.slice(0,b);m=m.slice(b);const S=ss(v,w);if(c[v.name]=S,s6()==="webgpu"){const O=s8();"uploadToGPU"in O&&G(S.shape)>=Hn().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&O.uploadToGPU(S.dataId)}}return c}function sf(u){if(u===null)throw new Error("Invalid input value: "+JSON.stringify(u));let a=0;const c=[];u.forEach(v=>{if(a+=v.byteLength,c.push(v.byteLength===v.buffer.byteLength?v:new v.constructor(v)),!(v instanceof Float32Array||v instanceof Int32Array||v instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+v.constructor.name)});const p=new Uint8Array(a);let m=0;return c.forEach(v=>{p.set(new Uint8Array(v.buffer),m),m+=v.byteLength}),p.buffer}const sO=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function sc(u){return sO?Buffer.byteLength(u,"utf8"):new Blob([u]).size}function sZ(u){if(sO)return Buffer.from(u).toString("base64");const a=new Uint8Array(u);let c="";for(let p=0,m=a.length;p<m;p++)c+=String.fromCharCode(a[p]);return btoa(c)}function sL(u){if(sO){const p=Buffer.from(u,"base64");return p.buffer.slice(p.byteOffset,p.byteOffset+p.byteLength)}const a=atob(u),c=new Uint8Array(a.length);for(let p=0;p<a.length;++p)c.set([a.charCodeAt(p)],p);return c.buffer}function sq(u){return aB.join(u)}function sF(u){const a="/";for(u=u.trim();u.endsWith(a);)u=u.slice(0,u.length-1);const c=u.split(a);return c[c.length-1]}function sY(u,a){const c={modelTopology:u.modelTopology,format:u.format,generatedBy:u.generatedBy,convertedBy:u.convertedBy,weightsManifest:a};return u.signature!=null&&(c.signature=u.signature),u.userDefinedMetadata!=null&&(c.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(c.modelInitializer=u.modelInitializer),u.initializerSignature!=null&&(c.initializerSignature=u.initializerSignature),u.trainingConfig!=null&&(c.trainingConfig=u.trainingConfig),c}function so(u,a,c){const p={modelTopology:u.modelTopology,format:u.format,generatedBy:u.generatedBy,convertedBy:u.convertedBy};if(u.trainingConfig!=null&&(p.trainingConfig=u.trainingConfig),u.weightsManifest!=null){if(!a)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!c)throw new Error("modelJSON has weightsManifest but weightData is null");p.weightSpecs=a,p.weightData=c}return u.signature!=null&&(p.signature=u.signature),u.userDefinedMetadata!=null&&(p.userDefinedMetadata=u.userDefinedMetadata),u.modelInitializer!=null&&(p.modelInitializer=u.modelInitializer),u.initializerSignature!=null&&(p.initializerSignature=u.initializerSignature),p}async function sn(u,a){let c,p;return u.weightsManifest!=null&&([c,p]=await a(u.weightsManifest)),so(u,c,p)}function sp(u){if(u.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:u.modelTopology==null?0:sc(JSON.stringify(u.modelTopology)),weightSpecsBytes:u.weightSpecs==null?0:sc(JSON.stringify(u.weightSpecs)),weightDataBytes:u.weightData==null?0:new aB(u.weightData).byteLength}}function sS(u){const a=[];for(const c of u)a.push(...c.weights);return a}function sl(){const u=c=>{let p=c<<13,m=0;for(;!(p&8388608);)m-=8388608,p<<=1;return p&=-8388609,m+=947912704,p|m},a=new Uint32Array(2048);a[0]=0;for(let c=1;c<1024;c++)a[c]=u(c);for(let c=1024;c<2048;c++)a[c]=939524096+(c-1024<<13);return a}function sh(){const u=new Uint32Array(64);u[0]=0,u[31]=1199570944,u[32]=2147483648,u[63]=3347054592;for(let a=1;a<31;a++)u[a]=a<<23;for(let a=33;a<63;a++)u[a]=2147483648+(a-32<<23);return u}function si(){const u=new Uint32Array(64);for(let a=0;a<64;a++)u[a]=1024;return u[0]=u[32]=0,u}function sm(){const u=sl(),a=sh(),c=si();return p=>{const m=new ArrayBuffer(4*p.length),v=new Uint32Array(m);for(let b=0;b<p.length;b++){const w=p[b],S=u[c[w>>10]+(w&1023)]+a[w>>10];v[b]=S}return new Float32Array(m)}}class st{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return st.instance==null&&(st.instance=new st),st.instance}static registerSaveRouter(a){st.getInstance().saveRouters.push(a)}static registerLoadRouter(a){st.getInstance().loadRouters.push(a)}static getSaveHandlers(a){return st.getHandlers(a,"save")}static getLoadHandlers(a,c){return st.getHandlers(a,"load",c)}static getHandlers(a,c,p){const m=[];return(c==="load"?st.getInstance().loadRouters:st.getInstance().saveRouters).forEach(v=>{const b=v(a,p);b!==null&&m.push(b)}),m}}const sk=u=>st.registerSaveRouter(u),sw=u=>st.registerLoadRouter(u),sU=u=>st.getSaveHandlers(u),sG=(u,a)=>st.getLoadHandlers(u,a),sz="tensorflowjs",sW=1,sR="models_store",sj="model_info_store";function sA(){if(!Hn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const u=typeof window>"u"?self:window,a=u.indexedDB||u.mozIndexedDB||u.webkitIndexedDB||u.msIndexedDB||u.shimIndexedDB;if(a==null)throw new Error("The current browser does not appear to support IndexedDB.");return a}function sC(u){const a=u.result;a.createObjectStore(sR,{keyPath:"modelPath"}),a.createObjectStore(sj,{keyPath:"modelPath"})}class su{constructor(a){if(this.indexedDB=sA(),a==null||!a)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=a}async save(a){if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,a)}async load(){return this.databaseAction(this.modelPath)}databaseAction(a,c){return new Promise((p,m)=>{const v=this.indexedDB.open(sz,sW);v.onupgradeneeded=()=>sC(v),v.onsuccess=()=>{const b=v.result;if(c==null){const w=b.transaction(sR,"readonly"),S=w.objectStore(sR).get(this.modelPath);S.onsuccess=()=>{if(S.result==null)return b.close(),m(new Error("Cannot find model with path '"+this.modelPath+"' in IndexedDB."));p(S.result.modelArtifacts)},S.onerror=O=>(b.close(),m(S.error)),w.oncomplete=()=>b.close()}else{c.weightData=aB.join(c.weightData);const w=sp(c),S=b.transaction(sj,"readwrite");let O=S.objectStore(sj),q;try{q=O.put({modelPath:this.modelPath,modelArtifactsInfo:w})}catch(j){return m(j)}let H;q.onsuccess=()=>{H=b.transaction(sR,"readwrite");const j=H.objectStore(sR);let $;try{$=j.put({modelPath:this.modelPath,modelArtifacts:c,modelArtifactsInfo:w})}catch(J){return m(J)}$.onsuccess=()=>p({modelArtifactsInfo:w}),$.onerror=J=>{O=S.objectStore(sj);const ee=O.delete(this.modelPath);ee.onsuccess=()=>(b.close(),m($.error)),ee.onerror=re=>(b.close(),m($.error))}},q.onerror=j=>(b.close(),m(q.error)),S.oncomplete=()=>{H==null?b.close():H.oncomplete=()=>b.close()}}},v.onerror=b=>m(v.error)})}}su.URL_SCHEME="indexeddb://";const sQ=u=>Hn().getBool("IS_BROWSER")&&!Array.isArray(u)&&u.startsWith(su.URL_SCHEME)?sJ(u.slice(su.URL_SCHEME.length)):null;st.registerSaveRouter(sQ),st.registerLoadRouter(sQ);function sJ(u){return new su(u)}function sx(u){return u.startsWith(su.URL_SCHEME)?u.slice(su.URL_SCHEME.length):u}class sM{constructor(){this.indexedDB=sA()}async listModels(){return new Promise((a,c)=>{const p=this.indexedDB.open(sz,sW);p.onupgradeneeded=()=>sC(p),p.onsuccess=()=>{const m=p.result,v=m.transaction(sj,"readonly"),b=v.objectStore(sj).getAll();b.onsuccess=()=>{const w={};for(const S of b.result)w[S.modelPath]=S.modelArtifactsInfo;a(w)},b.onerror=w=>(m.close(),c(b.error)),v.oncomplete=()=>m.close()},p.onerror=m=>c(p.error)})}async removeModel(a){return a=sx(a),new Promise((c,p)=>{const m=this.indexedDB.open(sz,sW);m.onupgradeneeded=()=>sC(m),m.onsuccess=()=>{const v=m.result,b=v.transaction(sj,"readwrite"),w=b.objectStore(sj),S=w.get(a);let O;S.onsuccess=()=>{if(S.result==null)return v.close(),p(new Error("Cannot find model with path '"+a+"' in IndexedDB."));{const q=w.delete(a),H=()=>{O=v.transaction(sR,"readwrite");const j=O.objectStore(sR).delete(a);j.onsuccess=()=>c(S.result.modelArtifactsInfo),j.onerror=$=>p(S.error)};q.onsuccess=H,q.onerror=j=>(H(),v.close(),p(S.error))}},S.onerror=q=>(v.close(),p(S.error)),b.oncomplete=()=>{O==null?v.close():O.oncomplete=()=>v.close()}},m.onerror=v=>p(m.error)})}}const sX="/",sg="tensorflowjs_models",sK="info",sb="model_topology",sV="weight_specs",sd="weight_data",sP="model_metadata";function sv(u){return{info:[sg,u,sK].join(sX),topology:[sg,u,sb].join(sX),weightSpecs:[sg,u,sV].join(sX),weightData:[sg,u,sd].join(sX),modelMetadata:[sg,u,sP].join(sX)}}function sT(u){for(const a of Object.values(u))window.localStorage.removeItem(a)}function se(u){const a=u.split(sX);if(a.length<3)throw new Error("Invalid key format: "+u);return a.slice(1,a.length-1).join(sX)}function sB(u){return u.startsWith(sN.URL_SCHEME)?u.slice(sN.URL_SCHEME.length):u}class sN{constructor(a){if(!Hn().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,a==null||!a)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=a,this.keys=sv(this.modelPath)}async save(a){if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const c=JSON.stringify(a.modelTopology),p=JSON.stringify(a.weightSpecs),m=sp(a),v=aB.join(a.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(m)),this.LS.setItem(this.keys.topology,c),this.LS.setItem(this.keys.weightSpecs,p),this.LS.setItem(this.keys.weightData,sZ(v));const b={format:a.format,generatedBy:a.generatedBy,convertedBy:a.convertedBy,signature:a.signature!=null?a.signature:void 0,userDefinedMetadata:a.userDefinedMetadata!=null?a.userDefinedMetadata:void 0,modelInitializer:a.modelInitializer!=null?a.modelInitializer:void 0,initializerSignature:a.initializerSignature!=null?a.initializerSignature:void 0,trainingConfig:a.trainingConfig!=null?a.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(b)),{modelArtifactsInfo:m}}catch{throw sT(this.keys),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+m.modelTopologyBytes+", weightSpecsBytes="+m.weightSpecsBytes+", weightDataBytes="+m.weightDataBytes+".")}}}async load(){const a=JSON.parse(this.LS.getItem(this.keys.info));if(a==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(a.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const c={},p=JSON.parse(this.LS.getItem(this.keys.topology));if(p==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");c.modelTopology=p;const m=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(m==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");c.weightSpecs=m;const v=this.LS.getItem(this.keys.modelMetadata);if(v!=null){const w=JSON.parse(v);c.format=w.format,c.generatedBy=w.generatedBy,c.convertedBy=w.convertedBy,w.signature!=null&&(c.signature=w.signature),w.userDefinedMetadata!=null&&(c.userDefinedMetadata=w.userDefinedMetadata),w.modelInitializer!=null&&(c.modelInitializer=w.modelInitializer),w.initializerSignature!=null&&(c.initializerSignature=w.initializerSignature),w.trainingConfig!=null&&(c.trainingConfig=w.trainingConfig)}const b=this.LS.getItem(this.keys.weightData);if(b==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return c.weightData=sL(b),c}}sN.URL_SCHEME="localstorage://";const I0=u=>Hn().getBool("IS_BROWSER")&&!Array.isArray(u)&&u.startsWith(sN.URL_SCHEME)?I1(u.slice(sN.URL_SCHEME.length)):null;st.registerSaveRouter(I0),st.registerLoadRouter(I0);function I1(u){return new sN(u)}class I2{constructor(){i(Hn().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),i(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const a={},c=sg+sX,p=sX+sK;for(let m=0;m<this.LS.length;++m){const v=this.LS.key(m);if(v.startsWith(c)&&v.endsWith(p)){const b=se(v);a[b]=JSON.parse(this.LS.getItem(v))}}return a}async removeModel(a){a=sB(a);const c=sv(a);if(this.LS.getItem(c.info)==null)throw new Error("Cannot find model at path '"+a+"'");const p=JSON.parse(this.LS.getItem(c.info));return sT(c),p}}const I3="model",I4=".json",I5=".weights.bin";function I6(u){return new Promise(a=>setTimeout(a)).then(u)}class I7{constructor(a){if(!Hn().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");a.startsWith(I7.URL_SCHEME)&&(a=a.slice(I7.URL_SCHEME.length)),(a==null||a.length===0)&&(a=I3),this.modelJsonFileName=a+I4,this.weightDataFileName=a+I5}async save(a){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const c=aB.join(a.weightData),p=window.URL.createObjectURL(new Blob([c],{type:"application/octet-stream"}));if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const m=[{paths:["./"+this.weightDataFileName],weights:a.weightSpecs}],v=sY(a,m),b=window.URL.createObjectURL(new Blob([JSON.stringify(v)],{type:"application/json"})),w=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(w.download=this.modelJsonFileName,w.href=b,await I6(()=>w.dispatchEvent(new MouseEvent("click"))),a.weightData!=null){const S=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;S.download=this.weightDataFileName,S.href=p,await I6(()=>S.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:sp(a)}}}}I7.URL_SCHEME="downloads://";class I8{constructor(a){if(a==null||a.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+a);this.jsonFile=a[0],this.weightsFiles=a.slice(1)}async load(){return new Promise((a,c)=>{const p=new FileReader;p.onload=m=>{const v=JSON.parse(m.target.result),b=v.modelTopology;if(b==null){c(new Error("modelTopology field is missing from file "+this.jsonFile.name));return}if(v.weightsManifest==null){c(new Error("weightManifest field is missing from file "+this.jsonFile.name));return}if(this.weightsFiles.length===0){a({modelTopology:b});return}const w=sn(v,S=>this.loadWeights(S));a(w)},p.onerror=m=>c("Failed to read model topology and weights manifest JSON from file '"+this.jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."),p.readAsText(this.jsonFile)})}loadWeights(a){const c=[],p=[];for(const b of a)c.push(...b.weights),p.push(...b.paths);const m=this.checkManifestAndWeightFiles(a),v=p.map(b=>this.loadWeightsFile(b,m[b]));return Promise.all(v).then(b=>[c,b])}loadWeightsFile(a,c){return new Promise((p,m)=>{const v=new FileReader;v.onload=b=>{const w=b.target.result;p(w)},v.onerror=b=>m("Failed to weights data from file of path '"+a+"'."),v.readAsArrayBuffer(c)})}checkManifestAndWeightFiles(a){const c=[],p=this.weightsFiles.map(v=>sF(v.name)),m={};for(const v of a)v.paths.forEach(b=>{const w=sF(b);if(c.indexOf(w)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+w+"'");if(c.push(w),p.indexOf(w)===-1)throw new Error("Weight file with basename '"+w+"' is not provided.");m[b]=this.weightsFiles[p.indexOf(w)]});if(c.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest ("+c.length+") and the number of weight files provided ("+this.weightsFiles.length+").");return m}}const I9=u=>Hn().getBool("IS_BROWSER")&&!Array.isArray(u)&&u.startsWith(I7.URL_SCHEME)?IH(u.slice(I7.URL_SCHEME.length)):null;st.registerSaveRouter(I9);function IH(u="model"){return new I7(u)}function ID(u){return new I8(u)}function Iy(u,a,c,p){b(u),c=c??0,p=p??1,w(c,p);let m=0;const v=S=>(S.then(O=>{const q=c+ ++m/u.length*(p-c);return a(q),O}),S);function b(S){i(S!=null&&Array.isArray(S)&&S.length>0,()=>"promises must be a none empty array")}function w(S,O){i(S>=0&&S<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+S),i(O>=0&&O<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+O),i(O>=S,()=>"startFraction must be no more than endFraction, but got startFraction "+S+" and endFraction "+O)}return Promise.all(u.map(v))}async function Ia(u,a){a==null&&(a={});const c=a.fetchFunc==null?Hn().platform.fetch:a.fetchFunc,p=u.map(O=>c(O,a.requestInit,{isBinary:!0})),m=0,v=.5,b=(a.onProgress==null?await Promise.all(p):await Iy(p,a.onProgress,m,v)).map(O=>O.arrayBuffer()),w=.5,S=1;return a.onProgress==null?await Promise.all(b):await Iy(b,a.onProgress,w,S)}function Is(u,a){var c;const p=a.fetchFunc==null?Hn().platform.fetch:a.fetchFunc;let m=0,v;return(c=a.onProgress)===null||c===void 0||c.call(a,0),new ReadableStream({pull:async b=>{for(var w;m<u.length;){v||(v=(await p(u[m],a.requestInit,{isBinary:!0})).body.getReader());const{done:S,value:O}=await v.read();if(S){m++,v=void 0,(w=a.onProgress)===null||w===void 0||w.call(a,m/u.length);continue}b.enqueue(O);return}b.close()}})}async function II(u,a="",c,p){return IE(m=>Ia(m,{requestInit:p}))(u,a,c)}function IE(u){return async(a,c="",p)=>{const m=a.map(()=>!1),v={},b=p!=null?p.map(()=>!1):[],w=[];if(a.forEach(($,J)=>{let ee=0;$.weights.forEach(re=>{const de="quantization"in re?re.quantization.dtype:re.dtype,Te=ae[de]*G(re.shape),Me=()=>{m[J]=!0,v[J]==null&&(v[J]=[]),v[J].push({manifestEntry:re,groupOffset:ee,sizeBytes:Te})};p!=null?p.forEach((Ae,Ce)=>{Ae===re.name&&(Me(),b[Ce]=!0)}):Me(),w.push(re.name),ee+=Te})}),!b.every($=>$)){const $=p.filter((J,ee)=>!b[ee]);throw new Error("Could not find weights in manifest with names: "+$.join(", ")+`. 
Manifest JSON has weights with names: `+w.join(", ")+".")}const S=m.reduce(($,J,ee)=>(J&&$.push(ee),$),[]),O=[];S.forEach($=>{a[$].paths.forEach(J=>{const ee=c+(c.endsWith("/")?"":"/")+J;O.push(ee)})});const q=await u(O),H={};let j=0;return S.forEach($=>{const J=a[$].paths.length,ee=new aB(q.slice(j,j+J));v[$].forEach(re=>{const de=ee.slice(re.groupOffset,re.groupOffset+re.sizeBytes),Te=sD(de,[re.manifestEntry]);for(const Me in Te)H[Me]=Te[Me]}),j+=J}),H}}const If="application/octet-stream",IO="application/json";class Ic{constructor(a,c){if(this.DEFAULT_METHOD="POST",c==null&&(c={}),this.weightPathPrefix=c.weightPathPrefix,this.weightUrlConverter=c.weightUrlConverter,c.fetchFunc!=null?(i(typeof c.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=c.fetchFunc):this.fetch=Hn().platform.fetch,i(a!=null&&a.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(a)&&i(a.length===2,()=>"URL paths for http must have a length of 2, (actual length is "+a.length+")."),this.path=a,c.requestInit!=null&&c.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=c.requestInit||{},this.loadOptions=c}async save(a){if(a.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const c=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);c.body=new FormData;const p=[{paths:["./model.weights.bin"],weights:a.weightSpecs}],m=sY(a,p);if(c.body.append("model.json",new Blob([JSON.stringify(m)],{type:IO}),"model.json"),a.weightData!=null){const b=aB.join(a.weightData);c.body.append("model.weights.bin",new Blob([b],{type:If}),"model.weights.bin")}const v=await this.fetch(this.path,c);if(v.ok)return{modelArtifactsInfo:sp(a),responses:[v]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+v.status+".")}async loadModelJSON(){const a=await this.fetch(this.path,this.requestInit);if(!a.ok)throw new Error("Request to "+this.path+" failed with status code "+a.status+". Please verify this URL points to the model JSON of the model to load.");let c;try{c=await a.json()}catch{let b="Failed to parse model JSON of response from "+this.path+".";throw this.path.endsWith(".pb")?b+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":b+=" Please make sure the server is serving valid JSON for this request.",new Error(b)}const p=c.modelTopology,m=c.weightsManifest;if(p==null&&m==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return c}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const a=await this.loadModelJSON();return sn(a,c=>this.loadWeights(c))}async loadStream(){const a=await this.loadModelJSON(),c=await this.getWeightUrls(a.weightsManifest),p=sS(a.weightsManifest),m=()=>Is(c,this.loadOptions);return Object.assign(Object.assign({},a),{weightSpecs:p,getWeightStream:m})}async getWeightUrls(a){const c=Array.isArray(this.path)?this.path[1]:this.path,[p,m]=IZ(c),v=this.weightPathPrefix||p,b=[],w=[];for(const S of a)for(const O of S.paths)this.weightUrlConverter!=null?w.push(this.weightUrlConverter(O)):b.push(v+O+m);return this.weightUrlConverter&&b.push(...await Promise.all(w)),b}async loadWeights(a){const c=await this.getWeightUrls(a),p=sS(a),m=await Ia(c,this.loadOptions);return[p,m]}}Ic.URL_SCHEME_REGEX=/^https?:\/\//;function IZ(u){const a=u.lastIndexOf("/"),c=u.lastIndexOf("?"),p=u.substring(0,a),m=c>a?u.substring(c):"";return[p+"/",m]}function IL(u){return u.match(Ic.URL_SCHEME_REGEX)!=null}const Iq=(u,a)=>{if(typeof fetch>"u"&&(a==null||a.fetchFunc==null))return null;{let c=!0;if(Array.isArray(u)?c=u.every(p=>IL(p)):c=IL(u),c)return IF(u,a)}return null};st.registerSaveRouter(Iq),st.registerLoadRouter(Iq);function IF(u,a){return new Ic(u,a)}function IY(u,a){return IF(u,a)}class Io{constructor(a){this.modelArtifacts=a}load(){return this.modelArtifacts}}class In{constructor(a){this.saveHandler=a}save(a){return this.saveHandler(a)}}class Ip{constructor(a){a.load&&(this.load=()=>Promise.resolve(a.load())),a.save&&(this.save=c=>Promise.resolve(a.save(c)))}}function IS(u,a,c,p){const m=arguments;return new Ip(Il(...m))}function Il(u,a,c,p){return arguments.length===1?u.modelTopology!=null||u.weightSpecs!=null?new Io(u):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Io({modelTopology:u})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Io({modelTopology:u,weightSpecs:a,weightData:c,trainingConfig:p}))}function Ih(u){return new In(u)}function Ii(u){return new In(u)}const Im="://";class It{constructor(){this.managers={}}static getInstance(){return It.instance==null&&(It.instance=new It),It.instance}static registerManager(a,c){i(a!=null,()=>"scheme must not be undefined or null."),a.endsWith(Im)&&(a=a.slice(0,a.indexOf(Im))),i(a.length>0,()=>"scheme must not be an empty string.");const p=It.getInstance();i(p.managers[a]==null,()=>"A model store manager is already registered for scheme '"+a+"'."),p.managers[a]=c}static getManager(a){const c=It.getInstance().managers[a];if(c==null)throw new Error("Cannot find model manager for scheme '"+a+"'");return c}static getSchemes(){return Object.keys(It.getInstance().managers)}}function Ik(u){if(u.indexOf(Im)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+It.getSchemes().join(","));return{scheme:u.split(Im)[0],path:u.split(Im)[1]}}async function Iw(u,a,c=!1){i(u!==a,()=>"Old path and new path are the same: '"+u+"'");const p=st.getLoadHandlers(u);i(p.length>0,()=>"Copying failed because no load handler is found for source URL "+u+"."),i(p.length<2,()=>"Copying failed because more than one ("+p.length+") load handlers for source URL "+u+".");const m=p[0],v=st.getSaveHandlers(a);i(v.length>0,()=>"Copying failed because no save handler is found for destination URL "+a+"."),i(v.length<2,()=>"Copying failed because more than one ("+p.length+") save handlers for destination URL "+a+".");const b=v[0],w=Ik(u).scheme,S=Ik(u).path,O=w===Ik(u).scheme,q=await m.load();c&&O&&await It.getManager(w).removeModel(S);const H=await b.save(q);return c&&!O&&await It.getManager(w).removeModel(S),H.modelArtifactsInfo}async function IU(){const u=It.getSchemes(),a={};for(const c of u){const p=await It.getManager(c).listModels();for(const m in p){const v=c+Im+m;a[v]=p[m]}}return a}async function IG(u){const a=Ik(u);return It.getManager(a.scheme).removeModel(a.path)}async function Iz(u,a){return Iw(u,a,!1)}async function IW(u,a){return Iw(u,a,!0)}var IR=Object.freeze({__proto__:null,CompositeArrayBuffer:aB,browserFiles:ID,browserHTTPRequest:IY,concatenateArrayBuffers:sq,copyModel:Iz,decodeWeights:sD,decodeWeightsStream:sE,encodeWeights:sH,fromMemory:IS,fromMemorySync:Il,getLoadHandlers:sG,getModelArtifactsForJSON:sn,getModelArtifactsForJSONSync:so,getModelArtifactsInfoForJSON:sp,getSaveHandlers:sU,getWeightSpecs:sS,http:IF,isHTTPScheme:IL,listModels:IU,loadWeights:II,moveModel:IW,registerLoadRouter:sw,registerSaveRouter:sk,removeModel:IG,weightsLoaderFactory:IE,withSaveHandler:Ih,withSaveHandlerSync:Ii});function Ij(u,a){const c=aK(u,"x","cast");if(!H1(a))throw new Error("Failed to cast to unknown dtype "+a);if(a==="string"&&c.dtype!=="string"||a!=="string"&&c.dtype==="string")throw new Error("Only strings can be casted to strings");const p={x:c},m={dtype:a};return aA.runKernel(HA,p,m)}const IA=ad({cast_:Ij});function IC(u,a,c=!1,p=!1){let m=aK(u,"a","matMul"),v=aK(a,"b","matMul");[m,v]=at(m,v);const b={a:m,b:v},w={transposeA:c,transposeB:p};return aA.runKernel(HW,b,w)}const Iu=ad({matMul_:IC});function IQ(u){const a={input:aK(u,"input","imag")};return aA.runKernel(D6,a)}const IJ=ad({imag_:IQ});function Ix(u){const a={x:aK(u,"x","neg")};return aA.runKernel(Dc,a)}const IM=ad({neg_:Ix});function IX(u){const a={input:aK(u,"input","real")};return aA.runKernel(DS,a)}const Ig=ad({real_:IX});function IK(u,a,c){const p=aK(u,"x","transpose");if(a==null&&(a=p.shape.map((b,w)=>w).reverse()),i(p.rank===a.length,()=>"Error in transpose: rank of input "+p.rank+" must match length of perm "+a+"."),a.forEach(b=>{i(b>=0&&b<p.rank,()=>"All entries in 'perm' must be between 0 and "+(p.rank-1)+" but got "+a)}),p.rank<=1)return p.clone();const m={x:p},v={perm:a};return p.dtype==="complex64"?s2(()=>{let b=Ig(p),w=IJ(p);return b=aA.runKernel(DX,{x:b},v),w=aA.runKernel(DX,{x:w},v),c&&(w=IM(w)),av(b,w)}):aA.runKernel(DX,m,v)}const Ib=ad({transpose_:IK});function IV(u,a){const c=u.length,p=[];for(let m=0;m<c;m++){const v=c-1-m,b=u[v]||1;(a[a.length-1-m]||1)>1&&b===1&&p.unshift(v)}return p}function Id(u,a){const c=[];for(let p=0;p<a.length;p++){const m=u[u.length-p-1],v=a.length-p-1,b=a[v];(m==null||m===1&&b>1)&&c.unshift(v)}return c}function IP(u,a){const c=Math.max(u.length,a.length),p=new Array(c);for(let m=0;m<c;m++){let v=u[u.length-m-1];v==null&&(v=1);let b=a[a.length-m-1];if(b==null&&(b=1),v===1)p[c-m-1]=b;else if(b===1)p[c-m-1]=v;else if(v!==b){const w="Operands could not be broadcast together with shapes "+u+" and "+a+".";throw Error(w)}else p[c-m-1]=v}return p}function Iv(u,a,c){if(U(u),a!=null&&a.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const p=aM(u,c);if(p.length!==3&&p.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(p.length===1&&a==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return aT(u,a,p,c)}let IT;function Ir(u,a=3){if(a>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(u==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let c=!1,p=!1,m=!1,v=!1,b=!1,w=!1;if(u.data instanceof Uint8Array)c=!0;else if(typeof ImageData<"u"&&u instanceof ImageData)p=!0;else if(typeof HTMLVideoElement<"u"&&u instanceof HTMLVideoElement)m=!0;else if(typeof HTMLImageElement<"u"&&u instanceof HTMLImageElement)v=!0;else if(u.getContext!=null)b=!0;else if(typeof ImageBitmap<"u"&&u instanceof ImageBitmap)w=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+u.constructor.name);if(y0(DV,aA.backendName)!=null){const j={pixels:u},$={numChannels:a};return aA.runKernel(DV,j,$)}const[S,O]=m?[u.videoWidth,u.videoHeight]:[u.width,u.height];let q;if(b)q=u.getContext("2d").getImageData(0,0,S,O).data;else if(p||c)q=u.data;else if(v||m||w){if(IT==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")IT=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else IT=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});IT.canvas.width=S,IT.canvas.height=O,IT.drawImage(u,0,0,S,O),q=IT.getImageData(0,0,S,O).data}let H;if(a===4)H=new Int32Array(q);else{const j=S*O;H=new Int32Array(j*a);for(let $=0;$<j;$++)for(let J=0;J<a;++J)H[$*a+J]=q[$*4+J]}return Iv(H,[O,S,a],"int32")}const Ie=ad({fromPixels_:Ir});function IB(u,a){const c=u.shape.length,p=a.shape.length;if(c<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+c+".");if(p<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+p+".");if(a.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+a.dtype+".");if(a.shape[p-1]>c)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+a.shape[p-1]+" vs. "+c);if(G(u.shape)===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+u.shape+".");const m=a.shape,v=m[m.length-1];let b=1;for(let H=0;H<m.length-1;++H)b*=m[H];const w=u.shape,S=m.slice();S.pop();let O=1;for(let H=v;H<c;++H)O*=w[H],S.push(w[H]);const q=[...HD(u.shape).map(H=>H/O),1].slice(0,v);return[S,b,O,q]}function IN(u,a,c){const p=a.rank>1?a.shape[a.rank-1]:1,m=a.rank>1?a.rank-1:1,v="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+c.shape+", indices.shape: "+a.shape+", shape: "+u+", sliceDim: "+p+", and batchDim: "+m+".";if(c.rank<m)throw new Error(v+(" update.rank < "+m+". "));if(u.length<p+(c.rank-m))throw new Error(v+(" Output shape length < "+(p+(c.rank-m))));if(c.rank!==m+u.length-p)throw new Error(v+(" update.rank != "+(m+u.length-p)));for(let b=0;b<m;++b)if(c.shape[b]!==a.shape[b])throw new Error(v+(" updates.shape["+b+"] ("+c.shape[b]+") != indices.shape["+b+"] ("+a.shape[b]+")."));for(let b=0;b<c.rank-m;++b)if(c.shape[b+m]!==u[b+p])throw new Error(v+(" updates.shape["+(b+m)+"] ("+c.shape[b+m]+") != shape["+(b+m)+"] ("+u[b+m]+")"))}function E0(u,a,c){if(a.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+a.rank+".");if(u.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+u.rank+".");if(a.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+a.dtype);if(c.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+c);if(c.length===0){if(a.size===0)throw new Error("Indices specified for empty output. indices shape: "+a.shape);if(u.size===0)throw new Error("Updates specified for empty output. updates shape: "+u.shape)}IN(c,a,u)}function E1(u,a,c){const p=a.shape.length,m=p>1?a.shape[p-1]:1,v=c.length;let b=1;for(let H=m;H<v;++H)b*=c[H];const w=m<1?1:m,S=G(a.shape)/w,O=[...HD(c.slice(0,m)),1],q=G(c);return{sliceRank:m,numUpdates:S,sliceSize:b,strides:O,outputSize:q}}const E2=-2,E3=-1;function E4(u,a,c){const p=u.shape.length;i(p===a.length,()=>"Error in slice"+p+"D: Length of begin "+a+" must match the rank of the array ("+p+")."),i(p===c.length,()=>"Error in slice"+p+"D: Length of size "+c+" must match the rank of the array ("+p+").");for(let m=0;m<p;++m)i(a[m]+c[m]<=u.shape[m],()=>"Error in slice"+p+"D: begin["+m+"] + size["+m+"] ("+(a[m]+c[m])+") would overflow input.shape["+m+"] ("+u.shape[m]+")")}function E5(u){const a=[];let c=0;for(;u>0;)u&1&&a.push(c),u/=2,c++;return a}function E6(u,a,c){const p=[];for(let m=0;m<u.length;m++)p[m]=Math.ceil((a[m]-u[m])/c[m]);return p}function E7(u,a,c,p){const m=[...u];for(let v=m.length;v<p.length;v++)m.push(1);for(let v=0;v<c;v++)v===0?m[a]=1:(m.splice(a,0,1),m.pop());return m}function E8(u,a,c){return c<=u?c:c-(a-1)}function E9(u,a){const c=[];for(let p=0;p<u;p++)c.push(a+p);return c}function EH(u,a,c,p,m,v,b,w,S){const O=u.length;let q=new Array(O),H=new Array(O),j=new Array(O);if(a.length&&c>0){const $=a[0],J=c+1;q=ED(b,$,J,p,u),H=Ey(w,$,J,m,u),j=E7(v,$,J,u)}else for(let $=0;$<O;$++)q[$]=Es(b,p,v,u,$,S),H[$]=EI(w,m,v,u,$,S),j[$]=Ea(v,$,S);return{begin:q,end:H,strides:j}}function ED(u,a,c,p,m){const v=[...m],b=E9(c,a);for(let w=0;w<v.length;w++)if(b.indexOf(w)>-1)v[w]=0;else{const S=E8(a,c,w);let O=p[S];u&1<<S&&(O=0),v[w]=O}return v}function Ey(u,a,c,p,m){const v=[...m],b=E9(c,a);for(let w=0;w<v.length;w++)if(b.indexOf(w)>-1)v[w]=Number.MAX_SAFE_INTEGER;else{const S=E8(a,c,w);let O=p[S];u&1<<S&&(O=Number.MAX_SAFE_INTEGER),v[w]=O}for(let w=0;w<v.length;w++){const S=m[w];v[w]<0&&(v[w]+=S),v[w]=o(0,v[w],m[w])}return v}function Ea(u,a,c){let p=u[a];return(c&1<<a||p==null)&&(p=1),p}function Es(u,a,c,p,m,v){let b=a[m];const w=c[m]||1;(u&1<<m||v&1<<m||b==null)&&(w>0?b=Number.MIN_SAFE_INTEGER:b=Number.MAX_SAFE_INTEGER);const S=p[m];return b<0&&(b+=S),b=o(0,b,S-1),b}function EI(u,a,c,p,m,v){let b=a[m];const w=c[m]||1;(u&1<<m||v&1<<m||b==null)&&(w>0?b=Number.MAX_SAFE_INTEGER:b=Number.MIN_SAFE_INTEGER);const S=p[m];return b<0&&(b+=S),w>0?b=o(0,b,S):b=o(-1,b,S-1),b}function EE(u,a,c){let p=c.length;for(let m=0;m<c.length;m++)if(c[m]>1){p=m;break}for(let m=p+1;m<c.length;m++)if(a[m]>0||c[m]!==u[m])return!1;return!0}function Ef(u,a){let c=u.length>0?u[u.length-1]:1;for(let p=0;p<u.length-1;p++)c+=u[p]*a[p];return c}function EO(u,a,c){let p;const m=u.shape.length;typeof a=="number"?p=[a,...new Array(m-1).fill(0)]:a.length<m?p=a.concat(new Array(m-a.length).fill(0)):p=a.slice(),p.forEach(b=>{i(b!==-1,()=>"slice() does not support negative begin indexing.")});let v;return c==null?v=new Array(m).fill(-1):typeof c=="number"?v=[c,...new Array(m-1).fill(-1)]:c.length<m?v=c.concat(new Array(m-c.length).fill(-1)):v=c,v=v.map((b,w)=>b>=0?b:(i(b===-1,()=>"Negative size values should be exactly -1 but got "+b+" for the slice() size at index "+w+"."),u.shape[w]-p[w])),[p,v]}function Ec(u,a,c,p,m,v,b,w,S){let O;if(p==null?(O=new Array(a.length),O.fill(1)):O=p,b!=null&&b&b-1)throw new Error("Multiple ellipses in slice is not allowed.");let q=!1;const H={dims:O.length,numAddAxisAfterEllipsis:0,begin:a.slice(),end:c.slice(),strides:O.slice(),beginMask:m,endMask:v,ellipsisMask:b,newAxisMask:w,shrinkAxisMask:S};for(let Te=0;Te<H.dims;Te++)q&&1<<Te&w&&H.numAddAxisAfterEllipsis++,1<<Te&b&&(q=!0);q||(H.ellipsisMask|=1<<H.dims,H.dims++);const j={dims:u.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};EZ(H,j);let $=!0,J=!0,ee=!0;const re=[],de=[];for(let Te=0;Te<u.length;++Te){if(j.strides[Te]===0)throw Error("strides["+Te+"] must be non-zero");const Me=!!(j.shrinkAxisMask&1<<Te),Ae=u[Te];if(Ae===-1){re.push(Me?1:-1);continue}const Ce=[j.beginMask&1<<Te,j.endMask&1<<Te],Pe=[j.strides[Te]>0?0:-1,j.strides[Te]>0?Ae:Ae-1];if(Me&&j.strides[Te]<=0)throw Error("only stride 1 allowed on non-range indexing.");ee=ee&&j.strides[Te]===1;const je=!!(j.beginMask&1<<Te&&j.endMask&1<<Te);if(j.beginValid&&j.endValid){if(Me){const dt=j.begin[Te]<0?Ae+j.begin[Te]:j.begin[Te];if(j.begin[Te]=dt,j.end[Te]=j.begin[Te]+1,dt<0||dt>=Ae)throw Error("slice index "+j.begin[Te]+" of dimension "+Te+" out of bounds.")}else j.begin[Te]=EL(j.begin[Te],0,j.strides[Te],Ae,Ce,Pe),j.end[Te]=EL(j.end[Te],1,j.strides[Te],Ae,Ce,Pe);const Ct=j.strides[Te]===1&&j.begin[Te]===0&&j.end[Te]===Ae;$=$&&Ct,J=J&&(Te===0&&j.strides[Te]===1||Ct)}else $=$&&j.strides[Te]===1&&je,J=J&&(Te===0&&j.strides[Te]===1||je);let Ne,Qe=!1;if(j.beginValid&&j.endValid?(Ne=j.end[Te]-j.begin[Te],Qe=!0):Me?(Ne=1,Qe=!0):je&&Ae>=0&&(j.strides[Te]<0?Ne=-Ae:Ne=Ae,Qe=!0),Qe){let Ct;Ne===0||Ne<0!=j.strides[Te]<0?Ct=0:Ct=Math.trunc(Ne/j.strides[Te])+(Ne%j.strides[Te]!==0?1:0),re.push(Ct)}else re.push(-1)}for(let Te=0;Te<j.finalShapeGatherIndices.length;++Te){const Me=j.finalShapeGatherIndices[Te];Me>=0?de.push(re[Me]):Me===E2&&de.push(1)}return{finalShapeSparse:de.filter((Te,Me)=>j.finalShapeGatherIndices[Me]!==E2),finalShape:de,isIdentity:$,sliceDim0:J,isSimpleSlice:ee,begin:j.begin,end:j.end,strides:j.strides}}function EZ(u,a){a.beginMask=0,a.endMask=0,a.shrinkAxisMask=0;let c=0;a.beginValid=u.begin!=null,a.endValid=u.end!=null,a.begin=new Array(a.dims),a.end=new Array(a.dims),a.strides=new Array(a.dims),a.finalShapeGatherIndices=[],a.finalShapeGatherIndicesSparse=[],a.inputShapeGatherIndicesSparse=new Array(a.dims);for(let p=0;p<u.dims;p++)if(1<<p&u.ellipsisMask){const m=Math.min(a.dims-(u.dims-p)+1+u.numAddAxisAfterEllipsis,a.dims);for(;c<m;c++)a.begin[c]=0,a.end[c]=0,a.strides[c]=1,a.beginMask|=1<<c,a.endMask|=1<<c,a.finalShapeGatherIndices.push(c),a.finalShapeGatherIndicesSparse.push(-1),a.inputShapeGatherIndicesSparse[c]=p}else if(1<<p&u.newAxisMask)a.finalShapeGatherIndices.push(E2),a.finalShapeGatherIndicesSparse.push(-1);else{if(c===a.begin.length)throw Error("Index out of range using input dim "+c+"; input has only "+a.dims+" dims, "+a.begin.length+".");u.begin!=null&&(a.begin[c]=u.begin[p]),u.end!=null&&(a.end[c]=u.end[p]),a.strides[c]=u.strides[p],u.beginMask&1<<p&&(a.beginMask|=1<<c),u.endMask&1<<p&&(a.endMask|=1<<c),u.shrinkAxisMask&1<<p?(a.finalShapeGatherIndices.push(E3),a.finalShapeGatherIndicesSparse.push(-1),a.shrinkAxisMask|=1<<c):(a.finalShapeGatherIndices.push(c),a.finalShapeGatherIndicesSparse.push(p)),a.inputShapeGatherIndicesSparse[c]=p,c++}}function EL(u,a,c,p,m,v){if(m[a])return c>0?v[a]:v[a+1&1];{const b=u<0?p+u:u;return b<v[0]?v[0]:b>v[1]?v[1]:b}}var Eq=Object.freeze({__proto__:null,assertParamsValid:E4,computeFlatOffset:Ef,computeOutShape:E6,getNormalizedAxes:EH,isSliceContinous:EE,maskToAxes:E5,parseSliceParams:EO,sliceInfo:Ec,startForAxis:Es,startIndicesWithElidedDims:ED,stopForAxis:EI,stopIndicesWithElidedDims:Ey,stridesForAxis:Ea,stridesWithElidedDims:E7});function EF(u,a){let c=aK(u,"a","add"),p=aK(a,"b","add");[c,p]=at(c,p);const m={a:c,b:p};return aA.runKernel(Hk,m)}const EY=ad({add_:EF});function Eo(u,a){let c=aK(u,"a","floorDiv"),p=aK(a,"b","floorDiv");[c,p]=at(c,p);const m={a:c,b:p};return aA.runKernel(D1,m)}const En=ad({floorDiv_:Eo});function Ep(u,a){let c=aK(u,"a","div"),p=aK(a,"b","div");if([c,p]=at(c,p),c.dtype==="int32"&&p.dtype==="int32")return En(c,p);const m={a:c,b:p},v={};return aA.runKernel(Hv,m,v)}const ES=ad({div_:Ep});function El(u,a){let c=aK(u,"a","mul"),p=aK(a,"b","mul");[c,p]=at(c,p);const m={a:c,b:p};return aA.runKernel(DO,m)}const Eh=ad({mul_:El});function Ei(u){const a=aK(u,"x","abs");if(a.dtype==="complex64"){const c={x:a};return aA.runKernel(HQ,c)}else{const c={x:a};return aA.runKernel(Ht,c)}}const Em=ad({abs_:Ei});function Et(u){i(Array.isArray(u),()=>"The argument passed to tf.addN() must be a list of tensors"),i(u.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+u.length);const a=u.map((m,v)=>aK(m,"tensors"+v,"addN")),c=a[0];a.forEach(m=>{if(m.dtype!==c.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),a.forEach(m=>{if(!z(m.shape,c.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const p=a;return aA.runKernel(Hw,p)}const Ek=ad({addN_:Et});function Ew(u,a){let c=aK(u,"a","atan2"),p=aK(a,"b","atan2");[c,p]=at(c,p);const m={a:c,b:p};return aA.runKernel(HU,m)}const EU=ad({atan2_:Ew});function EG(u,a,c,p,m="NHWC",v){const b=u[3],w=[...a,b],S=Ed(m);return ER(u,w,c,v,p,null,null,S)}function Ez(u,a,c,p,m,v,b="channelsLast"){const[w,S]=EQ(a);let O;if(b==="channelsLast")O=[w,S,u[3],u[3]];else if(b==="channelsFirst")O=[w,S,u[1],u[1]];else throw new Error("Unknown dataFormat "+b);return ER(u,O,c,p,m,v,!1,b)}function EW(u,a,c,p,m,v,b="NDHWC"){const[w,S,O]=EJ(a);let q,H;if(b==="NDHWC")H="channelsLast",q=[w,S,O,u[4],u[4]];else if(b==="NCDHW")H="channelsFirst",q=[w,S,O,u[1],u[1]];else throw new Error("Unknown dataFormat "+b);return Ej(u,q,c,p,m,!1,H,v)}function ER(u,a,c,p,m,v,b=!1,w="channelsLast"){let[S,O,q,H]=[-1,-1,-1,-1];if(w==="channelsLast")[S,O,q,H]=u;else if(w==="channelsFirst")[S,H,O,q]=u;else throw new Error("Unknown dataFormat "+w);const[j,$,,J]=a,[ee,re]=EQ(c),[de,Te]=EQ(p),Me=Ex(j,de),Ae=Ex($,Te),{padInfo:Ce,outHeight:Pe,outWidth:je}=EM(m,O,q,ee,re,Me,Ae,v,w),Ne=b?J*H:J;let Qe;return w==="channelsFirst"?Qe=[S,Ne,Pe,je]:w==="channelsLast"&&(Qe=[S,Pe,je,Ne]),{batchSize:S,dataFormat:w,inHeight:O,inWidth:q,inChannels:H,outHeight:Pe,outWidth:je,outChannels:Ne,padInfo:Ce,strideHeight:ee,strideWidth:re,filterHeight:j,filterWidth:$,effectiveFilterHeight:Me,effectiveFilterWidth:Ae,dilationHeight:de,dilationWidth:Te,inShape:u,outShape:Qe,filterShape:a}}function Ej(u,a,c,p,m,v=!1,b="channelsLast",w){let[S,O,q,H,j]=[-1,-1,-1,-1,-1];if(b==="channelsLast")[S,O,q,H,j]=u;else if(b==="channelsFirst")[S,j,O,q,H]=u;else throw new Error("Unknown dataFormat "+b);const[$,J,ee,,re]=a,[de,Te,Me]=EJ(c),[Ae,Ce,Pe]=EJ(p),je=Ex($,Ae),Ne=Ex(J,Ce),Qe=Ex(ee,Pe),{padInfo:Ct,outDepth:dt,outHeight:Xt,outWidth:Gt}=EX(m,O,q,H,de,Te,Me,je,Ne,Qe,w),Vt=v?re*j:re;let T0;return b==="channelsFirst"?T0=[S,Vt,dt,Xt,Gt]:b==="channelsLast"&&(T0=[S,dt,Xt,Gt,Vt]),{batchSize:S,dataFormat:b,inDepth:O,inHeight:q,inWidth:H,inChannels:j,outDepth:dt,outHeight:Xt,outWidth:Gt,outChannels:Vt,padInfo:Ct,strideDepth:de,strideHeight:Te,strideWidth:Me,filterDepth:$,filterHeight:J,filterWidth:ee,effectiveFilterDepth:je,effectiveFilterHeight:Ne,effectiveFilterWidth:Qe,dilationDepth:Ae,dilationHeight:Ce,dilationWidth:Pe,inShape:u,outShape:T0,filterShape:a}}function EA(u,a,c,p,m){p==null&&(p=Eu(u,a,c));const v=u[0],b=u[1],w=Eg((v-a+2*p)/c+1,m),S=Eg((b-a+2*p)/c+1,m);return[w,S]}function EC(u,a,c,p,m,v){m==null&&(m=Eu(u,a[0],p[0]));const b=[0,0,0,c];for(let w=0;w<3;w++)u[w]+2*m>=a[w]&&(b[w]=Eg((u[w]-a[w]+2*m)/p[w]+1,v));return b}function Eu(u,a,c,p=1){const m=Ex(a,p);return Math.floor((u[0]*(c-1)-c+m)/2)}function EQ(u){return typeof u=="number"?[u,u,u]:u.length===2?[u[0],u[1],1]:u}function EJ(u){return typeof u=="number"?[u,u,u]:u}function Ex(u,a){return a<=1?u:u+(u-1)*(a-1)}function EM(u,a,c,p,m,v,b,w,S){let O,q,H;if(typeof u=="number"){O={top:u,bottom:u,left:u,right:u,type:u===0?"VALID":"NUMBER"};const j=EA([a,c],v,p,u,w);q=j[0],H=j[1]}else if(u==="same"){q=Math.ceil(a/p),H=Math.ceil(c/m);const j=Math.max(0,(q-1)*p+v-a),$=Math.max(0,(H-1)*m+b-c),J=Math.floor(j/2),ee=j-J,re=Math.floor($/2),de=$-re;O={top:J,bottom:ee,left:re,right:de,type:"SAME"}}else if(u==="valid")O={top:0,bottom:0,left:0,right:0,type:"VALID"},q=Math.ceil((a-v+1)/p),H=Math.ceil((c-b+1)/m);else if(typeof u=="object"){const j=S==="channelsLast"?u[1][0]:u[2][0],$=S==="channelsLast"?u[1][1]:u[2][1],J=S==="channelsLast"?u[2][0]:u[3][0],ee=S==="channelsLast"?u[2][1]:u[3][1];O={top:j,bottom:$,left:J,right:ee,type:j===0&&$===0&&J===0&&ee===0?"VALID":"EXPLICIT"},q=Eg((a-v+j+$)/p+1,w),H=Eg((c-b+J+ee)/m+1,w)}else throw Error("Unknown padding parameter: "+u);return{padInfo:O,outHeight:q,outWidth:H}}function EX(u,a,c,p,m,v,b,w,S,O,q){let H,j,$,J;if(u==="valid"&&(u=0),typeof u=="number"){H={top:u,bottom:u,left:u,right:u,front:u,back:u,type:u===0?"VALID":"NUMBER"};const ee=EC([a,c,p,1],[w,S,O],1,[m,v,b],u,q);j=ee[0],$=ee[1],J=ee[2]}else if(u==="same"){j=Math.ceil(a/m),$=Math.ceil(c/v),J=Math.ceil(p/b);const ee=(j-1)*m+w-a,re=($-1)*v+S-c,de=(J-1)*b+O-p,Te=Math.floor(ee/2),Me=ee-Te,Ae=Math.floor(re/2),Ce=re-Ae,Pe=Math.floor(de/2),je=de-Pe;H={top:Ae,bottom:Ce,left:Pe,right:je,front:Te,back:Me,type:"SAME"}}else throw Error("Unknown padding parameter: "+u);return{padInfo:H,outDepth:j,outHeight:$,outWidth:J}}function Eg(u,a){if(!a)return Math.trunc(u);switch(a){case"round":return Math.round(u);case"ceil":return Math.ceil(u);case"floor":return Math.floor(u);default:throw new Error("Unknown roundingMode "+a)}}function EK(u){const[a,c,p]=EQ(u);return a===1&&c===1&&p===1}function Eb(u,a){return EK(u)||EK(a)}function EV(u){return EQ(u).every(a=>a>0)}function Ed(u){if(u==="NHWC")return"channelsLast";if(u==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+u)}function EP(u,a,c){if(c!=null){if(typeof a=="string")throw Error("Error in "+u+": pad must be an integer when using dimRoundingMode "+c+" but got pad "+a+".");if(typeof a=="number")i(W(a),()=>"Error in "+u+": pad must be an integer when using dimRoundingMode "+c+" but got pad "+a+".");else if(typeof a=="object")a.forEach(p=>{p.forEach(m=>{i(W(m),()=>"Error in "+u+": pad must be an integer when using dimRoundingMode "+c+" but got pad "+m+".")})});else throw Error("Error in "+u+": Unknown padding parameter: "+a)}}function Ev(u,a){const c={x:aK(u,"x","reshape","string_or_numeric")},p={shape:a};return aA.runKernel(Dh,c,p)}const ET=ad({reshape_:Ev});function Er(u,a,c,p,m){const v=aK(u,"x","avgPool","float32"),b=1;i(Eb(c,b),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+c+" and dilations '"+b+"'");let w=v,S=!1;v.rank===3&&(S=!0,w=ET(v,[1,v.shape[0],v.shape[1],v.shape[2]])),i(w.rank===4,()=>"Error in avgPool: x must be rank 4 but got rank "+w.rank+"."),EP("avgPool",p,m);const O={x:w},q={filterSize:a,strides:c,pad:p,dimRoundingMode:m};let H=aA.runKernel(HG,O,q);return H=IA(H,v.dtype),S?ET(H,[H.shape[1],H.shape[2],H.shape[3]]):H}const Ee=ad({avgPool_:Er});function EB(u){const a={x:aK(u,"x","clone","string_or_numeric")};return aA.runKernel(D5,a)}const EN=ad({clone_:EB});function f0(u,a=0){i(u.length>=1,()=>"Pass at least one tensor to concat");const c=ab(u,"tensors","concat","string_or_numeric");if(c[0].dtype==="complex64"&&c.forEach(v=>{if(v.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+v.dtype+". ")}),c.length===1)return EN(c[0]);const p=c,m={axis:a};return aA.runKernel(HJ,p,m)}const f1=ad({concat_:f0});function f2(u){const a={x:aK(u,"x","sigmoid","float32")};return aA.runKernel(DW,a)}const f3=ad({sigmoid_:f2});function f4(u,a,c){const p=aK(u,"x","slice","string_or_numeric");if(p.rank===0)throw new Error("Slicing scalar is not possible");const m={x:p},v={begin:a,size:c};return aA.runKernel(DG,m,v)}const f5=ad({slice_:f4});function f6(u,a,c){const p=aK(u,"x","batchToSpaceND"),m=a.reduce((w,S)=>w*S);i(p.rank>=1+a.length,()=>"input rank is "+p.rank+" but should be > than blockShape.length "+a.length),i(c.length===a.length,()=>"crops.length is "+c.length+" but should be equal to blockShape.length  "+a.length),i(p.shape[0]%m===0,()=>"input tensor batch is "+p.shape[0]+" but is not divisible by the product of the elements of blockShape "+a.join(" * ")+" === "+m);const v={x:p},b={blockShape:a,crops:c};return aA.runKernel(HR,v,b)}const f7=ad({batchToSpaceND_:f6});function f8(u,a,c){const p=aK(u,"x","bincount"),m=aK(a,"weights","bincount");i(p.dtype==="int32",()=>"Error in bincount: input dtype must be int32, but got "+p.dtype),i(c>=0,()=>"size must be non-negative, but got "+c+"."),i(m.size===p.size||m.size===0,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: "+p.shape+", weights shape: "+m.shape+".");const v={x:p,weights:m},b={size:c};return aA.runKernel(Hj,v,b)}const f9=ad({bincount_:f8});function fH(u,a){let c=aK(u,"broadcastTo","x");const p=c.shape;if(Hf(a),a.length<c.rank)throw new Error("broadcastTo(): shape.length="+a.length+" < input.rank="+c.rank+".");if(a.length>c.rank){const S=c.shape.slice();for(;S.length<a.length;)S.unshift(1);c=ET(c,S)}const m=c.shape,v=Array.from(a);for(let S=a.length-1;S>=0;S--)if(m[S]===a[S])v[S]=1;else if(c.shape[S]!==1)throw new Error("broadcastTo(): ["+p+"] cannot be broadcast to ["+a+"].");if(v.map((S,O)=>S>1?O:-1).filter(S=>S>=0).length===0)return EN(c);const b={x:c},w={reps:v};return aA.runKernel(Dx,b,w)}const fD=ad({broadcastTo_:fH});function fy(u,a="float32",c){return a=a||"float32",Hf(u),new as(u,a,c)}function fa(u,a,c){Hf(u),c=c||H8(a);const p={shape:u,value:a,dtype:c};return aA.runKernel(HB,{},p)}function fs(u,a,c){const p=aK(u,"x","clipByValue");if(i(a<=c,()=>"Error in clip: min ("+a+") must be less than or equal to max ("+c+")."),a===c)return fa(p.shape,a,p.dtype);const m={x:p},v={clipValueMin:a,clipValueMax:c};return aA.runKernel(HC,m,v)}const fI=ad({clipByValue_:fs});function fE(u,a){return f1(u,a)}const ff=ad({concat2d_:fE});function fO(u,a){return f1(u,a)}const fc=ad({concat3d_:fO});function fZ(u,a,c,p,m="NHWC",v=[1,1],b){const w=aK(u,"x","conv2d","float32"),S=aK(a,"filter","conv2d","float32");let O=w,q=!1;w.rank===3&&(q=!0,O=ET(w,[1,w.shape[0],w.shape[1],w.shape[2]])),i(O.rank===4,()=>"Error in conv2d: input must be rank 4, but got rank "+O.rank+"."),i(S.rank===4,()=>"Error in conv2d: filter must be rank 4, but got rank "+S.rank+"."),EP("conv2d",p,b);const H=m==="NHWC"?O.shape[3]:O.shape[1];i(H===S.shape[2],()=>"Error in conv2d: depth of input ("+H+") must match input depth for filter "+S.shape[2]+"."),i(Eb(c,v),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+c+" and dilations '"+v+"'"),i(EV(v),()=>"Error in conv2D: Dilated rates should be larger than 0."),i(EV(c),()=>"Error in conv2D: Strides should be larger than 0.");const j={x:O,filter:S},$={strides:c,pad:p,dataFormat:m,dilations:v,dimRoundingMode:b},J=aA.runKernel(Hx,j,$);return q?ET(J,[J.shape[1],J.shape[2],J.shape[3]]):J}const fL=ad({conv2d_:fZ});function fq(u,a,c,p,m,v="NHWC",b){i(u.length===a.rank,()=>"Length of inShape ("+u.length+") and rank of dy ("+a.rank+") must match");let w=u,S=a,O=!1;a.rank===3&&(O=!0,S=ET(a,[1,a.shape[0],a.shape[1],a.shape[2]]),w=[1,u[0],u[1],u[2]]),i(w.length===4,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+w.length+"."),i(S.rank===4,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+S.rank),i(c.rank===4,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+c.rank);const q=v==="NHWC"?w[3]:w[1],H=v==="NHWC"?S.shape[3]:S.shape[1];i(q===c.shape[2],()=>"Error in conv2dDerInput: depth of input ("+q+") must match input depth for filter "+c.shape[2]+"."),i(H===c.shape[3],()=>"Error in conv2dDerInput: depth of output ("+H+") must match output depth for filter "+c.shape[3]+"."),EP("conv2dDerInput",m,b);const j={dy:S,filter:c},$={strides:p,pad:m,dataFormat:v,dimRoundingMode:b,inputShape:w},J=aA.runKernel(HX,j,$);return O?ET(J,[J.shape[1],J.shape[2],J.shape[3]]):J}const fF=ad({conv2DBackpropInput_:fq});function fY(u){const a={x:aK(u,"x","cos","float32")};return aA.runKernel(Hg,a)}const fo=ad({cos_:fY});function fn(u,a,c="NHWC"){const p=aK(u,"x","depthToSpace","float32"),m=c==="NHWC"?p.shape[1]:p.shape[2],v=c==="NHWC"?p.shape[2]:p.shape[3],b=c==="NHWC"?p.shape[3]:p.shape[1];i(a>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+a),i(m*a>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+m+" and "+a+`  for depthToSpace with input shape
    `+p.shape),i(v*a>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+v+" and "+a+` for depthToSpace with input shape
        `+p.shape),i(b%(a*a)===0,()=>"Dimension size must be evenly divisible by "+a*a+" but is "+b+" for depthToSpace with input shape "+p.shape);const w={x:p},S={blockSize:a,dataFormat:c};return aA.runKernel(Hb,w,S)}const fp=ad({depthToSpace_:fn});function fS(u,a,c,p,m="NHWC",v=[1,1],b){const w=aK(u,"x","depthwiseConv2d","float32"),S=aK(a,"filter","depthwiseConv2d","float32");let O=w,q=!1;w.rank===3&&(q=!0,O=ET(w,[1,w.shape[0],w.shape[1],w.shape[2]])),i(O.rank===4,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank "+O.rank+"."),i(S.rank===4,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+S.rank+".");const H=m==="NHWC"?O.shape[3]:O.shape[1];i(H===S.shape[2],()=>"Error in depthwiseConv2d: number of input channels ("+H+") must match the inChannels dimension in filter "+S.shape[2]+"."),EP("depthwiseConv2d",p,b);const j={x:O,filter:S},$={strides:c,pad:p,dataFormat:m,dilations:v,dimRoundingMode:b},J=aA.runKernel(HV,j,$);return q?ET(J,[J.shape[1],J.shape[2],J.shape[3]]):J}const fl=ad({depthwiseConv2d_:fS});function fh(u,a,c){const p=aK(a,"a","where"),m=aK(c,"b","where"),v=aK(u,"condition","where","bool"),b=IP(IP(v.shape,p.shape),m.shape),w=fD(v,b),S=fD(p,b),O=fD(m,b),q={condition:w,t:S,e:O};return aA.runKernel(DU,q)}const fi=ad({where_:fh});function fm(u){const a={x:aK(u,"x","zerosLike")};return aA.runKernel(DK,a)}const ft=ad({zerosLike_:fm});function fk(u,...a){const c=a.map((m,v)=>aK(m,"tensors"+v,"einsum")),p={equation:u};return aA.runKernel(HT,c,p)}const fw=ad({einsum_:fk});function fU(u){const a={x:aK(u,"x","elu","float32")};return aA.runKernel(Hr,a)}const fG=ad({elu_:fU});function fz(u,a){for(let c=0;c<u.length;++c)if(u[u.length-c-1]!==a-1-c)return!1;return!0}function fW(u,a,c){const p=u.length+a.length,m=[];let v=0,b=0;for(let w=0;w<p;w++)c.indexOf(w)===-1?m.push(u[v++]):m.push(a[b++]);return m}function fR(u,a){const c=[],p=u.length;for(let v=0;v<p;v++)a.indexOf(v)===-1&&c.push(u[v]);const m=a.map(v=>u[v]);return[c,m]}function fj(u,a){const c=a.map(p=>1);return fW(u,c,a)}function fA(u,a,c){i(fz(a,c),()=>u+" supports only inner-most axes for now. Got axes "+a+" and rank-"+c+" input.")}function fC(u,a){if(fz(u,a))return null;const c=[];for(let p=0;p<a;++p)u.indexOf(p)===-1&&c.push(p);return u.forEach(p=>c.push(p)),c}function fu(u){return u.map((a,c)=>[c,a]).sort((a,c)=>a[1]-c[1]).map(a=>a[0])}function fQ(u,a){const c=[];for(let p=a-u;p<a;++p)c.push(p);return c}function fJ(u,a=null,c=!1){const p={x:aK(u,"x","max")},m={reductionIndices:a,keepDims:c};return aA.runKernel(Dy,p,m)}const fx=ad({max_:fJ});function fM(u,a=null,c=!1){const p={x:aK(u,"x","min")},m={axis:a,keepDims:c};return aA.runKernel(DE,p,m)}const fX=ad({min_:fM});function fg(u,a){let c=aK(u,"base","pow"),p=aK(a,"exp","pow");[c,p]=at(c,p);const m={a:c,b:p};return aA.runKernel(Do,m)}const fK=ad({pow_:fg});function fb(u,a){if((yB(u)&&a!=="string"||Array.isArray(u))&&a!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(a==="string"&&yB(u)&&!(u instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return aT(u,[],[],a)}function fV(u){const a={x:aK(u,"x","sqrt","float32")};return aA.runKernel(DR,a)}const fd=ad({sqrt_:fV});function fP(u){const a=aK(u,"x","square"),c={};return aA.runKernel("Square",{x:a},c)}const fv=ad({square_:fP});function fT(u,a=null,c=!1){let p=aK(u,"x","sum");p.dtype==="bool"&&(p=IA(p,"int32"));const m={x:p},v={axis:a,keepDims:c};return aA.runKernel(Dj,m,v)}const fr=ad({sum_:fT});function fe(u,a="euclidean",c=null,p=!1){u=aK(u,"x","norm");const m=fB(u,a,c);let v=m.shape;if(p){const b=P(c,u.shape);v=fj(m.shape,b)}return ET(m,v)}function fB(u,a,c=null){if(u.rank===0)return Em(u);if(u.rank!==1&&c===null)return fB(ET(u,[-1]),a,c);if(u.rank===1||typeof c=="number"||Array.isArray(c)&&c.length===1){if(a===1)return fr(Em(u),c);if(a===1/0)return fx(Em(u),c);if(a===-1/0)return fX(Em(u),c);if(a==="euclidean"||a===2)return fd(fr(fK(Em(u),fb(2,"int32")),c));throw new Error("Error in norm: invalid ord value: "+a)}if(Array.isArray(c)&&c.length===2){if(a===1)return fx(fr(Em(u),c[0]),c[1]-1);if(a===1/0)return fx(fr(Em(u),c[1]),c[0]);if(a===-1/0)return fX(fr(Em(u),c[1]),c[0]);if(a==="fro"||a==="euclidean")return fd(fr(fv(u),c));throw new Error("Error in norm: invalid ord value: "+a)}throw new Error("Error in norm: invalid axis: "+c)}const fN=ad({norm_:fe});function O0(u,a=null,c=!1){return fN(u,"euclidean",a,c)}const O1=ad({euclideanNorm_:O0});function O2(u,a=0){const c=aK(u,"x","expandDims","string_or_numeric");i(a<=c.rank,()=>"Axis must be <= rank of the tensor");const p={input:c},m={dim:a};return aA.runKernel(He,p,m)}const O3=ad({expandDims_:O2});function O4(u,a){const c=aK(u,"x","tile","string_or_numeric");i(c.rank===a.length,()=>"Error in transpose: rank of input "+c.rank+" must match length of reps "+a+".");const p={x:c},m={reps:a};return aA.runKernel(Dx,p,m)}const O5=ad({tile_:O4});function O6(u){const a={x:aK(u,"x","floor","float32")};return aA.runKernel(D0,a)}const O7=ad({floor_:O6});function O8(u,a,c=0,p=0){const m=aK(u,"x","gather"),v=aK(a,"indices","gather","int32"),b={x:m,indices:v},w={axis:c,batchDims:p};return aA.runKernel(D2,b,w)}const O9=ad({gather_:O8});function OH(u,a){let c=aK(u,"a","greater","string_or_numeric"),p=aK(a,"b","greater","string_or_numeric");[c,p]=at(c,p),IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(D3,m)}const OD=ad({greater_:OH});function Oy(u,a){let c=aK(u,"a","greaterEqual","string_or_numeric"),p=aK(a,"b","greaterEqual","string_or_numeric");[c,p]=at(c,p),IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(D4,m)}const Oa=ad({greaterEqual_:Oy});function Os(u,a=.2){const c={x:aK(u,"x","leakyRelu")},p={alpha:a};return aA.runKernel(D7,c,p)}const OI=ad({leakyRelu_:Os});function OE(u,a){let c=aK(u,"a","less","string_or_numeric"),p=aK(a,"b","less","string_or_numeric");[c,p]=at(c,p),IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(D8,m)}const Of=ad({less_:OE});function OO(u,a){let c=aK(u,"a","lessEqual","string_or_numeric"),p=aK(a,"b","lessEqual","string_or_numeric");[c,p]=at(c,p),IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(D9,m)}const Oc=ad({lessEqual_:OO});function OZ(u){return aA.customGrad(u)}function OL(u,a){let c=aK(u,"a","sub"),p=aK(a,"b","sub");[c,p]=at(c,p);const m={a:c,b:p};return aA.runKernel(DJ,m)}const Oq=ad({sub_:OL});function OF(u,a){const c=aK(u,"a","logicalAnd","bool"),p=aK(a,"b","logicalAnd","bool");IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(DH,m)}const OY=ad({logicalAnd_:OF});function Oo(u,a){const c=aK(u,"a","logicalOr","bool"),p=aK(a,"b","logicalOr","bool");IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(DD,m)}const On=ad({logicalOr_:Oo});function Op(u,a,c,p,m){const v=aK(u,"x","maxPool"),b=1;let w=v,S=!1;v.rank===3&&(S=!0,w=ET(v,[1,v.shape[0],v.shape[1],v.shape[2]])),i(w.rank===4,()=>"Error in maxPool: input must be rank 4 but got rank "+w.rank+"."),i(Eb(c,b),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+c+" and dilations '"+b+"'"),EP("maxPool",p,m);const O={x:w},q={filterSize:a,strides:c,pad:p,dimRoundingMode:m},H=aA.runKernel(Ds,O,q);return S?ET(H,[H.shape[1],H.shape[2],H.shape[3]]):H}const OS=ad({maxPool_:Op});function Ol(u,a){let c=aK(u,"a","maximum"),p=aK(a,"b","maximum");[c,p]=at(c,p),c.dtype==="bool"&&(c=IA(c,"int32"),p=IA(p,"int32")),IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(Da,m)}const Oh=ad({maximum_:Ol});function Oi(u,a=null,c=!1){const p={x:aK(u,"x","mean")},m={axis:a,keepDims:c};return aA.runKernel(DI,p,m)}const Om=ad({mean_:Oi});function Ot(u,a="float32"){if(Hf(u),a==="complex64"){const p=Ot(u,"float32"),m=Ot(u,"float32");return av(p,m)}const c=HE(G(u),a);return aA.makeTensor(c,u,a)}function Ok(u,a){let c=aK(u,"a","minimum"),p=aK(a,"b","minimum");[c,p]=at(c,p),c.dtype==="bool"&&(c=IA(c,"int32"),p=IA(p,"int32")),IP(c.shape,p.shape);const m={a:c,b:p};return aA.runKernel(Df,m)}const Ow=ad({minimum_:Ok});function OU(u,a,c=0){const p=aK(u,"x","pad");if(p.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const m={paddings:a,constantValue:c},v={x:p};return aA.runKernel(DY,v,m)}const OG=ad({pad_:OU});function Oz(u,a,c){const p=aK(u,"x","spaceToBatchND");i(p.rank>=1+a.length,()=>"input rank "+p.rank+" should be > than [blockShape] "+a.length),i(c.length===a.length,()=>"paddings.shape[0] "+c.length+" must be equal to [blockShape] "+a.length),i(p.shape.reduce((b,w,S)=>S>0&&S<=a.length?b&&(w+c[S-1][0]+c[S-1][1])%a[S-1]===0:b,!0),()=>"input spatial dimensions "+p.shape.slice(1)+" with paddings "+c.toString()+" must be divisible by blockShapes "+a.toString());const m={x:p},v={blockShape:a,paddings:c};return aA.runKernel(DA,m,v)}const OW=ad({spaceToBatchND_:Oz});function OR(u,a,c,p,m,v,b){m==null&&(m=[1,1]),v==null&&(v=1),p===0&&(p="valid");const w=aK(u,"x","maxPool");let S=w,O=!1;w.rank===3&&(O=!0,S=ET(w,[1,w.shape[0],w.shape[1],w.shape[2]])),i(Eb(v,m),()=>"Error in pool: Either strides or dilations must be 1. Got strides "+v+" and dilations '"+m+"'");const q=Ez(S.shape,a,v,m,p),H=[q.dilationHeight,q.dilationWidth];let j;p==="same"?j=OA([q.filterHeight,q.filterWidth],H):j=[[0,0],[0,0]];const $=H[0]===1&&H[1]===1,[J,ee]=Oj([q.inHeight,q.inWidth],H,j),re=$?p:"valid",de=$?S:OW(S,H,J),Te=(c==="avg"?()=>Ee(de,a,v,re,b):()=>OS(de,a,v,re,b))(),Me=$?Te:f7(Te,H,ee);return O?ET(Me,[Me.shape[1],Me.shape[2],Me.shape[3]]):Me}function Oj(u,a,c){const p=c.map(q=>q[0]),m=c.map(q=>q[1]),v=u.concat(p,m),b=a.map((q,H)=>(q-v[H]%q)%q),w=m.map((q,H)=>q+b[H]),S=a.map((q,H)=>[p[H],w[H]]),O=a.map((q,H)=>[0,b[H]]);return[S,O]}function OA(u,a){const c=u.map((v,b)=>v+(v-1)*(a[b]-1)).map(v=>v-1),p=c.map(v=>Math.floor(v/2)),m=c.map((v,b)=>v-p[b]);return c.map((v,b)=>[p[b],m[b]])}const OC=ad({pool_:OR});function Ou(u,a){const c=aK(u,"x","prelu"),p=aK(a,"alpha","prelu"),m={x:c,alpha:p};return aA.runKernel(Dn,m)}const OQ=ad({prelu_:Ou});function OJ(u,a=!1){console.log(u.toString(a))}var Ox={exports:{}};Ox.exports,function(u){(function(a,c,p){function m(S){var O=this,q=w();O.next=function(){var H=2091639*O.s0+O.c*23283064365386963e-26;return O.s0=O.s1,O.s1=O.s2,O.s2=H-(O.c=H|0)},O.c=1,O.s0=q(" "),O.s1=q(" "),O.s2=q(" "),O.s0-=q(S),O.s0<0&&(O.s0+=1),O.s1-=q(S),O.s1<0&&(O.s1+=1),O.s2-=q(S),O.s2<0&&(O.s2+=1),q=null}function v(S,O){return O.c=S.c,O.s0=S.s0,O.s1=S.s1,O.s2=S.s2,O}function b(S,O){var q=new m(S),H=O&&O.state,j=q.next;return j.int32=function(){return q.next()*4294967296|0},j.double=function(){return j()+(j()*2097152|0)*11102230246251565e-32},j.quick=j,H&&(typeof H=="object"&&v(H,q),j.state=function(){return v(q,{})}),j}function w(){var S=4022871197,O=function(q){q=String(q);for(var H=0;H<q.length;H++){S+=q.charCodeAt(H);var j=.02519603282416938*S;S=j>>>0,j-=S,j*=S,S=j>>>0,j-=S,S+=j*4294967296}return(S>>>0)*23283064365386963e-26};return O}c&&c.exports?c.exports=b:p&&p.amd?p(function(){return b}):this.alea=b})(y6,u,!1)}(Ox);var OM=Ox.exports,OX={exports:{}};OX.exports,function(u){(function(a,c,p){function m(w){var S=this,O="";S.x=0,S.y=0,S.z=0,S.w=0,S.next=function(){var H=S.x^S.x<<11;return S.x=S.y,S.y=S.z,S.z=S.w,S.w^=S.w>>>19^H^H>>>8},w===(w|0)?S.x=w:O+=w;for(var q=0;q<O.length+64;q++)S.x^=O.charCodeAt(q)|0,S.next()}function v(w,S){return S.x=w.x,S.y=w.y,S.z=w.z,S.w=w.w,S}function b(w,S){var O=new m(w),q=S&&S.state,H=function(){return(O.next()>>>0)/4294967296};return H.double=function(){do var j=O.next()>>>11,$=(O.next()>>>0)/4294967296,J=(j+$)/(1<<21);while(J===0);return J},H.int32=O.next,H.quick=H,q&&(typeof q=="object"&&v(q,O),H.state=function(){return v(O,{})}),H}c&&c.exports?c.exports=b:p&&p.amd?p(function(){return b}):this.xor128=b})(y6,u,!1)}(OX);var Og=OX.exports,OK={exports:{}};OK.exports,function(u){(function(a,c,p){function m(w){var S=this,O="";S.next=function(){var H=S.x^S.x>>>2;return S.x=S.y,S.y=S.z,S.z=S.w,S.w=S.v,(S.d=S.d+362437|0)+(S.v=S.v^S.v<<4^(H^H<<1))|0},S.x=0,S.y=0,S.z=0,S.w=0,S.v=0,w===(w|0)?S.x=w:O+=w;for(var q=0;q<O.length+64;q++)S.x^=O.charCodeAt(q)|0,q==O.length&&(S.d=S.x<<10^S.x>>>4),S.next()}function v(w,S){return S.x=w.x,S.y=w.y,S.z=w.z,S.w=w.w,S.v=w.v,S.d=w.d,S}function b(w,S){var O=new m(w),q=S&&S.state,H=function(){return(O.next()>>>0)/4294967296};return H.double=function(){do var j=O.next()>>>11,$=(O.next()>>>0)/4294967296,J=(j+$)/(1<<21);while(J===0);return J},H.int32=O.next,H.quick=H,q&&(typeof q=="object"&&v(q,O),H.state=function(){return v(O,{})}),H}c&&c.exports?c.exports=b:p&&p.amd?p(function(){return b}):this.xorwow=b})(y6,u,!1)}(OK);var Ob=OK.exports,OV={exports:{}};OV.exports,function(u){(function(a,c,p){function m(w){var S=this;S.next=function(){var q=S.x,H=S.i,j,$;return j=q[H],j^=j>>>7,$=j^j<<24,j=q[H+1&7],$^=j^j>>>10,j=q[H+3&7],$^=j^j>>>3,j=q[H+4&7],$^=j^j<<7,j=q[H+7&7],j=j^j<<13,$^=j^j<<9,q[H]=$,S.i=H+1&7,$};function O(q,H){var j,$=[];if(H===(H|0))$[0]=H;else for(H=""+H,j=0;j<H.length;++j)$[j&7]=$[j&7]<<15^H.charCodeAt(j)+$[j+1&7]<<13;for(;$.length<8;)$.push(0);for(j=0;j<8&&$[j]===0;++j);for(j==8?$[7]=-1:$[j],q.x=$,q.i=0,j=256;j>0;--j)q.next()}O(S,w)}function v(w,S){return S.x=w.x.slice(),S.i=w.i,S}function b(w,S){w==null&&(w=+new Date);var O=new m(w),q=S&&S.state,H=function(){return(O.next()>>>0)/4294967296};return H.double=function(){do var j=O.next()>>>11,$=(O.next()>>>0)/4294967296,J=(j+$)/(1<<21);while(J===0);return J},H.int32=O.next,H.quick=H,q&&(q.x&&v(q,O),H.state=function(){return v(O,{})}),H}c&&c.exports?c.exports=b:p&&p.amd?p(function(){return b}):this.xorshift7=b})(y6,u,!1)}(OV);var Od=OV.exports,OP={exports:{}};OP.exports,function(u){(function(a,c,p){function m(w){var S=this;S.next=function(){var q=S.w,H=S.X,j=S.i,$,J;return S.w=q=q+1640531527|0,J=H[j+34&127],$=H[j=j+1&127],J^=J<<13,$^=$<<17,J^=J>>>15,$^=$>>>12,J=H[j]=J^$,S.i=j,J+(q^q>>>16)|0};function O(q,H){var j,$,J,ee,re,de=[],Te=128;for(H===(H|0)?($=H,H=null):(H=H+"\0",$=0,Te=Math.max(Te,H.length)),J=0,ee=-32;ee<Te;++ee)H&&($^=H.charCodeAt((ee+32)%H.length)),ee===0&&(re=$),$^=$<<10,$^=$>>>15,$^=$<<4,$^=$>>>13,ee>=0&&(re=re+1640531527|0,j=de[ee&127]^=$+re,J=j==0?J+1:0);for(J>=128&&(de[(H&&H.length||0)&127]=-1),J=127,ee=512;ee>0;--ee)$=de[J+34&127],j=de[J=J+1&127],$^=$<<13,j^=j<<17,$^=$>>>15,j^=j>>>12,de[J]=$^j;q.w=re,q.X=de,q.i=J}O(S,w)}function v(w,S){return S.i=w.i,S.w=w.w,S.X=w.X.slice(),S}function b(w,S){w==null&&(w=+new Date);var O=new m(w),q=S&&S.state,H=function(){return(O.next()>>>0)/4294967296};return H.double=function(){do var j=O.next()>>>11,$=(O.next()>>>0)/4294967296,J=(j+$)/(1<<21);while(J===0);return J},H.int32=O.next,H.quick=H,q&&(q.X&&v(q,O),H.state=function(){return v(O,{})}),H}c&&c.exports?c.exports=b:p&&p.amd?p(function(){return b}):this.xor4096=b})(y6,u,!1)}(OP);var Ov=OP.exports,OT={exports:{}};OT.exports,function(u){(function(a,c,p){function m(w){var S=this,O="";S.next=function(){var H=S.b,j=S.c,$=S.d,J=S.a;return H=H<<25^H>>>7^j,j=j-$|0,$=$<<24^$>>>8^J,J=J-H|0,S.b=H=H<<20^H>>>12^j,S.c=j=j-$|0,S.d=$<<16^j>>>16^J,S.a=J-H|0},S.a=0,S.b=0,S.c=-1640531527,S.d=1367130551,w===Math.floor(w)?(S.a=w/4294967296|0,S.b=w|0):O+=w;for(var q=0;q<O.length+20;q++)S.b^=O.charCodeAt(q)|0,S.next()}function v(w,S){return S.a=w.a,S.b=w.b,S.c=w.c,S.d=w.d,S}function b(w,S){var O=new m(w),q=S&&S.state,H=function(){return(O.next()>>>0)/4294967296};return H.double=function(){do var j=O.next()>>>11,$=(O.next()>>>0)/4294967296,J=(j+$)/(1<<21);while(J===0);return J},H.int32=O.next,H.quick=H,q&&(typeof q=="object"&&v(q,O),H.state=function(){return v(O,{})}),H}c&&c.exports?c.exports=b:p&&p.amd?p(function(){return b}):this.tychei=b})(y6,u,!1)}(OT);var Or=OT.exports,Oe={exports:{}};(function(u){(function(a,c,p){var m=256,v=6,b=52,w="random",S=p.pow(m,v),O=p.pow(2,b),q=O*2,H=m-1,j;function $(Ae,Ce,Pe){var je=[];Ce=Ce==!0?{entropy:!0}:Ce||{};var Ne=de(re(Ce.entropy?[Ae,Me(c)]:Ae??Te(),3),je),Qe=new J(je),Ct=function(){for(var dt=Qe.g(v),Xt=S,Gt=0;dt<O;)dt=(dt+Gt)*m,Xt*=m,Gt=Qe.g(1);for(;dt>=q;)dt/=2,Xt/=2,Gt>>>=1;return(dt+Gt)/Xt};return Ct.int32=function(){return Qe.g(4)|0},Ct.quick=function(){return Qe.g(4)/4294967296},Ct.double=Ct,de(Me(Qe.S),c),(Ce.pass||Pe||function(dt,Xt,Gt,Vt){return Vt&&(Vt.S&&ee(Vt,Qe),dt.state=function(){return ee(Qe,{})}),Gt?(p[w]=dt,Xt):dt})(Ct,Ne,"global"in Ce?Ce.global:this==p,Ce.state)}function J(Ae){var Ce,Pe=Ae.length,je=this,Ne=0,Qe=je.i=je.j=0,Ct=je.S=[];for(Pe||(Ae=[Pe++]);Ne<m;)Ct[Ne]=Ne++;for(Ne=0;Ne<m;Ne++)Ct[Ne]=Ct[Qe=H&Qe+Ae[Ne%Pe]+(Ce=Ct[Ne])],Ct[Qe]=Ce;(je.g=function(dt){for(var Xt,Gt=0,Vt=je.i,T0=je.j,r0=je.S;dt--;)Xt=r0[Vt=H&Vt+1],Gt=Gt*m+r0[H&(r0[Vt]=r0[T0=H&T0+Xt])+(r0[T0]=Xt)];return je.i=Vt,je.j=T0,Gt})(m)}function ee(Ae,Ce){return Ce.i=Ae.i,Ce.j=Ae.j,Ce.S=Ae.S.slice(),Ce}function re(Ae,Ce){var Pe=[],je=typeof Ae,Ne;if(Ce&&je=="object")for(Ne in Ae)try{Pe.push(re(Ae[Ne],Ce-1))}catch{}return Pe.length?Pe:je=="string"?Ae:Ae+"\0"}function de(Ae,Ce){for(var Pe=Ae+"",je,Ne=0;Ne<Pe.length;)Ce[H&Ne]=H&(je^=Ce[H&Ne]*19)+Pe.charCodeAt(Ne++);return Me(Ce)}function Te(){try{var Ae;return j&&(Ae=j.randomBytes)?Ae=Ae(m):(Ae=new Uint8Array(m),(a.crypto||a.msCrypto).getRandomValues(Ae)),Me(Ae)}catch{var Ce=a.navigator,Pe=Ce&&Ce.plugins;return[+new Date,a,Pe,a.screen,Me(c)]}}function Me(Ae){return String.fromCharCode.apply(0,Ae)}if(de(p.random(),c),u.exports){u.exports=$;try{j=__webpack_require__(653)}catch{}}else p["seed"+w]=$})(typeof self<"u"?self:y6,[],Math)})(Oe);var OB=Oe.exports,ON=OM,c0=Og,c1=Ob,c2=Od,c3=Ov,c4=Or,c5=OB;c5.alea=ON,c5.xor128=c0,c5.xorwow=c1,c5.xorshift7=c2,c5.xor4096=c3,c5.tychei=c4;function c6(u,a,c=1,p="float32"){if(c===0)throw new Error("Cannot have a step of zero");const m={start:u,stop:a,step:c,dtype:p};return aA.runKernel(Dp,{},m)}function c7(u){const a={x:aK(u,"x","relu")};return aA.runKernel(Dl,a)}const c8=ad({relu_:c7});function c9(u){const a={x:aK(u,"x","relu6")};return aA.runKernel(Dt,a)}const cH=ad({relu6_:c9});function cD(u){const a={x:aK(u,"x","round")};return aA.runKernel(Dk,a)}const cy=ad({round_:cD});function ca(u){const a={x:aK(u,"x","sin","float32")};return aA.runKernel(Dz,a)}const cs=ad({sin_:ca});function cI(u,a,c){const p=aK(u,"x","slice3d");return i(p.rank===3,()=>"slice3d expects a rank-3 tensor, but got a rank-"+p.rank+" tensor"),f5(p,a,c)}const cE=ad({slice3d_:cI});function cf(u,a,c=0){const p={x:aK(u,"x","split")},m={numOrSizeSplits:a,axis:c};return aA.runKernel(DC,p,m)}const cO=ad({split_:cf});function cc(u,a){const c=aK(u,"x","squeeze","string_or_numeric");return ET(c,T(c.shape,a).newShape)}const cZ=ad({squeeze_:cc});function cL(u,a=0){const c=ab(u,"tensors","stack","string_or_numeric");i(c.length>=1,()=>"Pass at least one tensor to tf.stack"),c.length>0&&i(a<=c[0].rank,()=>"Axis must be <= rank of the tensor");const p=c,m={axis:a};return aA.runKernel(DF,p,m)}const cq=ad({stack_:cL});function cF(u,a=0){const c={x:aK(u,"x","step")},p={alpha:a};return aA.runKernel(Db,c,p)}const cY=ad({step_:cF});function co(u,a,c,p,m=0,v=0,b=0,w=0,S=0){const O={x:aK(u,"x","stridedSlice","string_or_numeric")},q={begin:a,end:c,strides:p,beginMask:m,endMask:v,ellipsisMask:b,newAxisMask:w,shrinkAxisMask:S};return aA.runKernel(DQ,O,q)}const cn=ad({stridedSlice_:co});function cp(u,a){U(u);const c=aM(u,a);if(c.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return aT(u,null,c,a)}function cS(u,a,c){if(U(u),a!=null&&a.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const p=aM(u,c);if(p.length!==2&&p.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(p.length===1&&a==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return aT(u,a,p,c)}function cl(u,a,c){const p=aK(u,"tensor","tensorScatterupdate"),m=aK(a,"indices","tensorScatterupdate","int32"),v=aK(c,"updates","tensorScatterupdate");if(E0(v,m,p.shape),p.dtype!==v.dtype)throw new Error("tensor and updates must have the same dtype, instead they are "+p.dtype+" and "+v.dtype+".");const b={tensor:p,indices:m,updates:v},w={};return aA.runKernel(Dw,b,w)}ad({tensorScatterUpdate_:cl});function ch(u,a=0){const c=aK(u,"x","unstack","string_or_numeric");i(a>=-c.shape.length&&a<c.shape.length,()=>"Axis = "+a+" is not in [-"+c.shape.length+", "+c.shape.length+")");const p={value:c},m={axis:a};return aA.runKernel(Dg,p,m)}const ci=ad({unstack_:ch});function cm(u,a){const c=[];for(let v=0;v<a.length;v++)a[v]&&c.push(v);const p=fy(u,"int32"),m=fy([c.length,u.length],"int32");for(let v=0;v<c.length;v++){const b=p.indexToLoc(c[v]),w=v*u.length;m.values.set(b,w)}return m.toTensor()}function ct(u,a,c,p,m,v="NHWC",b){let w=u;u.rank===3&&(w=ET(u,[1,u.shape[0],u.shape[1],u.shape[2]]));let S=a;S.rank===3&&(S=ET(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i(w.rank===4,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+w.shape+"."),i(S.rank===4,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+S.shape+"."),i(c.length===4,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+c+".");const O=v==="NHWC"?w.shape[3]:w.shape[1],q=v==="NHWC"?S.shape[3]:S.shape[1];i(O===c[2],()=>"Error in conv2dDerFilter: depth of input "+O+") must match input depth in filter ("+c[2]+"."),i(q===c[3],()=>"Error in conv2dDerFilter: depth of dy ("+q+") must match output depth for filter ("+c[3]+")."),EP("conv2dDerFilter",m,b);const H={x:w,dy:S},j={strides:p,pad:m,dataFormat:v,dimRoundingMode:b,filterShape:c};return aA.runKernel(HM,H,j)}const ck=ad({conv2DBackpropFilter_:ct});function cw(u,a,c){if(c==null||c==="linear")return u;if(c==="relu")return Eh(u,cY(a));throw new Error("Cannot compute gradient for fused activation "+c+".")}function cU(u,a){let c=a;const p=Id(u.shape,a.shape);return p.length>0&&(c=fr(c,p)),ET(c,u.shape)}function cG(u,a,c,p){if(a==="linear")return u;if(a==="relu")return c8(u);if(a==="elu")return fG(u);if(a==="relu6")return cH(u);if(a==="prelu")return OQ(u,c);if(a==="leakyrelu")return OI(u,p);if(a==="sigmoid")return f3(u);throw new Error("Unknown fused activation "+a+".")}const cz=(u,a)=>!(u>0)||a==="linear";function cW({x:u,filter:a,strides:c,pad:p,dataFormat:m="NHWC",dilations:v=[1,1],dimRoundingMode:b,bias:w,activation:S="linear",preluActivationWeights:O,leakyreluAlpha:q}){if(S=S||"linear",cz(aA.state.gradientDepth,S)===!1){i(m==="NHWC",()=>"Error in fused conv2d: got dataFormat of "+m+" but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let Pe=fL(u,a,c,p,m,v,b);return w!=null&&(Pe=EY(Pe,w)),cG(Pe,S,O,q)}const H=aK(u,"x","conv2d","float32"),j=aK(a,"filter","conv2d","float32");let $=H,J=!1;H.rank===3&&(J=!0,$=ET(H,[1,H.shape[0],H.shape[1],H.shape[2]])),i($.rank===4,()=>"Error in fused conv2d: input must be rank 4, but got rank "+$.rank+"."),i(j.rank===4,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+j.rank+"."),EP("fused conv2d",p,b);const ee=m==="NHWC"?$.shape[3]:$.shape[1];i(j.shape[2]===ee,()=>"Error in conv2d: depth of input ("+ee+") must match input depth for filter "+j.shape[2]+"."),i(Eb(c,v),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+c+" and dilations '"+v+"'");const re=ER($.shape,j.shape,c,v,p,b);let de;w!=null&&(de=aK(w,"bias","fused conv2d"),[de]=at(de,H),m==="NHWC"?IP(re.outShape,de.shape):(i(de.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-"+de.shape.length+"."),i(de.shape.length===0||de.shape[0]===re.outChannels||de.shape[0]===1,()=>"Error in fused conv2d: bias shape ("+de.shape+") is not compatible with the number of output channels ("+re.outChannels+")")));let Te;if(O!=null){const Pe=O.shape;if(i(Pe.length<=1||Pe.length===3,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-"+Pe.length+"."),Pe.length===1)i(Pe[0]===1||Pe[0]===re.outChannels,()=>"Error in fused conv2d: PReLU activation weights ("+Pe+") is not compatible with the number of output channels ("+re.outChannels+").");else if(Pe.length===3)try{IP(Pe,re.outShape)}catch{const Ne="Error in fused conv2d: PReLU activation weights ("+Pe+") is not compatible with the output shape of the conv2d ("+re.outShape+").";throw Error(Ne)}Te=aK(O,"prelu weights","fused conv2d")}const Me=(Pe,je)=>{i(m==="NHWC",()=>"Error in gradient of fused conv2D: got dataFormat of "+m+" but only NHWC is currently supported.");const[Ne,Qe,Ct,dt]=je,Xt=cw(Pe,Ct,S);i(EK(v),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+v+"'");const Gt=fF(Qe.shape,Xt,Ne,c,p),Vt=ck(Qe,Xt,Ne.shape,c,p),T0=[Gt,Vt];if(dt!=null){const r0=cU(dt,Xt);T0.push(r0)}return T0},Ae={x:$,filter:j,bias:de,preluActivationWeights:Te},Ce={strides:c,pad:p,dataFormat:m,dilations:v,dimRoundingMode:b,activation:S,leakyreluAlpha:q};return w==null?OZ((Pe,je,Ne)=>{let Qe=aA.runKernel(Dv,Ae,Ce);return Ne([je,Pe,Qe]),J&&(Qe=ET(Qe,[Qe.shape[1],Qe.shape[2],Qe.shape[3]])),{value:Qe,gradFunc:Me}})($,j):OZ((Pe,je,Ne,Qe)=>{let Ct=aA.runKernel(Dv,Ae,Ce);return Qe([je,Pe,Ct,Ne]),J&&(Ct=ET(Ct,[Ct.shape[1],Ct.shape[2],Ct.shape[3]])),{value:Ct,gradFunc:Me}})($,j,de)}const cR=ad({fusedConv2d_:cW});function cj(u,a,c,p,m,v=[1,1],b){let w=u;u.rank===3&&(w=ET(u,[1,u.shape[0],u.shape[1],u.shape[2]]));let S=a;S.rank===3&&(S=ET(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const O={x:w,dy:S},q={strides:p,pad:m,dimRoundingMode:b,dilations:v,filterShape:c};return aA.runKernel(Hd,O,q)}const cA=ad({depthwiseConv2dNativeBackpropFilter_:cj});function cC(u,a,c,p,m,v=[1,1],b){let w=a,S=!1;a.rank===3&&(S=!0,w=ET(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const O={dy:w,filter:c},q={strides:p,pad:m,dimRoundingMode:b,dilations:v,inputShape:u},H=aA.runKernel(HP,O,q);return S?ET(H,[H.shape[1],H.shape[2],H.shape[3]]):H}const cu=ad({depthwiseConv2dNativeBackpropInput_:cC});function cQ({x:u,filter:a,strides:c,pad:p,dataFormat:m="NHWC",dilations:v=[1,1],dimRoundingMode:b,bias:w,activation:S="linear",preluActivationWeights:O,leakyreluAlpha:q}){if(cz(aA.state.gradientDepth,S)===!1){let Ce=fl(u,a,c,p,m,v,b);return w!=null&&(Ce=EY(Ce,w)),cG(Ce,S,O,q)}const H=aK(u,"x","depthwiseConv2d","float32"),j=aK(a,"filter","depthwiseConv2d","float32");let $=H,J=!1;H.rank===3&&(J=!0,$=ET(H,[1,H.shape[0],H.shape[1],H.shape[2]])),i($.rank===4,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+$.rank+"."),i(j.rank===4,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+j.rank+"."),i($.shape[3]===j.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels ("+$.shape[3]+") must match the inChannels dimension in filter "+j.shape[2]+"."),v==null&&(v=[1,1]),i(Eb(c,v),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+c+" and dilations '"+v+"'"),EP("fused depthwiseConv2d",p,b);const ee=ER($.shape,j.shape,c,v,p,b,!0);let re;w!=null&&(re=aK(w,"bias","fused conv2d"),[re]=at(re,H),IP(ee.outShape,re.shape));let de;O!=null&&(de=aK(O,"prelu weights","fused depthwiseConv2d"));const Te=(Ce,Pe)=>{i(EK(v),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+v+"'");const[je,Ne,Qe,Ct]=Pe,dt=cw(Ce,Qe,S),Xt=cu(Ne.shape,dt,je,c,p,v,b),Gt=cA(Ne,dt,je.shape,c,p,v,b);if(Ct!=null){const Vt=cU(re,dt);return[Xt,Gt,Vt]}return[Xt,Gt]},Me={x:$,filter:j,bias:re,preluActivationWeights:de},Ae={strides:c,pad:p,dataFormat:m,dilations:v,dimRoundingMode:b,activation:S,leakyreluAlpha:q};return w==null?OZ((Ce,Pe,je)=>{let Ne=aA.runKernel(DT,Me,Ae);return je([Pe,Ce,Ne]),J&&(Ne=ET(Ne,[Ne.shape[1],Ne.shape[2],Ne.shape[3]])),{value:Ne,gradFunc:Te}})($,j):OZ((Ce,Pe,je,Ne)=>{let Qe=aA.runKernel(DT,Me,Ae);return Ne([Pe,Ce,Qe,je]),J&&(Qe=ET(Qe,[Qe.shape[1],Qe.shape[2],Qe.shape[3]])),{value:Qe,gradFunc:Te}})($,j,re)}const cJ=ad({fusedDepthwiseConv2d_:cQ});function cx({a:u,b:a,transposeA:c=!1,transposeB:p=!1,bias:m,activation:v="linear",preluActivationWeights:b,leakyreluAlpha:w=.2}){if(cz(aA.state.gradientDepth,v)===!1){let Ct=Iu(u,a,c,p);return m!=null&&(Ct=EY(Ct,m)),cG(Ct,v,b,w)}let S=aK(u,"a","fused matMul"),O=aK(a,"b","fused matMul");[S,O]=at(S,O);const q=c?S.shape[S.rank-2]:S.shape[S.rank-1],H=p?O.shape[O.rank-1]:O.shape[O.rank-2],j=c?S.shape[S.rank-1]:S.shape[S.rank-2],$=p?O.shape[O.rank-2]:O.shape[O.rank-1],J=S.shape.slice(0,-2),ee=O.shape.slice(0,-2),re=G(J),de=G(ee);i(q===H,()=>"Error in fused matMul: inner shapes ("+q+") and ("+H+") of Tensors with shapes "+S.shape+" and "+O.shape+" and transposeA="+c+" and transposeB="+p+" must match.");const Te=IP(S.shape.slice(0,-2),O.shape.slice(0,-2)).concat([j,$]),Me=c?ET(S,[re,q,j]):ET(S,[re,j,q]),Ae=p?ET(O,[de,$,H]):ET(O,[de,H,$]);let Ce;m!=null&&(Ce=aK(m,"bias","fused matMul"),[Ce]=at(Ce,S),IP(Te,Ce.shape));let Pe;b!=null&&(Pe=aK(b,"prelu weights","fused matMul"));const je=(Ct,dt)=>{const[Xt,Gt,Vt,T0]=dt,r0=cw(ET(Ct,Vt.shape),Vt,v);let d0,Ut;if(!c&&!p?(d0=Iu(r0,Gt,!1,!0),Ut=Iu(Xt,r0,!0,!1)):!c&&p?(d0=Iu(r0,Gt,!1,!1),Ut=Iu(r0,Xt,!0,!1)):c&&!p?(d0=Iu(Gt,r0,!1,!0),Ut=Iu(Xt,r0,!1,!1)):(d0=Iu(Gt,r0,!0,!0),Ut=Iu(r0,Xt,!0,!0)),m!=null){const $0=cU(T0,r0);return[d0,Ut,$0]}else return[d0,Ut]},Ne={a:Me,b:Ae,bias:Ce,preluActivationWeights:Pe},Qe={transposeA:c,transposeB:p,activation:v,leakyreluAlpha:w};return m==null?OZ((Ct,dt,Xt)=>{const Gt=aA.runKernel(DP,Ne,Qe);return Xt([Ct,dt,Gt]),{value:ET(Gt,Te),gradFunc:je}})(Me,Ae):OZ((Ct,dt,Xt,Gt)=>{const Vt=aA.runKernel(DP,Ne,Qe);return Gt([Ct,dt,Vt,Xt]),{value:ET(Vt,Te),gradFunc:je}})(Me,Ae,Ce)}const cM=ad({fusedMatMul_:cx});function cX(u,a,c,p,m="bilinear",v=0){const b=aK(u,"image","cropAndResize"),w=aK(a,"boxes","cropAndResize","float32"),S=aK(c,"boxInd","cropAndResize","int32"),O=w.shape[0];i(b.rank===4,()=>"Error in cropAndResize: image must be rank 4,but got rank "+b.rank+"."),i(w.rank===2&&w.shape[1]===4,()=>"Error in cropAndResize: boxes must be have size ["+O+",4] but had shape "+w.shape+"."),i(S.rank===1&&S.shape[0]===O,()=>"Error in cropAndResize: boxInd must be have size ["+O+"] but had shape "+w.shape+"."),i(p.length===2,()=>"Error in cropAndResize: cropSize must be of length 2, but got length "+p.length+"."),i(p[0]>=1&&p[1]>=1,()=>"cropSize must be atleast [1,1], but was "+p),i(m==="bilinear"||m==="nearest",()=>"method must be bilinear or nearest, but was "+m);const q={image:b,boxes:w,boxInd:S},H={method:m,extrapolationValue:v,cropSize:p};return aA.runKernel(HK,q,H)}const cg=ad({cropAndResize_:cX});function cK(u){const a=aK(u,"image","flipLeftRight","float32");i(a.rank===4,()=>"Error in flipLeftRight: image must be rank 4,but got rank "+a.rank+".");const c={image:a};return aA.runKernel(HN,c,{})}const cb=ad({flipLeftRight_:cK});function cV(u){const a=aK(u,"image","grayscaleToRGB"),c=a.rank-1,p=a.shape[c];i(a.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank "+a.rank+"."),i(p===1,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size "+p+".");const m=new Array(a.rank);return m.fill(1,0,c),m[c]=3,O5(a,m)}const cd=ad({grayscaleToRGB_:cV});function cP(u){const a=aK(u,"image","RGBToGrayscale"),c=a.rank-1,p=a.shape[c];i(a.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, but got rank "+a.rank+"."),i(p===3,()=>"Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size "+p+".");const m=a.dtype,v=IA(a,"float32"),b=cp([.2989,.587,.114]);let w;switch(a.rank){case 2:w=fw("ij,j->i",v,b);break;case 3:w=fw("ijk,k->ij",v,b);break;case 4:w=fw("ijkl,l->ijk",v,b);break;case 5:w=fw("ijklm,m->ijkl",v,b);break;case 6:w=fw("ijklmn,n->ijklm",v,b);break;default:throw new Error("Not a valid tensor rank.")}return w=O3(w,-1),IA(w,m)}const cv=ad({rgbToGrayscale_:cP});function cT(u,a,c=0,p=.5){const m=aK(u,"image","rotateWithOffset","float32");i(m.rank===4,()=>"Error in rotateWithOffset: image must be rank 4,but got rank "+m.rank+".");const v={image:m},b={radians:a,fillValue:c,center:p};return aA.runKernel(Dd,v,b)}const cr=ad({rotateWithOffset_:cT});function ce(u,a,c,p,m,v){p==null&&(p=.5),m==null&&(m=Number.NEGATIVE_INFINITY),v==null&&(v=0);const b=u.shape[0];return c=Math.min(c,b),i(0<=p&&p<=1,()=>"iouThreshold must be in [0, 1], but was '"+p+"'"),i(u.rank===2,()=>"boxes must be a 2D tensor, but was of rank '"+u.rank+"'"),i(u.shape[1]===4,()=>"boxes must have 4 columns, but 2nd dimension was "+u.shape[1]),i(a.rank===1,()=>"scores must be a 1D tensor"),i(a.shape[0]===b,()=>"scores has incompatible shape with boxes. Expected "+b+", but was "+a.shape[0]),i(0<=v&&v<=1,()=>"softNmsSigma must be in [0, 1], but was '"+v+"'"),{maxOutputSize:c,iouThreshold:p,scoreThreshold:m,softNmsSigma:v}}function cB(u,a,c,p=.5,m=Number.NEGATIVE_INFINITY){const v=aK(u,"boxes","nonMaxSuppression","float32"),b=aK(a,"scores","nonMaxSuppression","float32"),w=ce(v,b,c,p,m);c=w.maxOutputSize,p=w.iouThreshold,m=w.scoreThreshold;const S={maxOutputSize:c,iouThreshold:p,scoreThreshold:m};return aA.runKernel(DZ,{boxes:v,scores:b},S)}const cN=ad({nonMaxSuppression_:cB});function Z0(u,a,c){const p=Z1(u,a,c),m=p<0?-(p+1):p;u.splice(m,0,a)}function Z1(u,a,c){return Z3(u,a,c||Z2)}function Z2(u,a){return u>a?1:u<a?-1:0}function Z3(u,a,c){let p=0,m=u.length,v=0,b=!1;for(;p<m;){v=p+(m-p>>>1);const w=c(a,u[v]);w>0?p=v+1:(m=v,b=!w)}return b?p:-p-1}function Z4(u,a,c,p,m){return Z7(u,a,c,p,m,0)}function Z5(u,a,c,p,m,v){return Z7(u,a,c,p,m,0,!1,v,!0)}function Z6(u,a,c,p,m,v){return Z7(u,a,c,p,m,v,!0)}function Z7(u,a,c,p,m,v,b=!1,w=!1,S=!1){const O=[];for(let re=0;re<a.length;re++)a[re]>m&&O.push({score:a[re],boxIndex:re,suppressBeginIndex:0});O.sort(ZH);const q=v>0?-.5/v:0,H=[],j=[];for(;H.length<c&&O.length>0;){const re=O.pop(),{score:de,boxIndex:Te,suppressBeginIndex:Me}=re;if(de<m)break;let Ae=!1;for(let Ce=H.length-1;Ce>=Me;--Ce){const Pe=Z8(u,Te,H[Ce]);if(Pe>=p){Ae=!0;break}if(re.score=re.score*Z9(p,q,Pe),re.score<=m)break}re.suppressBeginIndex=H.length,Ae||(re.score===de?(H.push(Te),j.push(re.score)):re.score>m&&Z0(O,re,ZH))}const $=H.length,J=c-$;w&&J>0&&(H.push(...new Array(J).fill(0)),j.push(...new Array(J).fill(0)));const ee={selectedIndices:H};return b&&(ee.selectedScores=j),S&&(ee.validOutputs=$),ee}function Z8(u,a,c){const p=u.subarray(a*4,a*4+4),m=u.subarray(c*4,c*4+4),v=Math.min(p[0],p[2]),b=Math.min(p[1],p[3]),w=Math.max(p[0],p[2]),S=Math.max(p[1],p[3]),O=Math.min(m[0],m[2]),q=Math.min(m[1],m[3]),H=Math.max(m[0],m[2]),j=Math.max(m[1],m[3]),$=(w-v)*(S-b),J=(H-O)*(j-q);if($<=0||J<=0)return 0;const ee=Math.max(v,O),re=Math.max(b,q),de=Math.min(w,H),Te=Math.min(S,j),Me=Math.max(de-ee,0)*Math.max(Te-re,0);return Me/($+J-Me)}function Z9(u,a,c){const p=Math.exp(a*c*c);return c<=u?p:0}function ZH(u,a){return u.score-a.score||u.score===a.score&&a.boxIndex-u.boxIndex}async function ZD(u,a,c,p=.5,m=Number.NEGATIVE_INFINITY){const v=aK(u,"boxes","nonMaxSuppressionAsync"),b=aK(a,"scores","nonMaxSuppressionAsync"),w=ce(v,b,c,p,m);c=w.maxOutputSize,p=w.iouThreshold,m=w.scoreThreshold;const S=await Promise.all([v.data(),b.data()]),O=S[0],q=S[1],{selectedIndices:H}=Z4(O,q,c,p,m);return v!==u&&v.dispose(),b!==a&&b.dispose(),cp(H,"int32")}const Zy=ZD;function Za(u,a,c,p=.5,m=Number.NEGATIVE_INFINITY,v=0){const b=aK(u,"boxes","nonMaxSuppression"),w=aK(a,"scores","nonMaxSuppression"),S=ce(b,w,c,p,m,v);c=S.maxOutputSize,p=S.iouThreshold,m=S.scoreThreshold,v=S.softNmsSigma;const O={boxes:b,scores:w},q={maxOutputSize:c,iouThreshold:p,scoreThreshold:m,softNmsSigma:v},H=aA.runKernel(Dq,O,q);return{selectedIndices:H[0],selectedScores:H[1]}}const Zs=ad({nonMaxSuppressionWithScore_:Za});async function ZI(u,a,c,p=.5,m=Number.NEGATIVE_INFINITY,v=0){const b=aK(u,"boxes","nonMaxSuppressionAsync"),w=aK(a,"scores","nonMaxSuppressionAsync"),S=ce(b,w,c,p,m,v);c=S.maxOutputSize,p=S.iouThreshold,m=S.scoreThreshold,v=S.softNmsSigma;const O=await Promise.all([b.data(),w.data()]),q=O[0],H=O[1],{selectedIndices:j,selectedScores:$}=Z6(q,H,c,p,m,v);return b!==u&&b.dispose(),w!==a&&w.dispose(),{selectedIndices:cp(j,"int32"),selectedScores:cp($)}}const ZE=ZI;function Zf(u,a,c,p=.5,m=Number.NEGATIVE_INFINITY,v=!1){const b=aK(u,"boxes","nonMaxSuppression"),w=aK(a,"scores","nonMaxSuppression"),S=ce(b,w,c,p,m,null),O=S.maxOutputSize,q=S.iouThreshold,H=S.scoreThreshold,j={boxes:b,scores:w},$={maxOutputSize:O,iouThreshold:q,scoreThreshold:H,padToMaxOutputSize:v},J=aA.runKernel(DL,j,$);return{selectedIndices:J[0],validOutputs:J[1]}}const ZO=ad({nonMaxSuppressionPadded_:Zf});async function Zc(u,a,c,p=.5,m=Number.NEGATIVE_INFINITY,v=!1){const b=aK(u,"boxes","nonMaxSuppressionAsync"),w=aK(a,"scores","nonMaxSuppressionAsync"),S=ce(b,w,c,p,m,null),O=S.maxOutputSize,q=S.iouThreshold,H=S.scoreThreshold,[j,$]=await Promise.all([b.data(),w.data()]),{selectedIndices:J,validOutputs:ee}=Z5(j,$,O,q,H,v);return b!==u&&b.dispose(),w!==a&&w.dispose(),{selectedIndices:cp(J,"int32"),validOutputs:fb(ee,"int32")}}const ZZ=Zc;function ZL(u,a,c=!1,p=!1){const m=aK(u,"images","resizeBilinear");i(m.rank===3||m.rank===4,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+m.rank+"."),i(a.length===2,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+a+"."),i(p===!1||c===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let v=m,b=!1;m.rank===3&&(b=!0,v=ET(m,[1,m.shape[0],m.shape[1],m.shape[2]]));const w={images:v},S={alignCorners:c,halfPixelCenters:p,size:a},O=aA.runKernel(Dm,w,S);return b?ET(O,[O.shape[1],O.shape[2],O.shape[3]]):O}const Zq=ad({resizeBilinear_:ZL});function ZF(u,a,c=!1,p=!1){const m=aK(u,"images","resizeNearestNeighbor");i(m.rank===3||m.rank===4,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+m.rank+"."),i(a.length===2,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+a+"."),i(m.dtype==="float32"||m.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),i(p===!1||c===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let v=m,b=!1;m.rank===3&&(b=!0,v=ET(m,[1,m.shape[0],m.shape[1],m.shape[2]]));const w={images:v},S={alignCorners:c,halfPixelCenters:p,size:a},O=aA.runKernel(Di,w,S);return b?ET(O,[O.shape[1],O.shape[2],O.shape[3]]):O}const ZY=ad({resizeNearestNeighbor_:ZF});function Zo(u,a="binary",c=!1,p=.5){const m=aK(u,"image","threshold"),v=.2989,b=.587,w=.114,S=m.shape[0]*m.shape[1];let O=Eh(cp([p]),255),q,H,j,$;if(i(m.rank===3,()=>"Error in threshold: image must be rank 3,but got rank "+m.rank+"."),i(m.shape[2]===3||m.shape[2]===1,()=>"Error in threshold: image color channel must be equal to 3 or 1but got "+m.shape[2]+"."),i(m.dtype==="int32"||m.dtype==="float32",()=>"Error in dtype: image dtype must be int32 or float32,but got dtype "+m.dtype+"."),i(a==="otsu"||a==="binary",()=>"Method must be binary or otsu, but was "+a),m.shape[2]===3){[q,H,j]=cO(m,[1,1,1],-1);const ee=Eh(q,v),re=Eh(H,b),de=Eh(j,w);$=EY(EY(ee,re),de)}else $=u;if(a==="otsu"){const ee=f9(IA(cy($),"int32"),ar([]),256);O=Zn(ee,S)}const J=c?Oc($,O):OD($,O);return IA(Eh(J,255),"int32")}function Zn(u,a){let c=cp([-1]),p=cp([0]),m=cp([0]),v,b,w,S,O,q;for(let H=0;H<u.size-1;H++){v=f5(u,0,H+1),b=f5(u,H+1),O=ES(fr(v),a),q=ES(fr(b),a);const j=fr(Eh(v,c6(0,v.size)));w=ES(j,fr(v));const $=fa(b.shape,v.size),J=EY(c6(0,b.size),$),ee=Eh(b,J);S=ES(fr(ee),fr(b));const re=Oq(w,S),de=Oq(w,S),Te=Eh(O,q);m=Eh(Eh(Te,re),de);const Me=OD(m,p);p=fi(Me,m,p),c=fi(Me,cp([H]),c)}return c}const Zp=ad({threshold_:Zo});function ZS(u,a,c="nearest",p="constant",m=0,v){const b=aK(u,"image","transform","float32"),w=aK(a,"transforms","transform","float32");i(b.rank===4,()=>"Error in transform: image must be rank 4,but got rank "+b.rank+"."),i(w.rank===2&&(w.shape[0]===b.shape[0]||w.shape[0]===1)&&w.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),i(v==null||v.length===2,()=>"Error in transform: outputShape must be [height, width] or null, but got "+v+".");const S={image:b,transforms:w},O={interpolation:c,fillMode:p,fillValue:m,outputShape:v};return aA.runKernel(DM,S,O)}const Zl=ad({transform_:ZS});var Zh;(function(u){u[u.NONE=0]="NONE",u[u.MEAN=1]="MEAN",u[u.SUM=2]="SUM",u[u.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Zh||(Zh={}));const Zi={flipLeftRight:cb,grayscaleToRGB:cd,resizeNearestNeighbor:ZY,resizeBilinear:Zq,rgbToGrayscale:cv,rotateWithOffset:cr,cropAndResize:cg,nonMaxSuppression:cN,nonMaxSuppressionAsync:Zy,nonMaxSuppressionWithScore:Zs,nonMaxSuppressionWithScoreAsync:ZE,nonMaxSuppressionPadded:ZO,nonMaxSuppressionPaddedAsync:ZZ,threshold:Zp,transform:Zl},Zm=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:u=>u())();function Zt(){return new Promise(u=>Zm(()=>u()))}function Zk(u,a){const c=u[0].length;u.forEach((m,v)=>{i(m.length===c,()=>"Error in concat"+c+"D: rank of tensors["+v+"] must be the same as the rank of the rest ("+c+")")}),i(a>=0&&a<c,()=>"Error in concat"+c+"D: axis must be between 0 and "+(c-1)+".");const p=u[0];u.forEach((m,v)=>{for(let b=0;b<c;b++)i(b===a||m[b]===p[b],()=>"Error in concat"+c+"D: Shape of tensors["+v+"] ("+m+") does not match the shape of the rest ("+p+") along the non-concatenated axis "+v+".")})}function Zw(u,a){const c=u[0].slice();for(let p=1;p<u.length;p++)c[a]+=u[p][a];return c}var ZU;(function(u){u[u.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",u[u.VALUE_ROWIDS=1]="VALUE_ROWIDS",u[u.ROW_LENGTHS=2]="ROW_LENGTHS",u[u.ROW_SPLITS=3]="ROW_SPLITS",u[u.ROW_LIMITS=4]="ROW_LIMITS",u[u.ROW_STARTS=5]="ROW_STARTS"})(ZU||(ZU={}));function ZG(u,a,c){let p=new Array;if(c==null&&a==null)return p;if(a==null)for(;p.length<u+c.length;)p.push(-1);else p=a.slice();if(c==null)return p;if(u+c.length!==p.length)throw new Error("rt input.shape and shape="+a+" are incompatible: rt input.rank = "+(u+c.length)+", but shape.rank = "+p.length);for(let m=1;m<c.length;++m){const v=c[m],b=p[p.length-c.length+m],w=p[b];if(v>=0)if(w>=0){if(w!==v)throw new Error("rt input.shape and shape="+a+" are incompatible: rt input.shape["+(m+u)+"] = "+v+" but shape["+(m+u)+"] = "+w)}else p[b]=v}return p}function Zz(u){const a={FIRST_DIM_SIZE:ZU.FIRST_DIM_SIZE,VALUE_ROWIDS:ZU.VALUE_ROWIDS,ROW_LENGTHS:ZU.ROW_LENGTHS,ROW_SPLITS:ZU.ROW_SPLITS,ROW_LIMITS:ZU.ROW_LIMITS,ROW_STARTS:ZU.ROW_STARTS},c=[];for(const p of u)if(p in a)c.push(a[p]);else break;return c}function ZW(u){return u.length===0?0:u[0]===ZU.FIRST_DIM_SIZE?u.length-1:u.length}function ZR(u,a){if(u==null||a==null)return;const c=u.length,p=a.length;if(c>=p)throw new Error("defaultValue.shape="+u+" and ragged tensor flatValues.shape="+a+", are incompatible: defaultValue.rank = "+c+" must be less than ragged tensor input flatValues.rank = "+p+")");for(let m=0;m<Math.min(c,p-1);++m){const v=u[m],b=a[m+1];if(v>=0&&b>=0&&v!==1&&v!==b)throw new Error("defaultValue.shape="+u+", and ragged tensor input flatValues.shape="+a+" are incompatible: defaultValue.shape["+(m-u.length)+"] = "+v+" but ragged tensor input.flatValues.shape["+(m-u.length)+"] = "+b)}}const Zj=30;function ZA(u){return u<=Zj?u:HH(u,Math.floor(Math.sqrt(u)))}function ZC(u,a,c){const p=c*(typeof u=="number"?u:u[0]),m=a*(typeof u=="number"?u:u[1]);return[p,m]}function Zu(u,a,c,p=!0){let m=[];if(p)m=m.concat(a.slice(0)),m.push(u[0]/c),m=m.concat(u.slice(1));else{m=m.concat(u[0]);const v=a.length;for(let b=0;b<v;++b)m=m.concat([u[b+1]/a[b],a[b]]);m=m.concat(u.slice(v+1))}return m}function ZQ(u,a,c=!0){const p=[];if(c){p.push(a);for(let m=a+1;m<u;++m)m<=2*a?(p.push(m),p.push(m-(a+1))):p.push(m)}else{const m=[],v=[];for(let b=1;b<u;++b)b>=a*2+1||b%2===1?v.push(b):m.push(b);p.push(...m),p.push(0),p.push(...v)}return p}function ZJ(u,a,c,p=!0){const m=[];p?m.push(u[0]/c):m.push(u[0]*c);for(let v=1;v<u.length;++v)v<=a.length?p?m.push(a[v-1]*u[v]):m.push(u[v]/a[v-1]):m.push(u[v]);return m}function Zx(u,a){const c=[0];for(let p=0;p<a;++p)c.push(u[p][0]);return c}function ZM(u,a,c){const p=u.slice(0,1);for(let m=0;m<c;++m)p.push(u[m+1]-a[m][0]-a[m][1]);return p}const ZX=1.7580993408473768,Zg=1.0507009873554805,ZK=.3275911,Zb=.254829592,ZV=-.284496736,Zd=1.421413741,ZP=-1.453152027,Zv=1.061405429;function ZT(u,a){if(u.length!==a.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+u.length+", imag: "+a.length+".");const c=new Float32Array(u.length*2);for(let p=0;p<c.length;p+=2)c[p]=u[p/2],c[p+1]=a[p/2];return c}function Zr(u){const a=new Float32Array(u.length/2),c=new Float32Array(u.length/2);for(let p=0;p<u.length;p+=2)a[p/2]=u[p],c[p/2]=u[p+1];return{real:a,imag:c}}function Ze(u){const a=Math.ceil(u.length/4),c=new Float32Array(a),p=new Float32Array(a);for(let m=0;m<u.length;m+=4)c[Math.floor(m/4)]=u[m],p[Math.floor(m/4)]=u[m+1];return{real:c,imag:p}}function ZB(u){const a=Math.floor(u.length/4),c=new Float32Array(a),p=new Float32Array(a);for(let m=2;m<u.length;m+=4)c[Math.floor(m/4)]=u[m],p[Math.floor(m/4)]=u[m+1];return{real:c,imag:p}}function ZN(u,a){const c=u[a*2],p=u[a*2+1];return{real:c,imag:p}}function L0(u,a,c,p){u[p*2]=a,u[p*2+1]=c}function L1(u,a){const c=new Float32Array(u/2),p=new Float32Array(u/2);for(let m=0;m<Math.ceil(u/2);m++){const v=(a?2:-2)*Math.PI*(m/u);c[m]=Math.cos(v),p[m]=Math.sin(v)}return{real:c,imag:p}}function L2(u,a,c){const p=(c?2:-2)*Math.PI*(u/a),m=Math.cos(p),v=Math.sin(p);return{real:m,imag:v}}const L3="->",L4=/->/g,L5=",",L6="...";function L7(u,a){u=u.replace(/\s/g,"");const c=(u.length-u.replace(L4,"").length)/L3.length;if(c<1)throw new Error("Equations without an arrow are not supported.");if(c>1)throw new Error('Equation must contain exactly one arrow ("'+L3+'").');const[p,m]=u.split(L3);i(p.indexOf(L6)===-1,()=>'The ellipsis notation ("'+L6+'") is not supported yet.');const v=p.split(L5),b=v.length;if(a!==b)throw new Error("Expected "+b+" input tensors, received "+a);if(b>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const w=[];for(let j=0;j<m.length;++j){const $=m[j];if(!v.some(J=>J.indexOf($)!==-1))throw new Error("Output subscripts contain the label "+$+" not present in the input subscripts.");w.indexOf($)===-1&&w.push($)}for(let j=0;j<p.length;++j){const $=p[j];w.indexOf($)===-1&&$!==L5&&w.push($)}const S=new Array(v.length);for(let j=0;j<b;++j){if(new Set(v[j].split("")).size!==v[j].length)throw new Error("Found duplicate axes in input component "+v[j]+". Support for duplicate axes in input is not implemented yet.");S[j]=[];for(let $=0;$<v[j].length;++$)S[j].push(w.indexOf(v[j][$]))}const O=w.length,q=m.length,H=[];for(let j=q;j<O;++j)H.push(j);return{allDims:w,summedDims:H,idDims:S}}function L8(u,a){let c=new Array(u);c.fill(-1);for(let m=0;m<a.length;++m)c[a[m]]=m;const p=[];for(let m=0;m<u;++m)c[m]===-1&&p.push(m);return c=c.filter(m=>m!==-1),{permutationIndices:c,expandDims:p}}function L9(u,a,c){const p=new Array(u);for(let m=0;m<c.length;++m){const v=c[m].shape;for(let b=0;b<a[m].length;++b)p[a[m][b]]===void 0?p[a[m][b]]=v[b]:i(p[a[m][b]]===v[b],()=>"Expected dimension "+p[a[m][b]]+" at axis "+b+" of input shaped "+JSON.stringify(v)+", but got dimension "+v[b])}}function LH(u,a){const c=u,p=[];let m=0;u.length===0&&c.push(-1),m=u.length+1;for(let b=0;b<m;++b)p.push([]);const v=[];for(let b=0;b<c.length;++b){const w=c[b],S=Ly(a,w);for(const O of S)v.indexOf(O)===-1&&(p[b].push(O),v.push(O))}return{path:c,steps:p}}function LD(u){return u.every((a,c)=>a===c)}function Ly(u,a){const c=[];for(let p=0;p<u.length;++p)(u[p].length===0||u[p].indexOf(a)!==-1||a===-1)&&c.push(p);return c}function La(u,a,c=0){let p=[];if(typeof a=="number")i(u.shape[c]%a===0,()=>"Number of splits must evenly divide the axis."),p=new Array(a).fill(u.shape[c]/a);else{const m=a.reduce((b,w)=>(w===-1&&(b+=1),b),0);i(m<=1,()=>"There should be only one negative value in split array.");const v=a.indexOf(-1);if(v!==-1){const b=a.reduce((w,S)=>S>0?w+S:w);a[v]=u.shape[c]-b}i(u.shape[c]===a.reduce((b,w)=>b+w),()=>"The sum of sizes must match the size of the axis dimension."),p=a}return p}function Ls(u){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = `+u}function LI(u,a){return"indices("+u+", 0) is invalid: "+a+" < 0"}function LE(u,a,c){return"indices("+u+", 0) is invalid: "+a+" >= "+c}function Lf(u,a){return"only one output dimension may be -1, not both "+u+" and "+a}function LO(u,a){return"size "+u+" must be non-negative, not "+a}function Lc(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function LZ(u,a){const c=G(u),p=G(a);return"Input to reshape is a SparseTensor with "+c+`
  dense values, but the requested shape requires a multiple of `+p+". inputShape="+u+" outputShape= "+a}function LL(u,a){const c=G(u),p=G(a);return"Input to reshape is a tensor with "+c+" dense values, but the requested shape has "+p+". inputShape="+u+" outputShape="+a}function Lq(){return"segment ids must be >= 0"}function LF(){return"segment ids are not increasing"}function LY(u,a){return"Segment id "+u+" out of range [0, "+a+"), possibly because segmentIds input is not sorted."}function Lo(u,a,c){return"Bad: indices["+u+"] == "+a+" out of range [0, "+c+")"}function Ln(u,a){let c=!1,p;for(u<=Zj?(p=u,c=!0):p=HH(u,Math.floor(Math.sqrt(u)));!c;)p>a||p===u?c=!0:p=HH(u,p+1);return p}function Lp(u,a,c){const p=[],m=u.length;for(let v=0;v<m;v++)v!==a?p.push(u[v]):p.push(c);return p}function LS(u,a,c,p){const m=a.shape.length,v=u.shape.length;if(p!==0&&(p<-m||p>m))throw new Error("Expect batchDims in the range of [-"+m+", "+m+"], but got "+p);if(p<0&&(p+=m),p>v)throw new Error("batchDims ("+p+`) must be less than rank(x) (
    `+v+").");if(c<p)throw new Error("batchDims ("+p+") must be less than or equal to axis ("+c+").");for(let H=0;H<p;++H)if(u.shape[H]!==a.shape[H])throw new Error("x.shape["+H+"]: "+u.shape[H]+" should be equal to indices.shape["+H+"]: "+a.shape[H]+".");const b=u.shape[c],w=[];let S=1,O=1,q=1;for(let H=0;H<p;++H)w.push(u.shape[H]),S*=u.shape[H];for(let H=p;H<c;H++)w.push(u.shape[H]),O*=u.shape[H];for(let H=p;H<m;H++)w.push(a.shape[H]);for(let H=c+1;H<v;H++)w.push(u.shape[H]),q*=u.shape[H];return{batchSize:S,sliceSize:q,outerSize:O,dimSize:b,outputShape:w}}var Ll=Object.freeze({__proto__:null,collectGatherOpShapeInfo:LS,computeOutShape:Lp,segOpComputeOptimalWindowSize:Ln});function Lh(u){try{return u.map(a=>ye(a))}catch(a){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+a)}}function Li(u){return u.map(a=>yr(a))}var Lm=Object.freeze({__proto__:null,ERF_A1:Zb,ERF_A2:ZV,ERF_A3:Zd,ERF_A4:ZP,ERF_A5:Zv,ERF_P:ZK,PARALLELIZE_THRESHOLD:Zj,get RowPartitionType(){return ZU},SELU_SCALE:Zg,SELU_SCALEALPHA:ZX,applyActivation:cG,assertAndGetBroadcastShape:IP,assertAxesAreInnerMostDims:fA,assertParamsConsistent:Zk,assignToTypedArray:L0,axesAreInnerMostDims:fz,calculateShapes:E1,checkEinsumDimSizes:L9,checkPadOnDimRoundingMode:EP,combineLocations:fW,combineRaggedTensorToTensorShapes:ZG,complexWithEvenIndex:Ze,complexWithOddIndex:ZB,computeConv2DInfo:ER,computeConv3DInfo:Ej,computeDefaultPad:Eu,computeDilation2DInfo:EG,computeOptimalWindowSize:ZA,computeOutAndReduceShapes:fR,computeOutShape:Zw,computePool2DInfo:Ez,computePool3DInfo:EW,convertConv2DDataFormat:Ed,decodeEinsumEquation:L7,eitherStridesOrDilationsAreOne:Eb,expandShapeToKeepDim:fj,exponent:L2,exponents:L1,fromStringArrayToUint8:Li,fromUint8ToStringArray:Lh,getAxesPermutation:fC,getBroadcastDims:IV,getComplexWithIndex:ZN,getEinsumComputePath:LH,getEinsumPermutation:L8,getFusedBiasGradient:cU,getFusedDyActivation:cw,getImageCenter:ZC,getInnerMostAxes:fQ,getPermuted:ZQ,getRaggedRank:ZW,getReductionAxes:Id,getReshaped:Zu,getReshapedPermuted:ZJ,getRowPartitionTypesHelper:Zz,getSliceBeginCoords:Zx,getSliceSize:ZM,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Ls,getSparseFillEmptyRowsNegativeIndexErrorMessage:LI,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:LE,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Lc,getSparseReshapeInputOutputMismatchErrorMessage:LL,getSparseReshapeInputOutputMultipleErrorMessage:LZ,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Lf,getSparseReshapeNegativeOutputDimErrorMessage:LO,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Lo,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Lq,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:LF,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:LY,getUndoAxesPermutation:fu,isIdentityPermutation:LD,log:De,mergeRealAndImagArrays:ZT,prepareAndValidate:IB,prepareSplitSize:La,segment_util:Ll,shouldFuse:cz,slice_util:Eq,splitRealAndImagArrays:Zr,stridesOrDilationsArePositive:EV,tupleValuesAreOne:EK,upcastType:al,validateDefaultValueShape:ZR,validateInput:E0,validateUpdateShape:IN,warn:Dr});class Lt{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(a,c){return fetch(a,c)}now(){return performance.now()}encode(a,c){if(c!=="utf-8"&&c!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+c);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(a)}decode(a,c){return new TextDecoder(c).decode(a)}setTimeoutCustom(a,c){if(typeof window>"u"||!Hn().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(a,c);return}this.functionRefs.push(a),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},c),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",p=>{if(p.source===window&&p.data.name===this.messageName){p.stopPropagation();const m=this.functionRefs[p.data.index];m(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(a){return y5(a)}}if(Hn().get("IS_BROWSER")){Hn().setPlatform("browser",new Lt);try{It.registerManager(sN.URL_SCHEME,new I2)}catch{}try{It.registerManager(su.URL_SCHEME,new sM)}catch{}}const Lk={importFetch:()=>__webpack_require__(300)};let Lw;class LU{constructor(){this.util=__webpack_require__(539),this.textEncoder=new this.util.TextEncoder}fetch(a,c){return Hn().global.fetch!=null?Hn().global.fetch(a,c):(Lw==null&&(Lw=Lk.importFetch()),Lw(a,c))}now(){const a=process.hrtime();return a[0]*1e3+a[1]/1e6}encode(a,c){if(c!=="utf-8"&&c!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+c);return this.textEncoder.encode(a)}decode(a,c){return a.length===0?"":new this.util.TextDecoder(c).decode(a)}isTypedArray(a){return this.util.types.isFloat32Array(a)||this.util.types.isInt32Array(a)||this.util.types.isUint8Array(a)||this.util.types.isUint8ClampedArray(a)}}Hn().get("IS_NODE")&&!Hn().get("IS_BROWSER")&&Hn().setPlatform("node",new LU),aj();const LG={buffer:fy,cast:IA,clone:EN,print:OJ};aO(LG);var Lz=Object.defineProperty,LW=Object.getOwnPropertySymbols,LR=Object.prototype.hasOwnProperty,Lj=Object.prototype.propertyIsEnumerable,LA=(u,a,c)=>a in u?Lz(u,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):u[a]=c,LC=(u,a)=>{for(var c in a||(a={}))LR.call(a,c)&&LA(u,c,a[c]);if(LW)for(var c of LW(a))Lj.call(a,c)&&LA(u,c,a[c]);return u};class Lu{constructor(a){this.model=a,this.posesMax=1,this.iouThresh=.3,this.scoreThresh=.5,this.model=a,this.modelSize=a.inputs[0].shape?{width:a.inputs[0].shape[2],height:a.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=cp(this.anchorsData.map(c=>c.x)),this.anchorsY=cp(this.anchorsData.map(c=>c.y))}async process(a){let c={x:0,y:0};const[p,m]=s2(()=>{const O={width:a.shape[2],height:a.shape[1]},q=O.width/O.height;let H=LC({},O),j={x:0,y:0};q>this.modelRatio?(H.height=a.shape[2]/this.modelRatio,j.y=Math.floor((H.height-a.shape[1])*.5),c.y=j.y/H.height):q<this.modelRatio&&(H.width=a.shape[1]*this.modelRatio,j.x=Math.floor((H.width-a.shape[2])*.5),c.x=j.x/H.width);const $=OG(a,[[0,0],[j.y,j.y],[j.x,j.x],[0,0]],0),J=Zi.resizeBilinear($,[this.modelSize.height,this.modelSize.width]),ee=this.model.execute(J,"person"),re=cZ(f5(ee,[0,0,1],[1,-1,-1])),de=cZ(f5(ee,[0,0,0],[1,-1,1])),Te=f3(fI(de,-100,100));return[this.decodeBoxes(re,[this.anchorsX,this.anchorsY],this.modelSize),Te]}),v=await p.data(),b=await m.data();let w=[];for(let O=0;O<b.length;O++){if(b[O]<this.scoreThresh)continue;const q=v[O*12+2]-v[O*12+0],H=v[O*12+3]-v[O*12+1];q<0||H<0||w.push({box:[[v[O*12+0],v[O*12+1]],[v[O*12+2],v[O*12+3]]],points:[[v[O*12+4],v[O*12+5]],[v[O*12+6],v[O*12+7]],[v[O*12+8],v[O*12+9]],[v[O*12+10],v[O*12+11]]],score:b[O]})}if(p.dispose(),m.dispose(),w.length<1)return[];if(w.length>1){const O=cS(w.map(J=>[J.box[0][1],J.box[0][0],J.box[1][1],J.box[1][0]])),q=cp(w.map(J=>J.score)),H=await Zi.nonMaxSuppressionAsync(O,q,this.posesMax,this.iouThresh,this.scoreThresh),j=await H.data();H.dispose();const $=[];for(let J=0;J<j.length;J++)$.push(w[j[J]]);w=$}if(w.length<1)return[];const S={width:1-2*c.x,height:1-2*c.y};return w.map(O=>({box:O.box.map(q=>[(q[0]-c.x)/S.width,(q[1]-c.y)/S.height]),points:O.points.map(q=>[(q[0]-c.x)/S.width,(q[1]-c.y)/S.height]),score:O.score}))}decodeBoxes(a,c,p){let m=cZ(f5(a,[0,0],[-1,1])),v=cZ(f5(a,[0,1],[-1,1])),b=cZ(f5(a,[0,2],[-1,1])),w=cZ(f5(a,[0,3],[-1,1]));m=EY(ES(m,p.width),c[0]),v=EY(ES(v,p.height),c[1]),b=ES(b,p.width*2),w=ES(w,p.height*2);const S=ET(Oq(m,b),[2254,1]),O=ET(Oq(v,w),[2254,1]),q=ET(EY(m,b),[2254,1]),H=ET(EY(v,w),[2254,1]);let j=ff([S,O,q,H],1);for(let $=0;$<4;$++){let J=cZ(f5(a,[0,4+$*2],[-1,1])),ee=cZ(f5(a,[0,4+$*2+1],[-1,1]));J=ET(EY(ES(J,p.width),c[0]),[2254,1]),ee=ET(EY(ES(ee,p.height),c[1]),[2254,1]),j=ff([j,J,ee],1)}return j}buildAnchors(a){const c=[8,16,32,32,32],p=[];let m=0;for(;m<5;){let v=0,b=m;for(;b<c.length&&c[b]===c[m];)v+=2,b++;const w=c[m],S=Math.ceil(a.height/w),O=Math.ceil(a.width/w);for(let q=0;q<S;++q)for(let H=0;H<O;++H)for(let j=0;j<v;++j)p.push({x:(H+.5)/O,y:(q+.5)/S});m=b}return p}async prepare(){const{width:a,height:c}=this.modelSize,p=Ot([1,c,a,3]),m=this.model.execute(p,"person");await m.data(),p.dispose(),m.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}class LQ{constructor(a,c=!1){this.model=a,this.mask=c,this.sizeFactor=1.2,this.model=a,this.modelSize=a.inputs[0].shape?{width:a.inputs[0].shape[2],height:a.inputs[0].shape[1]}:{width:256,height:256}}async process(a,c){const[p,m]=[a.shape[1],a.shape[2]],{modelSize:v}=this;return c.map(b=>{const w=[b.center[0]*m,b.center[1]*p],S=[b.top[0]*m,b.top[1]*p],O=[S[0]-w[0],S[1]-w[1]],q=Math.sqrt(O[0]*O[0]+O[1]*O[1])*this.sizeFactor,H=Math.atan2(O[0],-O[1]),j=[w[1]-q,w[0]-q,w[1]+q,w[0]+q],$=s2(()=>{const Qe=this.rotatedRect(a,j,H,v);return EY(Eh(Qe,.5),.5)}),J=["ld_3d","world_3d","output_poseflag","activation_heatmap"];this.mask&&J.push("activation_segmentation");const[ee,re,de,Te,Me]=this.model.execute($,J),Ae=ee.dataSync(),Ce=re.dataSync(),Pe=de.dataSync()[0];let je=[];for(let Qe=0;Qe<39;Qe++)je.push([Ae[Qe*5+0]/v.width,Ae[Qe*5+1]/v.height,Ae[Qe*5+2]/v.width]);let Ne;if(Me){const Qe=Zi.rotateWithOffset(Me,-H),Ct=cZ(Qe,[0]),dt=Eh(Ct,255);Ne=new Uint8Array(dt.dataSync()),Qe.dispose(),Ct.dispose(),dt.dispose(),Me.dispose()}return $.dispose(),ee.dispose(),re.dispose(),de.dispose(),je=this.refinePoints(je,Te),Te.dispose(),{points:je,pointsData:Ae,metricData:Ce,maskData:Ne,score:Pe,center:w,top:S,radius:q,angle:H}}).map(b=>{const{points:w,pointsData:S,metricData:O,maskData:q,score:H,center:j,top:$,radius:J,angle:ee}=b;let re=w.map((je,Ne)=>({pixel:je,metric:[O[Ne*3+0],O[Ne*3+1],O[Ne*3+2]],norm:[O[Ne*3+0],O[Ne*3+1],O[Ne*3+2]],score:1/(1+Math.exp(-S[Ne*5+3])),visibility:1/(1+Math.exp(-S[Ne*5+4]))}));re.forEach(je=>{je.pixel[0]=(je.pixel[0]-.5)*2*J,je.pixel[1]=(je.pixel[1]-.5)*2*J,je.pixel[2]*=2*J});const de=Math.sin(ee),Te=Math.cos(ee);re.forEach(je=>{const Ne=je.pixel[0],Qe=je.pixel[1];je.pixel[0]=(Ne*Te-Qe*de+j[0])/m,je.pixel[1]=(Ne*de+Qe*Te+j[1])/p,je.pixel[2]/=m;const Ct=je.metric[0],dt=je.metric[1];je.metric[0]=Ct*Te-dt*de,je.metric[1]=Ct*de+dt*Te});const Me=re.map(je=>je.pixel[0]),Ae=re.map(je=>je.pixel[1]),Ce=[[Math.min(...Me),Math.min(...Ae)],[Math.max(...Me),Math.max(...Ae)]],Pe=q&&{buffer:q,size:{width:256,height:256},box:[[(j[0]-J)/m,(j[1]-J)/p],[(j[0]+J)/m,(j[1]+J)/p]]};return{keypoints:re,score:H,mask:Pe,center:[re[33].pixel[0],re[33].pixel[1]],top:[re[34].pixel[0],re[34].pixel[1]],debug:{center:j,top:$,box:Ce,radius:J,angle:ee}}})}refinePoints(a,c){const p=cZ(c,[0]),m=p.bufferSync(),[v,b,w]=p.shape;return a.map((S,O)=>{const q=S,H=Math.trunc(q[0]*b),j=Math.trunc(q[1]*v);if(H<0||H>=b||j<0||j>=v)return S;const $=Math.trunc((7-1)/2),J=Math.max(H-$,0),ee=Math.min(H+$+1,b),re=Math.max(j-$,0),de=Math.min(j+$+1,v);let Te=0,Me=0,Ae=0,Ce=0;for(let Pe=re;Pe<de;Pe++)for(let je=J;je<ee;je++){const Ne=m.get(Pe,je,O);Te+=Ne,Me=Math.max(Ne,Me),Ae+=je*Ne,Ce+=Pe*Ne}return p.dispose(),Me>=.5&&Te>0?[Ae/Te/b,Ce/Te/v,q[2]]:S})}rotatedRect(a,c,p,m){const[v,b]=[c[2]-c[0],c[3]-c[1]],[w,S]=[(c[2]+c[0])*.5,(c[3]+c[1])*.5],[O,q]=[v/m.height,b/m.width],[H,j]=[Math.cos(p),Math.sin(p)],$=[H*q,-j*O,(-H*b+j*v)*.5+S,j*q,H*O,(-j*b-H*v)*.5+w,0,0];return Zi.transform(a,[$],"bilinear","constant",0,[m.height,m.width])}async prepare(){const{width:a,height:c}=this.modelSize,p=Ot([1,c,a,3]),m=this.model.execute(p);await Promise.all(m.map(async v=>{await v.data(),v.dispose()})),p.dispose()}async dispose(){var a;(a=this.model)==null||a.dispose()}}var LJ=Object.defineProperty,Lx=Object.getOwnPropertySymbols,LM=Object.prototype.hasOwnProperty,LX=Object.prototype.propertyIsEnumerable,Lg=(u,a,c)=>a in u?LJ(u,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):u[a]=c,LK=(u,a)=>{for(var c in a||(a={}))LM.call(a,c)&&Lg(u,c,a[c]);if(Lx)for(var c of Lx(a))LX.call(a,c)&&Lg(u,c,a[c]);return u};class Lb{constructor(){this.freq=30,this.pixelParams={minCutOff:1,minCutOffD:1,beta:50},this.metricParams={minCutOff:.5,minCutOffD:1,beta:30},this.boxParams={minCutOff:1,minCutOffD:1,beta:50},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(a,c,p=1){return this.time>=c?a:(this.time!==0&&(this.freq=1/(c-this.time)),this.time=c,!this.raw||!this.smooth||!this.der?(this.raw=this.clonePose(a),this.smooth=this.clonePose(a),this.der={keypoints:a.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0],norm:[0,0,0],score:0,visibility:0})),score:0,center:[0,0],top:[0,0],debug:{box:[[0,0],[0,0]],center:[0,0],top:[0,0],radius:0,angle:0}},this.clonePose(this.smooth)):(this.filterKeypoints(a.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,p),this.filterCoord2D(a.center,this.raw.center,this.der.center,this.smooth.center,p,this.boxParams),this.filterCoord2D(a.top,this.raw.top,this.der.top,this.smooth.top,p,this.boxParams),this.smooth.score=a.score,this.smooth.mask=a.mask&&{buffer:a.mask.buffer,size:LK({},a.mask.size),box:[[...a.mask.box[0]],[...a.mask.box[1]]]},this.smooth.debug=a.debug&&{center:[...a.debug.center],top:[...a.debug.top],box:[[...a.debug.box[0]],[...a.debug.box[1]]],radius:a.debug.radius,angle:a.debug.angle},this.clonePose(this.smooth)))}filterKeypoints(a,c,p,m,v){const b=this.alpha(this.visibilityCutOff),w=this.alpha(this.scoreCutOff);for(let S=0;S<a.length;S++)this.filterCoord3D(a[S].pixel,c[S].pixel,p[S].pixel,m[S].pixel,v,this.pixelParams),this.filterCoord3D(a[S].metric,c[S].metric,p[S].metric,m[S].metric,v,this.metricParams),this.filterCoord3D(a[S].norm,c[S].norm,p[S].norm,m[S].norm,v,this.metricParams),m[S].score=m[S].score+w*(a[S].score-m[S].score),m[S].visibility=m[S].visibility+b*(a[S].visibility-m[S].visibility)}filterCoord3D(a,c,p,m,v,b){const w=[(a[0]-m[0])*v*this.freq,(a[1]-m[1])*v*this.freq,(a[2]-m[2])*v*this.freq],S=this.alpha(b.minCutOffD);p[0]=p[0]+S*(w[0]-p[0]),p[1]=p[1]+S*(w[1]-p[1]),p[2]=p[2]+S*(w[2]-p[2]);const O=[this.alpha(b.minCutOff+b.beta*Math.abs(p[0])),this.alpha(b.minCutOff+b.beta*Math.abs(p[1])),this.alpha(b.minCutOff+b.beta*Math.abs(p[2]))];m[0]=m[0]+O[0]*(a[0]-m[0]),m[1]=m[1]+O[1]*(a[1]-m[1]),m[2]=m[2]+O[2]*(a[2]-m[2]),c[0]=a[0],c[1]=a[1],c[2]=a[2]}filterCoord2D(a,c,p,m,v,b){const w=[(a[0]-m[0])*v*this.freq,(a[1]-m[1])*v*this.freq],S=this.alpha(b.minCutOffD);p[0]=p[0]+S*(w[0]-p[0]),p[1]=p[1]+S*(w[1]-p[1]);const O=[this.alpha(b.minCutOff+b.beta*Math.abs(p[0])),this.alpha(b.minCutOff+b.beta*Math.abs(p[1]))];m[0]=m[0]+O[0]*(a[0]-m[0]),m[1]=m[1]+O[1]*(a[1]-m[1]),c[0]=a[0],c[1]=a[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(a){return 1/(1+this.freq/(2*Math.PI*a))}clonePose(a){return{keypoints:a.keypoints.map(c=>({pixel:[...c.pixel],metric:[...c.metric],norm:[...c.norm],score:c.score,visibility:c.visibility})),score:a.score,center:[...a.center],top:[...a.top],mask:a.mask&&{buffer:a.mask.buffer,size:LK({},a.mask.size),box:[[...a.mask.box[0]],[...a.mask.box[1]]]},debug:a.debug&&{box:[[...a.debug.box[0]],[...a.debug.box[1]]],center:[...a.debug.center],top:[...a.debug.top],radius:a.debug.radius,angle:a.debug.angle}}}}function LV(u,a){const c=[Math.max(u.xy.x,a.xy.x),Math.max(u.xy.y,a.xy.y)],p=[Math.min(u.xy.x+u.size.width,u.xy.x+u.size.width),Math.min(u.xy.y+u.size.height,u.xy.y+u.size.height)],m=(p[0]-c[0])*(p[1]-c[1]);return m/(u.size.width*u.size.height+a.size.width*a.size.height-m)}function Ld(u,a){const c=[[Math.max(u[0][0],a[0][0]),Math.max(u[0][1],a[0][1])],[Math.min(u[1][0],a[1][0]),Math.min(u[1][1],a[1][1])]],p=(c[1][0]-c[0][0])*(c[1][1]-c[0][1]);return p/((u[1][0]-u[0][0])*(u[1][1]-u[0][1])+(a[1][0]-a[0][0])*(a[1][1]-a[0][1])-p)}function LP(u){return{xy:{x:u[0][0],y:u[0][1]},size:{width:u[1][0]-u[0][0],height:u[1][1]-u[0][1]}}}function Lv(u){return[[u.xy.x,u.xy.y],[u.xy.x+u.size.width,u.xy.y+u.size.height]]}var LT=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(a){a=a||{};var c=typeof a<"u"?a:{},p,m;c.ready=new Promise(function(et,Je){p=et,m=Je});var v=Object.assign({},c),b=!0,w="";function S(et){return c.locateFile?c.locateFile(et,w):w+et}var O;typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),u&&(w=u),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",c.print||console.log.bind(console);var q=c.printErr||console.warn.bind(console);Object.assign(c,v),v=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&c.quit;var H;c.wasmBinary&&(H=c.wasmBinary),c.noExitRuntime,typeof WebAssembly!="object"&&Rr("no native wasm support detected");var j,$=!1;function J(et,Je){et||Rr(Je)}var ee=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function re(et,Je,Nt){for(var _0=Je+Nt,Ue=Je;et[Ue]&&!(Ue>=_0);)++Ue;if(Ue-Je>16&&et.buffer&&ee)return ee.decode(et.subarray(Je,Ue));for(var ze="";Je<Ue;){var We=et[Je++];if(!(We&128)){ze+=String.fromCharCode(We);continue}var _t=et[Je++]&63;if((We&224)==192){ze+=String.fromCharCode((We&31)<<6|_t);continue}var jt=et[Je++]&63;if((We&240)==224?We=(We&15)<<12|_t<<6|jt:We=(We&7)<<18|_t<<12|jt<<6|et[Je++]&63,We<65536)ze+=String.fromCharCode(We);else{var e0=We-65536;ze+=String.fromCharCode(55296|e0>>10,56320|e0&1023)}}return ze}function de(et,Je){return et?re(Vt,et,Je):""}function Te(et,Je,Nt,_0){if(!(_0>0))return 0;for(var Ue=Nt,ze=Nt+_0-1,We=0;We<et.length;++We){var _t=et.charCodeAt(We);if(_t>=55296&&_t<=57343){var jt=et.charCodeAt(++We);_t=65536+((_t&1023)<<10)|jt&1023}if(_t<=127){if(Nt>=ze)break;Je[Nt++]=_t}else if(_t<=2047){if(Nt+1>=ze)break;Je[Nt++]=192|_t>>6,Je[Nt++]=128|_t&63}else if(_t<=65535){if(Nt+2>=ze)break;Je[Nt++]=224|_t>>12,Je[Nt++]=128|_t>>6&63,Je[Nt++]=128|_t&63}else{if(Nt+3>=ze)break;Je[Nt++]=240|_t>>18,Je[Nt++]=128|_t>>12&63,Je[Nt++]=128|_t>>6&63,Je[Nt++]=128|_t&63}}return Je[Nt]=0,Nt-Ue}function Me(et,Je,Nt){return Te(et,Vt,Je,Nt)}function Ae(et){for(var Je=0,Nt=0;Nt<et.length;++Nt){var _0=et.charCodeAt(Nt);_0>=55296&&_0<=57343&&(_0=65536+((_0&1023)<<10)|et.charCodeAt(++Nt)&1023),_0<=127?++Je:_0<=2047?Je+=2:_0<=65535?Je+=3:Je+=4}return Je}var Ce=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function Pe(et,Je){for(var Nt=et,_0=Nt>>1,Ue=_0+Je/2;!(_0>=Ue)&&r0[_0];)++_0;if(Nt=_0<<1,Nt-et>32&&Ce)return Ce.decode(Vt.subarray(et,Nt));for(var ze="",We=0;!(We>=Je/2);++We){var _t=T0[et+We*2>>1];if(_t==0)break;ze+=String.fromCharCode(_t)}return ze}function je(et,Je,Nt){if(Nt===void 0&&(Nt=2147483647),Nt<2)return 0;Nt-=2;for(var _0=Je,Ue=Nt<et.length*2?Nt/2:et.length,ze=0;ze<Ue;++ze){var We=et.charCodeAt(ze);T0[Je>>1]=We,Je+=2}return T0[Je>>1]=0,Je-_0}function Ne(et){return et.length*2}function Qe(et,Je){for(var Nt=0,_0="";!(Nt>=Je/4);){var Ue=d0[et+Nt*4>>2];if(Ue==0)break;if(++Nt,Ue>=65536){var ze=Ue-65536;_0+=String.fromCharCode(55296|ze>>10,56320|ze&1023)}else _0+=String.fromCharCode(Ue)}return _0}function Ct(et,Je,Nt){if(Nt===void 0&&(Nt=2147483647),Nt<4)return 0;for(var _0=Je,Ue=_0+Nt-4,ze=0;ze<et.length;++ze){var We=et.charCodeAt(ze);if(We>=55296&&We<=57343){var _t=et.charCodeAt(++ze);We=65536+((We&1023)<<10)|_t&1023}if(d0[Je>>2]=We,Je+=4,Je+4>Ue)break}return d0[Je>>2]=0,Je-_0}function dt(et){for(var Je=0,Nt=0;Nt<et.length;++Nt){var _0=et.charCodeAt(Nt);_0>=55296&&_0<=57343&&++Nt,Je+=4}return Je}var Xt,Gt,Vt,T0,r0,d0,Ut,$0,Q0;function Un(et){Xt=et,c.HEAP8=Gt=new Int8Array(et),c.HEAP16=T0=new Int16Array(et),c.HEAP32=d0=new Int32Array(et),c.HEAPU8=Vt=new Uint8Array(et),c.HEAPU16=r0=new Uint16Array(et),c.HEAPU32=Ut=new Uint32Array(et),c.HEAPF32=$0=new Float32Array(et),c.HEAPF64=Q0=new Float64Array(et)}c.INITIAL_MEMORY;var b0,X0=[],Rt=[],Qt=[];function A0(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)dx(c.preRun.shift());Po(X0)}function J0(){Po(Rt)}function Pn(){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)Wn(c.postRun.shift());Po(Qt)}function dx(et){X0.unshift(et)}function Bn(et){Rt.unshift(et)}function Wn(et){Qt.unshift(et)}var gx=0,Jx=null;function er(et){gx++,c.monitorRunDependencies&&c.monitorRunDependencies(gx)}function Cr(et){if(gx--,c.monitorRunDependencies&&c.monitorRunDependencies(gx),gx==0&&Jx){var Je=Jx;Jx=null,Je()}}function Rr(et){c.onAbort&&c.onAbort(et),et="Aborted("+et+")",q(et),$=!0,et+=". Build with -sASSERTIONS for more info.";var Je=new WebAssembly.RuntimeError(et);throw m(Je),Je}var xi="data:application/octet-stream;base64,";function Nr(et){return et.startsWith(xi)}var rr;rr="poseutils.wasm",Nr(rr)||(rr=S(rr));function ja(et){try{if(et==rr&&H)return new Uint8Array(H);throw"both async and sync fetching of the wasm failed"}catch(Je){Rr(Je)}}function xn(){return!H&&b&&typeof fetch=="function"?fetch(rr,{credentials:"same-origin"}).then(function(et){if(!et.ok)throw"failed to load wasm binary file at '"+rr+"'";return et.arrayBuffer()}).catch(function(){return ja(rr)}):Promise.resolve().then(function(){return ja(rr)})}function io(){var et={a:Jc};function Je(We,_t){var jt=We.exports;c.asm=jt,j=c.asm.y,Un(j.buffer),b0=c.asm.C,Bn(c.asm.z),Cr()}er();function Nt(We){Je(We.instance)}function _0(We){return xn().then(function(_t){return WebAssembly.instantiate(_t,et)}).then(function(_t){return _t}).then(We,function(_t){q("failed to asynchronously prepare wasm: "+_t),Rr(_t)})}function Ue(){return!H&&typeof WebAssembly.instantiateStreaming=="function"&&!Nr(rr)&&typeof fetch=="function"?fetch(rr,{credentials:"same-origin"}).then(function(We){var _t=WebAssembly.instantiateStreaming(We,et);return _t.then(Nt,function(jt){return q("wasm streaming compile failed: "+jt),q("falling back to ArrayBuffer instantiation"),_0(Nt)})}):_0(Nt)}if(c.instantiateWasm)try{var ze=c.instantiateWasm(et,Je);return ze}catch(We){return q("Module.instantiateWasm callback failed with error: "+We),!1}return Ue().catch(m),{}}function Po(et){for(;et.length>0;){var Je=et.shift();if(typeof Je=="function"){Je(c);continue}var Nt=Je.func;typeof Nt=="number"?Je.arg===void 0?Ji(Nt)():Ji(Nt)(Je.arg):Nt(Je.arg===void 0?null:Je.arg)}}var Ka=[];function Ji(et){var Je=Ka[et];return Je||(et>=Ka.length&&(Ka.length=et+1),Ka[et]=Je=b0.get(et)),Je}function W2(et){return z2(et+24)+24}function Vc(et){this.excPtr=et,this.ptr=et-24,this.set_type=function(Je){Ut[this.ptr+4>>2]=Je},this.get_type=function(){return Ut[this.ptr+4>>2]},this.set_destructor=function(Je){Ut[this.ptr+8>>2]=Je},this.get_destructor=function(){return Ut[this.ptr+8>>2]},this.set_refcount=function(Je){d0[this.ptr>>2]=Je},this.set_caught=function(Je){Je=Je?1:0,Gt[this.ptr+12>>0]=Je},this.get_caught=function(){return Gt[this.ptr+12>>0]!=0},this.set_rethrown=function(Je){Je=Je?1:0,Gt[this.ptr+13>>0]=Je},this.get_rethrown=function(){return Gt[this.ptr+13>>0]!=0},this.init=function(Je,Nt){this.set_adjusted_ptr(0),this.set_type(Je),this.set_destructor(Nt),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var Je=d0[this.ptr>>2];d0[this.ptr>>2]=Je+1},this.release_ref=function(){var Je=d0[this.ptr>>2];return d0[this.ptr>>2]=Je-1,Je===1},this.set_adjusted_ptr=function(Je){Ut[this.ptr+16>>2]=Je},this.get_adjusted_ptr=function(){return Ut[this.ptr+16>>2]},this.get_exception_ptr=function(){var Je=Cl(this.get_type());if(Je)return Ut[this.excPtr>>2];var Nt=this.get_adjusted_ptr();return Nt!==0?Nt:this.excPtr}}function Ql(et,Je,Nt){var _0=new Vc(et);throw _0.init(Je,Nt),et}var ba={};function uo(et){for(;et.length;){var Je=et.pop(),Nt=et.pop();Nt(Je)}}function Wi(et){return this.fromWireType(Ut[et>>2])}var $a={},Rs={},C2={},vd=48,Gu=57;function R2(et){if(et===void 0)return"_unknown";et=et.replace(/[^a-zA-Z0-9_]/g,"$");var Je=et.charCodeAt(0);return Je>=vd&&Je<=Gu?"_"+et:et}function ul(et,Je){return et=R2(et),function(){return Je.apply(this,arguments)}}function Q2(et,Je){var Nt=ul(Je,function(_0){this.name=Je,this.message=_0;var Ue=new Error(_0).stack;Ue!==void 0&&(this.stack=this.toString()+`
`+Ue.replace(/^Error(:[^\n]*)?\n/,""))});return Nt.prototype=Object.create(et.prototype),Nt.prototype.constructor=Nt,Nt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},Nt}var Ns=void 0;function Js(et){throw new Ns(et)}function Pi(et,Je,Nt){et.forEach(function(_t){C2[_t]=Je});function _0(_t){var jt=Nt(_t);jt.length!==et.length&&Js("Mismatched type converter count");for(var e0=0;e0<et.length;++e0)bs(et[e0],jt[e0])}var Ue=new Array(Je.length),ze=[],We=0;Je.forEach((_t,jt)=>{Rs.hasOwnProperty(_t)?Ue[jt]=Rs[_t]:(ze.push(_t),$a.hasOwnProperty(_t)||($a[_t]=[]),$a[_t].push(()=>{Ue[jt]=Rs[_t],++We,We===ze.length&&_0(Ue)}))}),ze.length===0&&_0(Ue)}function _a(et){var Je=ba[et];delete ba[et];var Nt=Je.rawConstructor,_0=Je.rawDestructor,Ue=Je.fields,ze=Ue.map(We=>We.getterReturnType).concat(Ue.map(We=>We.setterArgumentType));Pi([et],ze,We=>{var _t={};return Ue.forEach((jt,e0)=>{var u0=jt.fieldName,Jt=We[e0],B0=jt.getter,dn=jt.getterContext,zn=We[e0+Ue.length],Jn=jt.setter,Wx=jt.setterContext;_t[u0]={read:br=>Jt.fromWireType(B0(dn,br)),write:(br,Qr)=>{var gr=[];Jn(Wx,br,zn.toWireType(gr,Qr)),uo(gr)}}}),[{name:Je.name,fromWireType:function(jt){var e0={};for(var u0 in _t)e0[u0]=_t[u0].read(jt);return _0(jt),e0},toWireType:function(jt,e0){for(var u0 in _t)if(!(u0 in e0))throw new TypeError('Missing field:  "'+u0+'"');var Jt=Nt();for(u0 in _t)_t[u0].write(Jt,e0[u0]);return jt!==null&&jt.push(_0,Jt),Jt},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:_0}]})}function Ta(et,Je,Nt,_0,Ue){}function vs(et){switch(et){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+et)}}function Ba(){for(var et=new Array(256),Je=0;Je<256;++Je)et[Je]=String.fromCharCode(Je);Aa=et}var Aa=void 0;function Bi(et){for(var Je="",Nt=et;Vt[Nt];)Je+=Aa[Vt[Nt++]];return Je}var Ws=void 0;function Nn(et){throw new Ws(et)}function bs(et,Je,Nt={}){if(!("argPackAdvance"in Je))throw new TypeError("registerType registeredInstance requires argPackAdvance");var _0=Je.name;if(et||Nn('type "'+_0+'" must have a positive integer typeid pointer'),Rs.hasOwnProperty(et)){if(Nt.ignoreDuplicateRegistrations)return;Nn("Cannot register type '"+_0+"' twice")}if(Rs[et]=Je,delete C2[et],$a.hasOwnProperty(et)){var Ue=$a[et];delete $a[et],Ue.forEach(ze=>ze())}}function _r(et,Je,Nt,_0,Ue){var ze=vs(Nt);Je=Bi(Je),bs(et,{name:Je,fromWireType:function(We){return!!We},toWireType:function(We,_t){return _t?_0:Ue},argPackAdvance:8,readValueFromPointer:function(We){var _t;if(Nt===1)_t=Gt;else if(Nt===2)_t=T0;else if(Nt===4)_t=d0;else throw new TypeError("Unknown boolean type size: "+Je);return this.fromWireType(_t[We>>ze])},destructorFunction:null})}function Ui(et){if(!(this instanceof Uo)||!(et instanceof Uo))return!1;for(var Je=this.$$.ptrType.registeredClass,Nt=this.$$.ptr,_0=et.$$.ptrType.registeredClass,Ue=et.$$.ptr;Je.baseClass;)Nt=Je.upcast(Nt),Je=Je.baseClass;for(;_0.baseClass;)Ue=_0.upcast(Ue),_0=_0.baseClass;return Je===_0&&Nt===Ue}function go(et){return{count:et.count,deleteScheduled:et.deleteScheduled,preservePointerOnDelete:et.preservePointerOnDelete,ptr:et.ptr,ptrType:et.ptrType,smartPtr:et.smartPtr,smartPtrType:et.smartPtrType}}function dl(et){function Je(Nt){return Nt.$$.ptrType.registeredClass.name}Nn(Je(et)+" instance already deleted")}var Uc=!1;function ec(et){}function xc(et){et.smartPtr?et.smartPtrType.rawDestructor(et.smartPtr):et.ptrType.registeredClass.rawDestructor(et.ptr)}function rc(et){et.count.value-=1;var Je=et.count.value===0;Je&&xc(et)}function gl(et,Je,Nt){if(Je===Nt)return et;if(Nt.baseClass===void 0)return null;var _0=gl(et,Je,Nt.baseClass);return _0===null?null:Nt.downcast(_0)}var vl={};function uc(){return Object.keys(bo).length}function dc(){var et=[];for(var Je in bo)bo.hasOwnProperty(Je)&&et.push(bo[Je]);return et}var N2=[];function bl(){for(;N2.length;){var et=N2.pop();et.$$.deleteScheduled=!1,et.delete()}}var vo=void 0;function Wo(et){vo=et,N2.length&&vo&&vo(bl)}function Qo(){c.getInheritedInstanceCount=uc,c.getLiveInheritedInstances=dc,c.flushPendingDeletes=bl,c.setDelayFunction=Wo}var bo={};function Xu(et,Je){for(Je===void 0&&Nn("ptr should not be undefined");et.baseClass;)Je=et.upcast(Je),et=et.baseClass;return Je}function gc(et,Je){return Je=Xu(et,Je),bo[Je]}function Bo(et,Je){(!Je.ptrType||!Je.ptr)&&Js("makeClassHandle requires ptr and ptrType");var Nt=!!Je.smartPtrType,_0=!!Je.smartPtr;return Nt!==_0&&Js("Both smartPtrType and smartPtr must be specified"),Je.count={value:1},zo(Object.create(et,{$$:{value:Je}}))}function ju(et){var Je=this.getPointee(et);if(!Je)return this.destructor(et),null;var Nt=gc(this.registeredClass,Je);if(Nt!==void 0){if(Nt.$$.count.value===0)return Nt.$$.ptr=Je,Nt.$$.smartPtr=et,Nt.clone();var _0=Nt.clone();return this.destructor(et),_0}function Ue(){return this.isSmartPointer?Bo(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:Je,smartPtrType:this,smartPtr:et}):Bo(this.registeredClass.instancePrototype,{ptrType:this,ptr:et})}var ze=this.registeredClass.getActualType(Je),We=vl[ze];if(!We)return Ue.call(this);var _t;this.isConst?_t=We.constPointerType:_t=We.pointerType;var jt=gl(Je,this.registeredClass,_t.registeredClass);return jt===null?Ue.call(this):this.isSmartPointer?Bo(_t.registeredClass.instancePrototype,{ptrType:_t,ptr:jt,smartPtrType:this,smartPtr:et}):Bo(_t.registeredClass.instancePrototype,{ptrType:_t,ptr:jt})}function zo(et){return typeof FinalizationRegistry>"u"?(zo=Je=>Je,et):(Uc=new FinalizationRegistry(Je=>{rc(Je.$$)}),zo=Je=>{var Nt=Je.$$,_0=!!Nt.smartPtr;if(_0){var Ue={$$:Nt};Uc.register(Je,Ue,Je)}return Je},ec=Je=>Uc.unregister(Je),zo(et))}function Gc(){if(this.$$.ptr||dl(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var et=zo(Object.create(Object.getPrototypeOf(this),{$$:{value:go(this.$$)}}));return et.$$.count.value+=1,et.$$.deleteScheduled=!1,et}function Vo(){this.$$.ptr||dl(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Nn("Object already scheduled for deletion"),ec(this),rc(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function vc(){return!this.$$.ptr}function Ku(){return this.$$.ptr||dl(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Nn("Object already scheduled for deletion"),N2.push(this),N2.length===1&&vo&&vo(bl),this.$$.deleteScheduled=!0,this}function $u(){Uo.prototype.isAliasOf=Ui,Uo.prototype.clone=Gc,Uo.prototype.delete=Vo,Uo.prototype.isDeleted=vc,Uo.prototype.deleteLater=Ku}function Uo(){}function bc(et,Je,Nt){if(et[Je].overloadTable===void 0){var _0=et[Je];et[Je]=function(){return et[Je].overloadTable.hasOwnProperty(arguments.length)||Nn("Function '"+Nt+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+et[Je].overloadTable+")!"),et[Je].overloadTable[arguments.length].apply(this,arguments)},et[Je].overloadTable=[],et[Je].overloadTable[_0.argCount]=_0}}function Go(et,Je,Nt){c.hasOwnProperty(et)?((Nt===void 0||c[et].overloadTable!==void 0&&c[et].overloadTable[Nt]!==void 0)&&Nn("Cannot register public name '"+et+"' twice"),bc(c,et,et),c.hasOwnProperty(Nt)&&Nn("Cannot register multiple overloads of a function with the same number of arguments ("+Nt+")!"),c[et].overloadTable[Nt]=Je):(c[et]=Je,Nt!==void 0&&(c[et].numArguments=Nt))}function _o(et,Je,Nt,_0,Ue,ze,We,_t){this.name=et,this.constructor=Je,this.instancePrototype=Nt,this.rawDestructor=_0,this.baseClass=Ue,this.getActualType=ze,this.upcast=We,this.downcast=_t,this.pureVirtualFunctions=[]}function Ma(et,Je,Nt){for(;Je!==Nt;)Je.upcast||Nn("Expected null or instance of "+Nt.name+", got an instance of "+Je.name),et=Je.upcast(et),Je=Je.baseClass;return et}function Ju(et,Je){if(Je===null)return this.isReference&&Nn("null is not a valid "+this.name),0;Je.$$||Nn('Cannot pass "'+r2(Je)+'" as a '+this.name),Je.$$.ptr||Nn("Cannot pass deleted object as a pointer of type "+this.name);var Nt=Je.$$.ptrType.registeredClass,_0=Ma(Je.$$.ptr,Nt,this.registeredClass);return _0}function Xc(et,Je){var Nt;if(Je===null)return this.isReference&&Nn("null is not a valid "+this.name),this.isSmartPointer?(Nt=this.rawConstructor(),et!==null&&et.push(this.rawDestructor,Nt),Nt):0;Je.$$||Nn('Cannot pass "'+r2(Je)+'" as a '+this.name),Je.$$.ptr||Nn("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&Je.$$.ptrType.isConst&&Nn("Cannot convert argument of type "+(Je.$$.smartPtrType?Je.$$.smartPtrType.name:Je.$$.ptrType.name)+" to parameter type "+this.name);var _0=Je.$$.ptrType.registeredClass;if(Nt=Ma(Je.$$.ptr,_0,this.registeredClass),this.isSmartPointer)switch(Je.$$.smartPtr===void 0&&Nn("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:Je.$$.smartPtrType===this?Nt=Je.$$.smartPtr:Nn("Cannot convert argument of type "+(Je.$$.smartPtrType?Je.$$.smartPtrType.name:Je.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:Nt=Je.$$.smartPtr;break;case 2:if(Je.$$.smartPtrType===this)Nt=Je.$$.smartPtr;else{var Ue=Je.clone();Nt=this.rawShare(Nt,Gs.toHandle(function(){Ue.delete()})),et!==null&&et.push(this.rawDestructor,Nt)}break;default:Nn("Unsupporting sharing policy")}return Nt}function jc(et,Je){if(Je===null)return this.isReference&&Nn("null is not a valid "+this.name),0;Je.$$||Nn('Cannot pass "'+r2(Je)+'" as a '+this.name),Je.$$.ptr||Nn("Cannot pass deleted object as a pointer of type "+this.name),Je.$$.ptrType.isConst&&Nn("Cannot convert argument of type "+Je.$$.ptrType.name+" to parameter type "+this.name);var Nt=Je.$$.ptrType.registeredClass,_0=Ma(Je.$$.ptr,Nt,this.registeredClass);return _0}function Wu(et){return this.rawGetPointee&&(et=this.rawGetPointee(et)),et}function Qu(et){this.rawDestructor&&this.rawDestructor(et)}function eh(et){et!==null&&et.delete()}function _c(){To.prototype.getPointee=Wu,To.prototype.destructor=Qu,To.prototype.argPackAdvance=8,To.prototype.readValueFromPointer=Wi,To.prototype.deleteObject=eh,To.prototype.fromWireType=ju}function To(et,Je,Nt,_0,Ue,ze,We,_t,jt,e0,u0){this.name=et,this.registeredClass=Je,this.isReference=Nt,this.isConst=_0,this.isSmartPointer=Ue,this.pointeeType=ze,this.sharingPolicy=We,this.rawGetPointee=_t,this.rawConstructor=jt,this.rawShare=e0,this.rawDestructor=u0,!Ue&&Je.baseClass===void 0?_0?(this.toWireType=Ju,this.destructorFunction=null):(this.toWireType=jc,this.destructorFunction=null):this.toWireType=Xc}function _l(et,Je,Nt){c.hasOwnProperty(et)||Js("Replacing nonexistant public symbol"),c[et].overloadTable!==void 0&&Nt!==void 0?c[et].overloadTable[Nt]=Je:(c[et]=Je,c[et].argCount=Nt)}function _s(et,Je,Nt){var _0=c["dynCall_"+et];return Nt&&Nt.length?_0.apply(null,[Je].concat(Nt)):_0.call(null,Je)}function e2(et,Je,Nt){return et.includes("j")?_s(et,Je,Nt):Ji(Je).apply(null,Nt)}function Qs(et,Je){var Nt=[];return function(){return Nt.length=0,Object.assign(Nt,arguments),e2(et,Je,Nt)}}function Ps(et,Je){et=Bi(et);function Nt(){return et.includes("j")?Qs(et,Je):Ji(Je)}var _0=Nt();return typeof _0!="function"&&Nn("unknown function pointer with signature "+et+": "+Je),_0}var P2=void 0;function Ri(et){var Je=Ml(et),Nt=Bi(Je);return Ua(Je),Nt}function Gi(et,Je){var Nt=[],_0={};function Ue(ze){if(!_0[ze]&&!Rs[ze]){if(C2[ze]){C2[ze].forEach(Ue);return}Nt.push(ze),_0[ze]=!0}}throw Je.forEach(Ue),new P2(et+": "+Nt.map(Ri).join([", "]))}function ea(et,Je,Nt,_0,Ue,ze,We,_t,jt,e0,u0,Jt,B0){u0=Bi(u0),ze=Ps(Ue,ze),_t&&(_t=Ps(We,_t)),e0&&(e0=Ps(jt,e0)),B0=Ps(Jt,B0);var dn=R2(u0);Go(dn,function(){Gi("Cannot construct "+u0+" due to unbound types",[_0])}),Pi([et,Je,Nt],_0?[_0]:[],function(zn){zn=zn[0];var Jn,Wx;_0?(Jn=zn.registeredClass,Wx=Jn.instancePrototype):Wx=Uo.prototype;var br=ul(dn,function(){if(Object.getPrototypeOf(this)!==Qr)throw new Ws("Use 'new' to construct "+u0);if(gr.constructor_body===void 0)throw new Ws(u0+" has no accessible constructor");var ji=gr.constructor_body[arguments.length];if(ji===void 0)throw new Ws("Tried to invoke ctor of "+u0+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(gr.constructor_body).toString()+") parameters instead!");return ji.apply(this,arguments)}),Qr=Object.create(Wx,{constructor:{value:br}});br.prototype=Qr;var gr=new _o(u0,br,Qr,B0,Jn,ze,_t,e0),Qi=new To(u0,gr,!0,!1,!1),es=new To(u0+"*",gr,!1,!1,!1),Xs=new To(u0+" const*",gr,!1,!0,!1);return vl[et]={pointerType:es,constPointerType:Xs},_l(dn,br),[Qi,es,Xs]})}function gi(et,Je){for(var Nt=[],_0=0;_0<et;_0++)Nt.push(d0[(Je>>2)+_0]);return Nt}function Tc(et,Je,Nt,_0,Ue,ze){J(Je>0);var We=gi(Je,Nt);Ue=Ps(_0,Ue),Pi([],[et],function(_t){_t=_t[0];var jt="constructor "+_t.name;if(_t.registeredClass.constructor_body===void 0&&(_t.registeredClass.constructor_body=[]),_t.registeredClass.constructor_body[Je-1]!==void 0)throw new Ws("Cannot register multiple constructors with identical number of parameters ("+(Je-1)+") for class '"+_t.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return _t.registeredClass.constructor_body[Je-1]=()=>{Gi("Cannot construct "+_t.name+" due to unbound types",We)},Pi([],We,function(e0){return e0.splice(1,0,null),_t.registeredClass.constructor_body[Je-1]=k2(jt,e0,null,Ue,ze),[]}),[]})}function k2(et,Je,Nt,_0,Ue){var ze=Je.length;ze<2&&Nn("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var We=Je[1]!==null&&Nt!==null,_t=!1,jt=1;jt<Je.length;++jt)if(Je[jt]!==null&&Je[jt].destructorFunction===void 0){_t=!0;break}var e0=Je[0].name!=="void",u0=ze-2,Jt=new Array(u0),B0=[],dn=[];return function(){arguments.length!==u0&&Nn("function "+et+" called with "+arguments.length+" arguments, expected "+u0+" args!"),dn.length=0;var zn;B0.length=We?2:1,B0[0]=Ue,We&&(zn=Je[1].toWireType(dn,this),B0[1]=zn);for(var Jn=0;Jn<u0;++Jn)Jt[Jn]=Je[Jn+2].toWireType(dn,arguments[Jn]),B0.push(Jt[Jn]);var Wx=_0.apply(null,B0);function br(Qr){if(_t)uo(dn);else for(var gr=We?1:2;gr<Je.length;gr++){var Qi=gr===1?zn:Jt[gr-2];Je[gr].destructorFunction!==null&&Je[gr].destructorFunction(Qi)}if(e0)return Je[0].fromWireType(Qr)}return br(Wx)}}function x2(et,Je,Nt,_0,Ue,ze,We,_t){var jt=gi(Nt,_0);Je=Bi(Je),ze=Ps(Ue,ze),Pi([],[et],function(e0){e0=e0[0];var u0=e0.name+"."+Je;Je.startsWith("@@")&&(Je=Symbol[Je.substring(2)]),_t&&e0.registeredClass.pureVirtualFunctions.push(Je);function Jt(){Gi("Cannot call "+u0+" due to unbound types",jt)}var B0=e0.registeredClass.instancePrototype,dn=B0[Je];return dn===void 0||dn.overloadTable===void 0&&dn.className!==e0.name&&dn.argCount===Nt-2?(Jt.argCount=Nt-2,Jt.className=e0.name,B0[Je]=Jt):(bc(B0,Je,u0),B0[Je].overloadTable[Nt-2]=Jt),Pi([],jt,function(zn){var Jn=k2(u0,zn,e0,ze,We);return B0[Je].overloadTable===void 0?(Jn.argCount=Nt-2,B0[Je]=Jn):B0[Je].overloadTable[Nt-2]=Jn,[]}),[]})}function Tl(et,Je,Nt){return et instanceof Object||Nn(Nt+' with invalid "this": '+et),et instanceof Je.registeredClass.constructor||Nn(Nt+' incompatible with "this" of type '+et.constructor.name),et.$$.ptr||Nn("cannot call emscripten binding method "+Nt+" on deleted object"),Ma(et.$$.ptr,et.$$.ptrType.registeredClass,Je.registeredClass)}function ui(et,Je,Nt,_0,Ue,ze,We,_t,jt,e0){Je=Bi(Je),Ue=Ps(_0,Ue),Pi([],[et],function(u0){u0=u0[0];var Jt=u0.name+"."+Je,B0={get:function(){Gi("Cannot access "+Jt+" due to unbound types",[Nt,We])},enumerable:!0,configurable:!0};return jt?B0.set=()=>{Gi("Cannot access "+Jt+" due to unbound types",[Nt,We])}:B0.set=dn=>{Nn(Jt+" is a read-only property")},Object.defineProperty(u0.registeredClass.instancePrototype,Je,B0),Pi([],jt?[Nt,We]:[Nt],function(dn){var zn=dn[0],Jn={get:function(){var br=Tl(this,u0,Jt+" getter");return zn.fromWireType(Ue(ze,br))},enumerable:!0};if(jt){jt=Ps(_t,jt);var Wx=dn[1];Jn.set=function(br){var Qr=Tl(this,u0,Jt+" setter"),gr=[];jt(e0,Qr,Wx.toWireType(gr,br)),uo(gr)}}return Object.defineProperty(u0.registeredClass.instancePrototype,Je,Jn),[]}),[]})}var Xo=[],za=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Us(et){et>4&&--za[et].refcount===0&&(za[et]=void 0,Xo.push(et))}function Va(){for(var et=0,Je=5;Je<za.length;++Je)za[Je]!==void 0&&++et;return et}function Ao(){for(var et=5;et<za.length;++et)if(za[et]!==void 0)return za[et];return null}function Al(){c.count_emval_handles=Va,c.get_first_emval=Ao}var Gs={toValue:et=>(et||Nn("Cannot use deleted val. handle = "+et),za[et].value),toHandle:et=>{switch(et){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var Je=Xo.length?Xo.pop():za.length;return za[Je]={refcount:1,value:et},Je}}}};function Ac(et,Je){Je=Bi(Je),bs(et,{name:Je,fromWireType:function(Nt){var _0=Gs.toValue(Nt);return Us(Nt),_0},toWireType:function(Nt,_0){return Gs.toHandle(_0)},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:null})}function r2(et){if(et===null)return"null";var Je=typeof et;return Je==="object"||Je==="array"||Je==="function"?et.toString():""+et}function jo(et,Je){switch(Je){case 2:return function(Nt){return this.fromWireType($0[Nt>>2])};case 3:return function(Nt){return this.fromWireType(Q0[Nt>>3])};default:throw new TypeError("Unknown float type: "+et)}}function Ts(et,Je,Nt){var _0=vs(Nt);Je=Bi(Je),bs(et,{name:Je,fromWireType:function(Ue){return Ue},toWireType:function(Ue,ze){return ze},argPackAdvance:8,readValueFromPointer:jo(Je,_0),destructorFunction:null})}function Xi(et,Je,Nt){switch(Je){case 0:return Nt?function(_0){return Gt[_0]}:function(_0){return Vt[_0]};case 1:return Nt?function(_0){return T0[_0>>1]}:function(_0){return r0[_0>>1]};case 2:return Nt?function(_0){return d0[_0>>2]}:function(_0){return Ut[_0>>2]};default:throw new TypeError("Unknown integer type: "+et)}}function eu(et,Je,Nt,_0,Ue){Je=Bi(Je);var ze=vs(Nt),We=Jt=>Jt;if(_0===0){var _t=32-8*Nt;We=Jt=>Jt<<_t>>>_t}var jt=Je.includes("unsigned"),e0=(Jt,B0)=>{},u0;jt?u0=function(Jt,B0){return e0(B0,this.name),B0>>>0}:u0=function(Jt,B0){return e0(B0,this.name),B0},bs(et,{name:Je,fromWireType:We,toWireType:u0,argPackAdvance:8,readValueFromPointer:Xi(Je,ze,_0!==0),destructorFunction:null})}function Kc(et,Je,Nt){var _0=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],Ue=_0[Je];function ze(We){We=We>>2;var _t=Ut,jt=_t[We],e0=_t[We+1];return new Ue(Xt,e0,jt)}Nt=Bi(Nt),bs(et,{name:Nt,fromWireType:ze,argPackAdvance:8,readValueFromPointer:ze},{ignoreDuplicateRegistrations:!0})}function u2(et,Je){Je=Bi(Je);var Nt=Je==="std::string";bs(et,{name:Je,fromWireType:function(_0){var Ue=Ut[_0>>2],ze;if(Nt)for(var We=_0+4,_t=0;_t<=Ue;++_t){var jt=_0+4+_t;if(_t==Ue||Vt[jt]==0){var e0=jt-We,u0=de(We,e0);ze===void 0?ze=u0:(ze+=String.fromCharCode(0),ze+=u0),We=jt+1}}else{for(var Jt=new Array(Ue),_t=0;_t<Ue;++_t)Jt[_t]=String.fromCharCode(Vt[_0+4+_t]);ze=Jt.join("")}return Ua(_0),ze},toWireType:function(_0,Ue){Ue instanceof ArrayBuffer&&(Ue=new Uint8Array(Ue));var ze,We=typeof Ue=="string";We||Ue instanceof Uint8Array||Ue instanceof Uint8ClampedArray||Ue instanceof Int8Array||Nn("Cannot pass non-string to std::string"),Nt&&We?ze=()=>Ae(Ue):ze=()=>Ue.length;var _t=ze(),jt=z2(4+_t+1);if(Ut[jt>>2]=_t,Nt&&We)Me(Ue,jt+4,_t+1);else if(We)for(var e0=0;e0<_t;++e0){var u0=Ue.charCodeAt(e0);u0>255&&(Ua(jt),Nn("String has UTF-16 code units that do not fit in 8 bits")),Vt[jt+4+e0]=u0}else for(var e0=0;e0<_t;++e0)Vt[jt+4+e0]=Ue[e0];return _0!==null&&_0.push(Ua,jt),jt},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:function(_0){Ua(_0)}})}function xh(et,Je,Nt){Nt=Bi(Nt);var _0,Ue,ze,We,_t;Je===2?(_0=Pe,Ue=je,We=Ne,ze=()=>r0,_t=1):Je===4&&(_0=Qe,Ue=Ct,We=dt,ze=()=>Ut,_t=2),bs(et,{name:Nt,fromWireType:function(jt){for(var e0=Ut[jt>>2],u0=ze(),Jt,B0=jt+4,dn=0;dn<=e0;++dn){var zn=jt+4+dn*Je;if(dn==e0||u0[zn>>_t]==0){var Jn=zn-B0,Wx=_0(B0,Jn);Jt===void 0?Jt=Wx:(Jt+=String.fromCharCode(0),Jt+=Wx),B0=zn+Je}}return Ua(jt),Jt},toWireType:function(jt,e0){typeof e0!="string"&&Nn("Cannot pass non-string to C++ string type "+Nt);var u0=We(e0),Jt=z2(4+u0+Je);return Ut[Jt>>2]=u0>>_t,Ue(e0,Jt+4,u0+Je),jt!==null&&jt.push(Ua,Jt),Jt},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:function(jt){Ua(jt)}})}function xa(et,Je,Nt,_0,Ue,ze){ba[et]={name:Bi(Je),rawConstructor:Ps(Nt,_0),rawDestructor:Ps(Ue,ze),fields:[]}}function rh(et,Je,Nt,_0,Ue,ze,We,_t,jt,e0){ba[et].fields.push({fieldName:Bi(Je),getterReturnType:Nt,getter:Ps(_0,Ue),getterContext:ze,setterArgumentType:We,setter:Ps(_t,jt),setterContext:e0})}function uh(et,Je){Je=Bi(Je),bs(et,{isVoid:!0,name:Je,argPackAdvance:0,fromWireType:function(){},toWireType:function(Nt,_0){}})}function d2(et){et>4&&(za[et].refcount+=1)}function B2(et,Je){var Nt=Rs[et];return Nt===void 0&&Nn(Je+" has unknown type "+Ri(et)),Nt}function dh(et,Je){et=B2(et,"_emval_take_value");var Nt=et.readValueFromPointer(Je);return Gs.toHandle(Nt)}function xu(){Rr("")}function ru(et,Je,Nt){Vt.copyWithin(et,Je,Je+Nt)}function uu(){return 2147483648}function du(et){try{return j.grow(et-Xt.byteLength+65535>>>16),Un(j.buffer),1}catch{}}function $c(et){var Je=Vt.length;et=et>>>0;var Nt=uu();if(et>Nt)return!1;let _0=(jt,e0)=>jt+(e0-jt%e0)%e0;for(var Ue=1;Ue<=4;Ue*=2){var ze=Je*(1+.2/Ue);ze=Math.min(ze,et+100663296);var We=Math.min(Nt,_0(Math.max(et,ze),65536)),_t=du(We);if(_t)return!0}return!1}Ns=c.InternalError=Q2(Error,"InternalError"),Ba(),Ws=c.BindingError=Q2(Error,"BindingError"),$u(),Qo(),_c(),P2=c.UnboundTypeError=Q2(Error,"UnboundTypeError"),Al();var Jc={c:W2,b:Ql,x:_a,q:Ta,v:_r,j:ea,i:Tc,d:x2,f:ui,u:Ac,l:Ts,e:eu,a:Kc,k:u2,g:xh,m:xa,h:rh,w:uh,n:Us,o:d2,p:dh,r:xu,t:ru,s:$c};io(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.z).apply(null,arguments)};var Ua=c._free=function(){return(Ua=c._free=c.asm.A).apply(null,arguments)},z2=c._malloc=function(){return(z2=c._malloc=c.asm.B).apply(null,arguments)},Ml=c.___getTypeName=function(){return(Ml=c.___getTypeName=c.asm.D).apply(null,arguments)};c.___embind_register_native_and_builtin_types=function(){return(c.___embind_register_native_and_builtin_types=c.asm.E).apply(null,arguments)};var Cl=c.___cxa_is_pointer_type=function(){return(Cl=c.___cxa_is_pointer_type=c.asm.F).apply(null,arguments)},ra;Jx=function et(){ra||g2(),ra||(Jx=et)};function g2(et){if(gx>0||(A0(),gx>0))return;function Je(){ra||(ra=!0,c.calledRun=!0,!$&&(J0(),p(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Pn()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),Je()},1)):Je()}if(c.run=g2,c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();return g2(),a.ready}})(),Lr=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(a){a=a||{};var c=typeof a<"u"?a:{},p,m;c.ready=new Promise(function(Ge,Ve){p=Ge,m=Ve});var v=Object.assign({},c),b="./this.program",w=(Ge,Ve)=>{throw Ve},S=!0,O=!1,q="";function H(Ge){return c.locateFile?c.locateFile(Ge,q):q+Ge}var j;typeof document<"u"&&document.currentScript&&(q=document.currentScript.src),u&&(q=u),q.indexOf("blob:")!==0?q=q.substr(0,q.replace(/[?#].*/,"").lastIndexOf("/")+1):q="",c.print||console.log.bind(console);var $=c.printErr||console.warn.bind(console);Object.assign(c,v),v=null,c.arguments&&c.arguments,c.thisProgram&&(b=c.thisProgram),c.quit&&(w=c.quit);var J;c.wasmBinary&&(J=c.wasmBinary),c.noExitRuntime,typeof WebAssembly!="object"&&io("no native wasm support detected");var ee,re=!1,de;function Te(Ge,Ve){Ge||io(Ve)}var Me=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Ae(Ge,Ve,gt){for(var Kt=Ve+gt,k0=Ve;Ge[k0]&&!(k0>=Kt);)++k0;if(k0-Ve>16&&Ge.buffer&&Me)return Me.decode(Ge.subarray(Ve,k0));for(var z0="";Ve<k0;){var K0=Ge[Ve++];if(!(K0&128)){z0+=String.fromCharCode(K0);continue}var C0=Ge[Ve++]&63;if((K0&224)==192){z0+=String.fromCharCode((K0&31)<<6|C0);continue}var Rn=Ge[Ve++]&63;if((K0&240)==224?K0=(K0&15)<<12|C0<<6|Rn:K0=(K0&7)<<18|C0<<12|Rn<<6|Ge[Ve++]&63,K0<65536)z0+=String.fromCharCode(K0);else{var rx=K0-65536;z0+=String.fromCharCode(55296|rx>>10,56320|rx&1023)}}return z0}function Ce(Ge,Ve){return Ge?Ae(Q0,Ge,Ve):""}function Pe(Ge,Ve,gt,Kt){if(!(Kt>0))return 0;for(var k0=gt,z0=gt+Kt-1,K0=0;K0<Ge.length;++K0){var C0=Ge.charCodeAt(K0);if(C0>=55296&&C0<=57343){var Rn=Ge.charCodeAt(++K0);C0=65536+((C0&1023)<<10)|Rn&1023}if(C0<=127){if(gt>=z0)break;Ve[gt++]=C0}else if(C0<=2047){if(gt+1>=z0)break;Ve[gt++]=192|C0>>6,Ve[gt++]=128|C0&63}else if(C0<=65535){if(gt+2>=z0)break;Ve[gt++]=224|C0>>12,Ve[gt++]=128|C0>>6&63,Ve[gt++]=128|C0&63}else{if(gt+3>=z0)break;Ve[gt++]=240|C0>>18,Ve[gt++]=128|C0>>12&63,Ve[gt++]=128|C0>>6&63,Ve[gt++]=128|C0&63}}return Ve[gt]=0,gt-k0}function je(Ge,Ve,gt){return Pe(Ge,Q0,Ve,gt)}function Ne(Ge){for(var Ve=0,gt=0;gt<Ge.length;++gt){var Kt=Ge.charCodeAt(gt);Kt>=55296&&Kt<=57343&&(Kt=65536+((Kt&1023)<<10)|Ge.charCodeAt(++gt)&1023),Kt<=127?++Ve:Kt<=2047?Ve+=2:Kt<=65535?Ve+=3:Ve+=4}return Ve}var Qe=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function Ct(Ge,Ve){for(var gt=Ge,Kt=gt>>1,k0=Kt+Ve/2;!(Kt>=k0)&&b0[Kt];)++Kt;if(gt=Kt<<1,gt-Ge>32&&Qe)return Qe.decode(Q0.subarray(Ge,gt));for(var z0="",K0=0;!(K0>=Ve/2);++K0){var C0=Un[Ge+K0*2>>1];if(C0==0)break;z0+=String.fromCharCode(C0)}return z0}function dt(Ge,Ve,gt){if(gt===void 0&&(gt=2147483647),gt<2)return 0;gt-=2;for(var Kt=Ve,k0=gt<Ge.length*2?gt/2:Ge.length,z0=0;z0<k0;++z0){var K0=Ge.charCodeAt(z0);Un[Ve>>1]=K0,Ve+=2}return Un[Ve>>1]=0,Ve-Kt}function Xt(Ge){return Ge.length*2}function Gt(Ge,Ve){for(var gt=0,Kt="";!(gt>=Ve/4);){var k0=X0[Ge+gt*4>>2];if(k0==0)break;if(++gt,k0>=65536){var z0=k0-65536;Kt+=String.fromCharCode(55296|z0>>10,56320|z0&1023)}else Kt+=String.fromCharCode(k0)}return Kt}function Vt(Ge,Ve,gt){if(gt===void 0&&(gt=2147483647),gt<4)return 0;for(var Kt=Ve,k0=Kt+gt-4,z0=0;z0<Ge.length;++z0){var K0=Ge.charCodeAt(z0);if(K0>=55296&&K0<=57343){var C0=Ge.charCodeAt(++z0);K0=65536+((K0&1023)<<10)|C0&1023}if(X0[Ve>>2]=K0,Ve+=4,Ve+4>k0)break}return X0[Ve>>2]=0,Ve-Kt}function T0(Ge){for(var Ve=0,gt=0;gt<Ge.length;++gt){var Kt=Ge.charCodeAt(gt);Kt>=55296&&Kt<=57343&&++gt,Ve+=4}return Ve}function r0(Ge,Ve){$0.set(Ge,Ve)}function d0(Ge,Ve,gt){for(var Kt=0;Kt<Ge.length;++Kt)$0[Ve++>>0]=Ge.charCodeAt(Kt);gt||($0[Ve>>0]=0)}var Ut,$0,Q0,Un,b0,X0,Rt,Qt,A0;function J0(Ge){Ut=Ge,c.HEAP8=$0=new Int8Array(Ge),c.HEAP16=Un=new Int16Array(Ge),c.HEAP32=X0=new Int32Array(Ge),c.HEAPU8=Q0=new Uint8Array(Ge),c.HEAPU16=b0=new Uint16Array(Ge),c.HEAPU32=Rt=new Uint32Array(Ge),c.HEAPF32=Qt=new Float32Array(Ge),c.HEAPF64=A0=new Float64Array(Ge)}c.INITIAL_MEMORY;var Pn,dx=[],Bn=[],Wn=[];function gx(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)Cr(c.preRun.shift());ba(dx)}function Jx(){ba(Bn)}function er(){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)xi(c.postRun.shift());ba(Wn)}function Cr(Ge){dx.unshift(Ge)}function Rr(Ge){Bn.unshift(Ge)}function xi(Ge){Wn.unshift(Ge)}var Nr=0,rr=null;function ja(Ge){Nr++,c.monitorRunDependencies&&c.monitorRunDependencies(Nr)}function xn(Ge){if(Nr--,c.monitorRunDependencies&&c.monitorRunDependencies(Nr),Nr==0&&rr){var Ve=rr;rr=null,Ve()}}function io(Ge){c.onAbort&&c.onAbort(Ge),Ge="Aborted("+Ge+")",$(Ge),re=!0,de=1,Ge+=". Build with -sASSERTIONS for more info.";var Ve=new WebAssembly.RuntimeError(Ge);throw m(Ve),Ve}var Po="data:application/octet-stream;base64,";function Ka(Ge){return Ge.startsWith(Po)}var Ji;Ji="bodyutils.wasm",Ka(Ji)||(Ji=H(Ji));function W2(Ge){try{if(Ge==Ji&&J)return new Uint8Array(J);throw"both async and sync fetching of the wasm failed"}catch(Ve){io(Ve)}}function Vc(){return!J&&S&&typeof fetch=="function"?fetch(Ji,{credentials:"same-origin"}).then(function(Ge){if(!Ge.ok)throw"failed to load wasm binary file at '"+Ji+"'";return Ge.arrayBuffer()}).catch(function(){return W2(Ji)}):Promise.resolve().then(function(){return W2(Ji)})}function Ql(){var Ge={a:_d};function Ve(K0,C0){var Rn=K0.exports;c.asm=Rn,ee=c.asm.G,J0(ee.buffer),Pn=c.asm.J,Rr(c.asm.H),xn()}ja();function gt(K0){Ve(K0.instance)}function Kt(K0){return Vc().then(function(C0){return WebAssembly.instantiate(C0,Ge)}).then(function(C0){return C0}).then(K0,function(C0){$("failed to asynchronously prepare wasm: "+C0),io(C0)})}function k0(){return!J&&typeof WebAssembly.instantiateStreaming=="function"&&!Ka(Ji)&&typeof fetch=="function"?fetch(Ji,{credentials:"same-origin"}).then(function(K0){var C0=WebAssembly.instantiateStreaming(K0,Ge);return C0.then(gt,function(Rn){return $("wasm streaming compile failed: "+Rn),$("falling back to ArrayBuffer instantiation"),Kt(gt)})}):Kt(gt)}if(c.instantiateWasm)try{var z0=c.instantiateWasm(Ge,Ve);return z0}catch(K0){return $("Module.instantiateWasm callback failed with error: "+K0),!1}return k0().catch(m),{}}function ba(Ge){for(;Ge.length>0;){var Ve=Ge.shift();if(typeof Ve=="function"){Ve(c);continue}var gt=Ve.func;typeof gt=="number"?Ve.arg===void 0?Wi(gt)():Wi(gt)(Ve.arg):gt(Ve.arg===void 0?null:Ve.arg)}}var uo=[];function Wi(Ge){var Ve=uo[Ge];return Ve||(Ge>=uo.length&&(uo.length=Ge+1),uo[Ge]=Ve=Pn.get(Ge)),Ve}function $a(Ge){if(Ge instanceof Ad||Ge=="unwind")return de;w(1,Ge)}function Rs(Ge){return Ja(Ge+24)+24}function C2(Ge){this.excPtr=Ge,this.ptr=Ge-24,this.set_type=function(Ve){Rt[this.ptr+4>>2]=Ve},this.get_type=function(){return Rt[this.ptr+4>>2]},this.set_destructor=function(Ve){Rt[this.ptr+8>>2]=Ve},this.get_destructor=function(){return Rt[this.ptr+8>>2]},this.set_refcount=function(Ve){X0[this.ptr>>2]=Ve},this.set_caught=function(Ve){Ve=Ve?1:0,$0[this.ptr+12>>0]=Ve},this.get_caught=function(){return $0[this.ptr+12>>0]!=0},this.set_rethrown=function(Ve){Ve=Ve?1:0,$0[this.ptr+13>>0]=Ve},this.get_rethrown=function(){return $0[this.ptr+13>>0]!=0},this.init=function(Ve,gt){this.set_adjusted_ptr(0),this.set_type(Ve),this.set_destructor(gt),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var Ve=X0[this.ptr>>2];X0[this.ptr>>2]=Ve+1},this.release_ref=function(){var Ve=X0[this.ptr>>2];return X0[this.ptr>>2]=Ve-1,Ve===1},this.set_adjusted_ptr=function(Ve){Rt[this.ptr+16>>2]=Ve},this.get_adjusted_ptr=function(){return Rt[this.ptr+16>>2]},this.get_exception_ptr=function(){var Ve=Rl(this.get_type());if(Ve)return Rt[this.excPtr>>2];var gt=this.get_adjusted_ptr();return gt!==0?gt:this.excPtr}}function vd(Ge,Ve,gt){var Kt=new C2(Ge);throw Kt.init(Ve,gt),Ge}function Gu(Ge,Ve,gt,Kt,k0){}function R2(Ge){switch(Ge){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+Ge)}}function ul(){for(var Ge=new Array(256),Ve=0;Ve<256;++Ve)Ge[Ve]=String.fromCharCode(Ve);Q2=Ge}var Q2=void 0;function Ns(Ge){for(var Ve="",gt=Ge;Q0[gt];)Ve+=Q2[Q0[gt++]];return Ve}var Js={},Pi={},_a={},Ta=48,vs=57;function Ba(Ge){if(Ge===void 0)return"_unknown";Ge=Ge.replace(/[^a-zA-Z0-9_]/g,"$");var Ve=Ge.charCodeAt(0);return Ve>=Ta&&Ve<=vs?"_"+Ge:Ge}function Aa(Ge,Ve){return Ge=Ba(Ge),function(){return Ve.apply(this,arguments)}}function Bi(Ge,Ve){var gt=Aa(Ve,function(Kt){this.name=Ve,this.message=Kt;var k0=new Error(Kt).stack;k0!==void 0&&(this.stack=this.toString()+`
`+k0.replace(/^Error(:[^\n]*)?\n/,""))});return gt.prototype=Object.create(Ge.prototype),gt.prototype.constructor=gt,gt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},gt}var Ws=void 0;function Nn(Ge){throw new Ws(Ge)}var bs=void 0;function _r(Ge){throw new bs(Ge)}function Ui(Ge,Ve,gt){Ge.forEach(function(C0){_a[C0]=Ve});function Kt(C0){var Rn=gt(C0);Rn.length!==Ge.length&&_r("Mismatched type converter count");for(var rx=0;rx<Ge.length;++rx)go(Ge[rx],Rn[rx])}var k0=new Array(Ve.length),z0=[],K0=0;Ve.forEach((C0,Rn)=>{Pi.hasOwnProperty(C0)?k0[Rn]=Pi[C0]:(z0.push(C0),Js.hasOwnProperty(C0)||(Js[C0]=[]),Js[C0].push(()=>{k0[Rn]=Pi[C0],++K0,K0===z0.length&&Kt(k0)}))}),z0.length===0&&Kt(k0)}function go(Ge,Ve,gt={}){if(!("argPackAdvance"in Ve))throw new TypeError("registerType registeredInstance requires argPackAdvance");var Kt=Ve.name;if(Ge||Nn('type "'+Kt+'" must have a positive integer typeid pointer'),Pi.hasOwnProperty(Ge)){if(gt.ignoreDuplicateRegistrations)return;Nn("Cannot register type '"+Kt+"' twice")}if(Pi[Ge]=Ve,delete _a[Ge],Js.hasOwnProperty(Ge)){var k0=Js[Ge];delete Js[Ge],k0.forEach(z0=>z0())}}function dl(Ge,Ve,gt,Kt,k0){var z0=R2(gt);Ve=Ns(Ve),go(Ge,{name:Ve,fromWireType:function(K0){return!!K0},toWireType:function(K0,C0){return C0?Kt:k0},argPackAdvance:8,readValueFromPointer:function(K0){var C0;if(gt===1)C0=$0;else if(gt===2)C0=Un;else if(gt===4)C0=X0;else throw new TypeError("Unknown boolean type size: "+Ve);return this.fromWireType(C0[K0>>z0])},destructorFunction:null})}function Uc(Ge){if(!(this instanceof _o)||!(Ge instanceof _o))return!1;for(var Ve=this.$$.ptrType.registeredClass,gt=this.$$.ptr,Kt=Ge.$$.ptrType.registeredClass,k0=Ge.$$.ptr;Ve.baseClass;)gt=Ve.upcast(gt),Ve=Ve.baseClass;for(;Kt.baseClass;)k0=Kt.upcast(k0),Kt=Kt.baseClass;return Ve===Kt&&gt===k0}function ec(Ge){return{count:Ge.count,deleteScheduled:Ge.deleteScheduled,preservePointerOnDelete:Ge.preservePointerOnDelete,ptr:Ge.ptr,ptrType:Ge.ptrType,smartPtr:Ge.smartPtr,smartPtrType:Ge.smartPtrType}}function xc(Ge){function Ve(gt){return gt.$$.ptrType.registeredClass.name}Nn(Ve(Ge)+" instance already deleted")}var rc=!1;function gl(Ge){}function vl(Ge){Ge.smartPtr?Ge.smartPtrType.rawDestructor(Ge.smartPtr):Ge.ptrType.registeredClass.rawDestructor(Ge.ptr)}function uc(Ge){Ge.count.value-=1;var Ve=Ge.count.value===0;Ve&&vl(Ge)}function dc(Ge,Ve,gt){if(Ve===gt)return Ge;if(gt.baseClass===void 0)return null;var Kt=dc(Ge,Ve,gt.baseClass);return Kt===null?null:gt.downcast(Kt)}var N2={};function bl(){return Object.keys(Bo).length}function vo(){var Ge=[];for(var Ve in Bo)Bo.hasOwnProperty(Ve)&&Ge.push(Bo[Ve]);return Ge}var Wo=[];function Qo(){for(;Wo.length;){var Ge=Wo.pop();Ge.$$.deleteScheduled=!1,Ge.delete()}}var bo=void 0;function Xu(Ge){bo=Ge,Wo.length&&bo&&bo(Qo)}function gc(){c.getInheritedInstanceCount=bl,c.getLiveInheritedInstances=vo,c.flushPendingDeletes=Qo,c.setDelayFunction=Xu}var Bo={};function ju(Ge,Ve){for(Ve===void 0&&Nn("ptr should not be undefined");Ge.baseClass;)Ve=Ge.upcast(Ve),Ge=Ge.baseClass;return Ve}function zo(Ge,Ve){return Ve=ju(Ge,Ve),Bo[Ve]}function Gc(Ge,Ve){(!Ve.ptrType||!Ve.ptr)&&_r("makeClassHandle requires ptr and ptrType");var gt=!!Ve.smartPtrType,Kt=!!Ve.smartPtr;return gt!==Kt&&_r("Both smartPtrType and smartPtr must be specified"),Ve.count={value:1},vc(Object.create(Ge,{$$:{value:Ve}}))}function Vo(Ge){var Ve=this.getPointee(Ge);if(!Ve)return this.destructor(Ge),null;var gt=zo(this.registeredClass,Ve);if(gt!==void 0){if(gt.$$.count.value===0)return gt.$$.ptr=Ve,gt.$$.smartPtr=Ge,gt.clone();var Kt=gt.clone();return this.destructor(Ge),Kt}function k0(){return this.isSmartPointer?Gc(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:Ve,smartPtrType:this,smartPtr:Ge}):Gc(this.registeredClass.instancePrototype,{ptrType:this,ptr:Ge})}var z0=this.registeredClass.getActualType(Ve),K0=N2[z0];if(!K0)return k0.call(this);var C0;this.isConst?C0=K0.constPointerType:C0=K0.pointerType;var Rn=dc(Ve,this.registeredClass,C0.registeredClass);return Rn===null?k0.call(this):this.isSmartPointer?Gc(C0.registeredClass.instancePrototype,{ptrType:C0,ptr:Rn,smartPtrType:this,smartPtr:Ge}):Gc(C0.registeredClass.instancePrototype,{ptrType:C0,ptr:Rn})}function vc(Ge){return typeof FinalizationRegistry>"u"?(vc=Ve=>Ve,Ge):(rc=new FinalizationRegistry(Ve=>{uc(Ve.$$)}),vc=Ve=>{var gt=Ve.$$,Kt=!!gt.smartPtr;if(Kt){var k0={$$:gt};rc.register(Ve,k0,Ve)}return Ve},gl=Ve=>rc.unregister(Ve),vc(Ge))}function Ku(){if(this.$$.ptr||xc(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var Ge=vc(Object.create(Object.getPrototypeOf(this),{$$:{value:ec(this.$$)}}));return Ge.$$.count.value+=1,Ge.$$.deleteScheduled=!1,Ge}function $u(){this.$$.ptr||xc(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Nn("Object already scheduled for deletion"),gl(this),uc(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function Uo(){return!this.$$.ptr}function bc(){return this.$$.ptr||xc(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Nn("Object already scheduled for deletion"),Wo.push(this),Wo.length===1&&bo&&bo(Qo),this.$$.deleteScheduled=!0,this}function Go(){_o.prototype.isAliasOf=Uc,_o.prototype.clone=Ku,_o.prototype.delete=$u,_o.prototype.isDeleted=Uo,_o.prototype.deleteLater=bc}function _o(){}function Ma(Ge,Ve,gt){if(Ge[Ve].overloadTable===void 0){var Kt=Ge[Ve];Ge[Ve]=function(){return Ge[Ve].overloadTable.hasOwnProperty(arguments.length)||Nn("Function '"+gt+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+Ge[Ve].overloadTable+")!"),Ge[Ve].overloadTable[arguments.length].apply(this,arguments)},Ge[Ve].overloadTable=[],Ge[Ve].overloadTable[Kt.argCount]=Kt}}function Ju(Ge,Ve,gt){c.hasOwnProperty(Ge)?((gt===void 0||c[Ge].overloadTable!==void 0&&c[Ge].overloadTable[gt]!==void 0)&&Nn("Cannot register public name '"+Ge+"' twice"),Ma(c,Ge,Ge),c.hasOwnProperty(gt)&&Nn("Cannot register multiple overloads of a function with the same number of arguments ("+gt+")!"),c[Ge].overloadTable[gt]=Ve):(c[Ge]=Ve,gt!==void 0&&(c[Ge].numArguments=gt))}function Xc(Ge,Ve,gt,Kt,k0,z0,K0,C0){this.name=Ge,this.constructor=Ve,this.instancePrototype=gt,this.rawDestructor=Kt,this.baseClass=k0,this.getActualType=z0,this.upcast=K0,this.downcast=C0,this.pureVirtualFunctions=[]}function jc(Ge,Ve,gt){for(;Ve!==gt;)Ve.upcast||Nn("Expected null or instance of "+gt.name+", got an instance of "+Ve.name),Ge=Ve.upcast(Ge),Ve=Ve.baseClass;return Ge}function Wu(Ge,Ve){if(Ve===null)return this.isReference&&Nn("null is not a valid "+this.name),0;Ve.$$||Nn('Cannot pass "'+Kc(Ve)+'" as a '+this.name),Ve.$$.ptr||Nn("Cannot pass deleted object as a pointer of type "+this.name);var gt=Ve.$$.ptrType.registeredClass,Kt=jc(Ve.$$.ptr,gt,this.registeredClass);return Kt}function Qu(Ge,Ve){var gt;if(Ve===null)return this.isReference&&Nn("null is not a valid "+this.name),this.isSmartPointer?(gt=this.rawConstructor(),Ge!==null&&Ge.push(this.rawDestructor,gt),gt):0;Ve.$$||Nn('Cannot pass "'+Kc(Ve)+'" as a '+this.name),Ve.$$.ptr||Nn("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&Ve.$$.ptrType.isConst&&Nn("Cannot convert argument of type "+(Ve.$$.smartPtrType?Ve.$$.smartPtrType.name:Ve.$$.ptrType.name)+" to parameter type "+this.name);var Kt=Ve.$$.ptrType.registeredClass;if(gt=jc(Ve.$$.ptr,Kt,this.registeredClass),this.isSmartPointer)switch(Ve.$$.smartPtr===void 0&&Nn("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:Ve.$$.smartPtrType===this?gt=Ve.$$.smartPtr:Nn("Cannot convert argument of type "+(Ve.$$.smartPtrType?Ve.$$.smartPtrType.name:Ve.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:gt=Ve.$$.smartPtr;break;case 2:if(Ve.$$.smartPtrType===this)gt=Ve.$$.smartPtr;else{var k0=Ve.clone();gt=this.rawShare(gt,Xi.toHandle(function(){k0.delete()})),Ge!==null&&Ge.push(this.rawDestructor,gt)}break;default:Nn("Unsupporting sharing policy")}return gt}function eh(Ge,Ve){if(Ve===null)return this.isReference&&Nn("null is not a valid "+this.name),0;Ve.$$||Nn('Cannot pass "'+Kc(Ve)+'" as a '+this.name),Ve.$$.ptr||Nn("Cannot pass deleted object as a pointer of type "+this.name),Ve.$$.ptrType.isConst&&Nn("Cannot convert argument of type "+Ve.$$.ptrType.name+" to parameter type "+this.name);var gt=Ve.$$.ptrType.registeredClass,Kt=jc(Ve.$$.ptr,gt,this.registeredClass);return Kt}function _c(Ge){return this.fromWireType(Rt[Ge>>2])}function To(Ge){return this.rawGetPointee&&(Ge=this.rawGetPointee(Ge)),Ge}function _l(Ge){this.rawDestructor&&this.rawDestructor(Ge)}function _s(Ge){Ge!==null&&Ge.delete()}function e2(){Qs.prototype.getPointee=To,Qs.prototype.destructor=_l,Qs.prototype.argPackAdvance=8,Qs.prototype.readValueFromPointer=_c,Qs.prototype.deleteObject=_s,Qs.prototype.fromWireType=Vo}function Qs(Ge,Ve,gt,Kt,k0,z0,K0,C0,Rn,rx,$n){this.name=Ge,this.registeredClass=Ve,this.isReference=gt,this.isConst=Kt,this.isSmartPointer=k0,this.pointeeType=z0,this.sharingPolicy=K0,this.rawGetPointee=C0,this.rawConstructor=Rn,this.rawShare=rx,this.rawDestructor=$n,!k0&&Ve.baseClass===void 0?Kt?(this.toWireType=Wu,this.destructorFunction=null):(this.toWireType=eh,this.destructorFunction=null):this.toWireType=Qu}function Ps(Ge,Ve,gt){c.hasOwnProperty(Ge)||_r("Replacing nonexistant public symbol"),c[Ge].overloadTable!==void 0&&gt!==void 0?c[Ge].overloadTable[gt]=Ve:(c[Ge]=Ve,c[Ge].argCount=gt)}function P2(Ge,Ve,gt){var Kt=c["dynCall_"+Ge];return gt&&gt.length?Kt.apply(null,[Ve].concat(gt)):Kt.call(null,Ve)}function Ri(Ge,Ve,gt){return Ge.includes("j")?P2(Ge,Ve,gt):Wi(Ve).apply(null,gt)}function Gi(Ge,Ve){var gt=[];return function(){return gt.length=0,Object.assign(gt,arguments),Ri(Ge,Ve,gt)}}function ea(Ge,Ve){Ge=Ns(Ge);function gt(){return Ge.includes("j")?Gi(Ge,Ve):Wi(Ve)}var Kt=gt();return typeof Kt!="function"&&Nn("unknown function pointer with signature "+Ge+": "+Ve),Kt}var gi=void 0;function Tc(Ge){var Ve=Td(Ge),gt=Ns(Ve);return Ga(Ve),gt}function k2(Ge,Ve){var gt=[],Kt={};function k0(z0){if(!Kt[z0]&&!Pi[z0]){if(_a[z0]){_a[z0].forEach(k0);return}gt.push(z0),Kt[z0]=!0}}throw Ve.forEach(k0),new gi(Ge+": "+gt.map(Tc).join([", "]))}function x2(Ge,Ve,gt,Kt,k0,z0,K0,C0,Rn,rx,$n,jn,vx){$n=Ns($n),z0=ea(k0,z0),C0&&(C0=ea(K0,C0)),rx&&(rx=ea(Rn,rx)),vx=ea(jn,vx);var $r=Ba($n);Ju($r,function(){k2("Cannot construct "+$n+" due to unbound types",[Kt])}),Ui([Ge,Ve,gt],Kt?[Kt]:[],function(Mi){Mi=Mi[0];var ei,dr;Kt?(ei=Mi.registeredClass,dr=ei.instancePrototype):dr=_o.prototype;var $i=Aa($r,function(){if(Object.getPrototypeOf(this)!==gn)throw new Ws("Use 'new' to construct "+$n);if(Tx.constructor_body===void 0)throw new Ws($n+" has no accessible constructor");var Gx=Tx.constructor_body[arguments.length];if(Gx===void 0)throw new Ws("Tried to invoke ctor of "+$n+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(Tx.constructor_body).toString()+") parameters instead!");return Gx.apply(this,arguments)}),gn=Object.create(dr,{constructor:{value:$i}});$i.prototype=gn;var Tx=new Xc($n,$i,gn,vx,ei,z0,C0,rx),zi=new Qs($n,Tx,!0,!1,!1),us=new Qs($n+"*",Tx,!1,!1,!1),V2=new Qs($n+" const*",Tx,!1,!0,!1);return N2[Ge]={pointerType:us,constPointerType:V2},Ps($r,$i),[zi,us,V2]})}function Tl(Ge,Ve){for(var gt=[],Kt=0;Kt<Ge;Kt++)gt.push(X0[(Ve>>2)+Kt]);return gt}function ui(Ge){for(;Ge.length;){var Ve=Ge.pop(),gt=Ge.pop();gt(Ve)}}function Xo(Ge,Ve,gt,Kt,k0,z0){Te(Ve>0);var K0=Tl(Ve,gt);k0=ea(Kt,k0),Ui([],[Ge],function(C0){C0=C0[0];var Rn="constructor "+C0.name;if(C0.registeredClass.constructor_body===void 0&&(C0.registeredClass.constructor_body=[]),C0.registeredClass.constructor_body[Ve-1]!==void 0)throw new Ws("Cannot register multiple constructors with identical number of parameters ("+(Ve-1)+") for class '"+C0.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return C0.registeredClass.constructor_body[Ve-1]=()=>{k2("Cannot construct "+C0.name+" due to unbound types",K0)},Ui([],K0,function(rx){return rx.splice(1,0,null),C0.registeredClass.constructor_body[Ve-1]=za(Rn,rx,null,k0,z0),[]}),[]})}function za(Ge,Ve,gt,Kt,k0){var z0=Ve.length;z0<2&&Nn("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var K0=Ve[1]!==null&&gt!==null,C0=!1,Rn=1;Rn<Ve.length;++Rn)if(Ve[Rn]!==null&&Ve[Rn].destructorFunction===void 0){C0=!0;break}var rx=Ve[0].name!=="void",$n=z0-2,jn=new Array($n),vx=[],$r=[];return function(){arguments.length!==$n&&Nn("function "+Ge+" called with "+arguments.length+" arguments, expected "+$n+" args!"),$r.length=0;var Mi;vx.length=K0?2:1,vx[0]=k0,K0&&(Mi=Ve[1].toWireType($r,this),vx[1]=Mi);for(var ei=0;ei<$n;++ei)jn[ei]=Ve[ei+2].toWireType($r,arguments[ei]),vx.push(jn[ei]);var dr=Kt.apply(null,vx);function $i(gn){if(C0)ui($r);else for(var Tx=K0?1:2;Tx<Ve.length;Tx++){var zi=Tx===1?Mi:jn[Tx-2];Ve[Tx].destructorFunction!==null&&Ve[Tx].destructorFunction(zi)}if(rx)return Ve[0].fromWireType(gn)}return $i(dr)}}function Us(Ge,Ve,gt,Kt,k0,z0,K0,C0){var Rn=Tl(gt,Kt);Ve=Ns(Ve),z0=ea(k0,z0),Ui([],[Ge],function(rx){rx=rx[0];var $n=rx.name+"."+Ve;Ve.startsWith("@@")&&(Ve=Symbol[Ve.substring(2)]),C0&&rx.registeredClass.pureVirtualFunctions.push(Ve);function jn(){k2("Cannot call "+$n+" due to unbound types",Rn)}var vx=rx.registeredClass.instancePrototype,$r=vx[Ve];return $r===void 0||$r.overloadTable===void 0&&$r.className!==rx.name&&$r.argCount===gt-2?(jn.argCount=gt-2,jn.className=rx.name,vx[Ve]=jn):(Ma(vx,Ve,$n),vx[Ve].overloadTable[gt-2]=jn),Ui([],Rn,function(Mi){var ei=za($n,Mi,rx,z0,K0);return vx[Ve].overloadTable===void 0?(ei.argCount=gt-2,vx[Ve]=ei):vx[Ve].overloadTable[gt-2]=ei,[]}),[]})}function Va(Ge,Ve,gt){return Ge instanceof Object||Nn(gt+' with invalid "this": '+Ge),Ge instanceof Ve.registeredClass.constructor||Nn(gt+' incompatible with "this" of type '+Ge.constructor.name),Ge.$$.ptr||Nn("cannot call emscripten binding method "+gt+" on deleted object"),jc(Ge.$$.ptr,Ge.$$.ptrType.registeredClass,Ve.registeredClass)}function Ao(Ge,Ve,gt,Kt,k0,z0,K0,C0,Rn,rx){Ve=Ns(Ve),k0=ea(Kt,k0),Ui([],[Ge],function($n){$n=$n[0];var jn=$n.name+"."+Ve,vx={get:function(){k2("Cannot access "+jn+" due to unbound types",[gt,K0])},enumerable:!0,configurable:!0};return Rn?vx.set=()=>{k2("Cannot access "+jn+" due to unbound types",[gt,K0])}:vx.set=$r=>{Nn(jn+" is a read-only property")},Object.defineProperty($n.registeredClass.instancePrototype,Ve,vx),Ui([],Rn?[gt,K0]:[gt],function($r){var Mi=$r[0],ei={get:function(){var $i=Va(this,$n,jn+" getter");return Mi.fromWireType(k0(z0,$i))},enumerable:!0};if(Rn){Rn=ea(C0,Rn);var dr=$r[1];ei.set=function($i){var gn=Va(this,$n,jn+" setter"),Tx=[];Rn(rx,gn,dr.toWireType(Tx,$i)),ui(Tx)}}return Object.defineProperty($n.registeredClass.instancePrototype,Ve,ei),[]}),[]})}var Al=[],Gs=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Ac(Ge){Ge>4&&--Gs[Ge].refcount===0&&(Gs[Ge]=void 0,Al.push(Ge))}function r2(){for(var Ge=0,Ve=5;Ve<Gs.length;++Ve)Gs[Ve]!==void 0&&++Ge;return Ge}function jo(){for(var Ge=5;Ge<Gs.length;++Ge)if(Gs[Ge]!==void 0)return Gs[Ge];return null}function Ts(){c.count_emval_handles=r2,c.get_first_emval=jo}var Xi={toValue:Ge=>(Ge||Nn("Cannot use deleted val. handle = "+Ge),Gs[Ge].value),toHandle:Ge=>{switch(Ge){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var Ve=Al.length?Al.pop():Gs.length;return Gs[Ve]={refcount:1,value:Ge},Ve}}}};function eu(Ge,Ve){Ve=Ns(Ve),go(Ge,{name:Ve,fromWireType:function(gt){var Kt=Xi.toValue(gt);return Ac(gt),Kt},toWireType:function(gt,Kt){return Xi.toHandle(Kt)},argPackAdvance:8,readValueFromPointer:_c,destructorFunction:null})}function Kc(Ge){if(Ge===null)return"null";var Ve=typeof Ge;return Ve==="object"||Ve==="array"||Ve==="function"?Ge.toString():""+Ge}function u2(Ge,Ve){switch(Ve){case 2:return function(gt){return this.fromWireType(Qt[gt>>2])};case 3:return function(gt){return this.fromWireType(A0[gt>>3])};default:throw new TypeError("Unknown float type: "+Ge)}}function xh(Ge,Ve,gt){var Kt=R2(gt);Ve=Ns(Ve),go(Ge,{name:Ve,fromWireType:function(k0){return k0},toWireType:function(k0,z0){return z0},argPackAdvance:8,readValueFromPointer:u2(Ve,Kt),destructorFunction:null})}function xa(Ge,Ve,gt){switch(Ve){case 0:return gt?function(Kt){return $0[Kt]}:function(Kt){return Q0[Kt]};case 1:return gt?function(Kt){return Un[Kt>>1]}:function(Kt){return b0[Kt>>1]};case 2:return gt?function(Kt){return X0[Kt>>2]}:function(Kt){return Rt[Kt>>2]};default:throw new TypeError("Unknown integer type: "+Ge)}}function rh(Ge,Ve,gt,Kt,k0){Ve=Ns(Ve);var z0=R2(gt),K0=jn=>jn;if(Kt===0){var C0=32-8*gt;K0=jn=>jn<<C0>>>C0}var Rn=Ve.includes("unsigned"),rx=(jn,vx)=>{},$n;Rn?$n=function(jn,vx){return rx(vx,this.name),vx>>>0}:$n=function(jn,vx){return rx(vx,this.name),vx},go(Ge,{name:Ve,fromWireType:K0,toWireType:$n,argPackAdvance:8,readValueFromPointer:xa(Ve,z0,Kt!==0),destructorFunction:null})}function uh(Ge,Ve,gt){var Kt=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],k0=Kt[Ve];function z0(K0){K0=K0>>2;var C0=Rt,Rn=C0[K0],rx=C0[K0+1];return new k0(Ut,rx,Rn)}gt=Ns(gt),go(Ge,{name:gt,fromWireType:z0,argPackAdvance:8,readValueFromPointer:z0},{ignoreDuplicateRegistrations:!0})}function d2(Ge,Ve){Ve=Ns(Ve);var gt=Ve==="std::string";go(Ge,{name:Ve,fromWireType:function(Kt){var k0=Rt[Kt>>2],z0;if(gt)for(var K0=Kt+4,C0=0;C0<=k0;++C0){var Rn=Kt+4+C0;if(C0==k0||Q0[Rn]==0){var rx=Rn-K0,$n=Ce(K0,rx);z0===void 0?z0=$n:(z0+=String.fromCharCode(0),z0+=$n),K0=Rn+1}}else{for(var jn=new Array(k0),C0=0;C0<k0;++C0)jn[C0]=String.fromCharCode(Q0[Kt+4+C0]);z0=jn.join("")}return Ga(Kt),z0},toWireType:function(Kt,k0){k0 instanceof ArrayBuffer&&(k0=new Uint8Array(k0));var z0,K0=typeof k0=="string";K0||k0 instanceof Uint8Array||k0 instanceof Uint8ClampedArray||k0 instanceof Int8Array||Nn("Cannot pass non-string to std::string"),gt&&K0?z0=()=>Ne(k0):z0=()=>k0.length;var C0=z0(),Rn=Ja(4+C0+1);if(Rt[Rn>>2]=C0,gt&&K0)je(k0,Rn+4,C0+1);else if(K0)for(var rx=0;rx<C0;++rx){var $n=k0.charCodeAt(rx);$n>255&&(Ga(Rn),Nn("String has UTF-16 code units that do not fit in 8 bits")),Q0[Rn+4+rx]=$n}else for(var rx=0;rx<C0;++rx)Q0[Rn+4+rx]=k0[rx];return Kt!==null&&Kt.push(Ga,Rn),Rn},argPackAdvance:8,readValueFromPointer:_c,destructorFunction:function(Kt){Ga(Kt)}})}function B2(Ge,Ve,gt){gt=Ns(gt);var Kt,k0,z0,K0,C0;Ve===2?(Kt=Ct,k0=dt,K0=Xt,z0=()=>b0,C0=1):Ve===4&&(Kt=Gt,k0=Vt,K0=T0,z0=()=>Rt,C0=2),go(Ge,{name:gt,fromWireType:function(Rn){for(var rx=Rt[Rn>>2],$n=z0(),jn,vx=Rn+4,$r=0;$r<=rx;++$r){var Mi=Rn+4+$r*Ve;if($r==rx||$n[Mi>>C0]==0){var ei=Mi-vx,dr=Kt(vx,ei);jn===void 0?jn=dr:(jn+=String.fromCharCode(0),jn+=dr),vx=Mi+Ve}}return Ga(Rn),jn},toWireType:function(Rn,rx){typeof rx!="string"&&Nn("Cannot pass non-string to C++ string type "+gt);var $n=K0(rx),jn=Ja(4+$n+Ve);return Rt[jn>>2]=$n>>C0,k0(rx,jn+4,$n+Ve),Rn!==null&&Rn.push(Ga,jn),jn},argPackAdvance:8,readValueFromPointer:_c,destructorFunction:function(Rn){Ga(Rn)}})}function dh(Ge,Ve){Ve=Ns(Ve),go(Ge,{isVoid:!0,name:Ve,argPackAdvance:0,fromWireType:function(){},toWireType:function(gt,Kt){}})}function xu(Ge){delete We.xhrs[Ge-1]}function ru(Ge,Ve){var gt=Pi[Ge];return gt===void 0&&Nn(Ve+" has unknown type "+Tc(Ge)),gt}function uu(Ge,Ve,gt){Ge=Xi.toValue(Ge),Ve=ru(Ve,"emval::as");var Kt=[],k0=Xi.toHandle(Kt);return X0[gt>>2]=k0,Ve.toWireType(Kt,Ge)}var du={};function $c(Ge){var Ve=du[Ge];return Ve===void 0?Ns(Ge):Ve}function Jc(){if(typeof globalThis=="object")return globalThis;function Ge(Ve){Ve.$$$embind_global$$$=Ve;var gt=typeof $$$embind_global$$$=="object"&&Ve.$$$embind_global$$$==Ve;return gt||delete Ve.$$$embind_global$$$,gt}if(typeof $$$embind_global$$$=="object"||(typeof __webpack_require__.g=="object"&&Ge(__webpack_require__.g)?$$$embind_global$$$=__webpack_require__.g:typeof self=="object"&&Ge(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")}function Ua(Ge){return Ge===0?Xi.toHandle(Jc()):(Ge=$c(Ge),Xi.toHandle(Jc()[Ge]))}function z2(Ge,Ve){return Ge=Xi.toValue(Ge),Ve=Xi.toValue(Ve),Xi.toHandle(Ge[Ve])}function Ml(Ge){Ge>4&&(Gs[Ge].refcount+=1)}function Cl(Ge){return Xi.toHandle($c(Ge))}function ra(Ge){var Ve=Xi.toValue(Ge);ui(Ve),Ac(Ge)}function g2(Ge,Ve){Ge=ru(Ge,"_emval_take_value");var gt=Ge.readValueFromPointer(Ve);return Xi.toHandle(gt)}function et(){io("")}function Je(){return!O}function Nt(Ge,Ve,gt){Q0.copyWithin(Ge,Ve,Ve+gt)}function _0(){return 2147483648}function Ue(Ge){try{return ee.grow(Ge-Ut.byteLength+65535>>>16),J0(ee.buffer),1}catch{}}function ze(Ge){var Ve=Q0.length;Ge=Ge>>>0;var gt=_0();if(Ge>gt)return!1;let Kt=(Rn,rx)=>Rn+(rx-Rn%rx)%rx;for(var k0=1;k0<=4;k0*=2){var z0=Ve*(1+.2/k0);z0=Math.min(z0,Ge+100663296);var K0=Math.min(gt,Kt(Math.max(Ge,z0),65536)),C0=Ue(K0);if(C0)return!0}return!1}var We={xhrs:[],setu64:function(Ge,Ve){Rt[Ge>>2]=Ve,Rt[Ge+4>>2]=Ve/4294967296|0},openDatabase:function(Ge,Ve,gt,Kt){try{var k0=indexedDB.open(Ge,Ve)}catch(z0){return Kt(z0)}k0.onupgradeneeded=z0=>{var K0=z0.target.result;K0.objectStoreNames.contains("FILES")&&K0.deleteObjectStore("FILES"),K0.createObjectStore("FILES")},k0.onsuccess=z0=>gt(z0.target.result),k0.onerror=z0=>Kt(z0)},staticInit:function(){var Ge=gt=>{We.dbInstance=gt,xn()},Ve=()=>{We.dbInstance=!1,xn()};We.openDatabase("emscripten_filesystem",1,Ge,Ve),(typeof ENVIRONMENT_IS_FETCH_WORKER>"u"||!ENVIRONMENT_IS_FETCH_WORKER)&&ja()}};function _t(Ge,Ve,gt,Kt,k0){var z0=Rt[Ge+8>>2];if(!z0){gt(Ge,0,"no url specified!");return}var K0=Ce(z0),C0=Ge+112,Rn=Ce(C0);Rn||(Rn="GET"),Rt[Ge+4>>2];var rx=Rt[C0+52>>2],$n=Rt[C0+56>>2],jn=!!Rt[C0+60>>2];Rt[C0+64>>2];var vx=Rt[C0+68>>2],$r=Rt[C0+72>>2],Mi=Rt[C0+76>>2],ei=Rt[C0+80>>2],dr=Rt[C0+84>>2],$i=Rt[C0+88>>2],gn=!!(rx&1),Tx=!!(rx&2),zi=!!(rx&64),us=vx?Ce(vx):void 0,V2=$r?Ce($r):void 0,Gx=new XMLHttpRequest;if(Gx.withCredentials=jn,Gx.open(Rn,K0,!zi,us,V2),zi||(Gx.timeout=$n),Gx.url_=K0,Gx.responseType="arraybuffer",ei){var js=Ce(ei);Gx.overrideMimeType(js)}if(Mi)for(;;){var Cc=Rt[Mi>>2];if(!Cc)break;var Wc=Rt[Mi+4>>2];if(!Wc)break;Mi+=8;var Wp=Ce(Cc),Qp=Ce(Wc);Gx.setRequestHeader(Wp,Qp)}We.xhrs.push(Gx);var gu=We.xhrs.length;Rt[Ge+0>>2]=gu;var em=dr&&$i?Q0.slice(dr,dr+$i):null;function Qf(Ca){var v2=0,U2=0;Ca&&(U2=Gx.response?Gx.response.byteLength:0,v2=Ja(U2),Q0.set(new Uint8Array(Gx.response),v2)),Rt[Ge+12>>2]=v2,We.setu64(Ge+16,U2)}Gx.onload=Ca=>{Qf(gn&&!Tx);var v2=Gx.response?Gx.response.byteLength:0;We.setu64(Ge+24,0),v2&&We.setu64(Ge+32,v2),b0[Ge+40>>1]=Gx.readyState,b0[Ge+42>>1]=Gx.status,Gx.statusText&&je(Gx.statusText,Ge+44,64),Gx.status>=200&&Gx.status<300?Ve&&Ve(Ge,Gx,Ca):gt&&gt(Ge,Gx,Ca)},Gx.onerror=Ca=>{Qf(gn);var v2=Gx.status;We.setu64(Ge+24,0),We.setu64(Ge+32,Gx.response?Gx.response.byteLength:0),b0[Ge+40>>1]=Gx.readyState,b0[Ge+42>>1]=v2,gt&&gt(Ge,Gx,Ca)},Gx.ontimeout=Ca=>{gt&&gt(Ge,Gx,Ca)},Gx.onprogress=Ca=>{var v2=gn&&Tx&&Gx.response?Gx.response.byteLength:0,U2=0;gn&&Tx&&(U2=Ja(v2),Q0.set(new Uint8Array(Gx.response),U2)),Rt[Ge+12>>2]=U2,We.setu64(Ge+16,v2),We.setu64(Ge+24,Ca.loaded-v2),We.setu64(Ge+32,Ca.total),b0[Ge+40>>1]=Gx.readyState,Gx.readyState>=3&&Gx.status===0&&Ca.loaded>0&&(Gx.status=200),b0[Ge+42>>1]=Gx.status,Gx.statusText&&je(Gx.statusText,Ge+44,64),Kt&&Kt(Ge,Gx,Ca),U2&&Ga(U2)},Gx.onreadystatechange=Ca=>{b0[Ge+40>>1]=Gx.readyState,Gx.readyState>=2&&(b0[Ge+42>>1]=Gx.status),k0&&k0(Ge,Gx,Ca)};try{Gx.send(em)}catch(Ca){gt&&gt(Ge,Gx,Ca)}}function jt(Ge,Ve){if(!re){if(Ve){Ge();return}try{Ge()}catch(gt){$a(gt)}}}function e0(Ge,Ve,gt,Kt,k0){if(!Ge){k0(Ve,0,"IndexedDB not available!");return}var z0=Ve+112,K0=Rt[z0+64>>2];K0||(K0=Rt[Ve+8>>2]);var C0=Ce(K0);try{var Rn=Ge.transaction(["FILES"],"readwrite"),rx=Rn.objectStore("FILES"),$n=rx.put(gt,C0);$n.onsuccess=jn=>{b0[Ve+40>>1]=4,b0[Ve+42>>1]=200,je("OK",Ve+44,64),Kt(Ve,0,C0)},$n.onerror=jn=>{b0[Ve+40>>1]=4,b0[Ve+42>>1]=413,je("Payload Too Large",Ve+44,64),k0(Ve,0,jn)}}catch(jn){k0(Ve,0,jn)}}function u0(Ge,Ve,gt,Kt){if(!Ge){Kt(Ve,0,"IndexedDB not available!");return}var k0=Ve+112,z0=Rt[k0+64>>2];z0||(z0=Rt[Ve+8>>2]);var K0=Ce(z0);try{var C0=Ge.transaction(["FILES"],"readonly"),Rn=C0.objectStore("FILES"),rx=Rn.get(K0);rx.onsuccess=$n=>{if($n.target.result){var jn=$n.target.result,vx=jn.byteLength||jn.length,$r=Ja(vx);Q0.set(new Uint8Array(jn),$r),Rt[Ve+12>>2]=$r,We.setu64(Ve+16,vx),We.setu64(Ve+24,0),We.setu64(Ve+32,vx),b0[Ve+40>>1]=4,b0[Ve+42>>1]=200,je("OK",Ve+44,64),gt(Ve,0,jn)}else b0[Ve+40>>1]=4,b0[Ve+42>>1]=404,je("Not Found",Ve+44,64),Kt(Ve,0,"no data")},rx.onerror=$n=>{b0[Ve+40>>1]=4,b0[Ve+42>>1]=404,je("Not Found",Ve+44,64),Kt(Ve,0,$n)}}catch($n){Kt(Ve,0,$n)}}function Jt(Ge,Ve,gt,Kt){if(!Ge){Kt(Ve,0,"IndexedDB not available!");return}var k0=Ve+112,z0=Rt[k0+64>>2];z0||(z0=Rt[Ve+8>>2]);var K0=Ce(z0);try{var C0=Ge.transaction(["FILES"],"readwrite"),Rn=C0.objectStore("FILES"),rx=Rn.delete(K0);rx.onsuccess=$n=>{var jn=$n.target.result;Rt[Ve+12>>2]=0,We.setu64(Ve+16,0),We.setu64(Ve+24,0),We.setu64(Ve+32,0),b0[Ve+40>>1]=4,b0[Ve+42>>1]=200,je("OK",Ve+44,64),gt(Ve,0,jn)},rx.onerror=$n=>{b0[Ve+40>>1]=4,b0[Ve+42>>1]=404,je("Not Found",Ve+44,64),Kt(Ve,0,$n)}}catch($n){Kt(Ve,0,$n)}}function B0(Ge,Ve,gt,Kt,k0){var z0=Ge+112,K0=Ce(z0),C0=Rt[z0+36>>2],Rn=Rt[z0+40>>2],rx=Rt[z0+44>>2],$n=Rt[z0+48>>2],jn=Rt[z0+52>>2],vx=!!(jn&4),$r=!!(jn&32),Mi=!!(jn&16),ei=!!(jn&64),dr=(js,Cc,Wc)=>{jt(()=>{C0?Wi(C0)(js):Ve&&Ve(js)},ei)},$i=(js,Cc,Wc)=>{jt(()=>{rx?Wi(rx)(js):Kt&&Kt(js)},ei)},gn=(js,Cc,Wc)=>{jt(()=>{Rn?Wi(Rn)(js):gt&&gt(js)},ei)},Tx=(js,Cc,Wc)=>{jt(()=>{$n?Wi($n)(js):k0&&k0(js)},ei)},zi=(js,Cc,Wc)=>{_t(js,dr,gn,$i,Tx)},us=(js,Cc,Wc)=>{var Wp=(gu,em,Qf)=>{jt(()=>{C0?Wi(C0)(gu):Ve&&Ve(gu)},ei)},Qp=(gu,em,Qf)=>{jt(()=>{C0?Wi(C0)(gu):Ve&&Ve(gu)},ei)};e0(We.dbInstance,js,Cc.response,Wp,Qp)},V2=(js,Cc,Wc)=>{_t(js,us,gn,$i,Tx)};if(K0==="EM_IDB_STORE"){var Gx=Rt[z0+84>>2];e0(We.dbInstance,Ge,Q0.slice(Gx,Gx+Rt[z0+88>>2]),dr,gn)}else if(K0==="EM_IDB_DELETE")Jt(We.dbInstance,Ge,dr,gn);else if(!Mi)u0(We.dbInstance,Ge,dr,$r?gn:vx?V2:zi);else if(!$r)_t(Ge,vx?us:dr,gn,$i,Tx);else return 0;return Ge}var dn={};function zn(){return b||"./this.program"}function Jn(){if(!Jn.strings){var Ge=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",Ve={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:Ge,_:zn()};for(var gt in dn)dn[gt]===void 0?delete Ve[gt]:Ve[gt]=dn[gt];var Kt=[];for(var gt in Ve)Kt.push(gt+"="+Ve[gt]);Jn.strings=Kt}return Jn.strings}function Wx(Ge,Ve){var gt=0;return Jn().forEach(function(Kt,k0){var z0=Ve+gt;Rt[Ge+k0*4>>2]=z0,d0(Kt,z0),gt+=Kt.length+1}),0}function br(Ge,Ve){var gt=Jn();Rt[Ge>>2]=gt.length;var Kt=0;return gt.forEach(function(k0){Kt+=k0.length+1}),Rt[Ve>>2]=Kt,0}function Qr(Ge){return Ge%4===0&&(Ge%100!==0||Ge%400===0)}function gr(Ge,Ve){for(var gt=0,Kt=0;Kt<=Ve;gt+=Ge[Kt++]);return gt}var Qi=[31,29,31,30,31,30,31,31,30,31,30,31],es=[31,28,31,30,31,30,31,31,30,31,30,31];function Xs(Ge,Ve){for(var gt=new Date(Ge.getTime());Ve>0;){var Kt=Qr(gt.getFullYear()),k0=gt.getMonth(),z0=(Kt?Qi:es)[k0];if(Ve>z0-gt.getDate())Ve-=z0-gt.getDate()+1,gt.setDate(1),k0<11?gt.setMonth(k0+1):(gt.setMonth(0),gt.setFullYear(gt.getFullYear()+1));else return gt.setDate(gt.getDate()+Ve),gt}return gt}function ji(Ge,Ve,gt,Kt){var k0=X0[Kt+40>>2],z0={tm_sec:X0[Kt>>2],tm_min:X0[Kt+4>>2],tm_hour:X0[Kt+8>>2],tm_mday:X0[Kt+12>>2],tm_mon:X0[Kt+16>>2],tm_year:X0[Kt+20>>2],tm_wday:X0[Kt+24>>2],tm_yday:X0[Kt+28>>2],tm_isdst:X0[Kt+32>>2],tm_gmtoff:X0[Kt+36>>2],tm_zone:k0?Ce(k0):""},K0=Ce(gt),C0={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var Rn in C0)K0=K0.replace(new RegExp(Rn,"g"),C0[Rn]);var rx=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],$n=["January","February","March","April","May","June","July","August","September","October","November","December"];function jn(gn,Tx,zi){for(var us=typeof gn=="number"?gn.toString():gn||"";us.length<Tx;)us=zi[0]+us;return us}function vx(gn,Tx){return jn(gn,Tx,"0")}function $r(gn,Tx){function zi(V2){return V2<0?-1:V2>0?1:0}var us;return(us=zi(gn.getFullYear()-Tx.getFullYear()))===0&&(us=zi(gn.getMonth()-Tx.getMonth()))===0&&(us=zi(gn.getDate()-Tx.getDate())),us}function Mi(gn){switch(gn.getDay()){case 0:return new Date(gn.getFullYear()-1,11,29);case 1:return gn;case 2:return new Date(gn.getFullYear(),0,3);case 3:return new Date(gn.getFullYear(),0,2);case 4:return new Date(gn.getFullYear(),0,1);case 5:return new Date(gn.getFullYear()-1,11,31);case 6:return new Date(gn.getFullYear()-1,11,30)}}function ei(gn){var Tx=Xs(new Date(gn.tm_year+1900,0,1),gn.tm_yday),zi=new Date(Tx.getFullYear(),0,4),us=new Date(Tx.getFullYear()+1,0,4),V2=Mi(zi),Gx=Mi(us);return $r(V2,Tx)<=0?$r(Gx,Tx)<=0?Tx.getFullYear()+1:Tx.getFullYear():Tx.getFullYear()-1}var dr={"%a":function(gn){return rx[gn.tm_wday].substring(0,3)},"%A":function(gn){return rx[gn.tm_wday]},"%b":function(gn){return $n[gn.tm_mon].substring(0,3)},"%B":function(gn){return $n[gn.tm_mon]},"%C":function(gn){var Tx=gn.tm_year+1900;return vx(Tx/100|0,2)},"%d":function(gn){return vx(gn.tm_mday,2)},"%e":function(gn){return jn(gn.tm_mday,2," ")},"%g":function(gn){return ei(gn).toString().substring(2)},"%G":function(gn){return ei(gn)},"%H":function(gn){return vx(gn.tm_hour,2)},"%I":function(gn){var Tx=gn.tm_hour;return Tx==0?Tx=12:Tx>12&&(Tx-=12),vx(Tx,2)},"%j":function(gn){return vx(gn.tm_mday+gr(Qr(gn.tm_year+1900)?Qi:es,gn.tm_mon-1),3)},"%m":function(gn){return vx(gn.tm_mon+1,2)},"%M":function(gn){return vx(gn.tm_min,2)},"%n":function(){return`
`},"%p":function(gn){return gn.tm_hour>=0&&gn.tm_hour<12?"AM":"PM"},"%S":function(gn){return vx(gn.tm_sec,2)},"%t":function(){return"	"},"%u":function(gn){return gn.tm_wday||7},"%U":function(gn){var Tx=gn.tm_yday+7-gn.tm_wday;return vx(Math.floor(Tx/7),2)},"%V":function(gn){var Tx=Math.floor((gn.tm_yday+7-(gn.tm_wday+6)%7)/7);if((gn.tm_wday+371-gn.tm_yday-2)%7<=2&&Tx++,Tx){if(Tx==53){var zi=(gn.tm_wday+371-gn.tm_yday)%7;zi!=4&&(zi!=3||!Qr(gn.tm_year))&&(Tx=1)}}else{Tx=52;var us=(gn.tm_wday+7-gn.tm_yday-1)%7;(us==4||us==5&&Qr(gn.tm_year%400-1))&&Tx++}return vx(Tx,2)},"%w":function(gn){return gn.tm_wday},"%W":function(gn){var Tx=gn.tm_yday+7-(gn.tm_wday+6)%7;return vx(Math.floor(Tx/7),2)},"%y":function(gn){return(gn.tm_year+1900).toString().substring(2)},"%Y":function(gn){return gn.tm_year+1900},"%z":function(gn){var Tx=gn.tm_gmtoff,zi=Tx>=0;return Tx=Math.abs(Tx)/60,Tx=Tx/60*100+Tx%60,(zi?"+":"-")+("0000"+Tx).slice(-4)},"%Z":function(gn){return gn.tm_zone},"%%":function(){return"%"}};K0=K0.replace(/%%/g,"\0\0");for(var Rn in dr)K0.includes(Rn)&&(K0=K0.replace(new RegExp(Rn,"g"),dr[Rn](z0)));K0=K0.replace(/\0\0/g,"%");var $i=bd(K0,!1);return $i.length>Ve?0:(r0($i,Ge),$i.length-1)}function gh(Ge,Ve,gt,Kt){return ji(Ge,Ve,gt,Kt)}ul(),Ws=c.BindingError=Bi(Error,"BindingError"),bs=c.InternalError=Bi(Error,"InternalError"),Go(),gc(),e2(),gi=c.UnboundTypeError=Bi(Error,"UnboundTypeError"),Ts(),We.staticInit();function bd(Ge,Ve,gt){var Kt=gt>0?gt:Ne(Ge)+1,k0=new Array(Kt),z0=Pe(Ge,k0,0,k0.length);return Ve&&(k0.length=z0),k0}var _d={b:Rs,d:vd,u:Gu,B:dl,m:x2,g:Xo,e:Us,q:Ao,A:eu,t:xh,f:rh,a:uh,s:d2,n:B2,C:dh,D:xu,h:uu,c:Ac,p:Ua,i:z2,o:Ml,l:Cl,k:ra,j:g2,r:et,F:Je,z:Nt,y:ze,E:B0,w:Wx,x:br,v:gh};Ql(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.H).apply(null,arguments)};var Ja=c._malloc=function(){return(Ja=c._malloc=c.asm.I).apply(null,arguments)},Ga=c._free=function(){return(Ga=c._free=c.asm.K).apply(null,arguments)},Td=c.___getTypeName=function(){return(Td=c.___getTypeName=c.asm.L).apply(null,arguments)};c.___embind_register_native_and_builtin_types=function(){return(c.___embind_register_native_and_builtin_types=c.asm.M).apply(null,arguments)};var Rl=c.___cxa_is_pointer_type=function(){return(Rl=c.___cxa_is_pointer_type=c.asm.N).apply(null,arguments)};c.dynCall_viijii=function(){return(c.dynCall_viijii=c.asm.O).apply(null,arguments)},c.dynCall_iiiiij=function(){return(c.dynCall_iiiiij=c.asm.P).apply(null,arguments)},c.dynCall_iiiiijj=function(){return(c.dynCall_iiiiijj=c.asm.Q).apply(null,arguments)},c.dynCall_iiiiiijj=function(){return(c.dynCall_iiiiiijj=c.asm.R).apply(null,arguments)};var Mc;function Ad(Ge){this.name="ExitStatus",this.message="Program terminated with exit("+Ge+")",this.status=Ge}rr=function Ge(){Mc||vh(),Mc||(rr=Ge)};function vh(Ge){if(Nr>0||(gx(),Nr>0))return;function Ve(){Mc||(Mc=!0,c.calledRun=!0,!re&&(Jx(),p(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),er()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),Ve()},1)):Ve()}if(c.run=vh,c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();return vh(),a.ready}})();const Le=Hn();Le.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,u=>{u&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var LB;(function(u){u[u.DT_INVALID=0]="DT_INVALID",u[u.DT_FLOAT=1]="DT_FLOAT",u[u.DT_DOUBLE=2]="DT_DOUBLE",u[u.DT_INT32=3]="DT_INT32",u[u.DT_UINT8=4]="DT_UINT8",u[u.DT_INT16=5]="DT_INT16",u[u.DT_INT8=6]="DT_INT8",u[u.DT_STRING=7]="DT_STRING",u[u.DT_COMPLEX64=8]="DT_COMPLEX64",u[u.DT_INT64=9]="DT_INT64",u[u.DT_BOOL=10]="DT_BOOL",u[u.DT_QINT8=11]="DT_QINT8",u[u.DT_QUINT8=12]="DT_QUINT8",u[u.DT_QINT32=13]="DT_QINT32",u[u.DT_BFLOAT16=14]="DT_BFLOAT16",u[u.DT_QINT16=15]="DT_QINT16",u[u.DT_QUINT16=16]="DT_QUINT16",u[u.DT_UINT16=17]="DT_UINT16",u[u.DT_COMPLEX128=18]="DT_COMPLEX128",u[u.DT_HALF=19]="DT_HALF",u[u.DT_RESOURCE=20]="DT_RESOURCE",u[u.DT_VARIANT=21]="DT_VARIANT",u[u.DT_UINT32=22]="DT_UINT32",u[u.DT_UINT64=23]="DT_UINT64",u[u.DT_FLOAT_REF=101]="DT_FLOAT_REF",u[u.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",u[u.DT_INT32_REF=103]="DT_INT32_REF",u[u.DT_UINT8_REF=104]="DT_UINT8_REF",u[u.DT_INT16_REF=105]="DT_INT16_REF",u[u.DT_INT8_REF=106]="DT_INT8_REF",u[u.DT_STRING_REF=107]="DT_STRING_REF",u[u.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",u[u.DT_INT64_REF=109]="DT_INT64_REF",u[u.DT_BOOL_REF=110]="DT_BOOL_REF",u[u.DT_QINT8_REF=111]="DT_QINT8_REF",u[u.DT_QUINT8_REF=112]="DT_QUINT8_REF",u[u.DT_QINT32_REF=113]="DT_QINT32_REF",u[u.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",u[u.DT_QINT16_REF=115]="DT_QINT16_REF",u[u.DT_QUINT16_REF=116]="DT_QUINT16_REF",u[u.DT_UINT16_REF=117]="DT_UINT16_REF",u[u.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",u[u.DT_HALF_REF=119]="DT_HALF_REF",u[u.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",u[u.DT_VARIANT_REF=121]="DT_VARIANT_REF",u[u.DT_UINT32_REF=122]="DT_UINT32_REF",u[u.DT_UINT64_REF=123]="DT_UINT64_REF"})(LB||(LB={}));var LN;(function(u){(function(a){a[a.LEGACY=0]="LEGACY",a[a.V1=1]="V1",a[a.V2=2]="V2"})(u.CheckpointFormatVersion||(u.CheckpointFormatVersion={}))})(LN||(LN={}));const q0={};function q1(u){return q0[u]}function q2(u,a,c,p,m){const v=a.inputParams[u];if(v&&v.inputIndexStart!==void 0){const w=v.inputIndexStart,S=v.inputIndexEnd===0?void 0:v.inputIndexEnd===void 0?w+1:v.inputIndexEnd,O=w<0?a.inputNames.length+w:w;if(v.type==="tensor")return q3(a.inputNames[O],c,p,m);if(v.type==="tensors"){const j=a.inputs.slice(w,S);return a.inputNames.slice(w,S).filter(($,J)=>{var ee;return((ee=j[J])===null||ee===void 0?void 0:ee.op)!=="NoOp"}).map($=>q3($,c,p,m))}const q=q3(a.inputNames[O],c,p,m),H=q.dataSync();return v.type==="number"?H[0]:Ha(q.shape,H)}const b=a.attrParams[u];return b&&b.value}function q3(u,a,c,p){const[m,v]=q7(u,c);if(p!=null){const w=p.getHashTableHandleByName(m);if(w!=null)return w}const b=c.currentContextIds.find(w=>!!a[q6(m,w)]);return b!==void 0?a[q6(m,b)][v]:void 0}function q4(u,a,c){return a[q6(u,c.currentContextId)]}function q5(u,a){const[c,p,m]=q7(u,a);return[q6(c,a&&a.currentContextId),p,m]}function q6(u,a){return a?u+"-"+a:u}function q7(u,a){if(u==="")return["",0,void 0];const c=a!=null&&a.parseNodeNameCache!=null;if(c){const v=a.parseNodeNameCache.get(u);if(v!=null)return v}const p=u.split(":");let m;if(p.length===1)m=[u,0,void 0];else{const v=p[0],b=p.length===3?p[1]:void 0,w=Number(p[p.length-1]);m=[v,w,b]}return c&&a.parseNodeNameCache.set(u,m),m}function q8(u,a,c){let p=q2("pad",u,a,c);if(p==="explicit"){p=q2("explicitPaddings",u,a,c);const m=[[0,0],[0,0],[0,0],[0,0]];for(let v=0;v<4;v++)m[v][0]=p[v*2],m[v][1]=p[v*2+1];return m}return p}function q9(u){return u.kept?u:EN(u)}const qH=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var qD=Object.freeze({__proto__:null,json:qH});const qy=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var qa=Object.freeze({__proto__:null,json:qy});const qs=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var qI=Object.freeze({__proto__:null,json:qs});const qE=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var qf=Object.freeze({__proto__:null,json:qE});const qO=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var qc=Object.freeze({__proto__:null,json:qO});const qZ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var qL=Object.freeze({__proto__:null,json:qZ});const qq=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var qF=Object.freeze({__proto__:null,json:qq});const qY=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var qo=Object.freeze({__proto__:null,json:qY});const qn=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var qp=Object.freeze({__proto__:null,json:qn});const qS=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var ql=Object.freeze({__proto__:null,json:qS});const qh=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var qi=Object.freeze({__proto__:null,json:qh});const qm=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var qt=Object.freeze({__proto__:null,json:qm});const qk=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var qw=Object.freeze({__proto__:null,json:qk});const qU=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var qG=Object.freeze({__proto__:null,json:qU});const qz=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var qW=Object.freeze({__proto__:null,json:qz});const qR=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var qj=Object.freeze({__proto__:null,json:qR});const qA=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var qC=Object.freeze({__proto__:null,json:qA});const qu=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var qQ=Object.freeze({__proto__:null,json:qu});const qJ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var qx=Object.freeze({__proto__:null,json:qJ});class qM{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const a=[qD,qa,qI,qf,qc,qL,qF,qo,qp,ql,qi,qt,qw,qG,qW,qj,qC,qQ,qx],c=[].concat(...a.map(p=>p.json));this.opMappers=c.reduce((p,m)=>(p[m.tfOpName]=m,p),{})}transformGraph(a,c={}){const p=a.node,m=[],v=[],b=[],w=p.reduce((ee,re)=>(ee[re.name]=this.mapNode(re),re.op.startsWith("Placeholder")?m.push(ee[re.name]):re.op==="Const"?v.push(ee[re.name]):(re.input==null||re.input.length===0)&&b.push(ee[re.name]),ee),{});let S=[];const O=[];let q={},H={};c!=null&&(q=this.mapSignatureEntries(c.inputs),H=this.mapSignatureEntries(c.outputs));const j=Object.keys(w);j.forEach(ee=>{const re=w[ee];re.inputNames.forEach((de,Te)=>{const[Me,,Ae]=q5(de),Ce=w[Me];if(Ce.outputs!=null){const Pe=Ce.outputs.indexOf(Ae);if(Pe!==-1){const je=Me+":"+Pe;re.inputNames[Te]=je}}re.inputs.push(Ce),Ce.children.push(re)})}),Object.keys(H).length===0?j.forEach(ee=>{const re=w[ee];re.children.length===0&&O.push(re)}):Object.keys(H).forEach(ee=>{const[re]=q5(ee),de=w[re];de!=null&&(de.signatureKey=H[ee],O.push(de))}),Object.keys(q).length>0?Object.keys(q).forEach(ee=>{const[re]=q5(ee),de=w[re];de&&(de.signatureKey=q[ee],S.push(de))}):S=m;let $={};a.library!=null&&a.library.function!=null&&($=a.library.function.reduce((ee,re)=>(ee[re.signature.name]=this.mapFunction(re),ee),{}));const J={nodes:w,inputs:S,outputs:O,weights:v,placeholders:m,signature:c,functions:$};return b.length>0&&(J.initNodes=b),J}mapSignatureEntries(a){return Object.keys(a||{}).reduce((c,p)=>(c[a[p].name]=p,c),{})}mapNode(a){const c=q1(a.op)||this.opMappers[a.op]||{};a.attr==null&&(a.attr={});const p={name:a.name,op:a.op,category:c.category,inputNames:(a.input||[]).map(m=>m.startsWith("^")?m.slice(1):m),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:a.attr,outputs:c.outputs};return c.inputs!=null&&(p.inputParams=c.inputs.reduce((m,v)=>(m[v.name]={type:v.type,inputIndexStart:v.start,inputIndexEnd:v.end},m),{})),c.attrs!=null&&(p.attrParams=c.attrs.reduce((m,v)=>{const b=v.type;let w;switch(v.type){case"string":w=qK(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qK(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"string[]":w=qN(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qN(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"number":w=qV(a.attr,v.tfName,v.defaultValue||0),w===void 0&&v.tfDeprecatedName&&(w=qV(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"number[]":w=qB(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qB(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"bool":w=qb(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qb(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"bool[]":w=F1(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=F1(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"shape":w=qe(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qe(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"shape[]":w=F0(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=F0(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"dtype":w=qv(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qv(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"dtype[]":w=qT(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qT(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"func":w=qP(a.attr,v.tfName,v.defaultValue),w===void 0&&v.tfDeprecatedName&&(w=qP(a.attr,v.tfDeprecatedName,v.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+v.type+" for op: "+a.op)}return m[v.name]={value:w,type:b},m},{})),p}mapFunction(a){const c=a.nodeDef,p=[],m=[];let v={};c!=null&&(v=c.reduce((q,H)=>(q[H.name]=this.mapNode(H),H.op==="Const"&&m.push(q[H.name]),q),{}));const b=[],w=[];a.signature.inputArg.forEach(q=>{const[H]=q5(q.name),j={name:H,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:qd(q.type),type:"dtype"}},children:[]};j.signatureKey=q.name,b.push(j),v[H]=j}),Object.keys(v).forEach(q=>{const H=v[q];H.inputNames.forEach((j,$)=>{const[J,,ee]=q5(j),re=v[J];if(re.outputs!=null){const de=re.outputs.indexOf(ee);if(de!==-1){const Te=J+":"+de;H.inputNames[$]=Te}}H.inputs.push(re),re.children.push(H)})});const S=a.ret;a.signature.outputArg.forEach(q=>{const[H,j]=q5(S[q.name]),$=v[H];$!=null&&($.defaultOutput=j,w.push($))});const O=this.mapArgsToSignature(a);return{nodes:v,inputs:b,outputs:w,weights:m,placeholders:p,signature:O}}mapArgsToSignature(a){return{methodName:a.signature.name,inputs:a.signature.inputArg.reduce((c,p)=>(c[p.name]=this.mapArgToTensorInfo(p),c),{}),outputs:a.signature.outputArg.reduce((c,p)=>(c[p.name]=this.mapArgToTensorInfo(p,a.ret),c),{})}}mapArgToTensorInfo(a,c){let p=a.name;return c!=null&&(p=c[p]),{name:p,dtype:a.type}}}function qX(u){const a=Hn().global;if(typeof a.atob<"u")return a.atob(u);if(typeof Buffer<"u")return new Buffer(u,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function qg(u,a){const c=Array.isArray(u)?String.fromCharCode.apply(null,u):qX(u);return a?c:c.toLowerCase()}function qK(u,a,c,p=!1){const m=u[a];return m!=null?qg(m.s,p):c}function qb(u,a,c){const p=u[a];return p?p.b:c}function qV(u,a,c){const p=u[a]||{},m=p.i!=null?p.i:p.f!=null?p.f:c;return typeof m=="number"?m:parseInt(m,10)}function qd(u){switch(typeof u=="string"&&(u=LB[u]),u){case LB.DT_FLOAT:case LB.DT_HALF:return"float32";case LB.DT_INT32:case LB.DT_INT64:case LB.DT_INT8:case LB.DT_UINT8:return"int32";case LB.DT_BOOL:return"bool";case LB.DT_DOUBLE:return"float32";case LB.DT_STRING:return"string";case LB.DT_COMPLEX64:case LB.DT_COMPLEX128:return"complex64";default:return null}}function qP(u,a,c){const p=u[a];return p&&p.func?p.func.name:c}function qv(u,a,c){const p=u[a];return p&&p.type?qd(p.type):c}function qT(u,a,c){const p=u[a];return p&&p.list&&p.list.type?p.list.type.map(m=>qd(m)):c}function qr(u){if(!u.unknownRank)return u.dim!=null?u.dim.map(a=>typeof a.size=="number"?a.size:parseInt(a.size,10)):[]}function qe(u,a,c){const p=u[a];return p&&p.shape?qr(p.shape):c}function qB(u,a,c){const p=u[a];return p?((p.list.f&&p.list.f.length?p.list.f:p.list.i)||[]).map(m=>typeof m=="number"?m:parseInt(m,10)):c}function qN(u,a,c,p=!1){const m=u[a];return m&&m.list&&m.list.s?m.list.s.map(v=>qg(v,p)):c}function F0(u,a,c){const p=u[a];return p&&p.list&&p.list.shape?p.list.shape.map(m=>qr(m)):c}function F1(u,a,c){const p=u[a];return p&&p.list&&p.list.b?p.list.b:c}class F2{constructor(a,c,p){this.node=a,this.tensorMap=c,this.context=p,this.inputs=[],this.attrs={},this.inputs=a.inputNames.map(m=>this.getInput(m)),a.rawAttrs!=null&&(this.attrs=Object.keys(a.rawAttrs).reduce((m,v)=>(m[v]=this.getAttr(v),m),{}))}getInput(a){return q3(a,this.tensorMap,this.context)}getAttr(a,c){const p=this.node.rawAttrs[a];if(p.tensor!=null)return q3(a,this.tensorMap,this.context);if(p.i!=null||p.f!=null)return qV(this.node.rawAttrs,a,c);if(p.s!=null)return qK(this.node.rawAttrs,a,c);if(p.b!=null)return qb(this.node.rawAttrs,a,c);if(p.shape!=null)return qe(this.node.rawAttrs,a,c);if(p.type!=null)return qv(this.node.rawAttrs,a,c);if(p.list!=null){if(p.list.i!=null||p.list.f!=null)return qB(this.node.rawAttrs,a,c);if(p.list.s!=null)return qN(this.node.rawAttrs,a,c);if(p.list.shape!=null)return F0(this.node.rawAttrs,a,c);if(p.list.b!=null)return F1(this.node.rawAttrs,a,c);if(p.list.type!=null)return qT(this.node.rawAttrs,a,c)}return c}}const F3={conv2d:cR,depthwiseConv2d:cJ,matMul:cM},F4={resizeBilinear:Zq};var F5=Object.freeze({__proto__:null,add:EY,addN:Ek,atan2:EU,cast:IA,concat:f1,conv2d:fL,cos:fo,depthToSpace:fp,depthwiseConv2d:fl,expandDims:O3,fill:fa,floor:O7,fused:F3,gather:O9,greaterEqual:Oa,image:F4,lessEqual:Oc,logicalAnd:OY,matMul:Iu,max:fx,maxPool:OS,maximum:Oh,mean:Om,min:fX,minimum:Ow,mul:Eh,neg:IM,pad:OG,prelu:OQ,range:c6,relu:c8,relu6:cH,reshape:ET,scalar:fb,sigmoid:f3,sin:cs,squeeze:cZ,stack:cq,stridedSlice:cn,sub:Oq,tensor1d:cp,tile:O5,transpose:Ib,zerosLike:ft});const F6=(u,a,c,p=F5)=>{switch(u.op){case"BiasAdd":case"AddV2":case"Add":return[p.add(q2("a",u,a,c),q2("b",u,a,c))];case"AddN":return[p.addN(q2("tensors",u,a,c))];case"FloorMod":case"Mod":return[p.mod(q2("a",u,a,c),q2("b",u,a,c))];case"Mul":return[p.mul(q2("a",u,a,c),q2("b",u,a,c))];case"RealDiv":case"Div":return[p.div(q2("a",u,a,c),q2("b",u,a,c))];case"DivNoNan":return[p.divNoNan(q2("a",u,a,c),q2("b",u,a,c))];case"FloorDiv":return[p.floorDiv(q2("a",u,a,c),q2("b",u,a,c))];case"Sub":return[p.sub(q2("a",u,a,c),q2("b",u,a,c))];case"Minimum":return[p.minimum(q2("a",u,a,c),q2("b",u,a,c))];case"Maximum":return[p.maximum(q2("a",u,a,c),q2("b",u,a,c))];case"Pow":return[p.pow(q2("a",u,a,c),q2("b",u,a,c))];case"SquaredDifference":return[p.squaredDifference(q2("a",u,a,c),q2("b",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},F7=(u,a,c,p=F5)=>{switch(u.op){case"Abs":case"ComplexAbs":return[p.abs(q2("x",u,a,c))];case"Acos":return[p.acos(q2("x",u,a,c))];case"Acosh":return[p.acosh(q2("x",u,a,c))];case"Asin":return[p.asin(q2("x",u,a,c))];case"Asinh":return[p.asinh(q2("x",u,a,c))];case"Atan":return[p.atan(q2("x",u,a,c))];case"Atan2":return[p.atan2(q2("x",u,a,c),q2("y",u,a,c))];case"Atanh":return[p.atanh(q2("x",u,a,c))];case"Ceil":return[p.ceil(q2("x",u,a,c))];case"Complex":return[p.complex(q2("real",u,a,c),q2("imag",u,a,c))];case"Cos":return[p.cos(q2("x",u,a,c))];case"Cosh":return[p.cosh(q2("x",u,a,c))];case"Elu":return[p.elu(q2("x",u,a,c))];case"Erf":return[p.erf(q2("x",u,a,c))];case"Exp":return[p.exp(q2("x",u,a,c))];case"Expm1":return[p.expm1(q2("x",u,a,c))];case"Floor":return[p.floor(q2("x",u,a,c))];case"Log":return[p.log(q2("x",u,a,c))];case"Log1p":return[p.log1p(q2("x",u,a,c))];case"Imag":return[p.imag(q2("x",u,a,c))];case"Neg":return[p.neg(q2("x",u,a,c))];case"Reciprocal":return[p.reciprocal(q2("x",u,a,c))];case"Real":return[p.real(q2("x",u,a,c))];case"Relu":return[p.relu(q2("x",u,a,c))];case"Round":return[p.round(q2("x",u,a,c))];case"Selu":return[p.selu(q2("x",u,a,c))];case"Sigmoid":return[p.sigmoid(q2("x",u,a,c))];case"Sin":return[p.sin(q2("x",u,a,c))];case"Sign":return[p.sign(q2("x",u,a,c))];case"Sinh":return[p.sinh(q2("x",u,a,c))];case"Softplus":return[p.softplus(q2("x",u,a,c))];case"Sqrt":return[p.sqrt(q2("x",u,a,c))];case"Square":return[p.square(q2("x",u,a,c))];case"Tanh":return[p.tanh(q2("x",u,a,c))];case"Tan":return[p.tan(q2("x",u,a,c))];case"ClipByValue":return[p.clipByValue(q2("x",u,a,c),q2("clipValueMin",u,a,c),q2("clipValueMax",u,a,c))];case"Relu6":return[p.relu6(q2("x",u,a,c))];case"Rsqrt":return[p.rsqrt(q3(u.inputNames[0],a,c))];case"LeakyRelu":return[p.leakyRelu(q2("x",u,a,c),q2("alpha",u,a,c))];case"Prelu":return[p.prelu(q2("x",u,a,c),q2("alpha",u,a,c))];case"IsNan":return[p.isNaN(q3(u.inputNames[0],a,c))];case"IsInf":return[p.isInf(q3(u.inputNames[0],a,c))];case"IsFinite":return[p.isFinite(q3(u.inputNames[0],a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}};function F8(u,a,c=""){if(!(typeof u=="number"||typeof a=="number")){i(u.length===a.length,()=>c+(" Shapes "+u+" and "+a+" must match"));for(let p=0;p<u.length;p++){const m=u[p],v=a[p];i(m<0||v<0||m===v,()=>c+(" Shapes "+u+" and "+a+" must match"))}}}function F9(u){return!(typeof u=="number"||u.some(a=>a<0))}function FH(u,a,c){let p=FD(u,c);const m=!F9(p);if(m&&a.length===0)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+p);if(m&&a.forEach(v=>{p=FD(v.shape,p)}),!F9(p))throw new Error("Non-fully-defined elementShape: "+p);return p}function FD(u,a){if(typeof u=="number")return a;if(typeof a=="number")return u;if(u.length!==a.length)throw new Error("Incompatible ranks during merge: "+u+" vs. "+a);const c=[];for(let p=0;p<u.length;++p){const m=u[p],v=a[p];if(m>=0&&v>=0&&m!==v)throw new Error("Incompatible shape during merge: "+u+" vs. "+a);c[p]=m>=0?m:v}return c}class Fy{constructor(a,c,p,m,v,b,w){this.name=a,this.dtype=c,this.maxSize=p,this.elementShape=m,this.identicalElementShapes=v,this.dynamicSize=b,this.clearAfterRead=w,this.tensors=[],this.closed_=!1,this.idTensor=fb(0),s4(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(a){this.tensors.forEach(c=>{(a==null||!a.has(c.tensor.id))&&c.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(a){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(a<0||a>=this.size())throw new Error("Tried to read from index "+a+", but array size is: "+this.size());const c=this.tensors[a];if(c.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+a+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(c.cleared=!0),c.read=!0,c.tensor}readMany(a){return a.map(c=>this.read(c))}write(a,c){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(a<0||!this.dynamicSize&&a>=this.maxSize)throw new Error("Tried to write to index "+a+", but array is not resizeable and size is: "+this.maxSize);const p=this.tensors[a]||{};if(c.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+a+`,
          because the value dtype is `+c.dtype+", but TensorArray dtype is "+this.dtype+".");if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=c.shape),F8(this.elementShape,c.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+a+"."),p.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+a+", because it has already been read.");if(p.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+a+", because it has already been written.");p.tensor=c,s4(c),p.written=!0,this.tensors[a]=p}writeMany(a,c){if(a.length!==c.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+a.length+" is not the same as tensors size: "+c.length+".");a.forEach((p,m)=>this.write(p,c[m]))}gather(a,c){if(c&&c!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+c);if(a)a=a.slice(0,this.size());else{a=[];for(let m=0;m<this.size();m++)a.push(m)}if(a.length===0)return ar([],[0].concat(this.elementShape));const p=this.readMany(a);return F8(this.elementShape,p[0].shape,"TensorArray shape mismatch: "),cq(p,0)}concat(a){if(a&&a!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+a);if(this.size()===0)return ar([],[0].concat(this.elementShape));const c=[];for(let m=0;m<this.size();m++)c.push(m);const p=this.readMany(c);return F8(this.elementShape,p[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+p[0].shape+")"),f1(p,0)}scatter(a,c){if(c.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+c.dtype);if(a.length!==c.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+a.length+" vs. "+c.shape[0]);const p=Math.max(...a);if(!this.dynamicSize&&p>=this.maxSize)throw new Error("Max index must be < array size ("+p+"  vs. "+this.maxSize+")");this.writeMany(a,ci(c,0))}split(a,c){if(c.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+c.dtype);let p=0;const m=a.map(S=>(p+=S,p));if(p!==c.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+p+", and tensor's shape is: "+c.shape);if(!this.dynamicSize&&a.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+a.length+"), and the TensorArray is not marked as dynamically resizeable");const v=p===0?0:c.size/p,b=[];s2(()=>{c=ET(c,[1,p,v]);for(let S=0;S<a.length;++S){const O=[0,S===0?0:m[S-1],0],q=[1,a[S],v];b[S]=ET(f5(c,O,q),this.elementShape)}return b});const w=[];for(let S=0;S<a.length;S++)w[S]=S;this.writeMany(w,b)}}class Fa{get id(){return this.idTensor.id}constructor(a,c,p,m=-1){this.tensors=a,this.elementShape=c,this.elementDtype=p,a?.forEach(v=>{if(p!==v.dtype)throw new Error("Invalid data types; op elements "+p+", but list elements "+v.dtype);F8(c,v.shape,"TensorList shape mismatch: "),s4(v)}),this.idTensor=fb(0),this.maxNumElements=m,s4(this.idTensor)}copy(){return new Fa([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(a){this.tensors.forEach(c=>{(a==null||!a.has(c.id))&&c.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(a,c,p=-1){if(c!==this.elementDtype)throw new Error("Invalid data types; op elements "+c+", but list elements "+this.elementDtype);if(p!==-1&&this.tensors.length!==p)throw new Error("Operation expected a list with "+p+" elements but got a list with "+this.tensors.length+" elements.");F8(a,this.elementShape,"TensorList shape mismatch: ");const m=FH(this.elementShape,this.tensors,a);return s2(()=>{const v=this.tensors.map(b=>ET(b,m));return cq(v,0)})}popBack(a,c){if(c!==this.elementDtype)throw new Error("Invalid data types; op elements "+c+", but list elements "+this.elementDtype);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const p=FH(this.elementShape,this.tensors,a),m=this.tensors.pop();return m.kept=!1,F8(m.shape,a,"TensorList shape mismatch: "),ET(m,p)}pushBack(a){if(a.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+a.dtype+", but list elements "+this.elementDtype);if(F8(a.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");s4(a),this.tensors.push(a)}resize(a){if(a<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+a);if(this.maxNumElements!==-1&&a>this.maxNumElements)throw new Error("TensorListResize input size "+a+" is greater maxNumElement "+this.maxNumElements+".");const c=new Fa([],this.elementShape,this.elementDtype,this.maxNumElements);c.tensors.length=a;for(let p=0;p<Math.min(this.tensors.length,a);++p)c.tensors[p]=this.tensors[p];return c}getItem(a,c,p){if(p!==this.elementDtype)throw new Error("Invalid data types; op elements "+p+", but list elements "+this.elementDtype);if(a<0||a>this.tensors.length)throw new Error("Trying to access element "+a+" in a list with "+this.tensors.length+" elements.");if(this.tensors[a]==null)throw new Error("element at index "+a+" is null.");F8(this.tensors[a].shape,c,"TensorList shape mismatch: ");const m=FH(this.elementShape,this.tensors,c);return ET(this.tensors[a],m)}setItem(a,c){if(c.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+c.dtype+", but list elements "+this.elementDtype);if(a<0||this.maxNumElements!==-1&&a>=this.maxNumElements)throw new Error("Trying to set element "+a+" in a list with max "+this.maxNumElements+" elements.");F8(this.elementShape,c.shape,"TensorList shape mismatch: "),s4(c),this.tensors[a]!=null&&(this.tensors[a].kept=!1),this.tensors[a]=c}gather(a,c,p){if(c!==this.elementDtype)throw new Error("Invalid data types; op elements "+c+", but list elements "+this.elementDtype);F8(this.elementShape,p,"TensorList shape mismatch: "),a=a.slice(0,this.size());const m=FH(this.elementShape,this.tensors,p);return a.length===0?ar([],[0].concat(m)):s2(()=>{const v=a.map(b=>ET(this.tensors[b],m));return cq(v,0)})}concat(a,c){if(a&&a!==this.elementDtype)throw new Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+a);F8(this.elementShape,c,"TensorList shape mismatch: ");const p=FH(this.elementShape,this.tensors,c);return this.size()===0?ar([],[0].concat(p)):s2(()=>{const m=this.tensors.map(v=>ET(v,p));return f1(m,0)})}}function Fs(u,a,c){const p=u.dtype;if(u.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+u.shape);if(u.dtype!==c)throw new Error("Invalid data types; op elements "+u.dtype+", but list elements "+c);const m=u.shape.slice(1);F8(m,a,"TensorList shape mismatch: ");const v=ci(u);return new Fa(v,a,p)}function FI(u,a,c,p){return new Fa([],u,a,p)}function FE(u,a,c,p){if(a.length!==u.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+a.length+" vs. "+u.shape[0]);const m=Math.max(...a);if(p!=null&&p!==-1&&m>=p)throw new Error("Max index must be < array size ("+m+"  vs. "+p+")");const v=new Fa([],c,u.dtype,p),b=ci(u,0);return a.forEach((w,S)=>{v.setItem(w,b[S])}),v}function Ff(u,a,c){let p=0;const m=a.map(q=>(p+=q,p));if(p!==u.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+p+", and tensor's shape is: "+u.shape);const v=u.shape.slice(1),b=FD(v,c),w=p===0?0:u.size/p,S=s2(()=>{const q=[];u=ET(u,[1,p,w]);for(let H=0;H<a.length;++H){const j=[0,H===0?0:m[H-1],0],$=[1,a[H],w];q[H]=ET(f5(u,j,$),b)}return u.dispose(),q}),O=new Fa([],c,u.dtype,a.length);for(let q=0;q<S.length;q++)O.setItem(q,S[q]);return O}const FO=async(u,a,c)=>{switch(u.op){case"If":case"StatelessIf":{const p=q2("thenBranch",u,a,c),m=q2("elseBranch",u,a,c),v=q2("cond",u,a,c),b=q2("args",u,a,c);return(await v.data())[0]?c.functionMap[p].executeFunctionAsync(b,c.tensorArrayMap,c.tensorListMap):c.functionMap[m].executeFunctionAsync(b,c.tensorArrayMap,c.tensorListMap)}case"While":case"StatelessWhile":{const p=q2("body",u,a,c),m=q2("cond",u,a,c),v=q2("args",u,a,c),b=await c.functionMap[m].executeFunctionAsync(v,c.tensorArrayMap,c.tensorListMap),w=v.map(q=>q.id);let S=await b[0].data();b.forEach(q=>{!q.kept&&w.indexOf(q.id)===-1&&q.dispose()});let O=v;for(;S[0];){const q=O;O=await c.functionMap[p].executeFunctionAsync(O,c.tensorArrayMap,c.tensorListMap);const H=O.map($=>$.id);q.forEach($=>{!$.kept&&w.indexOf($.id)===-1&&H.indexOf($.id)===-1&&$.dispose()});const j=await c.functionMap[m].executeFunctionAsync(O,c.tensorArrayMap,c.tensorListMap);S=await j[0].data(),j.forEach($=>{!$.kept&&w.indexOf($.id)===-1&&H.indexOf($.id)===-1&&$.dispose()})}return O}case"LoopCond":{const p=q2("pred",u,a,c);return[q9(p)]}case"Switch":{const p=q2("pred",u,a,c);let m=q2("data",u,a,c);return m.kept||(m=q9(m)),(await p.data())[0]?[void 0,m]:[m,void 0]}case"Merge":{const p=u.inputNames.find(m=>q3(m,a,c)!==void 0);if(p){const m=q3(p,a,c);return[q9(m)]}return}case"Enter":{const p=q2("frameName",u,a,c),m=q2("tensor",u,a,c);return c.enterFrame(p),[q9(m)]}case"Exit":{const p=q2("tensor",u,a,c);return c.exitFrame(),[q9(p)]}case"NextIteration":{const p=q2("tensor",u,a,c);return c.nextIteration(),[q9(p)]}case"TensorArrayV3":{const p=q2("size",u,a,c),m=q2("dtype",u,a,c),v=q2("elementShape",u,a,c),b=q2("dynamicSize",u,a,c),w=q2("clearAfterRead",u,a,c),S=q2("identicalElementShapes",u,a,c),O=q2("name",u,a,c),q=new Fy(O,m,p,v,S,b,w);return c.addTensorArray(q),[q.idTensor,fb(1)]}case"TensorArrayWriteV3":{const p=q2("tensorArrayId",u,a,c),m=q2("index",u,a,c),v=q2("tensor",u,a,c),b=c.getTensorArray(p.id);return b.write(m,v),[b.idTensor]}case"TensorArrayReadV3":{const p=q2("tensorArrayId",u,a,c),m=q2("index",u,a,c);return[c.getTensorArray(p.id).read(m)]}case"TensorArrayGatherV3":{const p=q2("tensorArrayId",u,a,c),m=q2("indices",u,a,c),v=q2("dtype",u,a,c);return[c.getTensorArray(p.id).gather(m,v)]}case"TensorArrayScatterV3":{const p=q2("tensorArrayId",u,a,c),m=q2("indices",u,a,c),v=q2("tensor",u,a,c),b=c.getTensorArray(p.id);return b.scatter(m,v),[b.idTensor]}case"TensorArrayConcatV3":{const p=q2("tensorArrayId",u,a,c),m=c.getTensorArray(p.id),v=q2("dtype",u,a,c);return[m.concat(v)]}case"TensorArraySplitV3":{const p=q2("tensorArrayId",u,a,c),m=q2("tensor",u,a,c),v=q2("lengths",u,a,c),b=c.getTensorArray(p.id);return b.split(v,m),[b.idTensor]}case"TensorArraySizeV3":{const p=q2("tensorArrayId",u,a,c),m=c.getTensorArray(p.id);return[fb(m.size(),"int32")]}case"TensorArrayCloseV3":{const p=q2("tensorArrayId",u,a,c),m=c.getTensorArray(p.id);return m.clearAndClose(),[m.idTensor]}case"TensorListSetItem":{const p=q2("tensorListId",u,a,c),m=q2("index",u,a,c),v=q2("tensor",u,a,c),b=c.getTensorList(p.id);return b.setItem(m,v),[b.idTensor]}case"TensorListGetItem":{const p=q2("tensorListId",u,a,c),m=q2("index",u,a,c),v=q2("elementShape",u,a,c),b=q2("elementDType",u,a,c);return[c.getTensorList(p.id).getItem(m,v,b)]}case"TensorListScatterV2":case"TensorListScatter":{const p=q2("indices",u,a,c),m=q2("tensor",u,a,c),v=q2("elementShape",u,a,c),b=q2("numElements",u,a,c),w=FE(m,p,v,b);return c.addTensorList(w),[w.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const p=q2("elementShape",u,a,c),m=q2("elementDType",u,a,c);let v;u.op==="TensorListReserve"?v="numElements":v="maxNumElements";const b=q2(v,u,a,c),w=u.op==="TensorListReserve"?-1:b,S=FI(p,m,b,w);return c.addTensorList(S),[S.idTensor]}case"TensorListGather":{const p=q2("tensorListId",u,a,c),m=q2("indices",u,a,c),v=q2("elementShape",u,a,c),b=q2("elementDType",u,a,c);return[c.getTensorList(p.id).gather(m,b,v)]}case"TensorListStack":{const p=q2("tensorListId",u,a,c),m=q2("elementShape",u,a,c),v=q2("elementDType",u,a,c),b=q2("numElements",u,a,c);return[c.getTensorList(p.id).stack(m,v,b)]}case"TensorListFromTensor":{const p=q2("tensor",u,a,c),m=q2("elementShape",u,a,c),v=q2("elementDType",u,a,c),b=Fs(p,m,v);return c.addTensorList(b),[b.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const p=q2("tensorListId",u,a,c),m=c.getTensorList(p.id),v=q2("dtype",u,a,c),b=q2("elementShape",u,a,c);return[m.concat(v,b)]}case"TensorListPushBack":{const p=q2("tensorListId",u,a,c),m=q2("tensor",u,a,c),v=c.getTensorList(p.id);return v.pushBack(m),[v.idTensor]}case"TensorListPopBack":{const p=q2("tensorListId",u,a,c),m=q2("elementShape",u,a,c),v=q2("elementDType",u,a,c);return[c.getTensorList(p.id).popBack(m,v)]}case"TensorListSplit":{const p=q2("tensor",u,a,c),m=q2("elementShape",u,a,c),v=q2("lengths",u,a,c),b=Ff(p,v,m);return c.addTensorList(b),[b.idTensor]}case"TensorListLength":{const p=q2("tensorListId",u,a,c),m=c.getTensorList(p.id);return[fb(m.size(),"int32")]}case"TensorListResize":{const p=q2("tensorListId",u,a,c),m=q2("size",u,a,c),v=c.getTensorList(p.id).resize(m);return c.addTensorList(v),[v.idTensor]}default:throw TypeError("Node type "+u.op+" is not implemented")}};function Fc(u,a,c){const[p,m]=q2("fusedOps",u,a,c),v=p==="biasadd",b=!v,w=m==="prelu",S=p==="fusedbatchnorm",O=q2("numArgs",u,a,c);if(v){if(w&&O!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!w&&v&&O!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(S)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const q=q2("strides",u,a,c),H=q8(u,a,c),j=q2("dataFormat",u,a,c).toUpperCase(),$=q2("dilations",u,a,c);let[J,ee]=q2("args",u,a,c);b&&(ee=J,J=void 0);const re=q2("leakyreluAlpha",u,a,c);return{stride:q,pad:H,dataFormat:j,dilations:$,biasArg:J,preluArg:ee,activationFunc:m,leakyreluAlpha:re}}const FZ=(u,a,c,p=F5)=>{switch(u.op){case"Conv1D":{const m=q2("stride",u,a,c),v=q2("pad",u,a,c),b=q2("dataFormat",u,a,c).toUpperCase(),w=q2("dilation",u,a,c);return[p.conv1d(q2("x",u,a,c),q2("filter",u,a,c),m,v,b,w)]}case"Conv2D":{const m=q2("strides",u,a,c),v=q8(u,a,c),b=q2("dataFormat",u,a,c).toUpperCase(),w=q2("dilations",u,a,c);return[p.conv2d(q2("x",u,a,c),q2("filter",u,a,c),[m[1],m[2]],v,b,[w[1],w[2]])]}case"_FusedConv2D":{const{stride:m,pad:v,dataFormat:b,dilations:w,biasArg:S,preluArg:O,activationFunc:q,leakyreluAlpha:H}=Fc(u,a,c),j=u.name.endsWith("batch_normalization_88/FusedBatchNormV3")||u.name.endsWith("batch_normalization_90/FusedBatchNormV3")?Hn().get("WEBGL_USE_SHAPES_UNIFORMS"):void 0;j&&Hn().set("WEBGL_USE_SHAPES_UNIFORMS",!1);const $=[p.fused.conv2d({x:q2("x",u,a,c),filter:q2("filter",u,a,c),strides:[m[1],m[2]],pad:v,dataFormat:b,dilations:[w[1],w[2]],bias:S,activation:q,preluActivationWeights:O,leakyreluAlpha:H})];return j&&Hn().set("WEBGL_USE_SHAPES_UNIFORMS",!0),$}case"FusedDepthwiseConv2dNative":{const{stride:m,pad:v,dataFormat:b,dilations:w,biasArg:S,preluArg:O,activationFunc:q,leakyreluAlpha:H}=Fc(u,a,c);return[p.fused.depthwiseConv2d({x:q2("x",u,a,c),filter:q2("filter",u,a,c),strides:[m[1],m[2]],pad:v,dataFormat:b,dilations:[w[1],w[2]],bias:S,activation:q,preluActivationWeights:O,leakyreluAlpha:H})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const m=q2("outputShape",u,a,c),v=q2("strides",u,a,c),b=q8(u,a,c);return[p.conv2dTranspose(q2("x",u,a,c),q2("filter",u,a,c),m,[v[1],v[2]],b)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const m=q2("strides",u,a,c),v=q8(u,a,c),b=q2("dilations",u,a,c),w=q2("dataFormat",u,a,c).toUpperCase();return[p.depthwiseConv2d(q2("input",u,a,c),q2("filter",u,a,c),[m[1],m[2]],v,w,[b[1],b[2]])]}case"Conv3D":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("dataFormat",u,a,c).toUpperCase(),w=q2("dilations",u,a,c);return[p.conv3d(q2("x",u,a,c),q2("filter",u,a,c),[m[1],m[2],m[3]],v,b,[w[1],w[2],w[3]])]}case"AvgPool":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("kernelSize",u,a,c);return[p.avgPool(q2("x",u,a,c),[b[1],b[2]],[m[1],m[2]],v)]}case"MaxPool":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("kernelSize",u,a,c);return[p.maxPool(q2("x",u,a,c),[b[1],b[2]],[m[1],m[2]],v)]}case"MaxPoolWithArgmax":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("kernelSize",u,a,c),w=q2("includeBatchInIndex",u,a,c),{result:S,indexes:O}=p.maxPoolWithArgmax(q2("x",u,a,c),[b[1],b[2]],[m[1],m[2]],v,w);return[S,O]}case"AvgPool3D":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("kernelSize",u,a,c);return[p.avgPool3d(q2("x",u,a,c),[b[1],b[2],b[3]],[m[1],m[2],m[3]],v)]}case"MaxPool3D":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("kernelSize",u,a,c);return[p.maxPool3d(q2("x",u,a,c),[b[1],b[2],b[3]],[m[1],m[2],m[3]],v)]}case"Dilation2D":{const m=q2("strides",u,a,c),v=q2("pad",u,a,c),b=q2("dilations",u,a,c),w=m[1],S=m[2],O=b[1],q=b[2];return[p.dilation2d(q2("x",u,a,c),q2("filter",u,a,c),[w,S],v,[O,q],"NHWC")]}default:throw TypeError("Node type "+u.op+" is not implemented")}},FL=(u,a,c,p=F5)=>{switch(u.op){case"Fill":{const m=q2("shape",u,a,c),v=q2("dtype",u,a,c),b=q2("value",u,a,c);return[p.fill(m,b,v)]}case"LinSpace":{const m=q2("start",u,a,c),v=q2("stop",u,a,c),b=q2("num",u,a,c);return[p.linspace(m,v,b)]}case"Multinomial":{const m=q2("logits",u,a,c),v=q2("numSamples",u,a,c),b=q2("seed",u,a,c);return[p.multinomial(m,v,b)]}case"OneHot":{const m=q2("indices",u,a,c),v=q2("depth",u,a,c),b=q2("onValue",u,a,c),w=q2("offValue",u,a,c),S=q2("dtype",u,a,c);return[p.oneHot(m,v,b,w,S)]}case"Ones":return[p.ones(q2("shape",u,a,c),q2("dtype",u,a,c))];case"OnesLike":return[p.onesLike(q2("x",u,a,c))];case"RandomStandardNormal":return[p.randomStandardNormal(q2("shape",u,a,c),q2("dtype",u,a,c),q2("seed",u,a,c))];case"RandomUniform":return[p.randomUniform(q2("shape",u,a,c),q2("minval",u,a,c),q2("maxval",u,a,c),q2("dtype",u,a,c))];case"RandomUniformInt":return[p.randomUniformInt(q2("shape",u,a,c),q2("minval",u,a,c),q2("maxval",u,a,c),q2("seed",u,a,c))];case"Range":{const m=q2("start",u,a,c),v=q2("stop",u,a,c),b=q2("step",u,a,c);return[p.range(m,v,b,q2("dtype",u,a,c))]}case"TruncatedNormal":{const m=q2("shape",u,a,c),v=q2("mean",u,a,c),b=q2("stdDev",u,a,c),w=q2("seed",u,a,c);return[p.truncatedNormal(m,v,b,q2("dtype",u,a,c),w)]}case"Zeros":return[p.zeros(q2("shape",u,a,c),q2("dtype",u,a,c))];case"ZerosLike":return[p.zerosLike(q2("x",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}};function Fq(u,a,c){const p=q2("boxes",u,a,c),m=q2("scores",u,a,c),v=q2("maxOutputSize",u,a,c),b=q2("iouThreshold",u,a,c),w=q2("scoreThreshold",u,a,c),S=q2("softNmsSigma",u,a,c);return{boxes:p,scores:m,maxOutputSize:v,iouThreshold:b,scoreThreshold:w,softNmsSigma:S}}const FF=async(u,a,c,p,m=F5)=>{switch(u.op){case"NonMaxSuppressionV5":{const{boxes:v,scores:b,maxOutputSize:w,iouThreshold:S,scoreThreshold:O,softNmsSigma:q}=Fq(u,a,c),H=await m.image.nonMaxSuppressionWithScoreAsync(v,b,w,S,O,q);return[H.selectedIndices,H.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:v,scores:b,maxOutputSize:w,iouThreshold:S,scoreThreshold:O}=Fq(u,a,c),q=q2("padToMaxOutputSize",u,a,c),H=await m.image.nonMaxSuppressionPaddedAsync(v,b,w,S,O,q);return[H.selectedIndices,H.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:v,scores:b,maxOutputSize:w,iouThreshold:S,scoreThreshold:O}=Fq(u,a,c);return[await m.image.nonMaxSuppressionAsync(v,b,w,S,O)]}case"Where":{const v=m.cast(q2("condition",u,a,c),"bool"),b=[await m.whereAsync(v)];return v.dispose(),b}case"ListDiff":return m.setdiff1dAsync(q2("x",u,a,c),q2("y",u,a,c));default:throw TypeError("Node type "+u.op+" is not implemented")}},FY=(u,a,c,p=F5)=>{switch(u.op){case"LowerBound":{const m=q2("sortedSequence",u,a,c),v=q2("values",u,a,c);return[p.lowerBound(m,v)]}case"TopKV2":{const m=q2("x",u,a,c),v=q2("k",u,a,c),b=q2("sorted",u,a,c),w=p.topk(m,v,b);return[w.values,w.indices]}case"UpperBound":{const m=q2("sortedSequence",u,a,c),v=q2("values",u,a,c);return[p.upperBound(m,v)]}case"Unique":{const m=q2("x",u,a,c),v=p.unique(m);return[v.values,v.indices]}case"UniqueV2":{const m=q2("x",u,a,c),v=q2("axis",u,a,c),b=p.unique(m,v);return[b.values,b.indices]}default:throw TypeError("Node type "+u.op+" is not implemented")}},Fo=(u,a,c,p=F5)=>{switch(u.op){case"Const":return a[u.name];case"PlaceholderWithDefault":const m=q2("default",u,a,c);return[q3(u.name,a,c)||m];case"Placeholder":return[q3(u.name,a,c)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const q=q2("x",u,a,c);return[q9(q)]}case"IdentityN":return q2("x",u,a,c).map(q=>q9(q));case"Snapshot":const v=q2("x",u,a,c);return[q9(v)];case"Shape":return[p.tensor1d(q2("x",u,a,c).shape,"int32")];case"ShapeN":return q2("x",u,a,c).map(q=>p.tensor1d(q.shape));case"Size":return[p.scalar(q2("x",u,a,c).size,"int32")];case"Rank":return[p.scalar(q2("x",u,a,c).rank,"int32")];case"NoOp":return[p.scalar(1)];case"Print":const b=q2("x",u,a,c),w=q2("data",u,a,c),S=q2("message",u,a,c),O=q2("summarize",u,a,c);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(S);for(let q=0;q<w.length;q++)console.log(Array.prototype.slice.call(w[q].dataSync()).slice(0,O));return[b];default:throw TypeError("Node type "+u.op+" is not implemented")}};class Fn{get id(){return this.handle.id}constructor(a,c){this.keyDType=a,this.valueDType=c,this.handle=fb(0),this.tensorMap=new Map,s4(this.handle)}clearAndClose(){this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fb(this.size(),"int32")}async import(a,c){this.checkKeyAndValueTensor(a,c);const p=await a.data();return this.tensorMap.forEach(m=>m.dispose()),this.tensorMap.clear(),s2(()=>{const m=ci(c),v=p.length,b=m.length;i(v===b,()=>"The number of elements doesn't match, keys has "+v+" elements, the values has "+b+" elements.");for(let w=0;w<v;w++){const S=p[w],O=m[w];s4(O),this.tensorMap.set(S,O)}return this.handle})}async find(a,c){this.checkKeyAndValueTensor(a,c);const p=await a.data();return s2(()=>{const m=[];for(let v=0;v<p.length;v++){const b=p[v],w=this.findWithDefault(b,c);m.push(w)}return cq(m)})}findWithDefault(a,c){const p=this.tensorMap.get(a);return p??c}checkKeyAndValueTensor(a,c){if(a.dtype!==this.keyDType)throw new Error("Expect key dtype "+this.keyDType+", but got "+a.dtype);if(c.dtype!==this.valueDType)throw new Error("Expect value dtype "+this.valueDType+", but got "+c.dtype)}}const Fp=async(u,a,c,p)=>{switch(u.op){case"HashTable":case"HashTableV2":{const m=p.getHashTableHandleByName(u.name);if(m!=null)return[m];{const v=q2("keyDType",u,a,c),b=q2("valueDType",u,a,c),w=new Fn(v,b);return p.addHashTable(u.name,w),[w.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const m=q2("tableHandle",u,a,c,p),v=q2("keys",u,a,c),b=q2("values",u,a,c);return[await p.getHashTableById(m.id).import(v,b)]}case"LookupTableFind":case"LookupTableFindV2":{const m=q2("tableHandle",u,a,c,p),v=q2("keys",u,a,c),b=q2("defaultValue",u,a,c);return[await p.getHashTableById(m.id).find(v,b)]}case"LookupTableSize":case"LookupTableSizeV2":{const m=q2("tableHandle",u,a,c,p);return[p.getHashTableById(m.id).tensorSize()]}default:throw TypeError("Node type "+u.op+" is not implemented")}},FS=(u,a,c,p=F5)=>{switch(u.op){case"ResizeBilinear":{const m=q2("images",u,a,c),v=q2("size",u,a,c),b=q2("alignCorners",u,a,c),w=q2("halfPixelCenters",u,a,c);return[p.image.resizeBilinear(m,[v[0],v[1]],b,w)]}case"ResizeNearestNeighbor":{const m=q2("images",u,a,c),v=q2("size",u,a,c),b=q2("alignCorners",u,a,c),w=q2("halfPixelCenters",u,a,c);return[p.image.resizeNearestNeighbor(m,[v[0],v[1]],b,w)]}case"CropAndResize":{const m=q2("image",u,a,c),v=q2("boxes",u,a,c),b=q2("boxInd",u,a,c),w=q2("cropSize",u,a,c),S=q2("method",u,a,c),O=q2("extrapolationValue",u,a,c);return[p.image.cropAndResize(m,v,b,w,S,O)]}case"ImageProjectiveTransformV3":{const m=q2("images",u,a,c),v=q2("transforms",u,a,c),b=q2("outputShape",u,a,c),w=q2("fillValue",u,a,c),S=q2("interpolation",u,a,c),O=q2("fillMode",u,a,c);return[p.image.transform(m,v,S.toLowerCase(),O.toLowerCase(),w,b)]}default:throw TypeError("Node type "+u.op+" is not implemented")}},Fl=(u,a,c,p=F5)=>{switch(u.op){case"Equal":return[p.equal(q2("a",u,a,c),q2("b",u,a,c))];case"NotEqual":return[p.notEqual(q2("a",u,a,c),q2("b",u,a,c))];case"Greater":return[p.greater(q2("a",u,a,c),q2("b",u,a,c))];case"GreaterEqual":return[p.greaterEqual(q2("a",u,a,c),q2("b",u,a,c))];case"Less":return[p.less(q2("a",u,a,c),q2("b",u,a,c))];case"LessEqual":return[p.lessEqual(q2("a",u,a,c),q2("b",u,a,c))];case"LogicalAnd":return[p.logicalAnd(q2("a",u,a,c),q2("b",u,a,c))];case"LogicalNot":return[p.logicalNot(q2("a",u,a,c))];case"LogicalOr":return[p.logicalOr(q2("a",u,a,c),q2("b",u,a,c))];case"Select":case"SelectV2":return[p.where(q2("condition",u,a,c),q2("a",u,a,c),q2("b",u,a,c))];case"BitwiseAnd":return[p.bitwiseAnd(q2("a",u,a,c),q2("b",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},Fh=(u,a,c,p=F5)=>{switch(u.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[p.matMul(q2("a",u,a,c),q2("b",u,a,c),q2("transposeA",u,a,c),q2("transposeB",u,a,c))];case"Einsum":return[p.einsum(q2("equation",u,a,c),...q2("tensors",u,a,c))];case"Transpose":return[p.transpose(q2("x",u,a,c),q2("perm",u,a,c))];case"_FusedMatMul":const[m,v]=q2("fusedOps",u,a,c),b=m==="biasadd",w=v==="prelu",S=q2("numArgs",u,a,c),O=q2("leakyreluAlpha",u,a,c);if(b){if(w&&S!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!w&&S!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[q,H]=q2("args",u,a,c);return[p.fused.matMul({a:q2("a",u,a,c),b:q2("b",u,a,c),transposeA:q2("transposeA",u,a,c),transposeB:q2("transposeB",u,a,c),bias:q,activation:v,preluActivationWeights:H,leakyreluAlpha:O})];case"MatrixBandPart":return[p.linalg.bandPart(q2("a",u,a,c),q2("numLower",u,a,c),q2("numUpper",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},Fi=(u,a,c,p=F5)=>{switch(u.op){case"EuclideanNorm":return[p.euclideanNorm(q2("x",u,a,c),q2("axis",u,a,c),q2("keepDims",u,a,c))];case"FusedBatchNorm":case"FusedBatchNormV2":return[p.batchNorm(q2("x",u,a,c),q2("mean",u,a,c),q2("variance",u,a,c),q2("offset",u,a,c),q2("scale",u,a,c),q2("epsilon",u,a,c))];case"FusedBatchNormV3":return[p.batchNorm(q2("x",u,a,c),q2("mean",u,a,c),q2("variance",u,a,c),q2("offset",u,a,c),q2("scale",u,a,c),q2("epsilon",u,a,c))];case"LRN":return[p.localResponseNormalization(q2("x",u,a,c),q2("radius",u,a,c),q2("bias",u,a,c),q2("alpha",u,a,c),q2("beta",u,a,c))];case"Softmax":return[p.softmax(q2("x",u,a,c))];case"LogSoftmax":return[p.logSoftmax(q2("x",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},Fm=(u,a,c,p=F5)=>{switch(u.op){case"RaggedGather":{const{outputNestedSplits:m,outputDenseValues:v}=p.raggedGather(q2("paramsNestedSplits",u,a,c),q2("paramsDenseValues",u,a,c),q2("indices",u,a,c),q2("outputRaggedRank",u,a,c));return m.concat(v)}case"RaggedRange":{const{rtNestedSplits:m,rtDenseValues:v}=p.raggedRange(q2("starts",u,a,c),q2("limits",u,a,c),q2("splits",u,a,c));return[m,v]}case"RaggedTensorToTensor":return[p.raggedTensorToTensor(q2("shape",u,a,c),q2("values",u,a,c),q2("defaultValue",u,a,c),q2("rowPartitionTensors",u,a,c),q2("rowPartitionTypes",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},Ft=(u,a,c,p=F5)=>{switch(u.op){case"Max":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.max(q2("x",u,a,c),w,S)]}case"Mean":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.mean(q2("x",u,a,c),w,S)]}case"Min":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.min(q2("x",u,a,c),w,S)]}case"Sum":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.sum(q2("x",u,a,c),w,S)]}case"All":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.all(q2("x",u,a,c),w,S)]}case"Any":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.any(q2("x",u,a,c),w,S)]}case"ArgMax":{const w=q2("axis",u,a,c);return[p.argMax(q2("x",u,a,c),w)]}case"ArgMin":{const w=q2("axis",u,a,c);return[p.argMin(q2("x",u,a,c),w)]}case"Prod":{const w=q2("axis",u,a,c),S=q2("keepDims",u,a,c);return[p.prod(q2("x",u,a,c),w,S)]}case"Cumprod":{const w=q2("axis",u,a,c),S=q2("exclusive",u,a,c),O=q2("reverse",u,a,c);return[p.cumprod(q2("x",u,a,c),w,S,O)]}case"Cumsum":{const w=q2("axis",u,a,c),S=q2("exclusive",u,a,c),O=q2("reverse",u,a,c);return[p.cumsum(q2("x",u,a,c),w,S,O)]}case"Bincount":const m=q2("x",u,a,c),v=q2("weights",u,a,c),b=q2("size",u,a,c);return[p.bincount(m,v,b)];case"DenseBincount":{const w=q2("x",u,a,c),S=q2("weights",u,a,c),O=q2("size",u,a,c),q=q2("binaryOutput",u,a,c);return[p.denseBincount(w,S,O,q)]}default:throw TypeError("Node type "+u.op+" is not implemented")}},Fk=(u,a,c,p=F5)=>{switch(u.op){case"ConcatV2":case"Concat":{const m=q2("n",u,a,c),v=q2("axis",u,a,c);let b=q2("tensors",u,a,c);return b=b.slice(0,m),[p.concat(b,v)]}case"Gather":{const m=q2("x",u,a,c),v=q2("indices",u,a,c);return[p.gather(m,p.cast(v,"int32"),0)]}case"GatherV2":{const m=q2("axis",u,a,c),v=q2("batchDims",u,a,c),b=q2("x",u,a,c),w=q2("indices",u,a,c);return[p.gather(b,p.cast(w,"int32"),m,v)]}case"Reverse":{const m=q2("dims",u,a,c),v=[];for(let w=0;w<m.length;w++)m[w]&&v.push(w);const b=q2("x",u,a,c);return[p.reverse(b,v)]}case"ReverseV2":{const m=q2("axis",u,a,c),v=q2("x",u,a,c);return[p.reverse(v,m)]}case"Slice":{const m=q2("begin",u,a,c),v=q2("size",u,a,c);return[p.slice(q2("x",u,a,c),m,v)]}case"StridedSlice":{const m=q2("begin",u,a,c),v=q2("end",u,a,c),b=q2("strides",u,a,c),w=q2("beginMask",u,a,c),S=q2("endMask",u,a,c),O=q2("ellipsisMask",u,a,c),q=q2("newAxisMask",u,a,c),H=q2("shrinkAxisMask",u,a,c),j=q2("x",u,a,c);return[p.stridedSlice(j,m,v,b,w,S,O,q,H)]}case"Pack":return s2(()=>{const m=q2("axis",u,a,c),v=q2("tensors",u,a,c),b=v[0].shape,w=p.squeeze(v[0]).shape,S=v.map(O=>{const q=z(O.shape,b);if(!q&&!z(p.squeeze(O).shape,w))throw new Error("the input tensors shape does not match");return q?O:p.reshape(O,b)});return[p.stack(S,m)]});case"Unpack":{const m=q2("axis",u,a,c),v=q2("tensor",u,a,c);return p.unstack(v,m)}case"Tile":{const m=q2("reps",u,a,c);return[p.tile(q2("x",u,a,c),m)]}case"Split":case"SplitV":{const m=q2("axis",u,a,c),v=q2("numOrSizeSplits",u,a,c),b=q2("x",u,a,c);return p.split(b,v,m)}case"ScatterNd":{const m=q2("indices",u,a,c),v=q2("values",u,a,c),b=q2("shape",u,a,c);return[p.scatterND(m,v,b)]}case"GatherNd":{const m=q2("x",u,a,c),v=q2("indices",u,a,c);return[p.gatherND(m,v)]}case"SparseToDense":{const m=q2("sparseIndices",u,a,c),v=q2("outputShape",u,a,c),b=q2("sparseValues",u,a,c),w=q2("defaultValue",u,a,c);return[p.sparseToDense(m,b,v,b.dtype===w.dtype?w:p.cast(w,b.dtype))]}case"TensorScatterUpdate":{const m=q2("indices",u,a,c),v=q2("values",u,a,c),b=q2("tensor",u,a,c);return[p.tensorScatterUpdate(b,m,v)]}default:throw TypeError("Node type "+u.op+" is not implemented")}},Fw=(u,a,c,p=F5)=>{switch(u.op){case"SparseFillEmptyRows":{const{outputIndices:m,outputValues:v,emptyRowIndicator:b,reverseIndexMap:w}=p.sparse.sparseFillEmptyRows(q2("indices",u,a,c),q2("values",u,a,c),q2("denseShape",u,a,c),q2("defaultValue",u,a,c));return[m,v,b,w]}case"SparseReshape":{const{outputIndices:m,outputShape:v}=p.sparse.sparseReshape(q2("inputIndices",u,a,c),q2("inputShape",u,a,c),q2("newShape",u,a,c));return[m,v]}case"SparseSegmentMean":return[p.sparse.sparseSegmentMean(q2("data",u,a,c),q2("indices",u,a,c),q2("segmentIds",u,a,c))];case"SparseSegmentSum":return[p.sparse.sparseSegmentSum(q2("data",u,a,c),q2("indices",u,a,c),q2("segmentIds",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},FU=(u,a,c,p=F5)=>{switch(u.op){case"FFT":return[p.fft(q2("x",u,a,c))];case"IFFT":return[p.ifft(q2("x",u,a,c))];case"RFFT":return[p.rfft(q2("x",u,a,c))];case"IRFFT":return[p.irfft(q2("x",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},FG=(u,a,c,p=F5)=>{switch(u.op){case"StaticRegexReplace":return[p.string.staticRegexReplace(q2("input",u,a,c),q2("pattern",u,a,c),q2("rewrite",u,a,c),q2("replaceGlobal",u,a,c))];case"StringNGrams":{const{nGrams:m,nGramsSplits:v}=p.string.stringNGrams(q2("data",u,a,c),q2("dataSplits",u,a,c),q2("separator",u,a,c),q2("nGramWidths",u,a,c),q2("leftPad",u,a,c),q2("rightPad",u,a,c),q2("padWidth",u,a,c),q2("preserveShortSequences",u,a,c));return[m,v]}case"StringSplit":{const{indices:m,values:v,shape:b}=p.string.stringSplit(q2("input",u,a,c),q2("delimiter",u,a,c),q2("skipEmpty",u,a,c));return[m,v,b]}case"StringToHashBucketFast":return[p.string.stringToHashBucketFast(q2("input",u,a,c),q2("numBuckets",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}},Fz=(u,a,c,p=F5)=>{switch(u.op){case"Cast":return[p.cast(q2("x",u,a,c),q2("dtype",u,a,c))];case"ExpandDims":{const m=q2("axis",u,a,c);return[p.expandDims(q2("x",u,a,c),m)]}case"Squeeze":{const m=q2("axis",u,a,c);return[p.squeeze(q2("x",u,a,c),m)]}case"Reshape":return[p.reshape(q2("x",u,a,c),q2("shape",u,a,c))];case"EnsureShape":return[p.ensureShape(q2("x",u,a,c),q2("shape",u,a,c))];case"MirrorPad":return[p.mirrorPad(q2("x",u,a,c),q2("padding",u,a,c),q2("mode",u,a,c))];case"PadV2":case"Pad":return[p.pad(q2("x",u,a,c),q2("padding",u,a,c),q2("constantValue",u,a,c))];case"SpaceToBatchND":{const m=q2("blockShape",u,a,c),v=q2("paddings",u,a,c);return[p.spaceToBatchND(q2("x",u,a,c),m,v)]}case"BatchToSpaceND":{const m=q2("blockShape",u,a,c),v=q2("crops",u,a,c);return[p.batchToSpaceND(q2("x",u,a,c),m,v)]}case"DepthToSpace":{const m=q2("blockSize",u,a,c),v=q2("dataFormat",u,a,c).toUpperCase();return[p.depthToSpace(q2("x",u,a,c),m,v)]}case"BroadcastTo":return[p.broadcastTo(q2("x",u,a,c),q2("shape",u,a,c))];case"BroadcastArgs":return[p.broadcastArgs(q2("s0",u,a,c),q2("s1",u,a,c))];default:throw TypeError("Node type "+u.op+" is not implemented")}};function FW(u,a,c,p,m=s2){const v=((b,w,S)=>{switch(b.category){case"arithmetic":return m(()=>F6(b,w,S));case"basic_math":return m(()=>F7(b,w,S));case"control":return FO(b,w,S);case"convolution":return m(()=>FZ(b,w,S));case"creation":return m(()=>FL(b,w,S));case"dynamic":return FF(b,w,S);case"evaluation":return m(()=>FY(b,w,S));case"image":return m(()=>FS(b,w,S));case"graph":return m(()=>Fo(b,w,S));case"logical":return m(()=>Fl(b,w,S));case"matrices":return m(()=>Fh(b,w,S));case"normalization":return m(()=>Fi(b,w,S));case"ragged":return m(()=>Fm(b,w,S));case"reduction":return m(()=>Ft(b,w,S));case"slice_join":return m(()=>Fk(b,w,S));case"sparse":return m(()=>Fw(b,w,S));case"spectral":return m(()=>FU(b,w,S));case"string":return m(()=>FG(b,w,S));case"transformation":return m(()=>Fz(b,w,S));case"hash_table":return Fp(b,w,S,p);case"custom":const O=q1(b.op);if(O&&O.customExecutor)return O.customExecutor(new F2(b,w,S));throw TypeError("Custom op "+b.op+" is not registered.");default:throw TypeError("Unknown op '"+b.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(u,a,c);return HZ(v)?v.then(b=>[].concat(b)):[].concat(v)}class FR{constructor(a={},c={},p={},m={},v){this.weightMap=a,this.tensorArrayMap=c,this.tensorListMap=p,this.functionMap=m,this.parseNodeNameCache=v,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(a,c){return{id:a,frameName:c,iterationId:0}}set currentContext(a){this.contexts!==a&&(this.contexts=a,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const a=[];for(let c=0;c<this.contexts.length-1;c++){const p=this.contexts.slice(0,this.contexts.length-c);a.push(this.contextIdforContexts(p))}a.push(""),this._currentContextIds=a}contextIdforContexts(a){return a?a.map(c=>c.id===0&&c.iterationId===0?"":c.frameName+"-"+c.iterationId).join("/"):""}enterFrame(a){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,a)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const a=Object.assign({},this.contexts[this.contexts.length-1]);a.iterationId+=1,a.id=this.lastId,this.contexts.splice(-1,1,a),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(a){return this.weightMap[a]}addTensorArray(a){this.tensorArrayMap[a.id]=a}getTensorArray(a){return this.tensorArrayMap[a]}addTensorList(a){this.tensorListMap[a.id]=a}getTensorList(a){return this.tensorListMap[a]}dispose(a){for(const c in this.tensorArrayMap)this.tensorArrayMap[c].clearAndClose(a);for(const c in this.tensorListMap)this.tensorListMap[c].clearAndClose(a)}}function Fj(u,a,c,p){const m=new Set,v=[];let b=null,w=null;const S=new Set,O=new Set(Object.keys(u).map(j=>q7(j)[0]));p=p||[];const q=new Set(p.map(j=>q7(j.name)[0])),H=[...a];for(;H.length>0;){const j=H.pop();if((Fg(j)||FK(j)||Fb(j))&&b==null&&(b=j,w=b.children.map($=>$.name).filter($=>m.has($))),m.add(j.name),c[j.name]==null&&!O.has(j.name)&&!q.has(j.name)){if(j.inputs.length===0){v.push(j.name);continue}j.inputs.forEach($=>{S.has($.name)||(S.add($.name),H.push($))})}}return{inputs:u,outputs:a,usedNodes:m,missingInputs:v,dynamicNode:b,syncInputs:w}}function FA(u,a){const{usedNodes:c,inputs:p}=a,m=Object.keys(p).map(re=>q7(re)[0]).map(re=>u.nodes[re]),v=u.initNodes||[],b=re=>c.has(typeof re=="string"?re:re.name);function w(re){return[...new Map(re.map(de=>[de.name,de])).values()]}const S=w([...m,...u.weights,...v]).filter(b),O=w([...S,...Object.values(u.nodes)]).filter(b),q=new Map(O.map(re=>[re.name,re])),H={};for(const re of O){H[re.name]=H[re.name]||0;for(const de of re.children)b(de)||(H[de.name]=Number.POSITIVE_INFINITY),H[de.name]=(H[de.name]||0)+1}const j=Object.entries(H).filter(([,re])=>re===0).map(([re])=>re),$=[...j];for(;j.length>0;){const re=j.pop(),de=q.get(re);for(const Te of de.children.filter(b))--H[Te.name]===0&&($.push(Te.name),j.push(Te.name))}const J=$.map(re=>q.get(re)),ee=FC(J,S);return FQ(ee,S),ee}function FC(u,a){const c=new Map(u.map(v=>[v.name,v])),p=a.map(v=>v.name),m=new Set(p);for(;p.length>0;){const v=p.pop(),b=c.get(v);for(const w of b.children)!c.has(w.name)||m.has(w.name)||(m.add(w.name),p.push(w.name))}return u.filter(v=>m.has(v.name))}class Fu extends Error{constructor(a){super("NodesExecutionOrderError: "+a)}}function FQ(u,a){const c=new Map(u.map((w,S)=>[w.name,S])),p=new Set(a.map(w=>w.name)),m=w=>p.has(typeof w=="string"?w:w.name),v=new Set(u.map(w=>w.name)),b=w=>v.has(typeof w=="string"?w:w.name);for(const w of u){for(const S of w.children.filter(b)){if(!c.has(S.name))throw new Fu("Child "+S.name+" of node "+w.name+" is unreachable.");if(c.get(w.name)>c.get(S.name))throw new Fu("Node "+w.name+" is scheduled to run after its child "+S.name+".")}if(!m(w))for(const S of w.inputs){if(!c.has(S.name))throw new Fu("Input "+S.name+" of node "+w.name+" is unreachable.");if(c.get(S.name)>c.get(w.name))throw new Fu("Node "+w.name+" is scheduled to run before its input "+S.name+".")}}}function FJ(u){const a=new Map(u.map((w,S)=>[w.name,S])),c=Number.MAX_SAFE_INTEGER,p=u.map((w,S)=>Fg(w)?c:S),m=w=>{const S=p[a.get(w.name)];return S??-1},v=u.map((w,S)=>w.children.map(m).reduce((O,q)=>Math.max(O,q),p[S])),b=new Map;for(let w=0;w<u.length;++w){const S=v[w];if(S===c)continue;const O=u[w],q=u[S];b.has(q.name)||b.set(q.name,[]),b.get(q.name).push(O)}return b}const Fx=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),FM=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),FX=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Fg(u){return Fx.has(u.op)}function FK(u){return FM.has(u.op)}function Fb(u){return FX.has(u.op)}class FV{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(a){const c=Object.keys(a).map(p=>a[p].map(m=>m.id));this._weightIds=[].concat(...c),this._weightMap=a}set resourceManager(a){this._resourceManager=a}get inputs(){return this._inputs.map(a=>({name:a.name,shape:a.attrParams.shape?a.attrParams.shape.value:void 0,dtype:a.attrParams.dtype?a.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(a=>({name:a.name,shape:a.attrParams.shape?a.attrParams.shape.value:void 0,dtype:a.attrParams.dtype?a.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(a=>a.signatureKey||a.name)}get outputNodes(){return this._outputs.map(a=>{const c=a.signatureKey||a.name;return a.defaultOutput?c+":"+a.defaultOutput:c})}get functions(){return Object.keys(this._functions).reduce((a,c)=>(a[c]=this._functions[c].signature,a),{})}constructor(a,c){this.graph=a,this.parent=c,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=a.outputs,this._inputs=a.inputs,this._initNodes=a.initNodes,this._signature=a.signature,this._functions=a.functions,a.functions!=null&&Object.keys(a.functions).forEach(p=>{this._functionExecutorMap[p]=new FV(a.functions[p],this)})}getCompilationKey(a,c){const p=a.map(v=>v.name).sort(),m=c.map(v=>v.name).sort();return p.join(this.SEPARATOR)+"--"+m.join(this.SEPARATOR)}compile(a,c){const p=Fj(a,c,this.weightMap,this._initNodes),{missingInputs:m,dynamicNode:v,syncInputs:b}=p;if(v!=null)throw new Error("This execution contains the node '"+v.name+"', which has the dynamic op '"+v.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+b+"]");if(m.length>0){const O=c.map(H=>H.name),q=Object.keys(a);throw new Error("Cannot compute the outputs ["+O+"] from the provided inputs ["+q+"]. Missing the following inputs: ["+m+"]")}const w=FA(this.graph,p),S=FJ(w);return{orderedNodes:w,nodeLiveUntilMap:S}}cloneAndKeepTensor(a){if(a==null)return null;const c=a.clone();return s4(c),c}cloneTensorList(a){return a?a.map(c=>this.cloneAndKeepTensor(c)):null}cloneTensorMap(a){return Object.fromEntries(Object.entries(a).map(([c,p])=>[c,this.cloneTensorList(p)]))}execute(a,c){this.disposeIntermediateTensors(),a=this.mapInputs(a);const p=Object.keys(a).sort();this.checkInputs(a),this.checkInputShapeAndType(a),c=this.mapOutputs(c),this.checkOutputs(c);const m=p.map(j=>this.graph.nodes[q7(j)[0]]),v=c.map(j=>q7(j)[0]),b=new Set(v);let w=v.map(j=>this.graph.nodes[j]);w.length===0&&(w=this._outputs);const S=this.getCompilationKey(m,w);let O=this.compiledMap.get(S);O==null&&(O=this.compile(a,w),this.compiledMap.set(S,O));try{this.keepIntermediateTensors=Hn().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(j){this.keepIntermediateTensors=!1,console.warn(j.message)}const q={},H={};return s2(()=>{const j=new FR(this.weightMap,q,H,this.functionExecutorMap,this.parseNodeNameCache),$=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(a).forEach(de=>{const[Te,Me]=q7(de,j),Ae=[];Ae[Me]=a[de],$[Te]=Ae,this.keepIntermediateTensors&&(this.clonedTensorsMap[Te]=this.cloneTensorList(Ae))});const J=this.getFrozenTensorIds($),{orderedNodes:ee,nodeLiveUntilMap:re}=O;for(const de of ee){if($[de.name])continue;const Te=FW(de,$,j,this._resourceManager);if(HZ(Te))throw new Error("The execution of the op '"+de.op+"' returned a promise. Please use model.executeAsync() instead.");$[de.name]=Te,this.keepIntermediateTensors&&(this.clonedTensorsMap[de.name]=this.cloneTensorList(Te)),this.checkTensorForDisposalWithNodeLiveUntilInfo(de,$,j,J,b,re.get(de.name))}return this.parent==null&&j.dispose(J),c.map(de=>q3(de,$,j))})}getFrozenTensorIds(a){const c=[].concat.apply([],Object.keys(a).map(p=>a[p]).map(p=>p.map(m=>m.id)));return new Set(c)}checkTensorForDisposal(a,c,p,m,v,b,w){if(!(Fg(c)||b.has(a))){for(const S of p[a])S!=null&&(w[S.id]=(w[S.id]||0)+c.children.length);for(const S of c.inputs){if(Fg(S))continue;const O=q4(S.name,p,m);if(O!=null)for(const q of O){if(!q||q.kept||v.has(q.id))continue;const H=w[q.id];H===1?(q.dispose(),delete w[q.id]):H!=null&&w[q.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(a,c,p,m,v,b){function w(S){return Fg(S)||v.has(S.name)}if(!(Fg(a)||b==null))for(const S of b){if(w(S))continue;const O=q4(S.name,c,p);for(const q of O)!q||q.kept||m.has(q.id)||q.dispose()}}async executeAsync(a,c){return this._executeAsync(a,c)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(a=>{for(const c of a)c&&!c.isDisposed&&c.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(a,c,p=!1,m={},v={}){this.disposeIntermediateTensors(),p||(a=this.mapInputs(a),this.checkInputs(a),this.checkInputShapeAndType(a),c=this.mapOutputs(c),this.checkOutputs(c));try{this.keepIntermediateTensors=Hn().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(j){this.keepIntermediateTensors=!1,console.warn(j.message)}const b=new FR(this.weightMap,m,v,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const w=await this.executeWithControlFlow(a,b,c,p),S=c.map(j=>q3(j,w,b)),O=S.map(j=>j.id),q=Object.keys(a).map(j=>a[j].id),H=new Set([...O,...q,...this.weightIds]);return Object.values(w).forEach(j=>{j.forEach($=>{$&&!$.isDisposed&&!H.has($.id)&&$.dispose()})}),this.parent==null&&b.dispose(H),S}async executeFunctionAsync(a,c,p){const m=a.reduce((v,b,w)=>(v[this.inputs[w].name]=b,v),{});return this._executeAsync(m,this.outputNodes,!0,c,p)}async executeWithControlFlow(a,c,p,m){const v=Object.keys(a),b=v.map(Ae=>this.graph.nodes[q7(Ae)[0]]),w=p.map(Ae=>q7(Ae)[0]),S=new Set(w);let O=w.map(Ae=>this.graph.nodes[Ae]);O.length===0&&(O=this._outputs);const{usedNodes:q,missingInputs:H,dynamicNode:j,syncInputs:$}=Fj(a,O,this.weightMap,this._initNodes),J=[...b,...this.graph.weights,...this._initNodes||[]].map(Ae=>({node:Ae,contexts:c.currentContext})),ee=Object.assign({},this.weightMap);Object.keys(a).forEach(Ae=>{const[Ce,Pe]=q7(Ae),je=[];je[Pe]=a[Ae],ee[Ce]=je});const re={},de=this.getFrozenTensorIds(ee),Te={};for(;J.length>0;){const Ae=this.processStack(b,J,c,ee,Te,de,S,re,q);await Promise.all(Ae)}j==null&&!m&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const Me=O.filter(Ae=>!Fg(Ae)&&!q3(Ae.name,ee,c)).map(Ae=>Ae.name);if(Me.length>0){let Ae="";throw j!=null&&(Ae="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+$+"]"),new Error("Cannot compute the outputs ["+Me+"] from the provided inputs ["+v+"]. Consider providing the following inputs: ["+H+"]. "+Ae)}return ee}processStack(a,c,p,m,v,b,w,S,O){const q=[];for(;c.length>0;){const H=c.pop();p.currentContext=H.contexts;let j="";if(H.node.op==="Enter"&&q2("isConstant",H.node,m,p)&&([j]=q5(H.node.name,p)),m[H.node.name]==null){const $=FW(H.node,m,p,this._resourceManager);j||([j]=q5(H.node.name,p));const J=p.currentContext;HZ($)?q.push($.then(ee=>(m[j]=ee,this.keepIntermediateTensors&&(this.clonedTensorsMap[j]=this.cloneTensorList(ee)),p.currentContext=J,this.checkTensorForDisposal(j,H.node,m,p,b,w,S),this.processChildNodes(H.node,c,p,m,v,O),ee))):(m[j]=$,this.keepIntermediateTensors&&(this.clonedTensorsMap[j]=this.cloneTensorList($)),this.checkTensorForDisposal(j,H.node,m,p,b,w,S),this.processChildNodes(H.node,c,p,m,v,O))}else this.processChildNodes(H.node,c,p,m,v,O)}return q}processChildNodes(a,c,p,m,v,b){a.children.forEach(w=>{const[S]=q5(w.name,p);v[S]||!b.has(w.name)||(w.op==="Merge"?w.inputNames.some(O=>!!q3(O,m,p))&&(v[S]=!0,c.push({contexts:p.currentContext,node:w})):w.inputNames.every(O=>!!q3(O,m,p))&&(v[S]=!0,c.push({contexts:p.currentContext,node:w})))})}dispose(){Object.keys(this.weightMap).forEach(a=>this.weightMap[a].forEach(c=>c.dispose()))}checkInputShapeAndType(a){Object.keys(a).forEach(c=>{const p=a[c],[m]=q7(c),v=this.graph.nodes[m];if(v.attrParams.shape&&v.attrParams.shape.value){const b=v.attrParams.shape.value,w=b.length===p.shape.length&&p.shape.every((S,O)=>b[O]===-1||b[O]===S);i(w,()=>"The shape of dict['"+v.name+"'] provided in model.execute(dict) must be ["+b+"], but was ["+p.shape+"]")}v.attrParams.dtype&&v.attrParams.dtype.value&&i(p.dtype===v.attrParams.dtype.value,()=>"The dtype of dict['"+v.name+"'] provided in model.execute(dict) must be "+v.attrParams.dtype.value+", but was "+p.dtype)})}mapInputs(a){var c,p;const m={};for(const v in a){const b=(p=(c=this._signature)===null||c===void 0?void 0:c.inputs)===null||p===void 0?void 0:p[v];b!=null?m[b.name]=a[v]:m[v]=a[v]}return m}checkInputs(a){const c=Object.keys(a).filter(p=>{const[m]=q7(p);return this.graph.nodes[m]==null});if(c.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+c+"] that are not part of graph")}mapOutputs(a){return a.map(c=>{var p,m;const v=(m=(p=this._signature)===null||p===void 0?void 0:p.outputs)===null||m===void 0?void 0:m[c];return v!=null?v.name:c},{})}checkOutputs(a){a.forEach(c=>{const[p]=q7(c);if(!this.graph.nodes[p])throw new Error("The output '"+c+"' is not found in the graph")})}}class Fd{constructor(a={},c={}){this.hashTableNameToHandle=a,this.hashTableMap=c}addHashTable(a,c){this.hashTableNameToHandle[a]=c.handle,this.hashTableMap[c.id]=c}getHashTableHandleByName(a){return this.hashTableNameToHandle[a]}getHashTableById(a){return this.hashTableMap[a]}dispose(){for(const a in this.hashTableMap)this.hashTableMap[a].clearAndClose(),delete this.hashTableMap[a];for(const a in this.hashTableNameToHandle)this.hashTableNameToHandle[a].dispose(),delete this.hashTableNameToHandle[a]}}const FP="?tfjs-format=file",Fv="model.json";class FT{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(a,c={},p=IR){this.modelUrl=a,this.loadOptions=c,this.version="n/a",this.io=p,c==null&&(this.loadOptions={}),this.resourceManager=new Fd}findIOHandler(){const a=this.modelUrl;if(a.load!=null)this.handler=a;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(a,this.loadOptions);else{const c=this.io.getLoadHandlers(a,this.loadOptions);if(c.length===0)c.push(this.io.browserHTTPRequest(a,this.loadOptions));else if(c.length>1)throw new Error("Found more than one ("+c.length+") load handlers for URL '"+[a]+"'");this.handler=c[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const a=this.handler.load();return HZ(a)?a.then(c=>c.getWeightStream==null?this.loadSync(c):this.loadStreaming(c)):this.loadSync(a)}loadSync(a){const c=this.io.decodeWeights(a.weightData,a.weightSpecs);return this.loadWithWeightMap(a,c)}async loadStreaming(a){if(a.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const c=await sE(a.getWeightStream(),a.weightSpecs);return this.loadWithWeightMap(a,c)}loadWithWeightMap(a,c){this.artifacts=a;const p=this.artifacts.modelTopology;let m=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const v=this.artifacts.userDefinedMetadata;v.signature!=null&&(m=v.signature),v.structuredOutputKeys!=null&&(this.structuredOutputKeys=v.structuredOutputKeys)}if(this.signature=m,this.version=p.versions.producer+"."+p.versions.minConsumer,this.executor=new FV(qM.Instance.transformGraph(p,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(c),this.executor.resourceManager=this.resourceManager,a.modelInitializer!=null&&a.modelInitializer.node!=null){const v=qM.Instance.transformGraph(a.modelInitializer);this.initializer=new FV(v),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=a.initializerSignature}return!0}async save(a,c){if(typeof a=="string"){const p=this.io.getSaveHandlers(a);if(p.length===0)throw new Error("Cannot find any save handlers for URL '"+a+"'");if(p.length>1)throw new Error("Found more than one ("+p.length+") save handlers for URL '"+a+"'");a=p[0]}if(a.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return a.save(this.artifacts)}addStructuredOutputNames(a){if(this.structuredOutputKeys){const c=a instanceof ac?[a]:a,p={};return c.forEach((m,v)=>p[this.structuredOutputKeys[v]]=m),p}return a}predict(a,c){const p=this.execute(a,this.outputNodes);return this.addStructuredOutputNames(p)}async predictAsync(a,c){const p=await this.executeAsync(a,this.outputNodes);return this.addStructuredOutputNames(p)}normalizeInputs(a){var c;if(!(a instanceof ac)&&!Array.isArray(a)){const v=(c=this.signature)===null||c===void 0?void 0:c.inputs;if(v!=null)for(const b in v){const w=v[b];w.resourceId!=null&&(a[b]=this.resourceIdToCapturedInput[w.resourceId])}return a}a=Array.isArray(a)?a:[a];const p=Object.keys(this.resourceIdToCapturedInput).length;if(a.length+p!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has "+(this.inputNodes.length-p)+" non-resource placeholders, while there are "+a.length+" input tensors provided.");let m=0;return this.inputNodes.reduce((v,b)=>{var w,S,O;const q=(O=(S=(w=this.signature)===null||w===void 0?void 0:w.inputs)===null||S===void 0?void 0:S[b])===null||O===void 0?void 0:O.resourceId;return q!=null?v[b]=this.resourceIdToCapturedInput[q]:v[b]=a[m++],v},{})}normalizeOutputs(a){return a=a||this.outputNodes,Array.isArray(a)?a:[a]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(a){if(this.resourceIdToCapturedInput={},this.initializerSignature){const c=this.initializerSignature.outputs,p=Object.keys(c);for(let m=0;m<p.length;m++){const v=p[m],b=c[v];this.resourceIdToCapturedInput[b.resourceId]=a[m]}}}execute(a,c){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),a=this.normalizeInputs(a),c=this.normalizeOutputs(c);const p=this.executor.execute(a,c);return p.length>1?p:p[0]}async executeAsync(a,c){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),a=this.normalizeInputs(a),c=this.normalizeOutputs(c);const p=await this.executor.executeAsync(a,c);return p.length>1?p:p[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(a){return Object.keys(a).reduce((c,p)=>(c[p]=[a[p]],c),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&s3(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Fr(u,a={},c=IR){if(u==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");a==null&&(a={}),a.fromTFHub&&typeof u=="string"&&(u=Fe(u));const p=new FT(u,a,c);return await p.load(),p}function Fe(u){return u.endsWith("/")||(u=u+"/"),""+u+Fv+FP}const FB={},FN={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Y0(u,a){FB[u]=a}function Y1(u,a){if(!(u in FB)||a!=null){const p=Y3(u,a);if(p!==null)FB[u]=p;else return console.log("Could not get context for WebGL version",u),null}const c=FB[u];return c==null||c.isContextLost()?(delete FB[u],Y1(u)):(c.disable(c.DEPTH_TEST),c.disable(c.STENCIL_TEST),c.disable(c.BLEND),c.disable(c.DITHER),c.disable(c.POLYGON_OFFSET_FILL),c.disable(c.SAMPLE_COVERAGE),c.enable(c.SCISSOR_TEST),c.enable(c.CULL_FACE),c.cullFace(c.BACK),FB[u])}function Y2(u){if(!Hn().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&u===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Y3(u,a){if(u!==1&&u!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const c=a??Y2(u);return c.addEventListener("webglcontextlost",p=>{p.preventDefault(),delete FB[u]},!1),Hn().getBool("SOFTWARE_WEBGL_ENABLED")&&(FN.failIfMajorPerformanceCaveat=!1),u===1?c.getContext("webgl",FN)||c.getContext("experimental-webgl",FN):c.getContext("webgl2",FN)}var Y4;(function(u){u[u.DENSE=0]="DENSE",u[u.SHARED_BATCH=1]="SHARED_BATCH"})(Y4||(Y4={}));var Y5;(function(u){u[u.RENDER=0]="RENDER",u[u.UPLOAD=1]="UPLOAD",u[u.PIXELS=2]="PIXELS",u[u.DOWNLOAD=3]="DOWNLOAD"})(Y5||(Y5={}));var Y6;(function(u){u[u.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",u[u.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",u[u.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",u[u.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",u[u.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Y6||(Y6={}));function Y7(u,a){return[a,u]}function Y8(u,a){return u*a}function Y9(u){const a=G(u),c=Math.ceil(a/4);return C(c)}function YH(u,a){return[Math.max(1,Math.ceil(a/2)),Math.max(1,Math.ceil(u/2))]}function YD(u,a){const[c,p]=YH(u,a);return c*p*4}function Yy(u,a){const c=u;let p,m,v,b,w,S,O,q,H,j;return Hn().getNumber("WEBGL_VERSION")===2?(p=c.R32F,m=c.R16F,v=c.RGBA16F,b=c.RGBA32F,w=c.RED,O=4,q=1,H=c.HALF_FLOAT,j=c.FLOAT,S=c.RGBA8):(p=u.RGBA,m=u.RGBA,v=u.RGBA,b=c.RGBA,w=u.RGBA,O=4,q=4,H=a!=null?a.HALF_FLOAT_OES:null,j=u.FLOAT,S=u.RGBA),{internalFormatFloat:p,internalFormatHalfFloat:m,internalFormatPackedHalfFloat:v,internalFormatPackedFloat:b,textureFormatFloat:w,downloadTextureFormat:S,downloadUnpackNumChannels:O,defaultNumChannels:q,textureTypeHalfFloat:H,textureTypeFloat:j}}function Ya(u,a){const c=a();return Hn().getBool("DEBUG")&&Ys(u),c}function Ys(u){const a=u.getError();if(a!==u.NO_ERROR)throw new Error("WebGL Error: "+YO(u,a))}const YI=596e-10,YE=65504;function Yf(u){return!!(Hn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||u===0||YI<Math.abs(u)&&Math.abs(u)<YE)}function YO(u,a){switch(a){case u.NO_ERROR:return"NO_ERROR";case u.INVALID_ENUM:return"INVALID_ENUM";case u.INVALID_VALUE:return"INVALID_VALUE";case u.INVALID_OPERATION:return"INVALID_OPERATION";case u.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case u.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case u.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+a}}function Yc(u,a){return Yj(u,()=>u.getExtension(a),'Extension "'+a+'" not supported on this browser.')}function YZ(u,a){const c=Yj(u,()=>u.createShader(u.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ya(u,()=>u.shaderSource(c,a)),Ya(u,()=>u.compileShader(c)),u.getShaderParameter(c,u.COMPILE_STATUS)===!1)throw console.log(u.getShaderInfoLog(c)),new Error("Failed to compile vertex shader.");return c}function YL(u,a){const c=Yj(u,()=>u.createShader(u.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ya(u,()=>u.shaderSource(c,a)),Ya(u,()=>u.compileShader(c)),Hn().get("ENGINE_COMPILE_ONLY"))return c;if(u.getShaderParameter(c,u.COMPILE_STATUS)===!1)throw YF(a,u.getShaderInfoLog(c)),new Error("Failed to compile fragment shader.");return c}const Yq=/ERROR: [0-9]+:([0-9]+):/g;function YF(u,a){const c=Yq.exec(a);if(c==null){console.log("Couldn't parse line number in error: "+a),console.log(u);return}const p=+c[1],m=u.split(`
`),v=m.length.toString().length+2,b=m.map((H,j)=>x((j+1).toString(),v)+H);let w=0;for(let H=0;H<b.length;H++)w=Math.max(b[H].length,w);const S=b.slice(0,p-1),O=b.slice(p-1,p),q=b.slice(p);console.log(S.join(`
`)),console.log(a.split(`
`)[0]),console.log("%c "+x(O[0],w),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(q.join(`
`))}function YY(u){return Yj(u,()=>u.createProgram(),"Unable to create WebGLProgram.")}function Yo(u,a){if(Ya(u,()=>u.linkProgram(a)),!Hn().get("ENGINE_COMPILE_ONLY")&&u.getProgramParameter(a,u.LINK_STATUS)===!1)throw console.log(u.getProgramInfoLog(a)),new Error("Failed to link vertex and fragment shaders.")}function Yn(u,a){if(Ya(u,()=>u.validateProgram(a)),u.getProgramParameter(a,u.VALIDATE_STATUS)===!1)throw console.log(u.getProgramInfoLog(a)),new Error("Shader program validation failed.")}function Yp(u,a){const c=Yj(u,()=>u.createBuffer(),"Unable to create WebGLBuffer");return Ya(u,()=>u.bindBuffer(u.ARRAY_BUFFER,c)),Ya(u,()=>u.bufferData(u.ARRAY_BUFFER,a,u.STATIC_DRAW)),c}function YS(u,a){const c=Yj(u,()=>u.createBuffer(),"Unable to create WebGLBuffer");return Ya(u,()=>u.bindBuffer(u.ELEMENT_ARRAY_BUFFER,c)),Ya(u,()=>u.bufferData(u.ELEMENT_ARRAY_BUFFER,a,u.STATIC_DRAW)),c}function Yl(u){return Yj(u,()=>u.createTexture(),"Unable to create WebGLTexture.")}function Yh(u,a){const c=Hn().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(u<=0||a<=0){const p="["+u+"x"+a+"]";throw new Error("Requested texture size "+p+" is invalid.")}if(u>c||a>c){const p="["+u+"x"+a+"]",m="["+c+"x"+c+"]";throw new Error("Requested texture size "+p+" greater than WebGL maximum on this browser / GPU "+m+".")}}function Yi(u){return Yj(u,()=>u.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Ym(u,a,c,p,m,v,b){const w=u.getAttribLocation(a,c);return w===-1?!1:(Ya(u,()=>u.bindBuffer(u.ARRAY_BUFFER,p)),Ya(u,()=>u.vertexAttribPointer(w,m,u.FLOAT,!1,v,b)),Ya(u,()=>u.enableVertexAttribArray(w)),!0)}function Yt(u,a,c){YA(u,c),Ya(u,()=>u.activeTexture(u.TEXTURE0+c)),Ya(u,()=>u.bindTexture(u.TEXTURE_2D,a))}function Yk(u,a,c){return Yj(u,()=>u.getUniformLocation(a,c),'uniform "'+c+'" not present in program.')}function Yw(u,a,c){return u.getUniformLocation(a,c)}function YU(u,a,c,p){Ya(u,()=>Yt(u,a,p)),Ya(u,()=>u.uniform1i(c,p))}function YG(u,a,c){Ya(u,()=>u.bindFramebuffer(u.FRAMEBUFFER,c)),Ya(u,()=>u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,a,0))}function Yz(u,a){Ya(u,()=>u.bindFramebuffer(u.FRAMEBUFFER,a)),Ya(u,()=>u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,null,0))}function YW(u){const a=u.checkFramebufferStatus(u.FRAMEBUFFER);if(a!==u.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+YR(u,a))}function YR(u,a){switch(a){case u.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case u.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case u.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case u.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+a}}function Yj(u,a,c){const p=Ya(u,()=>a());if(p==null)throw new Error(c);return p}function YA(u,a){const c=u.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,p=a+u.TEXTURE0;if(p<u.TEXTURE0||p>c){const m="[gl.TEXTURE0, gl.TEXTURE"+c+"]";throw new Error("textureUnit must be in "+m+".")}}function YC(u,a=2){return G(u.slice(0,u.length-a))}function Yu(u){if(u.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[u.length>1?u[u.length-2]:1,u[u.length-1]]}function YQ(u){let a=[1,1,1];return u.length===0||u.length===1&&u[0]===1||(a=[YC(u),...Yu(u)]),a}function YJ(u,a=!1){let c=Hn().getNumber("WEBGL_MAX_TEXTURE_SIZE"),p=Hn().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");p===1/0&&Hn().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(p=c/2),a&&(c=c*2,p=p*2,u=u.map((w,S)=>S>=u.length-2?n(u[S]):u[S]),u.length===1&&(u=[2,u[0]])),u.length!==2&&(u=T(u).newShape);let m=G(u),v=null;u.length<=1&&m<=c?v=[1,m]:u.length===2&&u[0]<=c&&u[1]<=c?v=u:u.length===3&&u[0]*u[1]<=c&&u[2]<=c?v=[u[0]*u[1],u[2]]:u.length===3&&u[0]<=c&&u[1]*u[2]<=c?v=[u[0],u[1]*u[2]]:u.length===4&&u[0]*u[1]*u[2]<=c&&u[3]<=c?v=[u[0]*u[1]*u[2],u[3]]:u.length===4&&u[0]<=c&&u[1]*u[2]*u[3]<=c&&(v=[u[0],u[1]*u[2]*u[3]]);const b=v!=null&&Math.max(...v)>p&&Math.min(...v)<=(a?2:1)&&Math.min(...v)>0;if(v==null||b)if(a){const w=YC(u);let S=2,O=2;u.length&&([S,O]=Yu(u)),m=w*(S/2)*(O/2),v=C(m).map(q=>q*2)}else v=C(m);return v}function Yx(u){return u%2===0}function YM(u,a){if(u=u.slice(-2),a=a.slice(-2),z(u,a)||!u.length||!a.length||u[0]===0||u[1]===0||a[0]===0||a[1]===0)return!0;if(u.length!==a.length){const c=u[u.length-1],p=a[a.length-1];if(c===p||Yx(c)&&Yx(p)&&(u[0]===1||a[0]===1))return!0}return u[1]===a[1]&&Yx(u[0])&&Yx(a[0])}let YX,Yg;function YK(u){if(YX==null){const a=Y1(u);YX=a.getParameter(a.MAX_TEXTURE_SIZE)}return YX}function Yb(u){if(Yg==null){const a=Y1(u);Yg=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Yg)}function YV(u){if(u===0)return 0;let a;const c=Y1(u);return Yd(c,"EXT_disjoint_timer_query_webgl2")&&u===2?a=2:Yd(c,"EXT_disjoint_timer_query")?a=1:a=0,a}function Yd(u,a){return u.getExtension(a)!=null}function YP(u){try{if(Y1(u)!=null)return!0}catch(a){return console.log("Error when getting WebGL context: ",a),!1}return!1}function Yv(u){if(u===0)return!1;const a=Y1(u);if(u===1){if(!Yd(a,"OES_texture_float"))return!1}else if(!Yd(a,"EXT_color_buffer_float"))return!1;return Yr(a)}function YT(u){if(u===0)return!1;const a=Y1(u);if(u===1){if(!Yd(a,"OES_texture_float")||!Yd(a,"WEBGL_color_buffer_float"))return!1}else{if(Yd(a,"EXT_color_buffer_float"))return Yr(a);const c="EXT_color_buffer_half_float";if(Yd(a,c)){const p=a.getExtension(c);return Ye(a,p)}return!1}return Yr(a)}function Yr(u){const a=Yy(u),c=u.createTexture();u.bindTexture(u.TEXTURE_2D,c);const p=1,m=1;u.texImage2D(u.TEXTURE_2D,0,a.internalFormatFloat,p,m,0,a.textureFormatFloat,a.textureTypeFloat,null);const v=u.createFramebuffer();u.bindFramebuffer(u.FRAMEBUFFER,v),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,c,0);const b=u.checkFramebufferStatus(u.FRAMEBUFFER)===u.FRAMEBUFFER_COMPLETE;return u.bindTexture(u.TEXTURE_2D,null),u.bindFramebuffer(u.FRAMEBUFFER,null),u.deleteTexture(c),u.deleteFramebuffer(v),b}function Ye(u,a){const c=Yy(u,a),p=u.createTexture();u.bindTexture(u.TEXTURE_2D,p);const m=1,v=1;u.texImage2D(u.TEXTURE_2D,0,c.internalFormatHalfFloat,m,v,0,c.textureFormatFloat,c.textureTypeHalfFloat,null);const b=u.createFramebuffer();u.bindFramebuffer(u.FRAMEBUFFER,b),u.framebufferTexture2D(u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,p,0);const w=u.checkFramebufferStatus(u.FRAMEBUFFER)===u.FRAMEBUFFER_COMPLETE;return u.bindTexture(u.TEXTURE_2D,null),u.bindFramebuffer(u.FRAMEBUFFER,null),u.deleteTexture(p),u.deleteFramebuffer(b),w}function YB(u){return u!==2?!1:Y1(u).fenceSync!=null}function YN(u,a){Array.isArray(u)||(u=[u]),u.forEach(c=>{c!=null&&i(c.dtype!=="complex64",()=>a+" does not support complex64 tensors in the WebGL backend.")})}const o0=Hn();o0.registerFlag("HAS_WEBGL",()=>o0.getNumber("WEBGL_VERSION")>0),o0.registerFlag("WEBGL_VERSION",()=>YP(2)?2:YP(1)?1:0),o0.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),o0.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>o0.get("WEBGL_VERSION")===2),o0.registerFlag("WEBGL_CPU_FORWARD",()=>!0),o0.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),o0.registerFlag("WEBGL_PACK",()=>o0.getBool("HAS_WEBGL")),o0.registerFlag("WEBGL_PACK_NORMALIZATION",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_CLIP",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_REDUCE",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_LAZILY_UNPACK",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_CONV_IM2COL",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>o0.getBool("WEBGL_PACK")),o0.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>YK(o0.getNumber("WEBGL_VERSION"))),o0.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Yb(o0.getNumber("WEBGL_VERSION"))),o0.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const u=o0.getNumber("WEBGL_VERSION");return u===0?0:YV(u)}),o0.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>o0.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!aQ()),o0.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Yv(o0.getNumber("WEBGL_VERSION"))),o0.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>o0.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:o0.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),o0.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>YT(o0.getNumber("WEBGL_VERSION"))),o0.registerFlag("WEBGL_FENCE_API_ENABLED",()=>YB(o0.getNumber("WEBGL_VERSION"))),o0.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>o0.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),o0.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,u=>{if(typeof u!="number")throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got "+u+".");if(u<0&&u!==-1)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+u+".")}),o0.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>aQ()?1:-1,u=>{if(typeof u!="number")throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+u+".");if(u<0&&u!==-1)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+u+".")}),o0.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),o0.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),o0.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),o0.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),o0.registerFlag("WEBGL_EXP_CONV",()=>!1),o0.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>o0.getBool("IS_TEST")),o0.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),o0.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),o0.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),o0.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function o1(){let u,a,c,p,m,v,b,w,S,O;return Hn().getNumber("WEBGL_VERSION")===2?(u="#version 300 es",a="in",c="out",p="in",m="texture",v="outputColor",b="out vec4 outputColor;",w=Hn().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",S="",O=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(u="",a="attribute",c="varying",p="varying",m="texture2D",v="gl_FragColor",b="",w=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,S=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,O=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:u,attribute:a,varyingVs:c,varyingFs:p,texture2D:m,output:v,defineOutput:b,defineSpecialNaN:w,defineSpecialInf:S,defineRound:O}}function o2(u,a,c="index"){const p=HD(a);return p.map((m,v)=>{const b="int "+u[v]+" = "+c+" / "+m,w=v===p.length-1?"int "+u[v+1]+" = "+c+" - "+u[v]+" * "+m:"index -= "+u[v]+" * "+m;return b+"; "+w+";"}).join("")}function o3(u,a,c="index"){const p=HD(a);return p.map((m,v)=>{const b="int "+u[v]+" = "+c+" / outShapeStrides["+v+"]",w=v===p.length-1?"int "+u[v+1]+" = "+c+" - "+u[v]+" * outShapeStrides["+v+"]":"index -= "+u[v]+" * outShapeStrides["+v+"]";return b+"; "+w+";"}).join("")}function o4(u,a){const c=u.length,p=u.map(v=>a+"["+v+"]"),m=new Array(c-1);m[c-2]=p[c-1];for(let v=c-3;v>=0;--v)m[v]="("+m[v+1]+" * "+p[v+1]+")";return m}function o5(u,a,c="index"){const p=u.map((v,b)=>b),m=o4(p,a);return m.map((v,b)=>{const w="int "+u[b]+" = "+c+" / "+m[b],S=b===m.length-1?"int "+u[b+1]+" = "+c+" - "+u[b]+" * "+m[b]:"index -= "+u[b]+" * "+m[b];return w+"; "+S+";"}).join("")}function o6(u){const a=HD(u).map(c=>c.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+a[0]+" + coords.y * "+a[1]+` + coords.z;
  }
`}function o7(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const o8=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:o9}=Lm;function oH(u,a,c){const p=[];if(u.forEach(j=>{const $=G(j.shapeInfo.logicalShape);if(j.shapeInfo.isUniform?p.push("uniform float "+j.name+($>1?"["+$+"]":"")+";"):(p.push("uniform sampler2D "+j.name+";"),p.push("uniform int offset"+j.name+";")),c.enableShapeUniforms){const{uniformShape:J}=oV(c.packedInputs,j.shapeInfo.logicalShape,j.shapeInfo.texShape);switch(J.length){case 1:p.push("uniform int "+j.name+"Shape;");break;case 2:p.push("uniform ivec2 "+j.name+"Shape;");break;case 3:p.push("uniform ivec3 "+j.name+"Shape;");break;case 4:p.push("uniform ivec4 "+j.name+"Shape;");break}p.push("uniform ivec2 "+j.name+"TexShape;")}}),c.enableShapeUniforms){switch(a.logicalShape.length){case 1:p.push("uniform int outShape;");break;case 2:p.push("uniform ivec2 outShape;"),p.push("uniform int outShapeStrides;");break;case 3:p.push("uniform ivec3 outShape;"),p.push("uniform ivec2 outShapeStrides;");break;case 4:p.push("uniform ivec4 outShape;"),p.push("uniform ivec3 outShapeStrides;");break}p.push("uniform ivec2 outTexShape;")}c.customUniforms&&c.customUniforms.forEach(j=>{p.push("uniform "+j.type+" "+j.name+(j.arrayIndex?"["+j.arrayIndex+"]":"")+";")});const m=p.join(`
`),v=u.map(j=>oa(j,a,c.packedInputs,c.enableShapeUniforms)).join(`
`),b=a.texShape,w=o1(),S=oE(w);let O,q,H=oc(w);return a.isPacked?(O=os(a.logicalShape,b,c.enableShapeUniforms),q=oO(w)):(O=oI(a.logicalShape,b,c.enableShapeUniforms),q=of(w)),c.packedInputs&&(H+=oF),[H,S,q,m,O,v,c.userCode].join(`
`)}function oD(u,a=!1){const c=u.shapeInfo.logicalShape;switch(c.length){case 0:return oz(u,a);case 1:return oR(u,a);case 2:return oA(u,a);case 3:return ou(u,a);case 4:return oJ(u,a);case 5:return ox(u);case 6:return oM(u);default:throw new Error(c.length+"-D input sampling is not yet supported")}}function oy(u,a){switch(u.shapeInfo.logicalShape.length){case 0:return oG(u);case 1:return oW(u,a);case 2:return oj(u,a);case 3:return oC(u,a);default:return oQ(u,a)}}function oa(u,a,c=!1,p){let m="";c?m+=oy(u,p):m+=oD(u,p);const v=u.shapeInfo.logicalShape,b=a.logicalShape;return v.length<=b.length&&(c?m+=og(u,a):m+=oK(u,a)),m}function os(u,a,c){switch(u.length){case 0:return oY();case 1:return oo(u,a,c);case 2:return ok(u,a,c);case 3:return oS(u,a,c);default:return oh(u,a,c)}}function oI(u,a,c){switch(u.length){case 0:return oY();case 1:return on(u,a,c);case 2:return ow(u,a,c);case 3:return ol(u,a,c);case 4:return oi(u,a,c);case 5:return om(u,a);case 6:return ot(u,a);default:throw new Error(u.length+"-D output sampling is not yet supported")}}function oE(u){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+u.texture2D+`(textureSampler, uv).r;
    }
  `}function of(u){return`
    void setOutput(float val) {
      `+u.output+` = vec4(val, 0, 0, 0);
    }
  `}function oO(u){return`
    void setOutput(vec4 val) {
      `+u.output+` = val;
    }
  `}function oc(u){return u.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+u.varyingFs+` vec2 resultUV;
    `+u.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+u.defineSpecialNaN+`
    `+u.defineSpecialInf+`
    `+u.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+oZ+`
    `+oL+`
    `+oq+`
  `}const oZ=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oL=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oq=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,oF=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function oY(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function oo(u,a,c){const p=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return p[0]===1?c?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+p[1]+`.0);
      }
    `:p[1]===1?c?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+p[0]+`.0);
      }
    `:c?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+p[0]+", "+p[1]+`));
      return 2 * (resTexRC.x * `+p[1]+` + resTexRC.y);
    }
  `}function on(u,a,c){return a[0]===1?c?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * `+a[1]+`.0);
      }
    `:a[1]===1?c?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * `+a[0]+`.0);
      }
    `:c?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+a[0]+", "+a[1]+`));
      return resTexRC.x * `+a[1]+` + resTexRC.y;
    }
  `}function oS(u,a,c){if(c)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const p=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],m=Math.ceil(u[2]/2),v=m*Math.ceil(u[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+p[0]+", "+p[1]+`));
      int index = resTexRC.x * `+p[1]+` + resTexRC.y;

      int b = index / `+v+`;
      index -= b * `+v+`;

      int r = 2 * (index / `+m+`);
      int c = imod(index, `+m+`) * 2;

      return ivec3(b, r, c);
    }
  `}function ol(u,a,c){if(c)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    `+o3(["r","c","d"],u)+`
    return ivec3(r, c, d);
  }
`;const p=o2(["r","c","d"],u);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+a[0]+", "+a[1]+`));
      int index = resTexRC.x * `+a[1]+` + resTexRC.y;
      `+p+`
      return ivec3(r, c, d);
    }
  `}function oh(u,a,c){if(c)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const p=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],m=Math.ceil(u[u.length-1]/2),v=m*Math.ceil(u[u.length-2]/2);let b=v,w="",S="b, r, c";for(let O=2;O<u.length-1;O++)b*=u[u.length-O-1],w=`
      int b`+O+" = index / "+b+`;
      index -= b`+O+" * "+b+`;
    `+w,S="b"+O+", "+S;return`
    ivec`+u.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+p[0]+", "+p[1]+`));
      int index = resTexRC.x * `+p[1]+` + resTexRC.y;

      `+w+`

      int b = index / `+v+`;
      index -= b * `+v+`;

      int r = 2 * (index / `+m+`);
      int c = imod(index, `+m+`) * 2;

      return ivec`+u.length+"("+S+`);
    }
  `}function oi(u,a,c){if(c)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      `+o3(["r","c","d","d2"],u)+`
      return ivec4(r, c, d, d2);
    }
  `;const p=o2(["r","c","d","d2"],u);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+a[0]+", "+a[1]+`));
      int index = resTexRC.x * `+a[1]+` + resTexRC.y;
      `+p+`
      return ivec4(r, c, d, d2);
    }
  `}function om(u,a){const c=o2(["r","c","d","d2","d3"],u);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+a[0]+`,
                             `+a[1]+`));

      int index = resTexRC.x * `+a[1]+` + resTexRC.y;

      `+c+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function ot(u,a){const c=o2(["r","c","d","d2","d3","d4"],u);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+a[0]+", "+a[1]+`));
      int index = resTexRC.x * `+a[1]+` + resTexRC.y;

      `+c+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function ok(u,a,c){const p=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(z(u,a))return c?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+p[0]+", "+p[1]+`));
      }
    `;const m=Math.ceil(u[1]/2);return c?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+p[0]+", "+p[1]+`));

      int index = resTexRC.x * `+p[1]+` + resTexRC.y;
      int r = 2 * (index / `+m+`);
      int c = imod(index, `+m+`) * 2;

      return ivec2(r, c);
    }
  `}function ow(u,a,c){return z(u,a)?c?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+a[0]+", "+a[1]+`));
      }
    `:u[1]===1?c?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+a[0]+", "+a[1]+`));
        int index = resTexRC.x * `+a[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:u[0]===1?c?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+a[0]+", "+a[1]+`));
        int index = resTexRC.x * `+a[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:c?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+a[0]+", "+a[1]+`));
      int index = resTexRC.x * `+a[1]+` + resTexRC.y;
      int r = index / `+u[1]+`;
      int c = index - r * `+u[1]+`;
      return ivec2(r, c);
    }
  `}function oU(u){return"offset"+u}function oG(u){const a=u.name,c="get"+a.charAt(0).toUpperCase()+a.slice(1),p=o1();return`
    vec4 `+c+`() {
      return `+p.texture2D+"("+a+`, halfCR);
    }
  `}function oz(u,a){const c=u.name,p="get"+c.charAt(0).toUpperCase()+c.slice(1);if(u.shapeInfo.isUniform)return"float "+p+"() {return "+c+";}";const[m,v]=u.shapeInfo.texShape;if(m===1&&v===1)return`
      float `+p+`() {
        return sampleTexture(`+c+`, halfCR);
      }
    `;const b=oU(c);if(a)return`
    float `+p+`() {
      vec2 uv = uvFromFlat(`+c+"TexShape[0], "+c+"TexShape[1], "+b+`);
      return sampleTexture(`+c+`, uv);
    }
  `;const[w,S]=u.shapeInfo.texShape;return`
    float `+p+`() {
      vec2 uv = uvFromFlat(`+w+", "+S+", "+b+`);
      return sampleTexture(`+c+`, uv);
    }
  `}function oW(u,a){const c=u.name,p="get"+c.charAt(0).toUpperCase()+c.slice(1),m=u.shapeInfo.texShape,v=o1();if(a)return`
    vec4 `+p+`(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(`+c+"TexShape[0]) / 2.0), ceil(float("+c+`TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return `+v.texture2D+"("+c+`, uv);
    }
  `;const b=[Math.ceil(m[0]/2),Math.ceil(m[1]/2)];return`
    vec4 `+p+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+b[0]+", "+b[1]+`, index);
      return `+v.texture2D+"("+c+`, uv);
    }
  `}function oR(u,a){const c=u.name,p="get"+c.charAt(0).toUpperCase()+c.slice(1);if(u.shapeInfo.isUniform)return`
      float `+p+`(int index) {
        `+oX(u)+`
      }
    `;const m=u.shapeInfo.texShape,v=m[0],b=m[1];if(b===1&&v===1)return`
      float `+p+`(int index) {
        return sampleTexture(`+c+`, halfCR);
      }
    `;const w=oU(c);return b===1?a?`
      float `+p+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+w+") + 0.5) / float("+c+`TexShape[0]));
        return sampleTexture(`+c+`, uv);
      }
    `:`
      float `+p+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+w+") + 0.5) / "+v+`.0);
        return sampleTexture(`+c+`, uv);
      }
    `:v===1?a?`
      float `+p+`(int index) {
        vec2 uv = vec2((float(index + `+w+") + 0.5) / float("+c+`TexShape[1]), 0.5);
        return sampleTexture(`+c+`, uv);
      }
    `:`
      float `+p+`(int index) {
        vec2 uv = vec2((float(index + `+w+") + 0.5) / "+b+`.0, 0.5);
        return sampleTexture(`+c+`, uv);
      }
    `:a?`
    float `+p+`(int index) {
      vec2 uv = uvFromFlat(`+c+"TexShape[0], "+c+"TexShape[1], index + "+w+`);
      return sampleTexture(`+c+`, uv);
    }
  `:`
    float `+p+`(int index) {
      vec2 uv = uvFromFlat(`+v+", "+b+", index + "+w+`);
      return sampleTexture(`+c+`, uv);
    }
  `}function oj(u,a){const c=u.shapeInfo.logicalShape,p=u.name,m="get"+p.charAt(0).toUpperCase()+p.slice(1),v=u.shapeInfo.texShape,b=v[0],w=v[1],S=o1();if(v!=null&&z(c,v))return a?`
      vec4 `+m+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+p+"TexShape[1], "+p+`TexShape[0]);

        return `+S.texture2D+"("+p+`, uv);
      }
    `:`
      vec4 `+m+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+w+".0, "+b+`.0);

        return `+S.texture2D+"("+p+`, uv);
      }
    `;if(a)return`
    vec4 `+m+`(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+p+"TexShape[0]) / 2.0), ceil(float("+p+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+p+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return `+S.texture2D+"("+p+`, uv);
    }
  `;const O=[Math.ceil(v[0]/2),Math.ceil(v[1]/2)],q=Math.ceil(c[1]/2);return`
    vec4 `+m+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+q+", "+O[0]+", "+O[1]+`, row, col);
      return `+S.texture2D+"("+p+`, uv);
    }
  `}function oA(u,a){const c=u.shapeInfo.logicalShape,p=u.name,m="get"+p.charAt(0).toUpperCase()+p.slice(1),v=u.shapeInfo.texShape;if(v!=null&&z(c,v)){if(a)return`
      float `+m+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+p+"TexShape[1], "+p+`TexShape[0]);
        return sampleTexture(`+p+`, uv);
      }
    `;const j=v[0],$=v[1];return`
    float `+m+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+$+".0, "+j+`.0);
      return sampleTexture(`+p+`, uv);
    }
  `}const{newShape:b,keptDims:w}=T(c),S=b;if(S.length<c.length){const j=od(u,S),$=["row","col"];return`
      `+oD(j,a)+`
      float `+m+`(int row, int col) {
        return `+m+"("+oP($,w)+`);
      }
    `}if(u.shapeInfo.isUniform)return`
      float `+m+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+c[1]+`, 1)));
        `+oX(u)+`
      }
    `;const O=v[0],q=v[1],H=oU(p);return q===1?a?`
      float `+m+`(int row, int col) {
        float index = dot(vec3(row, col, `+H+"), vec3("+p+`Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(`+p+`TexShape[0]));
        return sampleTexture(`+p+`, uv);
      }
    `:`
    float `+m+`(int row, int col) {
      float index = dot(vec3(row, col, `+H+"), vec3("+c[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+O+`.0);
      return sampleTexture(`+p+`, uv);
    }
  `:O===1?a?`
      float `+m+`(int row, int col) {
        float index = dot(vec3(row, col, `+H+"), vec3("+p+`Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(`+p+`TexShape[1]), 0.5);
        return sampleTexture(`+p+`, uv);
      }
    `:`
    float `+m+`(int row, int col) {
      float index = dot(vec3(row, col, `+H+"), vec3("+c[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+q+`.0, 0.5);
      return sampleTexture(`+p+`, uv);
    }
  `:a?`
      float `+m+`(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+p+"Shape[1] + col + "+H+`;
        vec2 uv = uvFromFlat(`+p+"TexShape[0], "+p+`TexShape[1], index);
        return sampleTexture(`+p+`, uv);
      }
    `:`
  float `+m+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+c[1]+" + col + "+H+`;
    vec2 uv = uvFromFlat(`+O+", "+q+`, index);
    return sampleTexture(`+p+`, uv);
  }
`}function oC(u,a){const c=u.shapeInfo.logicalShape,p=u.name,m="get"+p.charAt(0).toUpperCase()+p.slice(1),v=u.shapeInfo.texShape,b=[Math.ceil(v[0]/2),Math.ceil(v[1]/2)];if(c[0]===1){const j=c.slice(1),$=[1,2],J=od(u,j),ee=["b","row","col"];return`
        `+oy(J,a)+`
        vec4 `+m+`(int b, int row, int col) {
          return `+m+"("+oP(ee,$)+`);
        }
      `}const w=o1();if(a)return`
    vec4 `+m+`(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+p+"TexShape[0]) / 2.0), ceil(float("+p+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+p+`Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+p+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return `+w.texture2D+"("+p+`, uv);
    }
  `;const S=b[0],O=b[1],q=Math.ceil(c[2]/2),H=q*Math.ceil(c[1]/2);return`
    vec4 `+m+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+S+", "+O+", "+H+", "+q+`, b, row, col);
      return `+w.texture2D+"("+p+`, uv);
    }
  `}function ou(u,a){const c=u.shapeInfo.logicalShape,p=u.name,m="get"+p.charAt(0).toUpperCase()+p.slice(1),v=c[1]*c[2],b=c[2],{newShape:w,keptDims:S}=T(c),O=w;if(O.length<c.length){const ee=od(u,O),re=["row","col","depth"];return`
        `+oD(ee,a)+`
        float `+m+`(int row, int col, int depth) {
          return `+m+"("+oP(re,S)+`);
        }
      `}if(u.shapeInfo.isUniform)return`
      float `+m+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+v+", "+b+`, 1)));
        `+oX(u)+`
      }
    `;const q=u.shapeInfo.texShape,H=q[0],j=q[1],$=u.shapeInfo.flatOffset;if(j===v&&$==null)return a?`
      float `+m+`(int row, int col, int depth) {
        int stride1 = `+p+`Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+p+"TexShape[1], "+p+`TexShape[0]);
        return sampleTexture(`+p+`, uv);
      }
    `:`
        float `+m+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+b+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+j+".0, "+H+`.0);
          return sampleTexture(`+p+`, uv);
        }
      `;if(j===b&&$==null)return a?`
      float `+m+`(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(`+p+`Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+p+"TexShape[1], "+p+`TexShape[0]);
        return sampleTexture(`+p+`, uv);
      }
    `:`
    float `+m+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+c[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+j+".0, "+H+`.0);
      return sampleTexture(`+p+`, uv);
    }
  `;const J=oU(p);return a?`
    float `+m+`(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = `+p+"Shape[1] * "+p+`Shape[2];
      int stride1 = `+p+`Shape[2];
      int index = row * stride0 + col * stride1 + depth + `+J+`;
      vec2 uv = uvFromFlat(`+p+"TexShape[0], "+p+`TexShape[1], index);
      return sampleTexture(`+p+`, uv);
    }
    `:`
      float `+m+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+v+" + col * "+b+" + depth + "+J+`;
        vec2 uv = uvFromFlat(`+H+", "+j+`, index);
        return sampleTexture(`+p+`, uv);
      }
  `}function oQ(u,a){const c=u.name,p="get"+c.charAt(0).toUpperCase()+c.slice(1),m=o1();if(a)return`
    vec4 `+p+`(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(`+c+`Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+c+`Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= `+c+`Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(`+c+"TexShape[0]) / 2.0), ceil(float("+c+`TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return `+m.texture2D+"("+c+`, uv);
    }
  `;const v=u.shapeInfo.logicalShape,b=v.length,w=u.shapeInfo.texShape,S=[Math.ceil(w[0]/2),Math.ceil(w[1]/2)],O=S[0],q=S[1],H=Math.ceil(v[b-1]/2);let j=H*Math.ceil(v[b-2]/2),$="int b, int row, int col",J="b * "+j+" + (row / 2) * "+H+" + (col / 2)";for(let ee=2;ee<b-1;ee++)$="int b"+ee+", "+$,j*=v[b-ee-1],J="b"+ee+" * "+j+" + "+J;return`
    vec4 `+p+"("+$+`) {
      int index = `+J+`;
      int texR = index / `+q+`;
      int texC = index - texR * `+q+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+q+", "+O+`);
      return `+m.texture2D+"("+c+`, uv);
    }
  `}function oJ(u,a){const c=u.shapeInfo.logicalShape,p=u.name,m="get"+p.charAt(0).toUpperCase()+p.slice(1),v=c[3],b=c[2]*v,w=c[1]*b,{newShape:S,keptDims:O}=T(c);if(S.length<c.length){const Te=od(u,S),Me=["row","col","depth","depth2"];return`
      `+oD(Te,a)+`
      float `+m+`(int row, int col, int depth, int depth2) {
        return `+m+"("+oP(Me,O)+`);
      }
    `}if(u.shapeInfo.isUniform)return`
      float `+m+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+w+", "+b+", "+v+`, 1)));
        `+oX(u)+`
      }
    `;const q=u.shapeInfo.flatOffset,H=u.shapeInfo.texShape,j=H[0],$=H[1],J="int stride2 = "+p+"Shape[3];",ee="int stride1 = "+p+"Shape[2] * stride2;",re="int stride0 = "+p+"Shape[1] * stride1;";if($===w&&q==null)return a?`
      float `+m+`(int row, int col, int depth, int depth2) {
        `+J+`
        `+ee+`
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+p+"TexShape[1], "+p+`TexShape[0]);
        return sampleTexture(`+p+`, uv);
      }
    `:`
      float `+m+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+b+", "+v+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+$+".0, "+j+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `;if($===v&&q==null)return a?`
      float `+m+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+p+"Shape[1] * "+p+"Shape[2], "+p+`Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+p+"TexShape[1], "+p+`TexShape[0]);
        return sampleTexture(`+p+`, uv);
      }
    `:`
      float `+m+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+c[1]*c[2]+", "+c[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+$+".0, "+j+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `;const de=oU(p);return a?`
    float `+m+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      `+J+`
      `+ee+`
      `+re+`
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(`+p+"TexShape[0], "+p+"TexShape[1], index + "+de+`);
      return sampleTexture(`+p+`, uv);
    }
  `:`
    float `+m+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+w+" + col * "+b+` +
          depth * `+v+` + depth2;
      vec2 uv = uvFromFlat(`+j+", "+$+", index + "+de+`);
      return sampleTexture(`+p+`, uv);
    }
  `}function ox(u){const a=u.shapeInfo.logicalShape,c=u.name,p="get"+c.charAt(0).toUpperCase()+c.slice(1),m=a[4],v=a[3]*m,b=a[2]*v,w=a[1]*b,{newShape:S,keptDims:O}=T(a);if(S.length<a.length){const ee=od(u,S),re=["row","col","depth","depth2","depth3"];return`
      `+oD(ee)+`
      float `+p+`(int row, int col, int depth, int depth2, int depth3) {
        return `+p+"("+oP(re,O)+`);
      }
    `}if(u.shapeInfo.isUniform)return`
      float `+p+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+w+", "+b+", "+v+", "+m+`)) +
          depth3;
        `+oX(u)+`
      }
    `;const q=u.shapeInfo.flatOffset,H=u.shapeInfo.texShape,j=H[0],$=H[1];if($===w&&q==null)return`
      float `+p+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+b+", "+v+", "+m+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+$+".0, "+j+`.0);
        return sampleTexture(`+c+`, uv);
      }
    `;if($===m&&q==null)return`
      float `+p+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+a[1]*a[2]*a[3]+`,
               `+a[2]*a[3]+", "+a[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+$+".0, "+j+`.0);
        return sampleTexture(`+c+`, uv);
      }
    `;const J=oU(c);return`
    float `+p+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+w+" + col * "+b+" + depth * "+v+` +
          depth2 * `+m+" + depth3 + "+J+`;
      vec2 uv = uvFromFlat(`+j+", "+$+`, index);
      return sampleTexture(`+c+`, uv);
    }
  `}function oM(u){const a=u.shapeInfo.logicalShape,c=u.name,p="get"+c.charAt(0).toUpperCase()+c.slice(1),{newShape:m,keptDims:v}=T(a);if(m.length<a.length){const re=od(u,m),de=["row","col","depth","depth2","depth3","depth4"];return`
      `+oD(re)+`
      float `+p+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+p+"("+oP(de,v)+`);
      }
    `}const b=a[5],w=a[4]*b,S=a[3]*w,O=a[2]*S,q=a[1]*O;if(u.shapeInfo.isUniform)return`
      float `+p+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+q+", "+O+", "+S+", "+w+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+b+`, 1)));
        `+oX(u)+`
      }
    `;const H=u.shapeInfo.flatOffset,j=u.shapeInfo.texShape,$=j[0],J=j[1];if(J===q&&H==null)return`
      float `+p+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+O+", "+S+", "+w+", "+b+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+J+".0, "+$+`.0);
        return sampleTexture(`+c+`, uv);
      }
    `;if(J===b&&H==null)return`
      float `+p+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+a[1]*a[2]*a[3]*a[4]+`,
               `+a[2]*a[3]*a[4]+`,
               `+a[3]*a[4]+`,
               `+a[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+J+".0, "+$+`.0);
        return sampleTexture(`+c+`, uv);
      }
    `;const ee=oU(c);return`
    float `+p+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+q+" + col * "+O+" + depth * "+S+` +
          depth2 * `+w+" + depth3 * "+b+" + depth4 + "+ee+`;
      vec2 uv = uvFromFlat(`+$+", "+J+`, index);
      return sampleTexture(`+c+`, uv);
    }
  `}function oX(u){const a=u.name,c=G(u.shapeInfo.logicalShape);return c<2?"return "+a+";":`
    for (int i = 0; i < `+c+`; i++) {
      if (i == index) {
        return `+a+`[i];
      }
    }
  `}function og(u,a){const c=u.name,p=c.charAt(0).toUpperCase()+c.slice(1),m="get"+p+"AtOutCoords",v=u.shapeInfo.logicalShape.length,b=a.logicalShape.length,w=o9(u.shapeInfo.logicalShape,a.logicalShape),S=ob(b),O=b-v;let q;const H=["x","y","z","w","u","v"];v===0?q="":b<2&&w.length>=1?q="coords = 0;":q=w.map(re=>"coords."+H[re+O]+" = 0;").join(`
`);let j="";b<2&&v>0?j="coords":j=u.shapeInfo.logicalShape.map((re,de)=>"coords."+H[de+O]).join(", ");let $="return outputValue;";const J=G(u.shapeInfo.logicalShape)===1,ee=G(a.logicalShape)===1;if(v===1&&!J&&!ee)$=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(J&&!ee)b===1?$=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:$=`
        return vec4(outputValue.x);
      `;else if(w.length){const re=v-2,de=v-1;w.indexOf(re)>-1&&w.indexOf(de)>-1?$="return vec4(outputValue.x);":w.indexOf(re)>-1?$="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":w.indexOf(de)>-1&&($="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 `+m+`() {
      `+S+` coords = getOutputCoords();
      `+q+`
      vec4 outputValue = get`+p+"("+j+`);
      `+$+`
    }
  `}function oK(u,a){const c=u.name,p=c.charAt(0).toUpperCase()+c.slice(1),m="get"+p+"AtOutCoords",v=a.texShape,b=u.shapeInfo.texShape,w=u.shapeInfo.logicalShape.length,S=a.logicalShape.length;if(!u.shapeInfo.isUniform&&w===S&&u.shapeInfo.flatOffset==null&&z(b,v))return`
      float `+m+`() {
        return sampleTexture(`+c+`, resultUV);
      }
    `;const O=ob(S),q=o9(u.shapeInfo.logicalShape,a.logicalShape),H=S-w;let j;const $=["x","y","z","w","u","v"];w===0?j="":S<2&&q.length>=1?j="coords = 0;":j=q.map(ee=>"coords."+$[ee+H]+" = 0;").join(`
`);let J="";return S<2&&w>0?J="coords":J=u.shapeInfo.logicalShape.map((ee,re)=>"coords."+$[re+H]).join(", "),`
    float `+m+`() {
      `+O+` coords = getOutputCoords();
      `+j+`
      return get`+p+"("+J+`);
    }
  `}function ob(u){if(u<=1)return"int";if(u===2)return"ivec2";if(u===3)return"ivec3";if(u===4)return"ivec4";if(u===5)return"ivec5";if(u===6)return"ivec6";throw Error("GPU for rank "+u+" is not yet supported")}function oV(u,a,c){const{newShape:p,keptDims:m}=T(a),v=a.length,b=u&&v===3&&a[0]===1,w=b?a.slice(1):p,S=!u&&v>1&&!z(a,c)&&p.length<v||b;return{useSqueezeShape:S,uniformShape:S?w:a,keptDims:m}}function od(u,a){const c=JSON.parse(JSON.stringify(u));return c.shapeInfo.logicalShape=a,c}function oP(u,a){return a.map(c=>u[c]).join(", ")}function ov(u,a,c,p){const m=c.map((q,H)=>{const j={logicalShape:q.shape,texShape:q.isUniform?null:q.texData.texShape,isUniform:q.isUniform,isPacked:q.isUniform?!1:q.texData.isPacked,flatOffset:null};return q.texData!=null&&q.texData.slice!=null&&q.texData.slice.flatOffset>0&&(j.flatOffset=q.texData.slice.flatOffset),{name:a.variableNames[H],shapeInfo:j}}),v=m.map(q=>q.shapeInfo),b={logicalShape:p.shape,texShape:p.texData.texShape,isUniform:!1,isPacked:p.texData.isPacked,flatOffset:null},w=oH(m,b,a),S=YL(u.gl,w),O=u.createProgram(S);return Hn().get("ENGINE_COMPILE_ONLY")?{program:a,fragmentShader:S,source:w,webGLProgram:O,inShapeInfos:v,outShapeInfo:b,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(u.buildVao(O),Object.assign({program:a,fragmentShader:S,source:w,webGLProgram:O,inShapeInfos:v,outShapeInfo:b},oT(u,a,O)))}function oT(u,a,c){const p=[],m=[];let v,b,w,S=null,O=null;O=u.getUniformLocation(c,"NAN",!1),Hn().getNumber("WEBGL_VERSION")===1&&(S=u.getUniformLocation(c,"INFINITY",!1));const q=!1;for(const H of a.variableNames){const j={name:H,uniform:u.getUniformLocation(c,H,q),offset:u.getUniformLocation(c,"offset"+H,q)};a.enableShapeUniforms&&(j.shape=u.getUniformLocation(c,H+"Shape",q),j.texShape=u.getUniformLocation(c,H+"TexShape",q)),p.push(j)}if(a.enableShapeUniforms&&(v=u.getUniformLocation(c,"outShape",q),w=u.getUniformLocation(c,"outShapeStrides",q),b=u.getUniformLocation(c,"outTexShape",q)),a.customUniforms)for(const H of a.customUniforms)m.push(u.getUniformLocation(c,H.name,q));return{variablesLocations:p,customUniformLocations:m,infLoc:S,nanLoc:O,outShapeLocation:v,outShapeStridesLocation:w,outTexShapeLocation:b}}function or(u,a){if(u.length!==a.length)throw Error("Binary was compiled with "+u.length+" inputs, but was executed with "+a.length+" inputs");u.forEach((c,p)=>{const m=c.logicalShape,v=a[p],b=v.shape;if(!z(m,b))throw Error("Binary was compiled with different shapes than the current args. Shapes "+m+" and "+b+" must match");if(c.isUniform&&v.isUniform)return;const w=c.texShape,S=v.isUniform?null:v.texData.texShape;if(!z(w,S))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+w+" and "+S+" must match")})}function oe(u,a,c,p,m){a.program.enableShapeUniforms||(or(a.inShapeInfos,c),or([a.outShapeInfo],[p]));const v=p.texData.texture,b=p.texData.texShape;p.texData.isPacked?u.setOutputPackedMatrixTexture(v.texture,b[0],b[1]):u.setOutputMatrixTexture(v.texture,b[0],b[1]),u.setProgram(a.webGLProgram),u.bindVertexArray(a.webGLProgram.vao),Hn().getNumber("WEBGL_VERSION")===1&&a.infLoc!==null&&u.gl.uniform1f(a.infLoc,1/0),a.nanLoc!==null&&u.gl.uniform1f(a.nanLoc,NaN);for(let S=0;S<c.length;++S){const O=c[S],{uniform:q,offset:H,shape:j,texShape:$}=a.variablesLocations[S];if(j){const{uniformShape:J}=oV(a.program.packedInputs,O.shape,O.texData.texShape);switch(J.length){case 1:u.gl.uniform1iv(j,new Int32Array(J));break;case 2:u.gl.uniform2iv(j,new Int32Array(J));break;case 3:u.gl.uniform3iv(j,new Int32Array(J));break;case 4:u.gl.uniform4iv(j,new Int32Array(J));break}}if($&&u.gl.uniform2i($,O.texData.texShape[0],O.texData.texShape[1]),q!=null){if(O.isUniform){if(G(O.shape)<2)u.gl.uniform1f(q,O.uniformValues[0]);else{let J=O.uniformValues;J instanceof Float32Array||(J=new Float32Array(J)),u.gl.uniform1fv(q,J)}continue}O.texData.slice!=null&&H!=null&&u.gl.uniform1i(H,O.texData.slice.flatOffset),u.setInputMatrixTexture(O.texData.texture.texture,q,S)}}const w=a.outShapeLocation;if(w)switch(p.shape.length){case 1:u.gl.uniform1iv(w,new Int32Array(p.shape));break;case 2:u.gl.uniform2iv(w,new Int32Array(p.shape));break;case 3:u.gl.uniform3iv(w,new Int32Array(p.shape));break;case 4:u.gl.uniform4iv(w,new Int32Array(p.shape));break}if(a.outShapeStridesLocation){const S=HD(p.shape);switch(p.shape.length){case 2:u.gl.uniform1iv(a.outShapeStridesLocation,new Int32Array(S));break;case 3:u.gl.uniform2iv(a.outShapeStridesLocation,new Int32Array(S));break;case 4:u.gl.uniform3iv(a.outShapeStridesLocation,new Int32Array(S));break}}if(a.outTexShapeLocation&&u.gl.uniform2i(a.outTexShapeLocation,p.texData.texShape[0],p.texData.texShape[1]),a.program.customUniforms&&m)for(let S=0;S<a.program.customUniforms.length;++S){const O=a.program.customUniforms[S],q=a.customUniformLocations[S],H=m[S];if(O.type==="float")u.gl.uniform1fv(q,H);else if(O.type==="vec2")u.gl.uniform2fv(q,H);else if(O.type==="vec3")u.gl.uniform3fv(q,H);else if(O.type==="vec4")u.gl.uniform4fv(q,H);else if(O.type==="int")u.gl.uniform1iv(q,H);else if(O.type==="ivec2")u.gl.uniform2iv(q,H);else if(O.type==="ivec3")u.gl.uniform3iv(q,H);else if(O.type==="ivec4")u.gl.uniform4iv(q,H);else throw Error("uniform type "+O.type+" is not supported yet.")}u.executeProgram()}function oB(u,a,c){let p="";a.concat(c).forEach(b=>{const w=b.texData!=null&&b.texData.slice!=null&&b.texData.slice.flatOffset>0;if(u.enableShapeUniforms&&!b.isUniform){const S=b.texData.texShape,{useSqueezeShape:O,uniformShape:q,keptDims:H}=oV(u.packedInputs,b.shape,S);let j="",$="",J="";if(q.length===1&&u.packedInputs){const Ce=[Math.ceil(S[0]/2),Math.ceil(S[1]/2)];j=(Ce[0]>1)+"_"+(Ce[1]>1)}else if(q.length===2&&!u.packedInputs)$=(q[0]>1)+"_"+(q[1]>1);else if(q.length>2&&!u.packedInputs){const Ce=HD(q);J=(Ce[0]===S[1])+"_"+(Ce[Ce.length-1]===S[1])}const ee=b.shape.length,re=q.length===2&&z(b.shape,S),de=G(b.shape)===1,Te=IV(b.shape,c.shape),Me=!u.packedInputs&&ee===c.shape.length&&z(S,c.texData.texShape),Ae=u.packedInputs||q.length>2?"":(S[0]>1)+"_"+(S[1]>1);p+=ee+"_"+Me+"_"+(O?H:"")+"_"+q.length+"_"+de+"_"+Te+"_"+re+"_"+j+"_"+$+"_"+J+"_"+Ae+"_"+w}else{const S=b.isUniform?"uniform":b.texData.texShape;p+=b.shape+"_"+S+"_"+w}});const m=u.userCode;let v=u.constructor.name;return v+="_"+p+"_"+m+(""+Hn().getNumber("WEBGL_VERSION")),v}function oN(u){return Hn().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&u<=4}class n0{constructor(a){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Y4.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const c=o1();this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?o3(["r","c","d"],a):o2(["r","c","d"],a))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+c.output+` = result;
      }
    `}}class n1{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Y4.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const c=o1();this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?o3(["r","c","d"],a):o2(["r","c","d"],a))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+c.output+` = result;
      }
    `}}class n2{constructor(a){this.variableNames=["A"],this.outTexUsage=Y5.DOWNLOAD;const c=o1();this.outputShape=a,this.userCode=`
      `+o8+`

      void main() {
        float x = getAAtOutCoords();
        `+c.output+` = encode_float(x);
      }
    `}}class n3{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Y5.DOWNLOAD;const c=o1();this.outputShape=a,this.userCode=`
      `+o8+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+c.output+` = encode_float(x);
      }
    `}}const n4={R:0,G:1,B:2,A:3};class n5{constructor(a,c=!1,p="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const m=o1();this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length);let v="result";c&&(v="floor(result * 255. + 0.5)");let b="";for(let w=0;w<p.length;w++){const S=p[w];b+=`
          if(offset == `+w+`) {
            result = values[`+n4[S]+`];
          }`}this.userCode=`
      `+(this.enableShapeUniforms?o7():o6(a))+`

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, `+p.length+`);

        flatIndex = idiv(flatIndex, `+p.length+`, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = `+m.texture2D+`(A, uv);
          `+b+`
        }
        `+m.output+" = vec4("+v+`, 0., 0., 0.);
      }
    `}}class n6{constructor(a,c=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const p=o1();this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length);let m="",v="result";c&&(v="floor(result * 255. + 0.5)");for(let b=0;b<=1;b++)for(let w=0;w<=1;w++){const S=b*2+w;m+=`
          localCoords = coords;
          if(localCoords[2] + `+w+" < "+(this.enableShapeUniforms?"outShape[2]":""+a[2])+`) {
          localCoords[2] += `+w+`;
          if (localCoords[1] + `+b+" < "+(this.enableShapeUniforms?"outShape[1]":""+a[1])+`) {
            localCoords[1] += `+b+`;

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = `+p.texture2D+`(A, uv);

            if (offset == 0) {
              result[`+S+`] = values[0];
            } else if (offset == 1) {
              result[`+S+`] = values[1];
            } else if (offset == 2) {
              result[`+S+`] = values[2];
            } else {
              result[`+S+`] = values[3];
            }
          }
        }
        `}this.userCode=`
        `+(this.enableShapeUniforms?o7():o6(a))+`

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          `+m+`

          `+p.output+" = "+v+`;
        }
    `}}function n7(u){const a=o1(),c=a.version+`
    precision highp float;
    `+a.attribute+` vec3 clipSpacePos;
    `+a.attribute+` vec2 uv;
    `+a.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return YZ(u,c)}function n8(u){const a=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Yp(u,a)}function n9(u){const a=new Uint16Array([0,1,2,2,1,3]);return YS(u,a)}function nH(u,a,c,p,m,v){Yh(a,c);const b=Yl(u),w=u.TEXTURE_2D;return Ya(u,()=>u.bindTexture(w,b)),Ya(u,()=>u.texParameteri(w,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE)),Ya(u,()=>u.texParameteri(w,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE)),Ya(u,()=>u.texParameteri(w,u.TEXTURE_MIN_FILTER,u.NEAREST)),Ya(u,()=>u.texParameteri(w,u.TEXTURE_MAG_FILTER,u.NEAREST)),Hn().getNumber("WEBGL_VERSION")===1?Ya(u,()=>u.texImage2D(w,0,p,a,c,0,m,v,null)):Ya(u,()=>u.texStorage2D(w,1,p,a,c)),Ya(u,()=>u.bindTexture(u.TEXTURE_2D,null)),{texture:b,texShape:[c,a]}}function nD(u){return u.internalFormatFloat}function ny(u,a,c,p){const[m,v]=Y7(a,c);return nH(u,m,v,nD(p),p.textureFormatFloat,u.FLOAT)}function na(u){return u.internalFormatHalfFloat}function ns(u,a,c,p){const[m,v]=Y7(a,c);return nH(u,m,v,na(p),p.textureFormatFloat,p.textureTypeHalfFloat)}function nI(u){return u.downloadTextureFormat}function nE(u,a,c,p){const[m,v]=Y7(a,c);return nH(u,m,v,nI(p),u.RGBA,u.UNSIGNED_BYTE)}function nf(u){return u.internalFormatPackedFloat}function nO(u,a,c,p){const[m,v]=YH(a,c);return nH(u,m,v,nf(p),u.RGBA,u.FLOAT)}function nc(u){return u.internalFormatPackedHalfFloat}function nZ(u,a,c,p){const[m,v]=YH(a,c);return nH(u,m,v,nc(p),u.RGBA,p.textureTypeHalfFloat)}function nL(u,a,c){return Ya(u,()=>u.bindBuffer(u.ARRAY_BUFFER,c)),Ym(u,a,"clipSpacePos",c,3,20,0)&&Ym(u,a,"uv",c,2,20,12)}function nq(u,a,c,p,m,v){Ya(u,()=>u.bindTexture(u.TEXTURE_2D,a));let b,w,S;m instanceof Uint8Array?(b=new Uint8Array(c*p*4),w=u.UNSIGNED_BYTE,S=u.RGBA):(b=new Float32Array(c*p*4),w=u.FLOAT,S=v.internalFormatPackedFloat),b.set(m),Hn().getNumber("WEBGL_VERSION")===2?Ya(u,()=>u.texSubImage2D(u.TEXTURE_2D,0,0,0,c,p,u.RGBA,w,b)):Ya(u,()=>u.texImage2D(u.TEXTURE_2D,0,S,c,p,0,u.RGBA,w,b)),Ya(u,()=>u.bindTexture(u.TEXTURE_2D,null))}function nF(u,a,c){Ya(u,()=>u.bindTexture(u.TEXTURE_2D,a)),c.data instanceof Uint8Array?Hn().getNumber("WEBGL_VERSION")===2?Ya(u,()=>u.texSubImage2D(u.TEXTURE_2D,0,0,0,c.width,c.height,u.RGBA,u.UNSIGNED_BYTE,c.data)):Ya(u,()=>u.texImage2D(u.TEXTURE_2D,0,u.RGBA,c.width,c.height,0,u.RGBA,u.UNSIGNED_BYTE,c.data)):Hn().getNumber("WEBGL_VERSION")===2?Ya(u,()=>u.texSubImage2D(u.TEXTURE_2D,0,0,0,u.RGBA,u.UNSIGNED_BYTE,c)):Ya(u,()=>u.texImage2D(u.TEXTURE_2D,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,c)),Ya(u,()=>u.bindTexture(u.TEXTURE_2D,null))}function nY(u,a,c,p){const m=u.createBuffer();Ya(u,()=>u.bindBuffer(u.PIXEL_PACK_BUFFER,m));const v=4*4*a*c;return Ya(u,()=>u.bufferData(u.PIXEL_PACK_BUFFER,v,u.STREAM_READ)),Ya(u,()=>u.readPixels(0,0,c,a,u.RGBA,u.FLOAT,0)),Ya(u,()=>u.bindBuffer(u.PIXEL_PACK_BUFFER,null)),m}function no(u,a,c){const p=u,m=new Float32Array(c);return p.bindBuffer(p.PIXEL_PACK_BUFFER,a),p.getBufferSubData(p.PIXEL_PACK_BUFFER,0,m),p.bindBuffer(p.PIXEL_PACK_BUFFER,null),m}function nn(u,a,c,p){const[m,v]=Y7(a,c),b=4,w=new Uint8Array(Y8(a*c,b));return Ya(u,()=>u.readPixels(0,0,m,v,p.downloadTextureFormat,u.UNSIGNED_BYTE,w)),new Float32Array(w.buffer)}function np(u,a,c,p,m,v,b,w){const S=u,O=new Float32Array(YD(v,b));return S.bindBuffer(S.PIXEL_PACK_BUFFER,a),S.getBufferSubData(S.PIXEL_PACK_BUFFER,0,O),S.bindBuffer(S.PIXEL_PACK_BUFFER,null),O}function nS(u,a,c){const p=new Float32Array(a*c*4);return Ya(u,()=>u.readPixels(0,0,c,a,u.RGBA,u.FLOAT,p)),p}class nl{constructor(a){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const c=Hn().getNumber("WEBGL_VERSION");if(a!=null?(this.gl=a,Y0(c,a)):this.gl=Y1(c),a=this.gl,Hn().getNumber("WEBGL_VERSION")===2){const v=a;this.createVertexArray=()=>Ya(v,()=>v.createVertexArray()),this.bindVertexArray=b=>Ya(v,()=>v.bindVertexArray(b)),this.deleteVertexArray=b=>Ya(v,()=>v.deleteVertexArray(b)),this.getVertexArray=()=>Ya(v,()=>v.getParameter(v.VERTEX_ARRAY_BINDING))}else if(a!=null){const v=a.getExtension("OES_vertex_array_object");if(v==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ya(a,()=>v.createVertexArrayOES()),this.bindVertexArray=b=>Ya(a,()=>v.bindVertexArrayOES(b)),this.deleteVertexArray=b=>Ya(a,()=>v.deleteVertexArrayOES(b)),this.getVertexArray=()=>Ya(a,()=>a.getParameter(v.VERTEX_ARRAY_BINDING_OES))}let p="WEBGL_color_buffer_float";const m="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Hn().getNumber("WEBGL_VERSION")===1){const v="OES_texture_float",b="OES_texture_half_float";if(this.textureFloatExtension=Yc(this.gl,v),Yd(this.gl,b))this.textureHalfFloatExtension=Yc(this.gl,b);else if(Hn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(p),Yd(this.gl,m))this.colorBufferHalfFloatExtension=Yc(this.gl,m);else if(Hn().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(p="EXT_color_buffer_float",Yd(this.gl,p))this.colorBufferFloatExtension=this.gl.getExtension(p);else if(Yd(this.gl,m))this.colorBufferHalfFloatExtension=this.gl.getExtension(m);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=n8(this.gl),this.indexBuffer=n9(this.gl),this.framebuffer=Yi(this.gl),this.textureConfig=Yy(this.gl,this.textureHalfFloatExtension)}get debug(){return Hn().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const a=this.gl;Ya(a,()=>a.finish()),Ya(a,()=>a.bindFramebuffer(a.FRAMEBUFFER,null)),Ya(a,()=>a.deleteFramebuffer(this.framebuffer)),Ya(a,()=>a.bindBuffer(a.ARRAY_BUFFER,null)),Ya(a,()=>a.bindBuffer(a.ELEMENT_ARRAY_BUFFER,null)),Ya(a,()=>a.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(a,c){return this.throwIfDisposed(),ny(this.gl,a,c,this.textureConfig)}createFloat16MatrixTexture(a,c){return this.throwIfDisposed(),ns(this.gl,a,c,this.textureConfig)}createUnsignedBytesMatrixTexture(a,c){return this.throwIfDisposed(),nE(this.gl,a,c,this.textureConfig)}uploadPixelDataToTexture(a,c){this.throwIfDisposed(),nF(this.gl,a,c)}uploadDenseMatrixToTexture(a,c,p,m){this.throwIfDisposed(),nq(this.gl,a,c,p,m,this.textureConfig)}createFloat16PackedMatrixTexture(a,c){return this.throwIfDisposed(),nZ(this.gl,a,c,this.textureConfig)}createPackedMatrixTexture(a,c){return this.throwIfDisposed(),nO(this.gl,a,c,this.textureConfig)}deleteMatrixTexture(a){this.throwIfDisposed(),this.outputTexture===a&&(Yz(this.gl,this.framebuffer),this.outputTexture=null),Ya(this.gl,()=>this.gl.deleteTexture(a))}downloadByteEncodedFloatMatrixFromOutputTexture(a,c,p){return this.downloadMatrixDriver(a,()=>nn(this.gl,c,p,this.textureConfig))}downloadPackedMatrixFromBuffer(a,c,p,m,v,b){return np(this.gl,a,c,p,m,v,b,this.textureConfig)}downloadFloat32MatrixFromBuffer(a,c){return no(this.gl,a,c)}createBufferFromTexture(a,c,p){this.bindTextureToFrameBuffer(a);const m=nY(this.gl,c,p,this.textureConfig);return this.unbindTextureToFrameBuffer(),m}createAndWaitForFence(){const a=this.createFence(this.gl);return this.pollFence(a)}createFence(a){let c,p;if(Hn().getBool("WEBGL_FENCE_API_ENABLED")){const m=a,v=m.fenceSync(m.SYNC_GPU_COMMANDS_COMPLETE,0);a.flush(),p=()=>{const b=m.clientWaitSync(v,0,0);return b===m.ALREADY_SIGNALED||b===m.CONDITION_SATISFIED},c=v}else Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(c=this.beginQuery(),this.endQuery(),p=()=>this.isQueryAvailable(c,Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):p=()=>!0;return{query:c,isFencePassed:p}}downloadMatrixFromPackedTexture(a,c,p){return this.downloadMatrixDriver(a,()=>nS(this.gl,c,p))}createProgram(a){this.throwIfDisposed();const c=this.gl;this.vertexShader==null&&(this.vertexShader=n7(c));const p=YY(c);Ya(c,()=>c.attachShader(p,this.vertexShader)),Ya(c,()=>c.attachShader(p,a)),Yo(c,p);const m=Object.assign(p,{vao:this.createVertexArray()});return this.debug&&Yn(c,m),m}buildVao(a){this.setProgram(a),this.bindVertexArray(a.vao);const c=this.gl;Ya(c,()=>c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),nL(c,a,this.vertexBuffer)}deleteProgram(a){this.throwIfDisposed(),a===this.program&&(this.program=null),a!=null&&(Ya(this.gl,()=>this.gl.deleteProgram(a)),this.deleteVertexArray(a.vao))}setProgram(a){this.throwIfDisposed(),this.program=a,this.program!=null&&this.debug&&Yn(this.gl,this.program),Ya(this.gl,()=>this.gl.useProgram(a))}getUniformLocation(a,c,p=!0){return this.throwIfDisposed(),p?Yk(this.gl,a,c):Yw(this.gl,a,c)}getAttributeLocation(a,c){return this.throwIfDisposed(),Ya(this.gl,()=>this.gl.getAttribLocation(a,c))}getUniformLocationNoThrow(a,c){return this.throwIfDisposed(),this.gl.getUniformLocation(a,c)}setInputMatrixTexture(a,c,p){this.throwIfDisposed(),this.throwIfNoProgram(),YU(this.gl,a,c,p)}setOutputMatrixTexture(a,c,p){this.setOutputMatrixTextureDriver(a,p,c)}setOutputPackedMatrixTexture(a,c,p){this.throwIfDisposed();const[m,v]=YH(c,p);this.setOutputMatrixTextureDriver(a,m,v)}setOutputMatrixWriteRegion(a,c,p,m){this.setOutputMatrixWriteRegionDriver(p,a,m,c)}setOutputPackedMatrixWriteRegion(a,c,p,m){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Yn(this.gl,this.program),YW(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const a=this.gl;if(this.debug){const c=this.getVertexArray();console.assert(c===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ya(a,()=>a.drawElements(a.TRIANGLES,6,a.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ya(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Yc(this.gl,Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const p=this.gl,m=this.getQueryTimerExtensionWebGL2(),v=p.createQuery();return p.beginQuery(m.TIME_ELAPSED_EXT,v),v}const a=this.getQueryTimerExtensionWebGL1(),c=a.createQueryEXT();return a.beginQueryEXT(a.TIME_ELAPSED_EXT,c),c}endQuery(){if(Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const c=this.gl,p=this.getQueryTimerExtensionWebGL2();c.endQuery(p.TIME_ELAPSED_EXT);return}const a=this.getQueryTimerExtensionWebGL1();a.endQueryEXT(a.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(a){return await M(()=>this.disposed||this.isQueryAvailable(a,Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(a,Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(a,c){if(c===0)return null;if(c===2){const p=this.gl;return p.getQueryParameter(a,p.QUERY_RESULT)/1e6}else{const p=this.getQueryTimerExtensionWebGL1();return p.getQueryObjectEXT(a,p.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(a,c){if(c===0)return!0;if(c===2){const p=this.gl,m=this.getQueryTimerExtensionWebGL2(),v=p.getQueryParameter(a,p.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(m.GPU_DISJOINT_EXT)),v&&!this.disjoint}else{const p=this.getQueryTimerExtensionWebGL1(),m=p.getQueryObjectEXT(a,p.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(p.GPU_DISJOINT_EXT)),m&&!this.disjoint}}pollFence(a){return new Promise(c=>{this.addItemToPoll(()=>a.isFencePassed(),()=>c())})}pollItems(){const a=nh(this.itemsToPoll.map(c=>c.isDoneFn));for(let c=0;c<=a;++c){const{resolveFn:p}=this.itemsToPoll[c];p()}this.itemsToPoll=this.itemsToPoll.slice(a+1)}addItemToPoll(a,c){if(this.itemsToPoll.push({isDoneFn:a,resolveFn:c}),this.itemsToPoll.length>1)return;let p;"setTimeoutCustom"in Hn().platform&&(p=Hn().platform.setTimeoutCustom.bind(Hn().platform)),M(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,p)}bindTextureToFrameBuffer(a){this.throwIfDisposed(),YG(this.gl,a,this.framebuffer),this.debug&&YW(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(YG(this.gl,this.outputTexture,this.framebuffer),this.debug&&YW(this.gl)):Yz(this.gl,this.framebuffer)}downloadMatrixDriver(a,c){this.bindTextureToFrameBuffer(a);const p=c();return this.unbindTextureToFrameBuffer(),p}setOutputMatrixTextureDriver(a,c,p){this.throwIfDisposed();const m=this.gl;YG(m,a,this.framebuffer),this.debug&&YW(m),this.outputTexture=a,Ya(m,()=>m.viewport(0,0,c,p)),Ya(m,()=>m.scissor(0,0,c,p))}setOutputMatrixWriteRegionDriver(a,c,p,m){this.throwIfDisposed(),Ya(this.gl,()=>this.gl.scissor(a,c,p,m))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function nh(u){let a=0;for(;a<u.length&&u[a]();++a);return a-1}function ni(u,a){Array.isArray(u)||(u=[u]),u.forEach(c=>{c!=null&&i(c.dtype!=="complex64",()=>a+" does not support complex64 tensors in the CPU backend.")})}function nm(u){const a=new Float32Array(u.length);for(let c=0;c<u.length;++c)a[c]=Math.abs(u[c]);return a}const nt=u=>{const{x:a}=u.inputs,c=u.backend;ni(a,"abs");let p=new Float32Array(G(a.shape));const m=c.data.get(a.dataId).values;return p=nm(m),c.makeOutput(p,a.shape,a.dtype)},nk={kernelName:Ht,backendName:"cpu",kernelFunc:nt};function nw(u){return(a,c,p,m,v)=>{const b=IP(a,c),w=b.length,S=HD(b),O=G(b),q=e(v,O),H=a.length,j=c.length,$=HD(a),J=HD(c),ee=IV(a,b),re=IV(c,b);if(ee.length+re.length===0)for(let de=0;de<q.length;++de)q[de]=u(p[de%p.length],m[de%m.length]);else for(let de=0;de<q.length;++de){const Te=Hc(de,w,S),Me=Te.slice(-H);ee.forEach(je=>Me[je]=0);const Ae=HO(Me,H,$),Ce=Te.slice(-j);re.forEach(je=>Ce[je]=0);const Pe=HO(Ce,j,J);q[de]=u(p[Ae],m[Pe])}return[q,b]}}function nU(u){const{inputs:a,backend:c}=u,{real:p,imag:m}=a,v=c.data.get(p.dataId).values,b=c.data.get(m.dataId).values,w=c.makeTensorInfo(p.shape,"complex64"),S=c.data.get(w.dataId);return S.complexTensorInfos={real:c.makeTensorInfo(p.shape,"float32",v),imag:c.makeTensorInfo(m.shape,"float32",b)},w}function nG(u,a,c="float32"){if(c==="complex64"){const m=nG(u,a,"float32"),v=nG(u,a,"float32");return nU({inputs:{real:m,imag:v},backend:u})}const p=HE(G(a),c);return u.makeTensorInfo(a,c,p)}function nz(u){const{inputs:a,backend:c}=u,{x:p}=a;return c.incRef(p.dataId),{dataId:p.dataId,shape:p.shape,dtype:p.dtype}}const nW={kernelName:D5,backendName:"cpu",kernelFunc:nz};function nR(u){const{inputs:a,backend:c}=u,{input:p}=a,m=c.data.get(p.dataId).complexTensorInfos.real,v=c.data.get(m.dataId).values;return c.makeTensorInfo(m.shape,m.dtype,v)}function nj(u,a,c,p){if(p==="int32"){const m=Int32Array.from(u);return[a,"int32",m]}if(p==="bool"){const m=yv([0],c),[v,b]=nw((w,S)=>w!==S?1:0)(a,[],u,m,"bool");return[b,"bool",v]}throw new Error("Error in Cast: failed to cast "+c+" to "+p)}function nA(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{dtype:v}=p;if(v==="complex64"){if(m.dtype==="complex64")return nz({inputs:{x:m},backend:c});const q=nG(c,m.shape,m.dtype),H=nA({inputs:{x:m},backend:c,attrs:{dtype:"float32"}}),j=nU({inputs:{real:H,imag:q},backend:c});return c.disposeIntermediateTensorInfo(q),c.disposeIntermediateTensorInfo(H),j}if(m.dtype==="complex64"){const q=nR({inputs:{input:m},backend:c}),H=nA({inputs:{x:q},backend:c,attrs:{dtype:v}});return c.disposeIntermediateTensorInfo(q),H}if(!H2(m.dtype,v)){const q=nz({inputs:{x:m},backend:c});return{dataId:q.dataId,shape:q.shape,dtype:v}}const b=c.data.get(m.dataId).values,[w,S,O]=nj(b,m.shape,m.dtype,v);return c.makeTensorInfo(w,S,O)}const nC={kernelName:HA,backendName:"cpu",kernelFunc:nA};function nu(u,a,c,p){return c==null?({inputs:m,backend:v})=>{const{a:b,b:w}=m,S=v;ni([b,w],u);const O=S.data.get(b.dataId).values,q=S.data.get(w.dataId).values,H=b.dtype==="string"?Lh(O):O,j=b.dtype==="string"?Lh(q):q,$=p||b.dtype,[J,ee]=a(b.shape,w.shape,H,j,$);return S.makeTensorInfo(ee,$,J)}:({inputs:m,backend:v})=>{const{a:b,b:w}=m,S=v;if(b.dtype==="complex64"||w.dtype==="complex64"){const O=nA({inputs:{x:b},backend:S,attrs:{dtype:"complex64"}}),q=S.data.get(O.dataId),H=q.complexTensorInfos.real,j=q.complexTensorInfos.imag,$=S.data.get(H.dataId).values,J=S.data.get(j.dataId).values,ee=nA({inputs:{x:w},backend:S,attrs:{dtype:"complex64"}}),re=S.data.get(ee.dataId),de=re.complexTensorInfos.real,Te=re.complexTensorInfos.imag,Me=S.data.get(de.dataId).values,Ae=S.data.get(Te.dataId).values,[Ce,Pe,je]=c(b.shape,w.shape,$,J,Me,Ae),Ne=S.makeTensorInfo(je,"float32",Ce),Qe=S.makeTensorInfo(je,"float32",Pe),Ct=nU({inputs:{real:Ne,imag:Qe},backend:S});return S.disposeIntermediateTensorInfo(O),S.disposeIntermediateTensorInfo(ee),S.disposeIntermediateTensorInfo(Ne),S.disposeIntermediateTensorInfo(Qe),Ct}else{const O=S.data.get(b.dataId).values,q=S.data.get(w.dataId).values,H=p||b.dtype,[j,$]=a(b.shape,w.shape,O,q,H);return S.makeTensorInfo($,H,j)}}}function nQ(u){return(a,c,p,m,v,b)=>{const w=IP(a,c),S=G(w),O=w.length,q=HD(w),H=e("float32",S),j=e("float32",S),$=IV(a,w),J=IV(c,w),ee=ZT(p,m),re=ZT(v,b),de=a.length,Te=HD(a),Me=c.length,Ae=HD(c);if($.length+J.length===0)for(let Ce=0;Ce<H.length;Ce++){const Pe=Ce%ee.length,je=Ce%re.length,Ne=u(ee[Pe*2],ee[Pe*2+1],re[je*2],re[je*2+1]);H[Ce]=Ne.real,j[Ce]=Ne.imag}else for(let Ce=0;Ce<H.length;Ce++){const Pe=Hc(Ce,O,q),je=Pe.slice(-de);$.forEach(Xt=>je[Xt]=0);const Ne=HO(je,de,Te),Qe=Pe.slice(-Me);J.forEach(Xt=>Qe[Xt]=0);const Ct=HO(Qe,Me,Ae),dt=u(ee[Ne*2],ee[Ne*2+1],re[Ct*2],re[Ct*2+1]);H[Ce]=dt.real,j[Ce]=dt.imag}return[H,j,w]}}const nJ=nw((u,a)=>u+a),nx=nQ((u,a,c,p)=>({real:u+c,imag:a+p})),nM=nu(Hk,nJ,nx),nX={kernelName:Hk,backendName:"cpu",kernelFunc:nM};function ng(u,a,c,p,m){const v=G(p),b=HE(m,c);for(let w=0;w<u.length;w++){const S=u[w];if(S<0)throw new Error("Input x must be non-negative!");S>=m||(v>0?b[S]+=a[w]:b[S]+=1)}return b}function nK(u,a,c,p=!1){const m=u.shape[0],v=u.shape[1],b=fy([m,c],a.dtype);for(let w=0;w<m;w++)for(let S=0;S<v;S++){const O=u.get(w,S);if(O<0)throw new Error("Input x must be non-negative!");O>=c||(p?b.set(1,w,O):a.size>0?b.set(b.get(w,O)+a.get(w,S),w,O):b.set(b.get(w,O)+1,w,O))}return b}const nb=nw((u,a)=>u&a);function nV(u){return(a,c,p)=>{const m=N(c,a.length);for(let v=0;v<a.length;++v)m[v]=u(a[v],p);return m}}function nd(u,a,c){const p=nV(a);return nP(u,p,c)}function nP(u,a,c){return({inputs:p,attrs:m,backend:v})=>{const{x:b}=p;ni(b,u);const w=v,S=w.data.get(b.dataId).values;let O;if(b.dtype==="string"){if(!Array.isArray(S))throw new Error("String tensor's value was not an instance of Array");O=Lh(S)}else O=S;const q=c||b.dtype,H=a(O,q,m);return w.makeTensorInfo(b.shape,q,H)}}const nv=nV(u=>Math.ceil(u));function nT(u,a,c,p){const m=N(c,G(a));if(p&&c!=="string"){let v=0;u.forEach(b=>{const w=G(b.shape);m.set(b.vals,v),v+=w})}else{let v=0;u.forEach(b=>{const w=c==="string"?Lh(b.vals):b.vals;let S=0;for(let O=0;O<b.shape[0];++O){const q=O*a[1]+v;for(let H=0;H<b.shape[1];++H)m[q+H]=w[S++]}v+=b.shape[1]})}return m}const nr=nw((u,a)=>u===a?1:0),ne=nV(u=>Math.exp(u)),nB=nV(u=>Math.expm1(u)),nN=nV(u=>Math.floor(u)),p0=nP(D0,nN),p1={kernelName:D0,backendName:"cpu",kernelFunc:p0},p2=nw((u,a)=>Math.floor(u/a));function p3(u,a,c,p,m,v,b,w,S){const O=fy([p,v],c);for(let q=0;q<p;q++){const H=[];let j=0;for(let $=0;$<m;$++){const J=u[q*m+$];j+=J*b[$],H.push(J)}if(j<0||j>=S/v)throw new Error("Invalid indices: "+H+" does not index into "+w);for(let $=0;$<v;$++)O.values[q*v+$]=a.get(...a.indexToLoc(j*v+$))}return O}function p4(u,a,c){const p=fy(c,u.dtype);for(let m=0;m<p.size;++m){const v=p.indexToLoc(m).slice(),b=v[0],w=v[2],S=a.locToIndex([b,w]);v[2]=a.values[S];const O=u.locToIndex(v);0<=O&&O<u.values.length&&(p.values[m]=u.values[O])}return p}const p5=nw((u,a)=>u>a?1:0),p6=nw((u,a)=>u>=a?1:0),p7=nu(D4,p6,null,"bool"),p8={kernelName:D4,backendName:"cpu",kernelFunc:p7},p9=nw((u,a)=>u<a?1:0),pH=nu(D8,p9,null,"bool"),pD={kernelName:D8,backendName:"cpu",kernelFunc:pH},py=nw((u,a)=>u<=a?1:0),pa=nu(D9,py,null,"bool"),ps={kernelName:D9,backendName:"cpu",kernelFunc:pa};function pI(u,a,c){const p=(a-u)/(c-1),m=HE(c,"float32");m[0]=u;for(let v=1;v<m.length;v++)m[v]=m[v-1]+p;return m}const pE=nV(u=>Math.log(u));function pf(u,a,c,p){const m=e(p,G(c));for(let v=0;v<m.length;++v){const b=v*a;let w=u[b];for(let S=0;S<a;++S){const O=u[b+S];(Number.isNaN(O)||O>w)&&(w=O)}m[v]=w}return m}const pO=nw((u,a)=>Math.max(u,a)),pc=nu(Da,pO),pZ={kernelName:Da,backendName:"cpu",kernelFunc:pc},pL=nw((u,a)=>Math.min(u,a)),pq=nu(Df,pL),pF={kernelName:Df,backendName:"cpu",kernelFunc:pq},pY=nw((u,a)=>u*a),po=nQ((u,a,c,p)=>({real:u*c-a*p,imag:u*p+a*c})),pn=nu(DO,pY,po),pp={kernelName:DO,backendName:"cpu",kernelFunc:pn};function pS(u,a,c){const p=yd(-1,c);return pY([],a,p,u,c)}function pl(u){const{inputs:a,backend:c}=u,{x:p}=a;ni(p,"neg");const m=c.data.get(p.dataId).values,[v,b]=pS(m,p.shape,p.dtype);return c.makeTensorInfo(b,p.dtype,v)}const ph={kernelName:Dc,backendName:"cpu",kernelFunc:pl},pi=nw((u,a)=>u!==a?1:0);function pm(u,a,c,p,m){const v=a.length,b=G(a),w=HD(a),S=HD(m),O=e(c,G(m));for(let q=0;q<b;++q){const H=Hc(q,v,w),j=new Array(H.length);for(let J=0;J<j.length;J++)j[J]=H[p[J]];const $=HO(j,v,S);O[$]=u[q]}return O}function pt(u){const{inputs:a,attrs:c,backend:p}=u,{x:m}=a,{perm:v}=c;ni(m,"transpose");const b=m.shape.length,w=new Array(b);for(let q=0;q<w.length;q++)w[q]=m.shape[v[q]];const S=p.data.get(m.dataId).values,O=pm(S,m.shape,m.dtype,v,w);return{dataId:p.write(O,w,m.dtype),shape:w,dtype:m.dtype}}const pk={kernelName:DX,backendName:"cpu",kernelFunc:pt};function pw(u,a,c,p){const[m,v]=fR(u,p),b=al(a,"int32"),w=HE(G(m),b),S=G(v);for(let O=0;O<w.length;++O){const q=O*S;let H=1;for(let j=0;j<S;++j)H*=c[q+j];w[O]=H}return{outVals:w,outShape:m,outDtype:b}}function pU(u,a,c){u.forEach((p,m)=>{if(p<0||p>=c){const v=Hc(m,a.length,HD(a)).join(",");throw new Error("indices["+v+"] = "+p+" is not in [0, "+c+")")}})}function pG(u,a){for(let c=0;c<u.length;++c){const p=u[c],m=c===u.length-1?a:u[c+1].length;if(p.length===0)throw new Error("Ragged splits may not be empty");if(p[0]<0)throw new Error("Ragged splits must be non-negative");if(p[p.length-1]>m)throw new Error("Ragged splits must not point past values");for(let v=1;v<p.length;++v)if(p[v-1]>p[v])throw new Error("Ragged splits must be sorted in ascending order")}}function pz(u,a,c,p){const m=[];let v=0;const b=a.length-1+c.length,w=new Array(b).fill(null).map(()=>[0]);pG(c,p);let S=1;for(let O=0;O<a.length-1;++O){S*=a[O];const q=a[O+1];for(let H=1;H<S+1;++H)w[O].push(H*q)}for(let O=0;O<u.length;++O){let q=u[O],H=u[O]+1;for(let j=0;j<c.length;++j){const $=c[j],J=j+a.length-1;if(J>=0){const ee=w[J],re=ee[ee.length-1]-$[q];for(let de=q;de<H;++de)w[J].push($[de+1]+re)}q=$[q],H=$[H]}H!==q&&(m.push([q,H]),v+=H-q)}return{outSplits:w,valueSlices:m,numValues:v}}function pW(u){const a=[];for(let c=0;c<u.length;++c){const p=u[c].length,m=N("int32",p);a.push(m),u[c].forEach((v,b)=>m[b]=v)}return a}function pR(u,a){const c=u.slice(0,a);for(;c.length<a;)c.push(1);for(let p=a;p<u.length;p++)c[a-1]*=u[p];return c}function pj(u,a,c,p,m,v){const b=pR(a,2)[1],w=pR(v,2)[1];let S=0;for(const O of c)for(let q=O[0];q<O[1];++q){for(let H=0;H<p;++H)m[S*w+H]=u[q*b+H];++S}}function pA(u,a,c,p,m){const v=a.slice();v[0]=m;const b=N(c,G(v)),w=u.length,S=w===0?0:w/a[0];return pj(u,a,p,S,b,v),[b,v]}function pC(u,a,c,p,m,v,b,w){if(u.length===0)throw new Error("paramsNestedSplits must be non empty");if(a[0].length===0)throw new Error("Split tensors must not be scalars");const S=a[0][0]-1;if(pU(v,b,S),p.length===0)throw new Error("params.rank must be nonzero");const O=p[0],{outSplits:q,valueSlices:H,numValues:j}=pz(v,b,u,O),$=pW(q),J=pA(c,p,m,H,j);return[$,J[0],J[1]]}const pu=2147483647;function pQ(u,a,c,p,m,v,b){if(a.length>1)throw new Error("starts must be a scalar or vector");if(m.length>1)throw new Error("limits must be a scalar or vector");if(b.length>1)throw new Error("deltas must be a scalar or vector");const w=a.length===0,S=m.length===0,O=b.length===0,q=[];w||q.push(a[0]),S||q.push(m[0]),O||q.push(b[0]);for(let re=1;re<q.length;++re)if(q[re]!==q[re-1])throw new Error("starts, limits, and deltas must have the same shape");const H=q.length===0?1:q[0],j=N("int32",H+1);j[0]=0;for(let re=0;re<H;++re){const de=w?u[0]:u[re],Te=S?p[0]:p[re],Me=O?v[0]:v[re];if(Me===0)throw new Error("Requires delta != 0");let Ae;if(Me>0&&Te<de||Me<0&&Te>de)Ae=0;else if(Ae=Math.ceil(Math.abs((Te-de)/Me)),Ae>pu)throw new Error("Requires ((limit - start) / delta) <= "+pu);j[re+1]=j[re]+Ae}const $=j[H],J=N(c,$);let ee=0;for(let re=0;re<H;++re){const de=j[re+1]-j[re];let Te=w?u[0]:u[re];const Me=O?v[0]:v[re];for(let Ae=0;Ae<de;++Ae)J[ee++]=Te,Te+=Me}return[j,J]}var pJ=ZU;class px{constructor(a,c,p,m,v,b,w,S,O,q){this.shape=a,this.shapeShape=c,this.values=p,this.valuesShape=m,this.valuesDType=v,this.defaultValue=b,this.defaultValueShape=w,this.rowPartitionValues=S,this.rowPartitionValuesShapes=O,this.rowPartitionTypes=Zz(q),this.raggedRank=ZW(this.rowPartitionTypes)}getRowPartitionTypeByDimension(a){return this.rowPartitionTypes[0]===pJ.FIRST_DIM_SIZE?this.rowPartitionTypes[a+1]:this.rowPartitionTypes[a]}getRowPartitionTensor(a){return this.rowPartitionTypes[0]===pJ.FIRST_DIM_SIZE?this.rowPartitionValues[a+1]:this.rowPartitionValues[a]}getMaxWidth(a){const c=this.getRowPartitionTensor(a-1);switch(this.getRowPartitionTypeByDimension(a-1)){case pJ.VALUE_ROWIDS:return px.getMaxWidthValueRowID(c);case pJ.ROW_SPLITS:return px.getMaxWidthRowSplit(c);default:throw new Error("Cannot handle partition type "+pJ[this.getRowPartitionTypeByDimension(a-1)])}}static getMaxWidthRowSplit(a){const c=a.length;if(c===0||c===1)return 0;let p=0;for(let m=0;m<c-1;++m){const v=a[m+1]-a[m];v>p&&(p=v)}return p}static getMaxWidthValueRowID(a){const c=a.length;if(c===0)return 0;let p=0,m=a[0],v=0;for(let b=1;b<c;++b){const w=a[b];w!==m&&(m=w,v=Math.max(b-p,v),p=b)}return Math.max(c-p,v)}tensorShapeFromTensor(a,c,p=!0){if(c.length===0){if(a[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return pX(a,p)}calculateOutputSize(a){const c=this.valuesShape,p=this.defaultValueShape;ZR(p,c);const m=this.tensorShapeFromTensor(this.shape,this.shapeShape),v=ZG(this.raggedRank,m,c);v[0]<0&&(v[0]=a);for(let b=1;b<=this.raggedRank;++b)v[b]<0&&(v[b]=this.getMaxWidth(b));return v}calculateFirstParentOutputIndex(a,c,p){const m=Math.min(a,p),v=[];let b=0;for(let w=0;w<m;++w,b+=c)v.push(b);for(let w=m;w<a;++w)v.push(-1);return i(v.length===a,()=>"Final length of result must be equal to firstDimension."),v}calculateOutputIndexRowSplit(a,c,p,m){const v=a.length,b=[];for(let w=0;w<v-1;++w){const S=a[w+1]-a[w];let O=Math.min(m,S),q=c[w];q===-1&&(O=0);for(let H=0;H<O;++H)b.push(q),q+=p;for(let H=0;H<S-O;++H)b.push(-1)}if(v>0&&b.length!==a[v-1])throw new Error("Invalid row split size.");return b}calculateOutputIndexValueRowID(a,c,p,m){const v=a.length,b=[];if(v===0)return[];let w=0,S=a[0];if(S>=c.length)throw new Error("Got currentValueRowId="+S+", which is not less than "+c.length);let O=c[S];b.push(O);for(let q=1;q<v;++q){const H=a[q];if(H===S)O>=0&&(++w,w<m?O+=p:O=-1);else{if(w=0,S=H,H>=c.length)throw new Error("Got nextValueRowId="+H+" which is not less than "+c.length);O=c[H]}b.push(O)}if(b.length!==a.length)throw new Error("Invalid row ids.");return b}calculateOutputIndex(a,c,p,m){const v=this.getRowPartitionTensor(a),b=this.getRowPartitionTypeByDimension(a);switch(b){case pJ.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(v,c,p,m);case pJ.ROW_SPLITS:if(v.length-1>c.length)throw new Error("Row partition size is greater than output size: "+(v.length-1)+" > "+c.length);return this.calculateOutputIndexRowSplit(v,c,p,m);default:throw new Error("Unsupported partition type: "+pJ[b])}}getFirstDimensionSize(){const a=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const c=this.rowPartitionTypes[0];switch(c){case pJ.FIRST_DIM_SIZE:return a[0];case pJ.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case pJ.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+pJ[c])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const a=this.getFirstDimensionSize(),c=this.calculateOutputSize(a),p=new Array(this.raggedRank+1);p[p.length-1]=1;for(let b=p.length-2;b>=0;--b)p[b]=p[b+1]*c[b+1];const m=pX(c,!1),v=N(this.valuesDType,G(m));if(p[0]*c[0]>0){let b=this.calculateFirstParentOutputIndex(a,p[0],c[0]);for(let w=1;w<=this.raggedRank;++w)b=this.calculateOutputIndex(w-1,b,p[w],c[w]);this.setOutput(this.raggedRank,b,v,m)}return[m,v]}setOutput(a,c,p,m){if(p.length===0)return;const v=this.values,b=p;let w=m.slice();w=w.slice(a+1);const S=G(w),O=c.length;let q=this.defaultValue;if(q.length!==S&&q.length!==1){const J=this.defaultValueShape;s2(()=>{const ee=ET(q,J);q=fD(ee,w).dataSync()})}let H=0,j=0,$=0;for(let J=0;J<=O;++J){let ee=J<O?c[J]:-1;if(ee===$){++$;continue}if(j<$){const re=v.subarray(H*S),de=b.subarray(j*S),Te=($-j)*S;pM(de,re,Te)}if(J>=O){const re=p.length;ee=Math.floor(re/S)}if(ee>$)if(this.defaultValue.length===1)b.subarray($*S,ee*S).fill(this.defaultValue[0]),$=ee;else for(;ee>$;){const re=b.slice($*S);pM(re,q,S),++$}ee<0?(H=J+1,j=$):(H=J,j=$,$=j+1)}}}function pM(u,a,c){for(let p=0;p<c;p++)u[p]=a[p]}function pX(u,a){const c=[];for(let p of u){if(p<0){if(!a)throw new Error("Dimension "+p+" must be >= 0");if(p<-1)throw new Error("Dimension "+p+" must be >= -1");p=-1}c.push(p)}return c}function pg(u,a,c,p,m,v,b,w,S,O){return new px(u,a,c,p,m,v,b,w,S,O).compute()}function pK(u,a,c,p){const m=u===a,v=u<a&&c<0,b=a<u&&c>1;if(m||v||b)return HE(0,p);const w=Math.abs(Math.ceil((a-u)/c)),S=HE(w,p);a<u&&c===1&&(c=-1),S[0]=u;for(let O=1;O<S.length;O++)S[O]=S[O-1]+c;return S}const pb=nV(u=>1/Math.sqrt(u));function pV(u,a,c,p,m,v,b,w,S,O){const q=[p/m,m],H=u.values,j=a.values;if(p===0)return fy(c,a.dtype);const $=S instanceof as?S:fy(q,a.dtype);typeof S=="string"||typeof S=="number"?$.values.fill(S):typeof S=="boolean"&&$.values.fill(+S);for(let J=0;J<v;J++){const ee=[];let re=0;for(let de=0;de<b;de++){const Te=H[J*b+de];ee.push(Te),re+=Te*w[de]}if(re<0||re>=p/m)throw new Error("Invalid indices: "+ee+" does not index into "+c);for(let de=0;de<m;de++)O?$.values[re*m+de]+=j[J*m+de]:$.values[re*m+de]=a.rank===0?j[0]:j[J*m+de]}return $}const pd=nV(u=>1/(1+Math.exp(-u))),pP=nd(DW,u=>1/(1+Math.exp(-u))),pv={kernelName:DW,backendName:"cpu",kernelFunc:pP};function pT(u,a,c,p,m){const v=EE(p,a,c),b=G(c),w=HD(p);if(v){const H=Ef(a,w);return m==="string"?u.slice(H,H+b):u.subarray(H,H+b)}const S=m==="string"?Lh(u):u,O=fy(p,m,S),q=fy(c,m);for(let H=0;H<q.size;++H){const j=q.indexToLoc(H),$=j.map((J,ee)=>J+a[ee]);q.set(O.get(...$),...j)}return m==="string"?Li(q.values):q.values}function pr(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{begin:v,size:b}=p;ni(m,"slice");const[w,S]=EO(m,v,b);E4(m,w,S);const O=c.data.get(m.dataId).values,q=pT(O,w,S,m.shape,m.dtype);return c.makeTensorInfo(S,m.dtype,q)}const pe={kernelName:DG,backendName:"cpu",kernelFunc:pr};function pB(u,a,c,p,m,v,b){const w=a[0],S=v[0],O=new Array(S),q=new Array(w),H=a[1];if(S===0){if(w!==0)throw new Error(Ls(w));const re=N(c,0),de=N(m,0);return[re,[0,H],de,O,q]}let j=!0,$=0;const J=new Array(S).fill(0);for(let re=0;re<w;++re){const de=u[re*H];if(de<0)throw new Error(LI(re,de));if(de>=S)throw new Error(LE(re,de,S));++J[de],j=j&&de>=$,$=de}let ee=!0;for(let re=0;re<S;++re){const de=J[re]===0;O[re]=de,ee=ee&&!de,J[re]=Math.max(J[re],1),re>0&&(J[re]+=J[re-1])}if(ee&&j){const re=u,de=p;for(let Te=0;Te<w;++Te)q[Te]=Te;return[re,[w,H],de,O,q]}else{const re=J[S-1],de=N(c,re*H),Te=N(m,re),Me=new Array(S).fill(0);for(let Ae=0;Ae<w;++Ae){const Ce=u[Ae*H],Pe=Me[Ce],je=(Ce===0?0:J[Ce-1])+Pe;Me[Ce]++;for(let Ne=0;Ne<H;++Ne)de[je*H+Ne]=u[Ae*H+Ne];Te[je]=p[Ae],q[Ae]=je}for(let Ae=0;Ae<S;++Ae)if(Me[Ae]===0){const Ce=Ae===0?0:J[Ae-1];de[Ce*H+0]=Ae;for(let Pe=1;Pe<H;++Pe)de[Ce*H+Pe]=0;Te[Ce]=b}return[de,[re,H],Te,O,q]}}function pN(u,a,c,p,m){const v=G(p),b=a[0],w=m.length,S=[];let O=1,q=-1;for(let ee=0;ee<w;++ee){const re=m[ee];if(re===-1){if(q!==-1)throw new Error(Lf(q,ee));q=ee,S.push(1)}else{if(re<0)throw new Error(LO(ee,re));O*=re,S.push(re)}}if(q!==-1){if(O<=0)throw new Error(Lc());const ee=Math.trunc(v/O);if(O*ee!==v)throw new Error(LZ(p,S));S[q]=ee}if(G(S)!==v)throw new Error(LL(p,S));const H=p.length,j=[];if(H>0){j[H-1]=1;for(let ee=H-2;ee>=0;--ee)j[ee]=j[ee+1]*p[ee+1]}const $=[];if(w>0){$[w-1]=1;for(let ee=w-2;ee>=0;--ee)$[ee]=$[ee+1]*S[ee+1]}const J=N(c,b*w);for(let ee=0;ee<b;++ee){let re=0;for(let de=0;de<H;++de)re+=u[ee*H+de]*j[de];for(let de=0;de<w;++de)J[ee*w+de]=Math.trunc(re/$[de]),re%=$[de]}return[J,[b,w],S]}function S0(u,a,c,p,m,v=!1,b=0){const w=p.length,S=[a[0],u.length/a[0]],O=S[1],q=w>0?m[w-1]+1:0;if(q<0)throw new Error(Lq());const H=a.slice();H[0]=q;const j=H.reduce((Te,Me)=>Te*Me,1),$=N(c,j);if(w===0)return q>0&&$.fill(b),[$,H];if(q<=0)throw new Error(Lq());let J=0,ee=1,re=0,de=m[J];for(;;){let Te=0;if(ee<w){if(Te=m[ee],de===Te){++ee;continue}if(de>=Te)throw new Error(LF())}if(de<0||de>=q)throw new Error(LY(de,q));de>re&&$.fill(b,re*O,de*O);for(let Me=J;Me<ee;++Me){const Ae=p[Me];if(Ae<0||Ae>=S[0])throw new Error(Lo(Me,p[Me],S[0]));for(let Ce=0;Ce<O;Ce++)$[de*O+Ce]+=u[Ae*O+Ce]}if(v)for(let Me=0;Me<O;Me++)$[de*O+Me]/=ee-J;if(J=ee,++ee,re=de+1,de=Te,ee>w)break}return re<q&&$.fill(b,re*O,q*O),[$,H]}const S1=nV(u=>Math.sqrt(u)),S2=nd(DR,u=>Math.sqrt(u)),S3={kernelName:DR,backendName:"cpu",kernelFunc:S2},S4=nw((u,a)=>{const c=u-a;return c*c}),S5=nV((u,a)=>{const{pattern:c,replaceGlobal:p,rewrite:m}=a;return u.replace(new RegExp(c,p?"g":""),m)});function S6(u,a,c,p){const m=fy(u,a.dtype);for(let v=0;v<m.size;v++){const b=m.indexToLoc(v),w=new Array(b.length);for(let S=0;S<w.length;S++)w[S]=b[S]*c[S]+p[S];m.set(a.get(...w),...b)}return m}class S7{constructor(a,c,p,m,v,b){this.separator=yr(a),this.nGramWidths=c,this.leftPad=yr(p),this.rightPad=yr(m),this.padWidth=v,this.preserveShort=b}getPadWidth(a){return Math.min(this.padWidth<0?a-1:this.padWidth,a-1)}getNumNGrams(a,c){const p=this.getPadWidth(c);return Math.max(0,a+2*p-c+1)}createNGrams(a,c,p,m,v,b){for(let w=0;w<v;++w){const S=this.getPadWidth(b),O=Math.max(0,S-w),q=Math.max(0,S-(v-(w+1))),H=b-(O+q),j=c+(O>0?0:w-S);let $=0;$+=O*this.leftPad.length;for(let Te=0;Te<H;++Te)$+=a[j+Te].length;$+=q*this.rightPad.length;const J=O+q+H-1;$+=J*this.separator.length,p[m+w]=new Uint8Array($);const ee=p[m+w];let re=0;const de=Te=>Te.forEach(Me=>ee[re++]=Me);for(let Te=0;Te<O;++Te)de(this.leftPad),de(this.separator);for(let Te=0;Te<H-1;++Te)de(a[j+Te]),de(this.separator);if(H>0){de(a[j+H-1]);for(let Te=0;Te<q;++Te)de(this.separator),de(this.rightPad)}else{for(let Te=0;Te<q-1;++Te)de(this.rightPad),de(this.separator);de(this.rightPad)}}}compute(a,c){const p=a.length,m=c.length;if(m>0){let S=c[0];if(S!==0)throw new Error("First split value must be 0, got "+S);for(let O=1;O<m;++O){let q=c[O]>=S;if(q=q&&c[O]<=p,!q)throw new Error("Invalid split value "+c[O]+", must be in ["+S+", "+p+"]");S=c[O]}if(S!==p)throw new Error("Last split value must be data size. Expected "+p+", got "+S)}const v=m-1,b=N("int32",m);if(p===0||m===0){const S=new Array(p);for(let O=0;O<=v;++O)b[O]=0;return[S,b]}b[0]=0;for(let S=1;S<=v;++S){const O=c[S]-c[S-1];let q=0;this.nGramWidths.forEach(H=>{q+=this.getNumNGrams(O,H)}),this.preserveShort&&O>0&&q===0&&(q=1),b[S]=b[S-1]+q}const w=new Array(b[v]);for(let S=0;S<v;++S){const O=c[S];let q=b[S];if(this.nGramWidths.forEach(H=>{const j=c[S+1]-c[S],$=this.getNumNGrams(j,H);this.createNGrams(a,O,w,q,$,H),q+=$}),this.preserveShort&&q===b[S]){const H=c[S+1]-c[S];if(H===0)continue;const j=H+2*this.padWidth,$=1;this.createNGrams(a,O,w,q,$,j)}}return[w,b]}}function S8(u,a,c,p,m,v,b,w){return new S7(c,p,m,v,b,w).compute(u,a)}function S9(u,a,c,p){if(!u.length)return;if(a.length===0){for(let v=0;v<u.length;++v)p.push(u.subarray(v,v+1));return}if(a.length===1){const v=a[0];let b=u.indexOf(v);for(;b!==-1;){const w=u.subarray(0,b);(!c||w.length!==0)&&p.push(w),u=u.subarray(b+1),b=u.indexOf(v)}(!c||u.length!==0)&&p.push(u);return}let m=0;for(let v=0;v<u.length+1;v++)if(v===u.length||a.indexOf(u[v])!==-1){const b=u.subarray(m,v);(!c||b.length!==0)&&p.push(b),m=v+1}}function SH(u,a,c){const p=u.length,m=[];let v=0,b=0;const w=new Array(p);for(let j=0;j<p;++j){const $=m.length;S9(u[j],a,c,m);const J=m.length-$;w[j]=J,v+=J,b=Math.max(b,J)}const S=N("int32",v*2),O=new Array(v),q=[p,b];let H=0;for(let j=0;j<p;++j)for(let $=0;$<w[j];++$)S[H*2]=j,S[H*2+1]=$,O[H]=m[H],++H;return[S,O,q]}function SD(u,a){const c=N("int32",u.length);for(let p=0;p<u.length;++p)c[p]=yV(u[p]).modulo(a).getLowBitsUnsigned();return c}const Sy=nw((u,a)=>u-a),Sa=nQ((u,a,c,p)=>({real:u-c,imag:a-p})),Ss=nu(DJ,Sy,Sa),SI={kernelName:DJ,backendName:"cpu",kernelFunc:Ss};function SE(u,a){const c=new Array(u.rank);for(let m=0;m<c.length;m++)c[m]=u.shape[m]*a[m];const p=fy(c,u.dtype);for(let m=0;m<p.values.length;++m){const v=p.indexToLoc(m),b=new Array(u.rank);for(let S=0;S<b.length;S++)b[S]=v[S]%u.shape[S];const w=u.locToIndex(b);p.values[m]=u.values[w]}return p}const Sf=(u,a)=>{const c=a.value-u.value;return c===0?u.index-a.index:c};function SO(u,a,c=0,p=u.length-1){for(;p>c;){if(p-c>600){const w=p-c+1,S=a-c+1,O=Math.log(w),q=.5*Math.exp(2*O/3),H=.5*Math.sqrt(O*q*(w-q)/w)*Math.sign(S-w/2),j=Math.max(c,Math.floor(a-S*q/w+H)),$=Math.min(p,Math.floor(a+(w-S)*q/w+H));SO(u,a,j,$)}const m=u[a];let v=c,b=p;for(l(u,c,a),Sf(u[p],m)>0&&l(u,c,p);v<b;){for(l(u,v,b),v++,b--;Sf(u[v],m)<0;)v=v+1;for(;Sf(u[b],m)>0;)b=b-1}Sf(u[c],m)===0?l(u,c,b):(b=b+1,l(u,b,p)),b<=a&&(c=b+1),a<=b&&(p=b-1)}}function Sc(u,a,c,p,m){const v=a[a.length-1],[b,w]=[u.length/v,v],S=e(c,b*p),O=e("int32",b*p);for(let H=0;H<b;H++){const j=H*w,$=u.subarray(j,j+w);let J=new Array($.length);$.forEach((Te,Me)=>J[Me]={value:Te,index:Me}),p<J.length&&(SO(J,p),J=J.slice(0,p)),m&&J.sort(Sf);const ee=H*p,re=S.subarray(ee,ee+p),de=O.subarray(ee,ee+p);for(let Te=0;Te<p;Te++)re[Te]=J[Te].value,de[Te]=J[Te].index}const q=a.slice();return q[q.length-1]=p,[fy(q,c,S),fy(q,"int32",O)]}function SZ(u,a,c,p){const m=P(a,c)[0],v=[1,c[0],1];for(let J=0;J<m;J++)v[0]*=c[J];v[1]=c[m];for(let J=m+1;J<c.length;J++)v[2]*=c[J];const b=new Map,w=new Int32Array(c[m]),S=new as(v,p,u),O=[],q=v[0]===1&&v[2]===1;for(let J=0;J<c[m];J++){let ee;if(q)ee=u[J].toString();else{const de=[];for(let Te=0;Te<v[0];Te++)for(let Me=0;Me<v[2];Me++)de.push(S.get(Te,J,Me));ee=de.join(",")}const re=b.get(ee);if(re!=null)w[J]=re;else{const de=b.size;b.set(ee,de),w[J]=de,O.push(J)}}const H=v.slice();H[1]=b.size;const j=new as(H,p);O.forEach((J,ee)=>{for(let re=0;re<v[0];re++)for(let de=0;de<v[2];de++)j.set(S.get(re,J,de),re,ee,de)});const $=c.slice();return $[m]=H[1],{outputValues:j.values,outputShape:$,indices:w}}var SL=Object.freeze({__proto__:null,addImpl:nJ,bincountImpl:ng,bincountReduceImpl:nK,bitwiseAndImpl:nb,castImpl:nj,ceilImpl:nv,concatImpl:nT,equalImpl:nr,expImpl:ne,expm1Impl:nB,floorDivImpl:p2,floorImpl:nN,gatherNdImpl:p3,gatherV2Impl:p4,greaterEqualImpl:p6,greaterImpl:p5,lessEqualImpl:py,lessImpl:p9,linSpaceImpl:pI,logImpl:pE,maxImpl:pf,maximumImpl:pO,minimumImpl:pL,multiplyImpl:pY,negImpl:pS,notEqualImpl:pi,prodImpl:pw,raggedGatherImpl:pC,raggedRangeImpl:pQ,raggedTensorToTensorImpl:pg,rangeImpl:pK,rsqrtImpl:pb,scatterImpl:pV,sigmoidImpl:pd,simpleAbsImpl:nm,sliceImpl:pT,sparseFillEmptyRowsImpl:pB,sparseReshapeImpl:pN,sparseSegmentReductionImpl:S0,sqrtImpl:S1,squaredDifferenceImpl:S4,staticRegexReplaceImpl:S5,stridedSliceImpl:S6,stringNGramsImpl:S8,stringSplitImpl:SH,stringToHashBucketFastImpl:SD,subImpl:Sy,tileImpl:SE,topKImpl:Sc,transposeImpl:pm,uniqueImpl:SZ});const{addImpl:Sq,bincountImpl:SF,bincountReduceImpl:SY,bitwiseAndImpl:So,castImpl:Sn,ceilImpl:Sp,concatImpl:SS,equalImpl:Sl,expImpl:Sh,expm1Impl:Si,floorImpl:Sm,gatherNdImpl:St,gatherV2Impl:Sk,greaterImpl:Sw,greaterEqualImpl:SU,lessImpl:SG,lessEqualImpl:Sz,linSpaceImpl:SW,logImpl:SR,maxImpl:Sj,maximumImpl:SA,minimumImpl:SC,multiplyImpl:Su,negImpl:SQ,notEqualImpl:SJ,prodImpl:Sx,raggedGatherImpl:SM,raggedRangeImpl:SX,raggedTensorToTensorImpl:Sg,rangeImpl:SK,rsqrtImpl:Sb,scatterImpl:SV,sigmoidImpl:Sd,simpleAbsImpl:SP,sliceImpl:Sv,sparseFillEmptyRowsImpl:ST,sparseReshapeImpl:Sr,sparseSegmentReductionImpl:Se,sqrtImpl:SB,staticRegexReplaceImpl:SN,stridedSliceImpl:l0,stringNGramsImpl:l1,stringSplitImpl:l2,stringToHashBucketFastImpl:l3,subImpl:l4,tileImpl:l5,topKImpl:l6,transposeImpl:l7,uniqueImpl:l8}=SL;function l9(u,a){return["x","y","z","w","u","v"].slice(0,a).map(c=>u+"."+c)}function lH(u,a){return a===1?[u]:l9(u,a)}function lD(u,a){if(u===1)return"rc";let c="";for(let p=0;p<u;p++)c+=a[p],p<u-1&&(c+=",");return c}class ly{constructor(a){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=a,this.rank=a.length,this.enableShapeUniforms=oN(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const c=lH("rc",this.rank),p=ob(this.rank),m=this.getOutOfBoundsCondition(c),v=this.getSetup(c),b=this.getOutput(c);this.userCode=`
        void main() {
          `+p+` rc = getOutputCoords();

          if(`+m+`) {
            setOutput(vec4(0));
          } else {
            `+v+`

            setOutput(vec4(`+b+`));
          }
        }
      `}}getSourceCoordsArr(a){const c=[];for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){let v=(p===0?"r":"rp1")+", "+(m===0?"c":"cp1");for(let b=2;b<this.rank;b++)v=a[a.length-1-b]+","+v;c.push(v)}return c}getOutOfBoundsCondition(a){if(this.rank===1)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let c="";for(let p=this.rank-2;p<this.rank;p++)c+=a[p]+" >= "+(this.enableShapeUniforms?"outShape["+p+"]":this.outputShape[p]),p<this.rank-1&&(c+="||");return c}getSetup(a){if(this.rank===1)return"";const c=a.slice(-2),p=this.enableShapeUniforms?"outShape["+this.rank+" - 1]":this.outputShape[this.rank-1],m=this.enableShapeUniforms?"outShape["+this.rank+" - 2]":this.outputShape[this.rank-2];return`
      int r = `+c[0]+`;
      int c = `+c[1]+`;
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= `+p+`;
      bool rEdge = rp1 >= `+m+`;
    `}getOutput(a){const c=this.getSourceCoordsArr(a);return this.rank===1?"getA(rc), (rc + 1 >= "+(this.enableShapeUniforms?"outShape":this.outputShape[0])+" ? 0. : getA(rc + 1)), 0, 0":"getA("+c[0]+`),
            cEdge ? 0. : getA(`+c[1]+`),
            rEdge ? 0. : getA(`+c[2]+`),
            rEdge || cEdge ? 0. : getA(`+c[3]+")"}}class la{constructor(a,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length);let p="";for(let m=0;m<4;m++){let v="thisRC = rc;";m%2===1&&(v+="thisRC.z += 1;"),m>1&&(v+="thisRC.y += 1;"),p+=`
        `+v+`
        `+(m>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+m+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(m>0?"}":"")+`
      `}this.userCode=`
      `+ls(c,this.enableShapeUniforms)+`
      `+(this.enableShapeUniforms?o7():o6(a))+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+(this.enableShapeUniforms?"outShape[1]":a[1])+`;
        int cols = `+(this.enableShapeUniforms?"outShape[2]":a[2])+`;

        `+p+`

        setOutput(result);
      }
    `}}function ls(u,a){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+(a?o5(["r","c","d"],"inputShape"):o2(["r","c","d"],u))+`
      return ivec3(r, c, d);
    }
  `}class lI{constructor(a){this.gpgpu=a,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(a,c,p){const m=lZ(c,p),v=lL(a,m,p);v in this.freeTextures||(this.freeTextures[v]=[]),v in this.usedTextures||(this.usedTextures[v]=[]);const b=lf(a,m,this.gpgpu.gl,this.gpgpu.textureConfig,p);if(this.freeTextures[v].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=b,this.log();const S=this.freeTextures[v].pop();return this.usedTextures[v].push(S),S}let w;return m===Y6.PACKED_2X2_FLOAT32?w=this.gpgpu.createPackedMatrixTexture(a[0],a[1]):m===Y6.PACKED_2X2_FLOAT16?w=this.gpgpu.createFloat16PackedMatrixTexture(a[0],a[1]):m===Y6.UNPACKED_FLOAT32?w=this.gpgpu.createFloat32MatrixTexture(a[0],a[1]):m===Y6.UNPACKED_FLOAT16?w=this.gpgpu.createFloat16MatrixTexture(a[0],a[1]):m===Y6.PACKED_4X1_UNSIGNED_BYTE&&(w=this.gpgpu.createUnsignedBytesMatrixTexture(a[0],a[1])),this.usedTextures[v].push(w),this.numUsedTextures++,this._numBytesAllocated+=b,this.log(),w}releaseTexture(a,c,p,m){if(this.freeTextures==null)return;const v=lZ(p,m),b=lL(c,v,m);b in this.freeTextures||(this.freeTextures[b]=[]);const w=lf(c,v,this.gpgpu.gl,this.gpgpu.textureConfig,m),S=Hn().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");S!==-1&&this._numBytesAllocated>S?(this.gpgpu.deleteMatrixTexture(a.texture),this._numBytesAllocated-=w):(this.freeTextures[b].push(a),this.numFreeTextures++,this._numBytesFree+=w),this.numUsedTextures--;const O=this.usedTextures[b],q=O&&O.indexOf(a);if(q==null||q<0)throw new Error("Cannot release a texture that was never provided by this texture manager");O[q]=O[O.length-1],O.pop(),this.log()}log(){if(!this.logEnabled)return;const a=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+a+")");const c=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*c)+"%)")}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const a in this.freeTextures)this.freeTextures[a].forEach(c=>{this.gpgpu.deleteMatrixTexture(c.texture)});for(const a in this.usedTextures)this.usedTextures[a].forEach(c=>{this.gpgpu.deleteMatrixTexture(c.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function lE(u,a){const c=u;if(a===c.R32F)return 4;if(a===c.R16F)return 2;if(a===c.RGBA32F||a===u.RGBA)return 16;if(a===c.RGBA16F)return 8;if(a===c.RGBA8)return 4;throw new Error("Unknown internal format "+a)}function lf(u,a,c,p,m){const v=lO(a,p);let b;if(m){const[S,O]=YH(u[0],u[1]);b=S*O}else{const[S,O]=Y7(u[0],u[1]);b=S*O}const w=lE(c,v);return b*w}function lO(u,a){switch(u){case Y6.PACKED_2X2_FLOAT32:return nf(a);case Y6.PACKED_2X2_FLOAT16:return nc(a);case Y6.UNPACKED_FLOAT32:return nD(a);case Y6.UNPACKED_FLOAT16:return na(a);case Y6.PACKED_4X1_UNSIGNED_BYTE:return nI(a);default:throw new Error("Unknown physical texture type "+u)}}function lc(u){return Hn().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?u?Y6.PACKED_2X2_FLOAT32:Y6.UNPACKED_FLOAT32:u?Y6.PACKED_2X2_FLOAT16:Y6.UNPACKED_FLOAT16}function lZ(u,a){if(u===Y5.UPLOAD)return Y6.PACKED_2X2_FLOAT32;if(u===Y5.RENDER||u==null)return lc(a);if(u===Y5.DOWNLOAD||u===Y5.PIXELS)return Y6.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+u)}function lL(u,a,c){return u[0]+"_"+u[1]+"_"+a+"_"+c}class lq{constructor(a,c){this.variableNames=["A"],this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        `+c+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const lF="if (isnan(x)) return x;",lY="return x;",lo="return abs(x);",ln="return (x >= 0.0) ? x : (exp(x) - 1.0);",lp=lF+`
  return (x < 0.0) ? 0.0 : x;
`,lS=lF+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ll="return x;",lh="return 1.0 / (1.0 + exp(-1.0 * x));",li="return x;",lm=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,lt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lk=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lw="return 1.0 / (1.0 + exp(-1.0 * x));";class lU{constructor(a,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+c+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class lG{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length);const c=a.length,p=lH("rc",c),m=ob(c),v=lD(c,p),b=p.slice(-2),w=c<=1?"rc":"vec2("+b.join(",")+")";this.userCode=`
      void main() {
        `+m+` rc = getOutputCoords();
        vec4 packedInput = getA(`+v+`);

        setOutput(getChannel(packedInput, `+w+`));
      }
    `}}const lz=cm,lW=1e-7,lR=1e-4,lj={};function lA(u){return u in lj||(lj[u]={}),lj[u]}const lC=Hn().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),lu=600;function lQ(){return Hn().global.screen==null?1024:Hn().global.screen.height*Hn().global.screen.width*window.devicePixelRatio*lu/1024/1024}class lJ extends L{nextDataId(){return lJ.nextDataId++}constructor(a){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Hn().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let c;if(a!=null){if(a instanceof nl)c=a;else{const p=Y1(Hn().getNumber("WEBGL_VERSION"),a);c=new nl(p)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const p=Y1(Hn().getNumber("WEBGL_VERSION"));c=new nl(p),this.binaryCache=lA(Hn().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=c,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new lI(this.gpgpu),this.numMBBeforeWarning=lQ(),this.texData=new Z(this,s1())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(a,c,p,m,v,b){const w=this.makeTensorInfo(c,p),S=this.texData.get(w.dataId);S.isPacked=!1,S.texture={texture:a,texShape:[m,v]},S.texShape=[m,v];const O=YQ(c),q=new n5(O,!1,b),H=this.runWebGLProgram(q,[w],p,[[m,v]]);return H.shape=c,S.texture=null,this.disposeIntermediateTensorInfo(w),H.dataId}write(a,c,p){if((Hn().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Hn().getBool("DEBUG"))&&this.checkNumericalProblems(a),p==="complex64"&&a!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const m={id:this.nextDataId()};return this.texData.set(m,{shape:c,dtype:p,values:a,usage:Y5.UPLOAD,refCount:1}),m}refCount(a){return this.texData.has(a)?this.texData.get(a).refCount:0}incRef(a){const c=this.texData.get(a);c.refCount++}decRef(a){if(this.texData.has(a)){const c=this.texData.get(a);c.refCount--}}move(a,c,p,m,v){if(Hn().getBool("DEBUG")&&this.checkNumericalProblems(c),m==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(a,{shape:p,dtype:m,values:c,usage:Y5.UPLOAD,refCount:v})}disposeIntermediateTensorInfo(a){this.disposeData(a.dataId)}readSync(a){const c=this.texData.get(a),{values:p,dtype:m,complexTensorInfos:v,slice:b,shape:w,isPacked:S}=c;if(b!=null){let j;S?j=new lU(w,ll):j=new lq(w,ll);const $=this.runWebGLProgram(j,[{dataId:a,shape:w,dtype:m}],m),J=this.readSync($.dataId);return this.disposeIntermediateTensorInfo($),J}if(p!=null)return this.convertAndCacheOnCPU(a);if(m==="string")return p;const O=this.activeTimers!=null;let q;O&&(q=yT());let H;if(m==="complex64"){const j=this.readSync(v.real.dataId),$=this.readSync(v.imag.dataId);H=ZT(j,$)}else H=this.getValuesFromTexture(a);return O&&(this.downloadWaitMs+=yT()-q),this.convertAndCacheOnCPU(a,H)}async read(a){if(this.pendingRead.has(a)){const J=this.pendingRead.get(a);return new Promise(ee=>J.push(ee))}const c=this.texData.get(a),{values:p,shape:m,slice:v,dtype:b,complexTensorInfos:w,isPacked:S}=c;if(v!=null){let J;S?J=new lU(m,ll):J=new lq(m,ll);const ee=this.runWebGLProgram(J,[{dataId:a,shape:m,dtype:b}],b),re=this.read(ee.dataId);return this.disposeIntermediateTensorInfo(ee),re}if(p!=null)return this.convertAndCacheOnCPU(a);if(Hn().getBool("DEBUG")&&!Hn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Hn().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let O=null,q;if(b!=="complex64"&&Hn().get("WEBGL_BUFFER_SUPPORTED")){q=this.decode(a);const J=this.texData.get(q.dataId);O=this.gpgpu.createBufferFromTexture(J.texture.texture,...Y9(m))}this.pendingRead.set(a,[]),b!=="complex64"&&await this.gpgpu.createAndWaitForFence();let H;if(b==="complex64"){const J=await Promise.all([this.read(w.real.dataId),this.read(w.imag.dataId)]),ee=J[0],re=J[1];H=ZT(ee,re)}else if(O==null)H=this.getValuesFromTexture(a);else{const J=G(m);H=this.gpgpu.downloadFloat32MatrixFromBuffer(O,J)}if(q!=null&&this.disposeIntermediateTensorInfo(q),O!=null){const J=this.gpgpu.gl;Ya(J,()=>J.deleteBuffer(O))}const j=this.convertAndCacheOnCPU(a,H),$=this.pendingRead.get(a);return this.pendingRead.delete(a),$.forEach(J=>J(j)),this.pendingDisposal.has(a)&&(this.pendingDisposal.delete(a),this.disposeData(a)&&s1().removeDataId(a,this),this.pendingDeletes--),j}readToGPU(a,c={}){const p=this.texData.get(a),{values:m,shape:v,slice:b,dtype:w,isPacked:S,texture:O}=p;if(w==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(b!=null){let $;S?$=new lU(v,ll):$=new lq(v,ll);const J=this.runWebGLProgram($,[{dataId:a,shape:v,dtype:w}],w),ee=this.readToGPU(J,c);return this.disposeIntermediateTensorInfo(J),ee}if(O==null)throw m!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const q=this.decode(a,c.customTexShape),H=s1().makeTensorFromTensorInfo(q),j=this.texData.get(q.dataId);return Object.assign({tensorRef:H},j.texture)}bufferSync(a){const c=this.readSync(a.dataId);if(a.dtype==="string")try{const p=c.map(m=>ye(m));return fy(a.shape,a.dtype,p)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return fy(a.shape,a.dtype,c)}checkNumericalProblems(a){if(a!=null)for(let c=0;c<a.length;c++){const p=a[c];if(!Yf(p))throw Hn().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+p+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+p+" cannot be represented on this device.")}}getValuesFromTexture(a){const{shape:c,dtype:p,isPacked:m}=this.texData.get(a),v=G(c);if(Hn().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const j=this.decode(a),$=this.texData.get(j.dataId),J=this.gpgpu.downloadMatrixFromPackedTexture($.texture.texture,...Y9(c)).subarray(0,v);return this.disposeIntermediateTensorInfo(j),J}const b=Hn().getBool("WEBGL_PACK")&&m===!0,w=b?YQ(c):c,S=b?new n3(w):new n2(w),O=this.runWebGLProgram(S,[{shape:w,dtype:p,dataId:a}],"float32"),q=this.texData.get(O.dataId),H=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(q.texture.texture,q.texShape[0],q.texShape[1]).subarray(0,v);return this.disposeIntermediateTensorInfo(O),H}timerAvailable(){return Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(a){const c=this.activeTimers,p=[];let m=!1;this.programTimersStack==null?(this.programTimersStack=p,m=!0):this.activeTimers.push(p),this.activeTimers=p,a();const v=yN(this.activeTimers.map(S=>S.query)).filter(S=>S!=null),b=yN(this.activeTimers.map(S=>S.name)).filter(S=>S!=null);this.activeTimers=c,m&&(this.programTimersStack=null);const w={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const S=await Promise.all(v);w.kernelMs=h(S),w.getExtraProfileInfo=()=>S.map((O,q)=>({name:b[q],ms:O})).map(O=>O.name+": "+O.ms).join(", ")}else w.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,w})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:yT(),endMs:null}}endTimer(a){return Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),a):(a.endMs=yT(),a)}async getQueryTime(a){if(Hn().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(a);const c=a;return c.endMs-c.startMs}disposeData(a,c=!1){if(this.pendingDisposal.has(a))return!1;if(!this.texData.has(a))return!0;if(c?this.texData.get(a).refCount=0:this.texData.get(a).refCount--,!c&&this.texData.get(a).refCount>0)return!1;if(this.pendingRead.has(a))return this.pendingDisposal.add(a),this.pendingDeletes++,!1;this.releaseGPUData(a);const{complexTensorInfos:p}=this.texData.get(a);return p!=null&&(this.disposeData(p.real.dataId,c),this.disposeData(p.imag.dataId,c)),this.texData.delete(a),!0}releaseGPUData(a){const{texture:c,dtype:p,texShape:m,usage:v,isPacked:b,slice:w}=this.texData.get(a),S=w&&w.origDataId||a,O=this.dataRefCount.get(S);O>1?this.dataRefCount.set(S,O-1):(this.dataRefCount.delete(S),c!=null&&(this.numBytesInGPU-=this.computeBytes(m,p),this.textureManager.releaseTexture(c,m,v,b)));const q=this.texData.get(a);q.texture=null,q.texShape=null,q.isPacked=!1,q.slice=null}getTexture(a){return this.uploadToGPU(a),this.texData.get(a).texture.texture}getDataInfo(a){return this.texData.get(a)}shouldExecuteOnCPU(a,c=lC){return Hn().getBool("WEBGL_CPU_FORWARD")&&a.every(p=>this.texData.get(p.dataId).texture==null&&G(p.shape)<c)}getGPGPUContext(){return this.gpgpu}where(a){Dr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const c=a.dataSync();return lz(a.shape,c)}packedUnaryOp(a,c,p){const m=new lU(a.shape,c),v=this.compileAndRun(m,[a],p);return s1().makeTensorFromTensorInfo(v)}abs(a){if(this.shouldExecuteOnCPU([a])&&a.dtype!=="complex64"){const m=SP(this.texData.get(a.dataId).values);return this.makeOutput(a.shape,a.dtype,m)}if(Hn().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(a,lo,a.dtype);const c=new lq(a.shape,lo),p=this.compileAndRun(c,[a]);return s1().makeTensorFromTensorInfo(p)}makeTensorInfo(a,c,p){let m;if(c==="string"&&p!=null&&p.length>0&&H5(p[0])){const v=p.map(b=>yr(b));m=this.write(v,a,c)}else m=this.write(p,a,c);return this.texData.get(m).usage=null,{dataId:m,shape:a,dtype:c}}makeOutput(a,c,p){return s1().makeTensorFromTensorInfo(this.makeTensorInfo(a,c,p),this)}unpackTensor(a){const c=new lG(a.shape);return this.runWebGLProgram(c,[a],a.dtype)}packTensor(a){const c=new ly(a.shape),p=!0;return this.runWebGLProgram(c,[a],a.dtype,null,p)}packedReshape(a,c){const p=[YC(a.shape),...Yu(a.shape)],m={dtype:a.dtype,shape:p,dataId:a.dataId},v=[YC(c),...Yu(c)],b=new la(v,p),w=!0,S=[p],O=this.runWebGLProgram(b,[m],a.dtype,S,w);return{dataId:O.dataId,shape:c,dtype:O.dtype}}decode(a,c){const p=this.texData.get(a),{isPacked:m,shape:v,dtype:b}=p;if(c!=null){const j=G(v),$=c[0]*c[1]*4;i(j<=$,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const w=YQ(v);let S;m?S=new n1(w):S=new n0(w);const O=!0,q=[c??Y9(w)],H=this.runWebGLProgram(S,[{shape:w,dtype:b,dataId:a}],b,q,O,c);return{dtype:b,shape:v,dataId:H.dataId}}runWebGLProgram(a,c,p,m,v=!1,b){const w=this.makeTensorInfo(a.outputShape,p),S=this.texData.get(w.dataId);if(a.packedOutput&&(S.isPacked=!0),a.outPackingScheme===Y4.DENSE){const de=b??Y9(a.outputShape);S.texShape=de.map(Te=>Te*2)}if(a.outTexUsage!=null&&(S.usage=a.outTexUsage),G(w.shape)===0)return S.values=e(w.dtype,0),w;const O=[],q=c.map(de=>{if(de.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let Te=this.texData.get(de.dataId);if(Te.texture==null){if(!a.packedInputs&&G(de.shape)<=Hn().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:de.shape,texData:null,isUniform:!0,uniformValues:Te.values};a.packedInputs&&(Te.isPacked=!0,Te.shape=de.shape)}if(this.uploadToGPU(de.dataId),!!Te.isPacked!=!!a.packedInputs)de=Te.isPacked?this.unpackTensor(de):this.packTensor(de),O.push(de),Te=this.texData.get(de.dataId);else if(Te.isPacked&&!YM(Te.shape,de.shape)){const Me=de,Ae=de.shape;de.shape=Te.shape,de=this.packedReshape(de,Ae),O.push(de),Te=this.texData.get(de.dataId),Me.shape=Ae}return{shape:de.shape,texData:Te,isUniform:!1}});this.uploadToGPU(w.dataId);const H={shape:w.shape,texData:S,isUniform:!1},j=oB(a,q,H),$=this.getAndSaveBinary(j,()=>ov(this.gpgpu,a,q,H)),J=this.activeTimers!=null;let ee;J&&(ee=this.startTimer()),Hn().get("ENGINE_COMPILE_ONLY")||oe(this.gpgpu,$,q,H,m),O.forEach(de=>this.disposeIntermediateTensorInfo(de)),J&&(ee=this.endTimer(ee),this.activeTimers.push({name:a.constructor.name,query:this.getQueryTime(ee)}));const re=Hn().getNumber("WEBGL_FLUSH_THRESHOLD");if(re>0){const de=yT();de-this.lastGlFlushTime>re&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=de)}if(!Hn().getBool("WEBGL_LAZILY_UNPACK")&&S.isPacked&&v===!1){const de=this.unpackTensor(w);return this.disposeIntermediateTensorInfo(w),de}return w}compileAndRun(a,c,p,m,v=!1){return p=p||c[0].dtype,this.runWebGLProgram(a,c,p,m,v)}getAndSaveBinary(a,c){return a in this.binaryCache||(this.binaryCache[a]=c()),this.binaryCache[a]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Hn().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(a=>{this.gpgpu.deleteProgram(this.binaryCache[a].webGLProgram),delete this.binaryCache[a]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=s2(()=>{if(!Hn().get("WEBGL_RENDER_FLOAT32_ENABLED")){const a=Hn().getBool("DEBUG");Hn().set("DEBUG",!1);const c=this.abs(fb(1e-8)).dataSync()[0];if(Hn().set("DEBUG",a),c>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?lW:lR}uploadToGPU(a){const c=this.texData.get(a),{shape:p,dtype:m,values:v,texture:b,usage:w,isPacked:S}=c;if(b!=null)return;const O=this.activeTimers!=null;let q;O&&(q=yT());let H=c.texShape;if(H==null&&(H=YJ(p,S),c.texShape=H),v!=null){const j=YQ(p);let $,J=H[1],ee=H[0];const re=v instanceof Uint8Array||v instanceof Uint8ClampedArray;(S||!re)&&([J,ee]=YH(H[0],H[1])),S?$=new n6(j,re):$=new n5(j,re);const de=re?[ee,J]:H,Te=this.makeTensorInfo(de,m),Me=this.texData.get(Te.dataId);re?Me.usage=Y5.PIXELS:Me.usage=Y5.UPLOAD,Me.texShape=de,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(Te.dataId),J,ee,v);const Ae=[[ee,J]],Ce=!0,Pe=this.runWebGLProgram($,[Te],m,Ae,Ce),je=this.texData.get(Pe.dataId);c.texShape=je.texShape,c.isPacked=je.isPacked,c.usage=je.usage,Hn().get("ENGINE_COMPILE_ONLY")?this.disposeData(Pe.dataId):(c.texture=je.texture,c.values=null,this.texData.delete(Pe.dataId)),this.disposeIntermediateTensorInfo(Te),O&&(this.uploadWaitMs+=yT()-q)}else{const j=this.acquireTexture(H,w,m,S);c.texture=j}}convertAndCacheOnCPU(a,c){const p=this.texData.get(a),{dtype:m}=p;return c!=null&&(p.values=lx(c,m)),p.values}acquireTexture(a,c,p,m){if(this.numBytesInGPU+=this.computeBytes(a,p),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const v=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+v+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(a,c,m)}computeBytes(a,c){return a[0]*a[1]*H3(c)}checkCompileCompletion(){for(const[,a]of Object.entries(this.binaryCache))this.checkCompletion_(a)}async checkCompileCompletionAsync(){const a=[];if(this.gpgpu.parallelCompilationExtension){for(const[,c]of Object.entries(this.binaryCache))a.push(this.checkCompletionAsync_(c));return Promise.all(a)}else{for(const[,c]of Object.entries(this.binaryCache)){const p=new Promise(m=>{try{this.checkCompletion_(c),m(!0)}catch(v){throw v}});a.push(p)}return Promise.all(a)}}async checkCompletionAsync_(a){return this.gpgpu.gl.getProgramParameter(a.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(a):(await Zt(),this.checkCompletionAsync_(a))}checkCompletion_(a){if(this.gpgpu.gl.getProgramParameter(a.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(a.webGLProgram)),this.gpgpu.gl.getShaderParameter(a.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(YF(a.source,this.gpgpu.gl.getShaderInfoLog(a.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const a of Object.values(this.binaryCache)){this.gpgpu.buildVao(a.webGLProgram);const{variablesLocations:c,customUniformLocations:p,infLoc:m,nanLoc:v,outShapeLocation:b,outShapeStridesLocation:w,outTexShapeLocation:S}=oT(this.gpgpu,a.program,a.webGLProgram);a.variablesLocations=c,a.customUniformLocations=p,a.infLoc=m,a.nanLoc=v,a.outShapeLocation=b,a.outShapeStridesLocation=w,a.outTexShapeLocation=S}}createTensorFromGPUData(a,c,p){a.channels=a.channels||"RGBA";const{texture:m,height:v,width:b,channels:w}=a,S=s1().backend;if(!S.gpgpu.gl.isTexture(m))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const O=S.writeTexture(m,c,p,v,b,w);return s1().makeTensorFromDataId(O,c,p,S)}}lJ.nextDataId=0;function lx(u,a){if(a==="float32"||a==="complex64")return u;if(a==="int32"||a==="bool"){const c=a==="int32"?new Int32Array(u.length):new Uint8Array(u.length);for(let p=0;p<c.length;++p)c[p]=Math.round(u[p]);return c}else throw new Error("Unknown dtype "+a)}aJ()&&s7("webgl",()=>new lJ,2);const lM="return abs(x);";function lX(u){const{inputs:a,backend:c}=u,{x:p}=a;if(c.shouldExecuteOnCPU([p])&&p.dtype!=="complex64"){const v=c.texData.get(p.dataId),b=SP(v.values);return c.makeTensorInfo(p.shape,p.dtype,b)}let m;return Hn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?m=new lU(p.shape,lM):m=new lq(p.shape,lM),c.runWebGLProgram(m,[p],p.dtype)}const lg={kernelName:Ht,backendName:"webgl",kernelFunc:lX},lK=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class lb{constructor(a,c,p){this.variableNames=["A","B"],this.outputShape=IP(c,p),this.enableShapeUniforms=oN(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        `+a+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const lV=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ld{constructor(a,c,p,m=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=IP(c,p);const v=this.outputShape.length;this.enableShapeUniforms=oN(v);let b="";if(m)if(v===0||G(this.outputShape)===1)b=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(b=`
          `+ob(v)+` coords = getOutputCoords();
        `,v===1)this.enableShapeUniforms?b+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:b+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const w=lH("coords",v);this.enableShapeUniforms?b+=`
            bool nextRowOutOfBounds =
              (`+w[v-2]+" + 1) >= outShape["+v+` - 2];
            bool nextColOutOfBounds =
              (`+w[v-1]+" + 1) >= outShape["+v+` - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:b+=`
            bool nextRowOutOfBounds =
              (`+w[v-2]+" + 1) >= "+this.outputShape[v-2]+`;
            bool nextColOutOfBounds =
              (`+w[v-1]+" + 1) >= "+this.outputShape[v-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+a+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+b+`

        setOutput(result);
      }
    `}}function lP(u){const{inputs:a,backend:c}=u,{x:p}=a;return c.incRef(p.dataId),{dataId:p.dataId,shape:p.shape,dtype:p.dtype}}const lv={kernelName:D5,backendName:"webgl",kernelFunc:lP};function lT(u){const{inputs:a,backend:c}=u,{real:p,imag:m}=a,v=c.makeTensorInfo(p.shape,"complex64"),b=c.texData.get(v.dataId),w=lP({inputs:{x:p},backend:c}),S=lP({inputs:{x:m},backend:c});return b.complexTensorInfos={real:w,imag:S},v}const lr="return (a < 0.) ? b * a : a;",le=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,lB="return (a < 0.) ? b * a : a;",lN=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function h0(u){const{inputs:a,backend:c}=u,{x:p,alpha:m}=a,v=Hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ld(lN,p.shape,m.shape):new lb(lB,p.shape,m.shape);return c.runWebGLProgram(v,[p,m],"float32")}const h1={kernelName:Dn,backendName:"webgl",kernelFunc:h0},h2="if (isnan(x)) return x;";function h3({opSnippet:u,packedOpSnippet:a,cpuKernelImpl:c,dtype:p}){return({inputs:m,backend:v})=>{const{x:b}=m,w=v,S=p||b.dtype;if(w.shouldExecuteOnCPU([b])&&c!=null){const H=w.texData.get(b.dataId),j=c(H.values,S);return w.makeTensorInfo(b.shape,S,j)}const O=Hn().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&a!=null;let q;return O?q=new lU(b.shape,a):q=new lq(b.shape,u),w.runWebGLProgram(q,[b],S)}}function h4({opSnippet:u,packedOpSnippet:a,checkOutOfBounds:c=!1,supportsComplex:p=!1,cpuKernelImpl:m,dtype:v}){return({inputs:b,backend:w})=>{const{a:S,b:O}=b,q=w;if(p&&S.dtype==="complex64"){const J=q.texData.get(S.dataId),ee=q.texData.get(O.dataId),[re,de]=[[J.complexTensorInfos.real,ee.complexTensorInfos.real],[J.complexTensorInfos.imag,ee.complexTensorInfos.imag]].map(Me=>{const[Ae,Ce]=Me,Pe={dataId:Ae.dataId,dtype:Ae.dtype,shape:S.shape},je={dataId:Ce.dataId,dtype:Ce.dtype,shape:O.shape},Ne=new lb(u,S.shape,O.shape);return q.runWebGLProgram(Ne,[Pe,je],al(Ae.dtype,Ce.dtype))}),Te=lT({inputs:{real:re,imag:de},backend:q});return q.disposeIntermediateTensorInfo(re),q.disposeIntermediateTensorInfo(de),Te}const H=v||al(S.dtype,O.dtype);if((S.dtype==="string"||O.dtype==="string"||q.shouldExecuteOnCPU([S,O]))&&m!=null){const J=q.texData.get(S.dataId).values,ee=q.texData.get(O.dataId).values,re=S.dtype==="string"?Lh(J):J,de=S.dtype==="string"?Lh(ee):ee,[Te,Me]=m(S.shape,O.shape,re,de,H),Ae=q.makeTensorInfo(Me,H),Ce=q.texData.get(Ae.dataId);return Ce.values=Te,Ae}const j=Hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&a!=null;let $;return j?$=new ld(a,S.shape,O.shape,c):$=new lb(u,S.shape,O.shape),q.runWebGLProgram($,[S,O],H)}}function h5(u,a=!1){if(u==="linear")return a?li:lY;if(u==="relu")return a?lt:lp;if(u==="elu")return a?lm:ln;if(u==="relu6")return a?lk:lS;if(u==="prelu")return a?lN:lB;if(u==="leakyrelu")return a?le:lr;if(u==="sigmoid")return a?lw:lh;throw new Error("Activation "+u+" has not been implemented for the WebGL backend.")}const h6="return a + b;",h7=h4({opSnippet:h6,packedOpSnippet:h6,supportsComplex:!0,cpuKernelImpl:Sq}),h8={kernelName:Hk,backendName:"webgl",kernelFunc:h7};class h9{constructor(a,c){this.outputShape=[],this.outputShape=a,this.variableNames=c.map((v,b)=>"T"+b);const p=[];this.variableNames.forEach(v=>{p.push("float v"+v+" = get"+v+"AtOutCoords();")});const m=this.variableNames.map(v=>"v"+v).join(" + ");this.userCode=`
      void main() {
        `+p.join(`
        `)+`

        float result = `+m+`;
        setOutput(result);
      }
    `}}class hH{constructor(a,c){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.variableNames=c.map((v,b)=>"T"+b);const p=[];this.variableNames.forEach(v=>{p.push("vec4 v"+v+" = get"+v+"AtOutCoords();")});const m=this.variableNames.map(v=>"v"+v).join(" + ");this.userCode=`
      void main() {
        `+p.join(`
        `)+`

        vec4 result = `+m+`;
        setOutput(result);
      }
    `}}function hD(u){const{inputs:a,backend:c}=u,p=a;if(p.length===1)return lP({inputs:{x:p[0]},backend:c});if(p.length>Hn().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const w=Math.floor(p.length/2),S=hD({inputs:p.slice(0,w),backend:c}),O=hD({inputs:p.slice(w),backend:c});return hD({inputs:[S,O],backend:c})}const m=p.map(w=>w.dtype).reduce((w,S)=>al(w,S)),v=p.map(w=>w.shape),b=Hn().getBool("WEBGL_PACK")?new hH(p[0].shape,v):new h9(p[0].shape,v);return c.runWebGLProgram(b,p,m)}const hy={kernelName:Hw,backendName:"webgl",kernelFunc:hD},ha=lK+`
  return atan(a, b);
`,hs=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+lV+`
  return result;
`,hI=h4({opSnippet:ha,packedOpSnippet:hs}),hE={kernelName:HU,backendName:"webgl",kernelFunc:hI};class hf{constructor(a,c,p,m=!1,v=!1){if(this.variableNames=["x"],c==="avg"&&p)throw new Error("Cannot compute positions for average pool.");const b=a.filterWidth,w=a.strideHeight,S=a.strideWidth,O=a.dilationHeight,q=a.dilationWidth,H=a.effectiveFilterHeight,j=a.effectiveFilterWidth,$=a.padInfo.top,J=a.padInfo.left;this.outputShape=a.outShape;const ee=c==="avg",re="((batch  * "+a.inHeight+" + xR) * "+a.inWidth+" + xC) * "+a.inChannels+" + d",de="(xR * "+a.inWidth+" + xC) * "+a.inChannels+" + d";let Te="0.0";if(ee||(Te="-1.0 / 1e-20"),p){const Ne=">=";this.userCode=`
        const ivec2 strides = ivec2(`+w+", "+S+`);
        const ivec2 pads = ivec2(`+$+", "+J+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+H+`;
              wR += `+O+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+a.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+j+`;
                wC += `+q+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+a.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value `+Ne+` currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = `+(m?v?re:de:"wR * "+j+" + wC")+`;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const Me="max";let Ae=c+"("+c+"("+c+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";c==="avg"&&(Ae="avgValue / max(count, 1.0)");const Ce=Math.floor(b/4)*4,Pe=b%4,je=`
      if (`+ee+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+Me+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+w+", "+S+`);
      const ivec2 pads = ivec2(`+$+", "+J+`);
      const float initializationValue = `+Te+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+a.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+Te+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+H+`;
            wR += `+O+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+a.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+Ce+`; wC += 4) {
            int xC = xCCorner + wC * `+q+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+q+`, d),
              getValue(batch, xR, xC + 2 * `+q+`, d),
              getValue(batch, xR, xC + 3 * `+q+`, d)
            );

            `+je+`
          }

          int xC = xCCorner + `+Ce+`;
          if (`+(Pe===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+je+`
          } else if (`+(Pe===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+q+`, d),
              initializationValue,
              initializationValue
            );

            `+je+`
          } else if (`+(Pe===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+q+`, d),
              getValue(batch, xR, xC + 2 * `+q+`, d),
              initializationValue
            );

            `+je+`
          }
        }
        setOutput(`+Ae+`);
      }
    `}}function hO(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a;YN(m,"avgPool");const{filterSize:v,strides:b,pad:w,dimRoundingMode:S}=p,O=1;i(Eb(b,O),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+O+"'");const q=Ez(m.shape,v,b,O,w,S);if(q.filterWidth===1&&q.filterHeight===1&&z(q.inShape,q.outShape))return lP({inputs:{x:m},backend:c});const H=new hf(q,"avg",!1);return c.runWebGLProgram(H,[m],"float32")}const hc={kernelName:HG,backendName:"webgl",kernelFunc:hO};class hZ{constructor(a,c,p,m=!1,v=!1,b=!1,w=null,S=!1,O=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=p,this.enableShapeUniforms=oN(this.outputShape.length);const q=m?a[1]:a[2],H=Math.ceil(q/2),j=m?"i * 2, rc.y":"rc.y, i * 2",$=v?"rc.z, i * 2":"i * 2, rc.z",J=m?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],ee=v?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let re="",de="";w&&(S?re=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+w+`
        }`:O?re=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+w+`
        }`:re=`vec4 activation(vec4 x) {
          `+w+`
        }`,de="result = activation(result);");const Te=b?"result += getBiasAtOutCoords();":"";b&&this.variableNames.push("bias"),S&&this.variableNames.push("preluActivationWeights"),O&&this.variableNames.push("leakyreluAlpha");let Me="rc.x",Ae="rc.x";a[0]<c[0]?Me="imod(rc.x, "+a[0]+")":c[0]<a[0]&&(Ae="imod(rc.x, "+c[0]+")"),this.userCode=`
      `+re+`
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = `+H+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = `+Me+`;
        int batchB = `+Ae+`;
        for (int i = 0; i < `+H+`; i++) {
          vec4 a = getMatrixA(batchA, `+j+`);
          vec4 b = getMatrixB(batchB, `+$+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+J[0]+" * "+ee[0]+`);
          result += (`+J[1]+" * "+ee[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+Te+`

        `+de+`

        setOutput(result);
      }
    `}}const hL={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class hq{constructor(a,c,p){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=IP(c,p),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+a+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const hF="return a * b;";function hY(u){const{inputs:a,backend:c}=u,{a:p,b:m}=a,v=al(p.dtype,m.dtype);if(p.dtype==="complex64"){const w=c.texData.get(p.dataId),S=c.texData.get(m.dataId),O=new hq(hL.REAL,p.shape,m.shape),q=new hq(hL.IMAG,p.shape,m.shape),H=[{dataId:w.complexTensorInfos.real.dataId,dtype:w.complexTensorInfos.real.dtype,shape:p.shape},{dataId:w.complexTensorInfos.imag.dataId,dtype:w.complexTensorInfos.imag.dtype,shape:p.shape},{dataId:S.complexTensorInfos.real.dataId,dtype:S.complexTensorInfos.real.dtype,shape:m.shape},{dataId:S.complexTensorInfos.imag.dataId,dtype:S.complexTensorInfos.imag.dtype,shape:m.shape}],j=c.runWebGLProgram(O,H,"float32"),$=c.runWebGLProgram(q,H,"float32"),J=lT({inputs:{real:j,imag:$},backend:c});return c.disposeIntermediateTensorInfo(j),c.disposeIntermediateTensorInfo($),J}if(c.shouldExecuteOnCPU([p,m])){const w=c.texData.get(p.dataId),S=c.texData.get(m.dataId),[O,q]=Su(p.shape,m.shape,w.values,S.values,v),H=c.makeTensorInfo(q,v),j=c.texData.get(H.dataId);return j.values=O,H}let b;return Hn().getBool("WEBGL_PACK_BINARY_OPERATIONS")?b=new ld(hF,p.shape,m.shape):b=new lb(hF,p.shape,m.shape),c.runWebGLProgram(b,[p,m],v)}const ho={kernelName:DO,backendName:"webgl",kernelFunc:hY};function hn(u,a,c){const p=[YC(u.shape),...Yu(u.shape)],m={dtype:u.dtype,shape:p,dataId:u.dataId},v=[YC(a),...Yu(a)],b=new la(v,p),w=!0,S=[p],O=c.runWebGLProgram(b,[m],u.dtype,S,w);return{dataId:O.dataId,shape:a,dtype:O.dtype}}function hp(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{shape:v}=p,b=c,w=G(m.shape),S=V(v,w),O=G(S);i(w===O,()=>"The new shape ("+S+") has "+O+" elements and the old shape ("+m.shape+") has "+w+" elements. The new shape and old shape must have the same number of elements.");const q=b.texData.get(m.dataId);return q.isPacked&&!YM(m.shape,S)&&!(q.texture!==null&&YM(q.shape,S))?hn(m,S,b):(b.incRef(m.dataId),{dataId:m.dataId,shape:S,dtype:m.dtype})}const hS={kernelName:Dh,backendName:"webgl",kernelFunc:hp};class hl{constructor(a,c){this.variableNames=["x"];const{windowSize:p,batchSize:m,inSize:v,outSize:b}=a;this.outputShape=[m,b];const w=Math.floor(p/4)*4,S=p%4;let O="sumValue += dot(values, ones);";if(c!=null){const H=1/c;O="sumValue += dot(values * "+(W(H)?H.toPrecision(2):H)+", ones);"}let q="";v%p>0&&(q=`
        if (inIdx < 0 || inIdx >= `+v+`) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+q+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+p+`;

        float sumValue = 0.0;

        for (int i = 0; i < `+w+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+O+`
        }

        int inIdx = inOffset + `+w+`;
        if (`+(S===1)+`) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          `+O+`
        } else if (`+(S===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          `+O+`
        } else if (`+(S===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          `+O+`
        }
        setOutput(sumValue);
      }
    `}}class hh{constructor(a,c){this.variableNames=["x"];const{windowSize:p,batchSize:m,inSize:v,outSize:b}=a;this.outputShape=[m,b];let w="0.0",S="";c==="prod"?w="1.0":c==="min"?(w="1.0 / 1e-20",S="min"):c==="max"&&(w="-1.0 / 1e-20",S="max");let O=c+"("+c+"("+c+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";c==="sum"?O="sumValue":c==="prod"?O="prodValue":c==="all"?O="allValue":c==="any"&&(O="anyValue");const q=Math.floor(p/4)*4,H=p%4;let j=`
      if (`+(c==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(c==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+S+`(values, minMaxValue);
        if (`+(c==="min")+" || "+(c==="max")+`) {
          minMaxValue = `+S+`(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,$="vec4";c==="all"?(w="1.0",j=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,$="bvec4"):c==="any"&&(w="0.0",j=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,$="bvec4");let J="";v%p>0&&(J=`
        if (inIdx < 0 || inIdx >= `+v+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+w+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+J+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+p+`;

        vec4 minMaxValue = vec4(`+w+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+q+`; i += 4) {
          int inIdx = inOffset + i;
          `+$+" values = "+$+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+j+`
        }

        int inIdx = inOffset + `+q+`;
        if (`+(H===1)+`) {
          `+$+" values = "+$+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+j+`
        } else if (`+(H===2)+`) {
          `+$+" values = "+$+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+j+`
        } else if (`+(H===3)+`) {
          `+$+" values = "+$+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+j+`
        }
        setOutput(`+O+`);
      }
    `}}function hi(u){const a=[];for(;a.length===0||a[a.length-1].outSize!==1;){const c=a.length?a[a.length-1].outSize:u[1],p=ZA(c);a.push({inSize:c,windowSize:p,outSize:Math.ceil(c/p)})}return a}function hm(u,a,c,p){const m=hi(u.shape);let v=u;for(let b=0;b<m.length;b++){const{inSize:w,windowSize:S,outSize:O}=m[b];let q,H;c==="mean"?q=b===0?new hl({windowSize:S,inSize:w,batchSize:u.shape[0],outSize:O},w):new hl({windowSize:S,inSize:w,batchSize:u.shape[0],outSize:O}):q=new hh({windowSize:S,inSize:w,batchSize:u.shape[0],outSize:O},c),H=v,v=p.runWebGLProgram(q,[v],a),H.dataId!==u.dataId&&p.disposeIntermediateTensorInfo(H)}return v}class ht{constructor(a,c){this.variableNames=["A"];const p=new Array(a.length);for(let b=0;b<p.length;b++)p[b]=a[c[b]];this.outputShape=p,this.rank=p.length;const m=ob(this.rank),v=hk(c);this.userCode=`
    void main() {
      `+m+` resRC = getOutputCoords();
      setOutput(getA(`+v+`));
    }
    `}}function hk(u){const a=u.length;if(a>6)throw Error("Transpose for rank "+a+" is not yet supported");const c=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],p=new Array(a);for(let m=0;m<u.length;m++)p[u[m]]=c[m];return p.join()}class hw{constructor(a,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const p=new Array(a.length);for(let q=0;q<p.length;q++)p[q]=a[c[q]];if(this.outputShape=p,this.rank=p.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");const m=ob(this.rank),v=l9("rc",this.rank),b=new Array(this.rank);for(let q=0;q<c.length;q++)b[c[q]]=v[q];const w="vec2("+b.slice(-2).join()+")",S="++"+v[this.rank-1]+" < "+p[this.rank-1],O="getChannel(getA("+b.join()+"), "+w+")";this.userCode=`
    void main() {
      `+m+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+O+`;
      if(`+S+`) {
        result[1] = `+O+`;
      }
      --`+v[this.rank-1]+`;
      if(++`+v[this.rank-2]+" < "+p[this.rank-2]+`) {
        result[2] = `+O+`;
        if(`+S+`) {
          result[3] = `+O+`;
        }
      }
      setOutput(result);
    }
    `}}function hU(u,a,c){const p=Hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hw(u.shape,a):new ht(u.shape,a);return c.runWebGLProgram(p,[u],u.dtype)}function hG(u,a,c,p){const m=a,v=u.shape.length,b=P(m,u.shape);let w=b;const S=fC(w,v),O=S!=null;let q=u;O&&(q=hU(u,S,p),w=fQ(w.length,v)),fA("sum",w,v);const[H,j]=fR(q.shape,w);let $=H;c&&($=fj(H,b));const J=G(j),ee=G(u.shape)/J,re=hp({inputs:{x:q},attrs:{shape:[ee,J]},backend:p}),de=ah(u.dtype),Te=hm(re,de,"sum",p),Me=hp({inputs:{x:Te},attrs:{shape:$},backend:p});return p.disposeIntermediateTensorInfo(re),p.disposeIntermediateTensorInfo(Te),O&&p.disposeIntermediateTensorInfo(q),Me}function hz(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{axis:v,keepDims:b}=p;return hG(m,v,b,c)}const hW={kernelName:Dj,backendName:"webgl",kernelFunc:hz};function hR(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{perm:v}=p,b=c,w=m.shape.length,S=new Array(w);for(let q=0;q<S.length;q++)S[q]=m.shape[v[q]];let O;if(b.shouldExecuteOnCPU([m])){const q=b.texData.get(m.dataId).values,H=l7(q,m.shape,m.dtype,v,S);O=b.makeTensorInfo(S,m.dtype);const j=b.texData.get(O.dataId);j.values=H}else O=hU(m,v,b);return O}const hj={kernelName:DX,backendName:"webgl",kernelFunc:hR},hA=1e3;function hC({a:u,b:a,transposeA:c,transposeB:p,backend:m,bias:v=null,preluActivationWeights:b=null,leakyreluAlpha:w=0,activation:S=null}){const O=u.shape.length,q=a.shape.length,H=c?u.shape[O-2]:u.shape[O-1],j=p?a.shape[q-1]:a.shape[q-2],$=c?u.shape[O-1]:u.shape[O-2],J=p?a.shape[q-2]:a.shape[q-1],ee=u.shape.slice(0,-2),re=a.shape.slice(0,-2),de=G(ee),Te=G(re),Me=IP(u.shape.slice(0,-2),a.shape.slice(0,-2)).concat([$,J]);i(H===j,()=>"Error in matMul: inner shapes ("+H+") and ("+j+") of Tensors with shapes "+u.shape+" and "+a.shape+" and transposeA="+c+" and transposeB="+p+" must match.");const Ae=c?[de,H,$]:[de,$,H],Ce=p?[Te,J,j]:[Te,j,J],Pe=hp({inputs:{x:u},backend:m,attrs:{shape:Ae}}),je=hp({inputs:{x:a},backend:m,attrs:{shape:Ce}}),Ne=[Pe,je],Qe=Math.max(de,Te),Ct=c?Pe.shape[1]:Pe.shape[2],dt=v!=null,Xt=b!=null,Gt=S==="leakyrelu",Vt=S!=null?h5(S,!0):null,T0=dt||Xt||Gt||Vt!=null;let r0;if(($===1||J===1)&&Ct>hA&&T0===!1){let Ut=Pe,$0=je;c&&(Ut=hR({inputs:{x:Pe},backend:m,attrs:{perm:[0,2,1]}}),Ne.push(Ut)),p&&($0=hR({inputs:{x:je},backend:m,attrs:{perm:[0,2,1]}}),Ne.push($0));const Q0=J!==1,Un=J===1;let b0=Ut;Q0&&(b0=hp({inputs:{x:Ut},backend:m,attrs:{shape:[Qe,Ct,1]}}),Ne.push(b0));const X0=J===1?2:1;let Rt=$0;Un&&(Rt=hp({inputs:{x:$0},backend:m,attrs:{shape:[Qe,1,Ct]}}),Ne.push(Rt));const Qt=hY({inputs:{a:b0,b:Rt},backend:m});r0=hz({inputs:{x:Qt},backend:m,attrs:{axis:X0,keepDims:!0}}),Ne.push(Qt)}else{const Ut=al(u.dtype,a.dtype),$0=new hZ(Ae,Ce,[Qe,$,J],c,p,dt,Vt,Xt,Gt),Q0=[Pe,je];if(v!=null&&Q0.push(v),Xt&&Q0.push(b),Gt){const Un=m.makeTensorInfo([],"float32",yd(w,"float32"));Q0.push(Un),Ne.push(Un)}r0=m.runWebGLProgram($0,Q0,Ut)}const d0=hp({inputs:{x:r0},backend:m,attrs:{shape:Me}});Ne.push(r0);for(const Ut of Ne)m.disposeIntermediateTensorInfo(Ut);return d0}function hu(u){const{inputs:a,backend:c,attrs:p}=u,{a:m,b:v}=a,{transposeA:b,transposeB:w}=p;return hC({a:m,b:v,transposeA:b,transposeB:w,backend:c})}const hQ={kernelName:HW,backendName:"webgl",kernelFunc:hu},hJ="return float(a != b);",hx=h4({opSnippet:hJ,cpuKernelImpl:SJ,dtype:"bool"});function hM(u){const{inputs:a,backend:c}=u,{input:p}=a,m=c.texData.get(p.dataId);return lP({inputs:{x:m.complexTensorInfos.real},backend:c})}const hX="return float(int(x));";function hg(u,a){const c=new lq(u.shape,hX),p=a.runWebGLProgram(c,[u],"int32");return{dataId:p.dataId,shape:p.shape,dtype:p.dtype}}function hK(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{dtype:v}=p;if(v==="complex64"){if(m.dtype==="complex64")return lP({inputs:{x:m},backend:c});const b=Ot(m.shape),w=hK({inputs:{x:m},backend:c,attrs:{dtype:"float32"}}),S=lT({inputs:{real:w,imag:b},backend:c});return b.dispose(),c.disposeIntermediateTensorInfo(w),S}if(m.dtype==="complex64"){const b=hM({inputs:{input:m},backend:c}),w=hK({inputs:{x:b},backend:c,attrs:{dtype:v}});return c.disposeIntermediateTensorInfo(b),w}if(!H2(m.dtype,v)){const b=lP({inputs:{x:m},backend:c});return{dataId:b.dataId,shape:b.shape,dtype:v}}if(c.shouldExecuteOnCPU([m])){const b=c.texData.get(m.dataId).values,[w,S,O]=Sn(b,m.shape,m.dtype,v);return c.makeTensorInfo(w,S,O)}if(v==="int32")return hg(m,c);if(v==="bool"){const b=c.makeTensorInfo([],"bool",e("bool",1)),w=hx({inputs:{a:m,b},backend:c});return c.disposeIntermediateTensorInfo(b),w}throw new Error("Error in Cast: failed to cast "+m.dtype+" to "+v)}const hb={kernelName:HA,backendName:"webgl",kernelFunc:hK};class hV{constructor(a){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=a,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class hd{constructor(a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=a,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function hP(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{clipValueMin:v,clipValueMax:b}=p;let w;Hn().getBool("WEBGL_PACK_CLIP")?w=new hd(m.shape):w=new hV(m.shape);const S=[[v],[b]];return c.runWebGLProgram(w,[m],m.dtype,S)}const hv={kernelName:HC,backendName:"webgl",kernelFunc:hP};class hT{constructor(a){this.outputShape=[],this.outputShape=Zw(a,1),this.variableNames=a.map((b,w)=>"T"+w);const c=new Array(a.length-1);c[0]=a[0][1];for(let b=1;b<c.length;b++)c[b]=c[b-1]+a[b][1];const p=["if (yC < "+c[0]+") setOutput(getT0(yR, yC));"];for(let b=1;b<c.length;b++){const w=c[b-1];p.push("else if (yC < "+c[b]+") setOutput(getT"+b+"(yR, yC-"+w+"));")}const m=c.length,v=c[c.length-1];p.push("else setOutput(getT"+m+"(yR, yC-"+v+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+p.join(`
        `)+`
      }
    `}}class hr{constructor(a,c){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zw(a,c);const p=this.outputShape,m=p.length,v=ob(m),b=lH("coords",m),w=["x","y","z","w","u","v"].slice(0,m);this.variableNames=a.map((ee,re)=>"T"+re);const S=new Array(a.length-1);S[0]=a[0][c];for(let ee=1;ee<S.length;ee++)S[ee]=S[ee-1]+a[ee][c];const O=w[c],q=w.slice(-2),H=w.join();let j="if ("+O+" < "+S[0]+`) {
        return getChannel(
            getT0(`+H+"), vec2("+q.join()+`));
        }`;for(let ee=1;ee<S.length;ee++){const re=S[ee-1];j+=`
        if (`+O+" < "+S[ee]+"  && "+O+" >= "+S[ee-1]+`) {
          return getChannel(
            getT`+ee+"("+he(w,O,re)+`),
            vec2(`+he(q,O,re)+`));
        }`}const $=S.length,J=S[S.length-1];j+=`
        return getChannel(
          getT`+$+"("+he(w,O,J)+`),
          vec2(`+he(q,O,J)+"));",this.userCode=`
      float getValue(`+w.map(ee=>"int "+ee)+`) {
        `+j+`
      }

      void main() {
        `+v+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+b+`), 0., 0., 0.);

        `+b[m-1]+" = "+b[m-1]+` + 1;
        if (`+b[m-1]+" < "+p[m-1]+`) {
          result.g = getValue(`+b+`);
        }

        `+b[m-2]+" = "+b[m-2]+` + 1;
        if (`+b[m-2]+" < "+p[m-2]+`) {
          result.a = getValue(`+b+`);
        }

        `+b[m-1]+" = "+b[m-1]+` - 1;
        if (`+b[m-2]+" < "+p[m-2]+` &&
            `+b[m-1]+" < "+p[m-1]+`) {
          result.b = getValue(`+b+`);
        }
        setOutput(result);
      }
    `}}function he(u,a,c){const p=u.indexOf(a);return u.map((m,v)=>v===p?m+" - "+c:m).join()}function hB(u){const{inputs:a,backend:c}=u,{input:p}=a,m=c.texData.get(p.dataId);return lP({inputs:{x:m.complexTensorInfos.imag},backend:c})}function hN(u,a,c){const p=u[0].dtype;if(p==="complex64"){const $=u.map(Te=>hM({inputs:{input:Te},backend:c})),J=u.map(Te=>hB({inputs:{input:Te},backend:c})),ee=hN($,a,c),re=hN(J,a,c),de=lT({inputs:{real:ee,imag:re},backend:c});return $.forEach(Te=>c.disposeIntermediateTensorInfo(Te)),J.forEach(Te=>c.disposeIntermediateTensorInfo(Te)),c.disposeIntermediateTensorInfo(ee),c.disposeIntermediateTensorInfo(re),de}let m=c.shouldExecuteOnCPU(u);if(p==="string"&&(m=!0),m){const $=u.map(Ae=>{const Ce=[-1,G(Ae.shape.slice(a))];return hp({inputs:{x:Ae},backend:c,attrs:{shape:Ce}})}),J=$.map(Ae=>({vals:c.readSync(Ae.dataId),shape:Ae.shape})),ee=Zw($.map(Ae=>Ae.shape),1),re=$[0].shape[0]===1,de=SS(J,ee,p,re),Te=Zw(u.map(Ae=>Ae.shape),a),Me=c.makeTensorInfo(Te,p,de);return $.forEach(Ae=>c.disposeIntermediateTensorInfo(Ae)),Me}const v=u.filter($=>G($.shape)>0),b=Hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&v[0].shape.length>1;if(v.length===1){const $=b?new lq(u[0].shape,ll):new lU(u[0].shape,ll);return c.runWebGLProgram($,u,p)}const w=Hn().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(v.length>w){const $=[];for(let ee=0;ee<v.length;ee+=w){const re=v.slice(ee,ee+w);$.push(hN(re,a,c))}const J=hN($,a,c);for(const ee of $)c.disposeIntermediateTensorInfo(ee);return J}if(b){const $=new hr(v.map(J=>J.shape),a);return c.runWebGLProgram($,v,p)}const{tensors2D:S,outShape:O}=i0(v,a,c),q=new hT(S.map($=>$.shape)),H=c.runWebGLProgram(q,S,p);S.forEach($=>c.disposeIntermediateTensorInfo($));const j=hp({inputs:{x:H},attrs:{shape:O},backend:c});return c.disposeIntermediateTensorInfo(H),j}function i0(u,a,c){const p=Zw(u.map(m=>m.shape),a);return{tensors2D:u.map(m=>hp({inputs:{x:m},attrs:{shape:[-1,G(m.shape.slice(a))]},backend:c})),outShape:p}}function i1(u){const{inputs:a,backend:c,attrs:p}=u,{axis:m}=p,v=P(m,a[0].shape)[0],b=a.map(O=>O.shape);Zk(b,v);const w=Zw(a.map(O=>O.shape),v);if(G(w)===0)return c.makeTensorInfo(w,a[0].dtype,[]);const S=a.filter(O=>G(O.shape)>0);return S.length===1?lP({inputs:{x:S[0]},backend:c}):hN(S,v,c)}const i2={kernelName:HJ,backendName:"webgl",kernelFunc:i1};class i3{constructor(a,c=!1,p=null,m=!1,v=!1){this.variableNames=["x","W"],this.outputShape=a.outShape;const b=a.padInfo.top,w=a.padInfo.left,S=a.strideHeight,O=a.strideWidth,q=a.dilationHeight,H=a.dilationWidth,j=a.filterHeight,$=a.filterWidth,J=Math.floor(a.inChannels/4)*4,ee=a.inChannels%4,re=a.dataFormat==="channelsLast",de=re?1:2,Te=re?2:3,Me=re?3:1;let Ae="",Ce="";p&&(m?Ae=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+p+`
        }`:v?Ae=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+p+`
        }`:Ae=`
          float activation(float x) {
            `+p+`
          }
        `,Ce="result = activation(result);");const Pe=c?"result += getBiasAtOutCoords();":"";c&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),v&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+Ae+`

      const ivec2 strides = ivec2(`+S+", "+O+`);
      const ivec2 pads = ivec2(`+b+", "+w+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+Me+`];

        ivec2 xRCCorner =
            ivec2(coords[`+de+"], coords["+Te+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+j+`; wR++) {
          int xR = xRCorner + wR * `+q+`;

          if (xR < 0 || xR >= `+a.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+$+`; wC++) {
            int xC = xCCorner + wC * `+H+`;

            if (xC < 0 || xC >= `+a.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+J+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+re+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(ee===1)+`) {

              if (`+re+`) {
                dotProd +=
                    getX(batch, xR, xC, `+J+`) *
                    getW(wR, wC, `+J+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+J+`, xR, xC) *
                    getW(wR, wC, `+J+`, d2);
              }

            } else if (`+(ee===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+J+`, d2),
                getW(wR, wC, `+J+` + 1, d2)
              );

              if (`+re+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+J+`),
                  getX(batch, xR, xC, `+J+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+J+`, xR, xC),
                  getX(batch, `+J+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(ee===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+J+`, d2),
                getW(wR, wC, `+J+` + 1, d2),
                getW(wR, wC, `+J+` + 2, d2)
              );

              if (`+re+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+J+`),
                  getX(batch, xR, xC, `+J+` + 1),
                  getX(batch, xR, xC, `+J+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+J+`, xR, xC),
                  getX(batch, `+J+` + 1, xR, xC),
                  getX(batch, `+J+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+Pe+`
        `+Ce+`
        setOutput(result);
      }
    `}}class i4{constructor(a,c=!1,p=null,m=!1,v=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=oN(this.outputShape.length);const b=a.padInfo.left,w=a.strideWidth,S=a.dilationWidth,O=a.filterHeight,q=a.filterWidth,H=q;let j=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let re=0;re<q;re++)j+=`
           vec4 xTexelC`+re*2+`;
           int xTexelC`+re*2+`Ready;
           vec4 xTexelC`+(re*2+1)+`;
           int xTexelC`+(re*2+1)+`Ready;
           vec4 xC`+re+";";j+=`
     for (int r = 0; r < `+O+`; r++) {
      for (int d1 = 0; d1 < `+a.inChannels+`; d1 += 2) {
       `;for(let re=0;re<q;re++)j+=`
           xTexelC`+re*2+` = vec4(0.0);
           xTexelC`+re*2+`Ready = 0;
           xTexelC`+(re*2+1)+` = vec4(0.0);
           xTexelC`+(re*2+1)+`Ready = 0;
           xC`+re+" = vec4(0.0);";j+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let re=0;re<(H+1)/2;re++){const de=re*2;if(j+=`
           xC = xCCorner + `+de*S+`;
           `,w===1){if(de<q&&(b%2===1?(j+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+de+`Ready == 0) {
                   xTexelC`+de+` = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+de+`.zw = vec2(0.0);
                   }
                   xTexelC`+de+`Ready = 1;
                 }
               `,S===1&&de>0?j+=`
                 xC`+de+" = vec4(xTexelC"+(de-2)+".zw, xTexelC"+de+`.xy);
                 `:j+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC`+de+" = vec4(previous.zw, xTexelC"+de+`.xy);
                   } else {
                     xC`+de+" = vec4(0.0, 0.0, xTexelC"+de+`.xy);
                   }
                   `):j+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC`+de+`Ready == 0) {
                   xTexelC`+de+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+de+`.zw = vec2(0.0);
                   }
                   xTexelC`+de+`Ready = 1;
                 }

                 xC`+de+" = xTexelC"+de+`;
                 `,de+1<q)){const Te=b%2===0?n(S):S;S%2===0&&b%2===1||S%2!==0&&b%2!==1?(j+=`
                   xCOffset = xC + imod(pads[1], 2) + `+Te+`;

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(de+1)+`Ready == 0) {
                     xTexelC`+(de+1)+` = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC`+(de+1)+`.zw = vec2(0.0);
                     }
                     xTexelC`+(de+1)+`Ready = 1;
                   }
                   `,S>1?j+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC`+(de+1)+" = vec4(previous.zw, xTexelC"+(de+1)+`.xy);
                     } else {
                      xC`+(de+1)+" = vec4(0.0, 0.0, xTexelC"+(de+1)+`.xy);
                     }
                     `:j+=`
                     xC`+(de+1)+" = vec4(xTexelC"+de+".zw, xTexelC"+(de+1)+`.xy);
                     `):Te===1?j+=`
                     xC`+(de+1)+" = xTexelC"+de+`;
                     `:j+=`
                     xCOffset = xC + `+Te+`;

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(de+1)+`Ready == 0) {
                       xTexelC`+(de+1)+` = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC`+(de+1)+`.zw = vec2(0.0);
                       }
                       xTexelC`+(de+1)+`Ready = 1;
                     }

                     xC`+(de+1)+" = xTexelC"+(de+1)+`;
                     `}}else de<q&&(b%2===1?(j+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+de+`Ready == 0) {
                   xTexelC`+de+` = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+de+`.zw = vec2(0.0);
                   }
                   xTexelC`+de+`Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(de+1)+`Ready == 0) {
                   xTexelC`+(de+1)+` = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC`+(de+1)+`.zw = vec2(0.0);
                   }
                   xTexelC`+(de+1)+`Ready = 1;
                 }

                 xC`+de+" = vec4(xTexelC"+de+".zw, xTexelC"+(de+1)+`.zw);
               `,de+1<q&&(j+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC`+(de+1)+" = vec4(xTexelC"+(de+1)+`.xy, final.xy);
                 `)):(j+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC`+de+`Ready == 0) {
                   xTexelC`+de+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+de+`.zw = vec2(0.0);
                   }
                   xTexelC`+de+`Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(de+1)+`Ready == 0) {
                   xTexelC`+(de+1)+` = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+(de+1)+`.zw = vec2(0.);
                   }
                   xTexelC`+(de+1)+`Ready = 1;
                 }

                 xC`+de+` = vec4(
                   xTexelC`+de+".xy, xTexelC"+(de+1)+`.xy);
               `,de+1<q&&(j+=`
                   xC`+(de+1)+" = vec4(xTexelC"+de+".zw, xTexelC"+(de+1)+`.zw);
                 `)));de<q&&(j+=`
             wTexel = getW(r, `+de+`, d1, d2);
             dotProd += xC`+de+`.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < `+a.inChannels+`) {
               dotProd += xC`+de+`.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,de+1<q&&(j+=`
               wTexel = getW(r, `+(de+1)+`, d1, d2);
               dotProd += xC`+(de+1)+`.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < `+a.inChannels+`) {
                 dotProd += xC`+(de+1)+`.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}j+=`
     }
   `,j+=`
     }
   `,j+=`
     }
   `;let $="",J="";p&&(m?$=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           `+p+`
         }`:v?$=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           `+p+`
         }`:$=`vec4 activation(vec4 x) {
           `+p+`
         }`,J="result = activation(result);");const ee=c?"result += getBiasAtOutCoords();":"";c&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),v&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       `+$+`

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         `+j+`

         vec4 result = dotProd - vec4(0.000000000000001);
         `+ee+`
         `+J+`
         setOutput(result);
       }
     `}}class i5{constructor(a,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=a,this.enableShapeUniforms=oN(this.outputShape.length);const{dataFormat:p}=c,m=o1(),v=p==="channelsLast",b=v?1:2,w=v?2:3,S=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < "+a[2]+" && pos < "+a[1]+") {";let O="";for(let q=0;q<=1;q++)for(let H=0;H<=1;H++)O+=`
          blockIndex = rc.z + `+H+`;
          pos = rc.y + `+q+`;

          `+S+`
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[`+b+`] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[`+w+`] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (`+v+`) {
                  innerDims = vec2(d1, ch);
                  result[`+(q*2+H)+`] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+(q*2+H)+`] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+O+`

        `+m.output+` = result;
      }
    `}}function i6(u,a){const c=u.length;return c>=3?a?[...u.slice(0,-3),u[c-3]*u[c-2],u[c-1]]:[...u.slice(0,-3),u[c-3],u[c-2]*u[c-1]]:!a&&c===1&&u[0]>1?[u[0],1]:null}function i7({x:u,filter:a,convInfo:c,backend:p,bias:m=null,preluActivationWeights:v=null,leakyreluAlpha:b=0,activation:w=null}){const S=u.shape,O=p.texData.get(u.dataId),q=c.inChannels,H=S[0]*S[1]*S[2],j=c.outChannels,$=c.dataFormat==="channelsLast",J=!1,ee=!1;let re;const de=[];if(v!=null){const Te=i6(v.shape,$);Te!=null&&(v=hp({inputs:{x:v},backend:p,attrs:{shape:Te}}),de.push(v))}if(m!=null){const Te=i6(m.shape,$);Te!=null&&(m=hp({inputs:{x:m},backend:p,attrs:{shape:Te}}),de.push(m))}if(!((H===1||j===1)&&q>hA)&&O.isPacked&&$&&O.texture!=null&&S[2]%2!==0&&z(O.shape.slice(-3),S.slice(-3))){const Te=S[0]*S[1]*(S[2]+1),Me={dataId:u.dataId,shape:[1,Te,c.inChannels],dtype:u.dtype},Ae=O.shape;O.shape=O.shape.slice(),O.shape[O.shape.length-2]++,i(YM(O.shape,Me.shape),()=>"packed reshape "+O.shape+" to "+Me.shape+" isn't free");const Ce=hp({inputs:{x:a},backend:p,attrs:{shape:[1,c.inChannels,c.outChannels]}});de.push(Ce);const Pe=hC({a:Me,b:Ce,backend:p,transposeA:J,transposeB:ee,bias:m,activation:w,preluActivationWeights:v,leakyreluAlpha:b}),je=p.texData.get(Pe.dataId);i(je.isPacked,()=>"batchMatMul result is expected to be packed"),O.shape=Ae,je.shape=c.outShape,re=lP({inputs:{x:Pe},backend:p}),re.shape=c.outShape,de.push(Pe)}else{const Te=c.outHeight*c.outWidth,Me=hp({inputs:{x:u},backend:p,attrs:{shape:$?[c.batchSize,Te,c.inChannels]:[c.batchSize,c.inChannels,Te]}}),Ae=hp({inputs:{x:a},backend:p,attrs:{shape:[1,c.inChannels,c.outChannels]}}),Ce=hC({a:$?Me:Ae,b:$?Ae:Me,transposeA:!$,transposeB:ee,backend:p,bias:m,activation:w,preluActivationWeights:v,leakyreluAlpha:b});re=hp({inputs:{x:Ce},backend:p,attrs:{shape:c.outShape}}),de.push(Me),de.push(Ae),de.push(Ce)}for(const Te of de)p.disposeIntermediateTensorInfo(Te);return re}function i8({x:u,filter:a,convInfo:c,backend:p,bias:m=null,preluActivationWeights:v=null,leakyreluAlpha:b=0,activation:w=null}){const{filterWidth:S,filterHeight:O,inChannels:q,outWidth:H,outHeight:j,dataFormat:$}=c,J=$==="channelsLast",ee=S*O*q,re=j*H,de=[c.batchSize,ee,re],Te=!0,Me=!1,Ae=[];if(v!=null){const Ut=i6(v.shape,J);Ut!=null&&(v=hp({inputs:{x:v},backend:p,attrs:{shape:Ut}}),Ae.push(v))}if(m!=null){const Ut=i6(m.shape,J);Ut!=null&&(m=hp({inputs:{x:m},backend:p,attrs:{shape:Ut}}),Ae.push(m))}const Ce=hp({inputs:{x:a},backend:p,attrs:{shape:[1,ee,G(a.shape)/ee]}});Ae.push(Ce);const Pe=new i5(de,c),je=[u.shape,[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inChannels],[c.filterWidth*c.inChannels],[c.outWidth]],Ne=p.runWebGLProgram(Pe,[u],"float32",je),Qe=hp({inputs:{x:Ne},backend:p,attrs:{shape:de}});Ae.push(Ne),Ae.push(Qe);const Ct=m!=null,dt=v!=null,Xt=w==="leakyrelu",Gt=w?h5(w,!0):null,Vt=new hZ(J?Qe.shape:Ce.shape,J?Ce.shape:Qe.shape,J?[c.batchSize,re,c.outChannels]:[c.batchSize,c.outChannels,re],Te,Me,Ct,Gt,dt,Xt),T0=J?[Qe,Ce]:[Ce,Qe];if(m&&T0.push(m),dt&&T0.push(v),Xt){const Ut=p.makeTensorInfo([],"float32",yd(b,"float32"));T0.push(Ut),Ae.push(Ut)}const r0=p.runWebGLProgram(Vt,T0,"float32"),d0=hp({inputs:{x:r0},backend:p,attrs:{shape:c.outShape}});Ae.push(r0);for(const Ut of Ae)p.disposeIntermediateTensorInfo(Ut);return d0}function i9(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v}=a,{strides:b,pad:w,dataFormat:S,dilations:O,dimRoundingMode:q}=p,H=Ed(S),j=ER(m.shape,v.shape,b,O,w,q,!1,H);let $;if(j.filterHeight===1&&j.filterWidth===1&&j.dilationHeight===1&&j.dilationWidth===1&&j.strideHeight===1&&j.strideWidth===1&&(j.padInfo.type==="SAME"||j.padInfo.type==="VALID"))$=i7({x:m,filter:v,convInfo:j,backend:c});else if(j.strideWidth<=2&&H==="channelsLast"&&Hn().getBool("WEBGL_EXP_CONV")){const ee=new i4(j),re=[[j.padInfo.top,j.padInfo.left],[j.strideHeight,j.strideWidth],[j.dilationHeight,j.dilationWidth],[j.inHeight,j.inWidth]];$=c.runWebGLProgram(ee,[m,v],"float32",re)}else if(Hn().getBool("WEBGL_CONV_IM2COL"))$=i8({x:m,filter:v,convInfo:j,backend:c});else{const ee=new i3(j);$=c.runWebGLProgram(ee,[m,v],"float32")}const J=hp({inputs:{x:$},backend:c,attrs:{shape:j.outShape}});return c.disposeIntermediateTensorInfo($),J}const iH={kernelName:Hx,backendName:"webgl",kernelFunc:i9},iD=h2+`
  return cos(x);
`,iy=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  `+lV+`
  return result;
`,ia=h3({opSnippet:iD,packedOpSnippet:iy}),is={kernelName:Hg,backendName:"webgl",kernelFunc:ia};class iI{constructor(a,c,p,m,v){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[b,w,S,O]=a,[q]=c,[H,j]=p;this.outputShape=[q,H,j,O];const $=m==="bilinear"?1:0,[J,ee]=[w-1+".0",S-1+".0"],[re,de,Te]=H>1?[""+(w-1)/(H-1),"(y2-y1) * height_ratio","y1*"+J+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+J],[Me,Ae,Ce]=j>1?[""+(S-1)/(j-1),"(x2-x1) * width_ratio","x1*"+ee+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+ee];this.userCode=`
      const float height_ratio = float(`+re+`);
      const float width_ratio = float(`+Me+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+b+`) {
          return;
        }

        float height_scale = `+de+`;
        float width_scale = `+Ae+`;

        float in_y = `+Te+`;
        if( in_y < 0.0 || in_y > `+J+` ) {
          setOutput(float(`+v+`));
          return;
        }
        float in_x = `+Ce+`;
        if( in_x < 0.0 || in_x > `+ee+` ) {
          setOutput(float(`+v+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+$+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const iE=u=>{const{inputs:a,backend:c,attrs:p}=u,{image:m,boxes:v,boxInd:b}=a,{cropSize:w,method:S,extrapolationValue:O}=p,q=new iI(m.shape,v.shape,w,S,O);return c.runWebGLProgram(q,[m,v,b],"float32")},iO={kernelName:HK,backendName:"webgl",kernelFunc:iE};class ic{constructor(a,c,p){this.variableNames=["x"],this.outputShape=[],this.outputShape=a,this.blockSize=c,this.dataFormat=p,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+c+`;
      int offset_h = imod(h, `+c+`);
      int in_w = w / `+c+`;
      int offset_w = imod(w, `+c+`);
      int offset_d = (offset_h * `+c+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function iZ(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{blockSize:v,dataFormat:b}=p,w=m.shape[0],S=b==="NHWC"?m.shape[1]:m.shape[2],O=b==="NHWC"?m.shape[2]:m.shape[3],q=b==="NHWC"?m.shape[3]:m.shape[1],H=S*v,j=O*v,$=q/(v*v),J=b==="NHWC"?[w,H,j,$]:[w,$,H,j],ee=new ic(J,v,b);return c.runWebGLProgram(ee,[m],m.dtype)}const iL={kernelName:Hb,backendName:"webgl",kernelFunc:iZ};class iq{constructor(a,c=!1,p=null,m=!1,v=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=oN(this.outputShape.length);const b=a.filterHeight,w=a.filterWidth,S=a.outChannels/a.inChannels;let O="",q="";p&&(m?O=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+p+`
        }`:v?O=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+p+`
        }`:O=`
          float activation(float x) {
            `+p+`
          }
        `,q="result = activation(result);");const H=c?"result += getBiasAtOutCoords();":"";c&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),v&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+O+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+S+`;
        int q = d2 - d1 * `+S+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+b+`; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < `+w+`; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+H+`
        `+q+`
        setOutput(result);
      }
    `}}class iF{constructor(a,c=!1,p=null,m=!1,v=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=a.outShape,this.enableShapeUniforms=oN(this.outputShape.length);const b=a.outChannels/a.inChannels,w=a.padInfo.left,S=a.strideWidth,O=a.dilationWidth,q=a.filterHeight,H=a.filterWidth,j=H;let $=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let de=0;de<H;de++)$+=`
          vec4 xTexelC`+de*2+`;
          int xTexelC`+de*2+`Ready;
          vec4 xTexelC`+(de*2+1)+`;
          int xTexelC`+(de*2+1)+`Ready;
          vec4 xC`+de+";";$+=`
    for (int r = 0; r < `+q+`; r++) {
      `;for(let de=0;de<H;de++)$+=`
          xTexelC`+de*2+` = vec4(0.0);
          xTexelC`+de*2+`Ready = 0;
          xTexelC`+(de*2+1)+` = vec4(0.0);
          xTexelC`+(de*2+1)+`Ready = 0;
          xC`+de+" = vec4(0.0);";$+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let de=0;de<(j+1)/2;de++){const Te=de*2;if($+=`
          xC = xCCorner + `+Te*O+`;
          `,S===1){if(Te<H&&(w%2===1?($+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Te+`Ready == 0) {
                  xTexelC`+Te+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+Te+`.zw = vec2(0.0);
                  }
                  xTexelC`+Te+`Ready = 1;
                }
              `,O===1&&Te>0?$+=`
                xC`+Te+" = vec4(xTexelC"+(Te-2)+".zw, xTexelC"+Te+`.xy);
                `:$+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC`+Te+" = vec4(previous.zw, xTexelC"+Te+`.xy);
                  } else {
                    xC`+Te+" = vec4(0.0, 0.0, xTexelC"+Te+`.xy);
                  }
                  `):$+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC`+Te+`Ready == 0) {
                  xTexelC`+Te+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+Te+`.zw = vec2(0.0);
                  }
                  xTexelC`+Te+`Ready = 1;
                }

                xC`+Te+" = xTexelC"+Te+`;
                `,Te+1<H)){const Me=w%2===0?n(O):O;O%2===0&&w%2===1||O%2!==0&&w%2!==1?($+=`
                  xCOffset = xC + imod(pads[1], 2) + `+Me+`;

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Te+1)+`Ready == 0) {
                    xTexelC`+(Te+1)+` = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC`+(Te+1)+`.zw = vec2(0.0);
                    }
                    xTexelC`+(Te+1)+`Ready = 1;
                  }
                  `,O>1?$+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC`+(Te+1)+" = vec4(previous.zw, xTexelC"+(Te+1)+`.xy);
                    } else {
                     xC`+(Te+1)+" = vec4(0.0, 0.0, xTexelC"+(Te+1)+`.xy);
                    }
                    `:$+=`
                    xC`+(Te+1)+" = vec4(xTexelC"+Te+".zw, xTexelC"+(Te+1)+`.xy);
                    `):Me===1?$+=`
                    xC`+(Te+1)+" = xTexelC"+Te+`;
                    `:$+=`
                    xCOffset = xC + `+Me+`;

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Te+1)+`Ready == 0) {
                      xTexelC`+(Te+1)+` = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC`+(Te+1)+`.zw = vec2(0.0);
                      }
                      xTexelC`+(Te+1)+`Ready = 1;
                    }

                    xC`+(Te+1)+" = xTexelC"+(Te+1)+`;
                    `}}else Te<H&&(w%2===1?($+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+Te+`Ready == 0) {
                  xTexelC`+Te+` = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+Te+`.zw = vec2(0.0);
                  }
                  xTexelC`+Te+`Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(Te+1)+`Ready == 0) {
                  xTexelC`+(Te+1)+` = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC`+(Te+1)+`.zw = vec2(0.0);
                  }
                  xTexelC`+(Te+1)+`Ready = 1;
                }

                xC`+Te+" = vec4(xTexelC"+Te+".zw, xTexelC"+(Te+1)+`.zw);
              `,Te+1<H&&($+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC`+(Te+1)+" = vec4(xTexelC"+(Te+1)+`.xy, final.xy);
                `)):($+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC`+Te+`Ready == 0) {
                  xTexelC`+Te+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+Te+`.zw = vec2(0.0);
                  }
                  xTexelC`+Te+`Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(Te+1)+`Ready == 0) {
                  xTexelC`+(Te+1)+` = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+(Te+1)+`.zw = vec2(0.);
                  }
                  xTexelC`+(Te+1)+`Ready = 1;
                }

                xC`+Te+` = vec4(
                  xTexelC`+Te+".xy, xTexelC"+(Te+1)+`.xy);
              `,Te+1<H&&($+=`
                  xC`+(Te+1)+" = vec4(xTexelC"+Te+".zw, xTexelC"+(Te+1)+`.zw);
                `)));Te<H&&($+=`
            wTexel = getW(r, `+Te+`, d1, q);
            dotProd += xC`+Te+` * vec4(wTexel.xz, wTexel.xz);
          `,Te+1<H&&($+=`
              wTexel = getW(r, `+(Te+1)+`, d1, q);
              dotProd += xC`+(Te+1)+` * vec4(wTexel.xz, wTexel.xz);
            `))}$+=`
    }
  `,$+=`
      }
    `;let J="",ee="";p&&(m?J=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+p+`
        }`:v?J=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+p+`
        }`:J=`vec4 activation(vec4 x) {
          `+p+`
        }`,ee="result = activation(result);");const re=c?"result += getBiasAtOutCoords();":"";c&&this.variableNames.push("bias"),m&&this.variableNames.push("preluActivationWeights"),v&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+J+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+b+`;
        int q = d2 - d1 * `+b+`;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        `+$+`

        vec4 result = dotProd - vec4(0.000000000000001);
        `+re+`
        `+ee+`
        setOutput(result);
      }
    `}}function iY(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v}=a,{strides:b,pad:w,dilations:S,dimRoundingMode:O}=p;let q=S;q==null&&(q=[1,1]),i(Eb(b,q),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+q+"'");const H=ER(m.shape,v.shape,b,q,w,O,!0);let j;Hn().getBool("WEBGL_PACK_DEPTHWISECONV")&&H.strideWidth<=2&&H.outChannels/H.inChannels===1?j=new iF(H):j=new iq(H);const $=[[H.padInfo.top,H.padInfo.left],[H.strideHeight,H.strideWidth],[H.dilationHeight,H.dilationWidth],[H.inHeight,H.inWidth]];return c.runWebGLProgram(j,[m,v],"float32",$)}const ip={kernelName:HV,backendName:"webgl",kernelFunc:iY};function iS(u){const{inputs:a,attrs:c,backend:p}=u,{dim:m}=c,{input:v}=a,b=v.shape.length,w=v.shape.slice();let S=m;return m<0&&(i(-(b+1)<=m,()=>"Axis must be in the interval ["+-(b+1)+", "+b+"]"),S=b+m+1),w.splice(S,0,1),hp({inputs:{x:v},backend:p,attrs:{shape:w}})}const il={kernelName:He,backendName:"webgl",kernelFunc:iS};class ih{constructor(a,c){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=a,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function ii(u){const{backend:a,attrs:c}=u,{shape:p,value:m}=c;let{dtype:v}=c;if(v=v||H8(m),v==="string"){const b=N(v,G(p));return b.fill(m),a.makeTensorInfo(p,v,b)}else{const b=new ih(p,m),w=[[m]];return a.runWebGLProgram(b,[],v,w)}}const im={kernelName:HB,backendName:"webgl",kernelFunc:ii},it="return floor(x);",ik=h3({opSnippet:it,packedOpSnippet:it,cpuKernelImpl:Sm}),iw={kernelName:D0,backendName:"webgl",kernelFunc:ik};class iU{constructor(a){this.variableNames=["A"];const c=o1(),[p,m]=a;this.outputShape=a,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+m+".0, "+p+`.0);

        vec4 values = `+c.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class iG{constructor(a){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const c=o1(),[p,m]=a;this.outputShape=a,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+m+".0, "+p+`.0);
            vec4 values = `+c.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+c.output+` = result;
      }
    `}}const iz={kernelName:DV,backendName:"webgl",kernelFunc:ij};let iW,iR=Hn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function ij(u){const{inputs:a,backend:c,attrs:p}=u;let{pixels:m}=a;const{numChannels:v}=p,b=typeof HTMLVideoElement<"u"&&m instanceof HTMLVideoElement,w=typeof HTMLImageElement<"u"&&m instanceof HTMLImageElement,[S,O]=b?[m.videoWidth,m.videoHeight]:[m.width,m.height],q=[O,S],H=[O,S,v];if(w||b){const ee=Hn().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(iW==null||ee!==iR)&&(iR=ee,iW=document.createElement("canvas").getContext("2d",{willReadFrequently:iR})),iW.canvas.width=S,iW.canvas.height=O,iW.drawImage(m,0,0,S,O),m=iW.canvas}const j=c.makeTensorInfo(q,"int32");c.texData.get(j.dataId).usage=Y5.PIXELS,c.gpgpu.uploadPixelDataToTexture(c.getTexture(j.dataId),m);const $=Hn().getBool("WEBGL_PACK")?new iG(H):new iU(H),J=c.runWebGLProgram($,[j],"int32");return c.disposeData(j.dataId),J}function iA(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v,bias:b,preluActivationWeights:w}=a,{strides:S,pad:O,dataFormat:q,dilations:H,dimRoundingMode:j,activation:$,leakyreluAlpha:J}=p,ee=Ed(q),re=ER(m.shape,v.shape,S,H,O,j,!1,ee);let de;const Te=[],Me=b!=null,Ae=w!=null,Ce=$==="leakyrelu",Pe=()=>{const Ne=[m,v],Qe=(Ct,dt)=>{if(dt==="NCHW"&&Ct.shape.length===1&&Ct.shape[0]!==1){const Xt=hp({inputs:{x:Ct},backend:c,attrs:{shape:[Ct.shape[0],1,1]}});return Te.push(Xt),Xt}return Ct};if(Me&&Ne.push(Qe(b,q)),Ae&&Ne.push(Qe(w,q)),Ce){const Ct=c.makeTensorInfo([],"float32",yd(J,"float32"));Ne.push(Ct),Te.push(Ct)}return Ne};if(re.filterHeight===1&&re.filterWidth===1&&re.dilationHeight===1&&re.dilationWidth===1&&re.strideHeight===1&&re.strideWidth===1&&(re.padInfo.type==="SAME"||re.padInfo.type==="VALID"))de=i7({x:m,filter:v,convInfo:re,backend:c,bias:b,activation:$,preluActivationWeights:w,leakyreluAlpha:J});else if(re.strideWidth<=2&&ee==="channelsLast"&&Hn().getBool("WEBGL_EXP_CONV")){const Ne=$?h5($,!0):null,Qe=new i4(re,Me,Ne,Ae,Ce),Ct=[[re.padInfo.top,re.padInfo.left],[re.strideHeight,re.strideWidth],[re.dilationHeight,re.dilationWidth],[re.inHeight,re.inWidth]],dt=Pe();de=c.runWebGLProgram(Qe,dt,"float32",Ct)}else if(Hn().getBool("WEBGL_CONV_IM2COL"))de=i8({x:m,filter:v,convInfo:re,backend:c,bias:b,activation:$,preluActivationWeights:w,leakyreluAlpha:J});else{const Ne=$?h5($,!1):null,Qe=new i3(re,Me,Ne,Ae,Ce),Ct=Pe();de=c.runWebGLProgram(Qe,Ct,"float32")}const je=hp({inputs:{x:de},backend:c,attrs:{shape:re.outShape}});return Te.push(de),Te.forEach(Ne=>c.disposeIntermediateTensorInfo(Ne)),je}const iC={kernelName:Dv,backendName:"webgl",kernelFunc:iA};function iu(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v,bias:b,preluActivationWeights:w}=a,{strides:S,pad:O,dilations:q,dimRoundingMode:H,activation:j,leakyreluAlpha:$}=p,J=[];let ee=q;ee==null&&(ee=[1,1]),i(Eb(S,ee),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+S+" and dilations '"+ee+"'");const re=ER(m.shape,v.shape,S,ee,O,H,!0),de=Hn().getBool("WEBGL_PACK_DEPTHWISECONV")&&re.strideWidth<=2&&re.outChannels/re.inChannels===1,Te=j?h5(j,de):null,Me=[m,v],Ae=b!=null,Ce=w!=null,Pe=j==="leakyrelu";if(Ae&&Me.push(b),Ce&&Me.push(w),Pe){const Ct=c.makeTensorInfo([],"float32",yd($,"float32"));Me.push(Ct),J.push(Ct)}let je;de?je=new iF(re,Ae,Te,Ce,Pe):je=new iq(re,Ae,Te,Ce,Pe);const Ne=[[re.padInfo.top,re.padInfo.left],[re.strideHeight,re.strideWidth],[re.dilationHeight,re.dilationWidth],[re.inHeight,re.inWidth]],Qe=c.runWebGLProgram(je,Me,"float32",Ne);return J.forEach(Ct=>c.disposeIntermediateTensorInfo(Ct)),Qe}const iQ={kernelName:DT,backendName:"webgl",kernelFunc:iu};class iJ{constructor(a,c){this.variableNames=["A","indices"],this.outputShape=c,this.rank=c.length;const p=ob(this.rank),m=ix(a);this.userCode=`
      void main() {
        `+p+` resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < `+a[2]+`) ? 1.0 : 0.0;
        setOutput(inBounds * getA(`+m+`));
      }
    `}}function ix(u,a){const c=["resRC.x","resRC.y","resRC.z","resRC.w"],p=[];for(let m=0;m<u.length;m++)m===2?p.push("index"):p.push(""+c[m]);return p.join()}function iM(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,indices:v}=a,{axis:b,batchDims:w}=p,S=P(b,m.shape)[0];if(Hn().get("DEBUG")){const Te=c.readSync(v.dataId),Me=m.shape[S];for(let Ae=0;Ae<Te.length;++Ae){const Ce=Te[Ae];i(Ce<=Me-1&&Ce>=0,()=>"GatherV2: the index value "+Ce+" is not in [0, "+(Me-1)+"]")}}const O=LS(m,v,S,w),q=G(v.shape),H=[],j=hp({inputs:{x:m},backend:c,attrs:{shape:[O.batchSize,O.outerSize,O.dimSize,O.sliceSize]}}),$=hp({inputs:{x:v},backend:c,attrs:{shape:[O.batchSize,q/O.batchSize]}});H.push(j),H.push($);const J=[O.batchSize,O.outerSize,q/O.batchSize,O.sliceSize];if(c.shouldExecuteOnCPU([m,v])||m.dtype==="string"){const Te=c.bufferSync($),Me=c.bufferSync(j),Ae=Sk(Me,Te,J);return H.forEach(Ce=>c.disposeIntermediateTensorInfo(Ce)),c.makeTensorInfo(O.outputShape,Ae.dtype,Ae.values)}const ee=new iJ(j.shape,J),re=c.runWebGLProgram(ee,[j,$],j.dtype);H.push(re);const de=hp({inputs:{x:re},backend:c,attrs:{shape:O.outputShape}});return H.forEach(Te=>c.disposeIntermediateTensorInfo(Te)),de}const iX={kernelName:D2,backendName:"webgl",kernelFunc:iM},ig="return float(a >= b);",iK=`
  return vec4(greaterThanEqual(a, b));
`,ib=h4({opSnippet:ig,packedOpSnippet:iK,dtype:"bool",cpuKernelImpl:SU}),iV={kernelName:D4,backendName:"webgl",kernelFunc:ib},id="return float(a < b);",iP=`
  return vec4(lessThan(a, b));
`,iv=h4({opSnippet:id,packedOpSnippet:iP,cpuKernelImpl:SG,dtype:"bool"}),iT={kernelName:D8,backendName:"webgl",kernelFunc:iv},ir="return float(a <= b);",ie=`
  return vec4(lessThanEqual(a, b));
`,iB=h4({opSnippet:ir,packedOpSnippet:ie,cpuKernelImpl:Sz,dtype:"bool"}),iN={kernelName:D9,backendName:"webgl",kernelFunc:iB},m0="return float(a >= 1.0 && b >= 1.0);",m1=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,m2=h4({opSnippet:m0,packedOpSnippet:m1,dtype:"bool"}),m3={kernelName:DH,backendName:"webgl",kernelFunc:m2},m4="return float(a >= 1.0 || b >= 1.0);",m5=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,m6=h4({opSnippet:m4,packedOpSnippet:m5,dtype:"bool"}),m7={kernelName:DD,backendName:"webgl",kernelFunc:m6};function m8(u,a,c,p){const m=G(a),v=G(u.shape)/m,b=hp({inputs:{x:u},attrs:{shape:[v,m]},backend:p}),w=hm(b,u.dtype,"max",p),S=hp({inputs:{x:w},attrs:{shape:c},backend:p});return p.disposeIntermediateTensorInfo(b),p.disposeIntermediateTensorInfo(w),S}function m9(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{reductionIndices:v,keepDims:b}=p,w=m.shape.length,S=P(v,m.shape);let O=S;const q=fC(O,w),H=q!=null,j=c.shouldExecuteOnCPU([m]);let $=m;if(H){if(j){const Te=c.texData.get($.dataId).values,Me=new Array(w);for(let Pe=0;Pe<Me.length;Pe++)Me[Pe]=m.shape[q[Pe]];const Ae=l7(Te,m.shape,m.dtype,q,Me);$=c.makeTensorInfo(Me,m.dtype);const Ce=c.texData.get($.dataId);Ce.values=Ae}else $=hU(m,q,c);O=fQ(O.length,w)}fA("max",O,w);const[J,ee]=fR($.shape,O);let re=J;b&&(re=fj(J,S));let de;if(j){const Te=c.texData.get($.dataId).values,Me=Sj(Te,G(ee),re,m.dtype);de=c.makeTensorInfo(re,m.dtype);const Ae=c.texData.get(de.dataId);Ae.values=Me}else de=m8($,ee,re,c);return H&&c.disposeIntermediateTensorInfo($),de}const mH={kernelName:Dy,backendName:"webgl",kernelFunc:m9};function mD(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a;YN(m,"maxPool");const{filterSize:v,strides:b,pad:w,dimRoundingMode:S}=p,O=1;i(Eb(b,O),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+O+"'");const q=Ez(m.shape,v,b,O,w,S);if(q.filterWidth===1&&q.filterHeight===1&&z(q.inShape,q.outShape))return lP({inputs:{x:m},backend:c});const H=new hf(q,"max",!1);return c.runWebGLProgram(H,[m],m.dtype)}const my={kernelName:Ds,backendName:"webgl",kernelFunc:mD},ma=lK+`
  return max(a, b);
`,ms=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+lV+`
  return result;
`,mI=h4({opSnippet:ma,packedOpSnippet:ms,cpuKernelImpl:SA}),mE={kernelName:Da,backendName:"webgl",kernelFunc:mI};function mf(u,a,c,p){const m=G(a),v=G(u.shape)/m,b=hp({inputs:{x:u},attrs:{shape:[v,m]},backend:p}),w=hm(b,"float32","mean",p),S=hp({inputs:{x:w},attrs:{shape:c},backend:p});return p.disposeIntermediateTensorInfo(b),p.disposeIntermediateTensorInfo(w),S}const mO={kernelName:DI,backendName:"webgl",kernelFunc:({inputs:u,attrs:a,backend:c})=>{const{x:p}=u,{keepDims:m,axis:v}=a,b=c,w=p.shape.length,S=P(v,p.shape);let O=S;const q=fC(O,w),H=q!=null,j=b.shouldExecuteOnCPU([p]),$=[];let J=p;if(H){if(j){const Me=b.texData.get(J.dataId).values,Ae=new Array(w);for(let je=0;je<Ae.length;je++)Ae[je]=p.shape[q[je]];const Ce=l7(Me,p.shape,p.dtype,q,Ae);J=b.makeTensorInfo(Ae,p.dtype);const Pe=b.texData.get(J.dataId);Pe.values=Ce}else J=hU(p,q,b);$.push(J),O=fQ(O.length,w)}fA("sum",O,w);const[ee,re]=fR(J.shape,O);let de=ee;m&&(de=fj(ee,S));const Te=mf(J,re,de,b);for(const Me of $)b.disposeIntermediateTensorInfo(Me);return Te}};function mc(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{axis:v,keepDims:b}=p,w=m.shape.length,S=P(v,m.shape);let O=S;const q=fC(O,w);let H=m;q!=null&&(H=hR({inputs:{x:m},backend:c,attrs:{perm:q}}),O=fQ(O.length,m.shape.length)),fA("min",O,w);const[j,$]=fR(H.shape,O),J=G($),ee=hp({inputs:{x:H},backend:c,attrs:{shape:[-1,J]}}),re=hm(ee,ee.dtype,"min",c);let de;if(b){const Te=fj(j,S);de=hp({inputs:{x:re},backend:c,attrs:{shape:Te}})}else de=hp({inputs:{x:re},backend:c,attrs:{shape:j}});return c.disposeIntermediateTensorInfo(ee),c.disposeIntermediateTensorInfo(re),q!=null&&c.disposeIntermediateTensorInfo(H),de}const mZ={kernelName:DE,backendName:"webgl",kernelFunc:mc},mL=lK+`
  return min(a, b);
`,mq=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+lV+`
  return result;
`,mF=h4({opSnippet:mL,packedOpSnippet:mq,cpuKernelImpl:SC}),mY={kernelName:Df,backendName:"webgl",kernelFunc:mF},mo=lF+`
  return -x;
`,mn=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function mp(u){const{inputs:a,backend:c}=u,{x:p}=a;if(c.shouldExecuteOnCPU([p])){const v=c.texData.get(p.dataId),[b,w]=SQ(v.values,p.shape,p.dtype);return c.makeTensorInfo(w,p.dtype,b)}let m;return Hn().getBool("WEBGL_PACK_UNARY_OPERATIONS")?m=new lU(p.shape,mn):m=new lq(p.shape,mo),c.runWebGLProgram(m,[p],p.dtype)}const mS={kernelName:Dc,backendName:"webgl",kernelFunc:mp};function ml(u){const{inputs:a,backend:c,attrs:p}=u,{axis:m}=p;if(a.length===1)return iS({inputs:{input:a[0]},backend:c,attrs:{dim:m}});const v=a[0].shape,b=a[0].dtype;a.forEach(q=>{t(v,q.shape,"All tensors passed to stack must have matching shapes"),i(b===q.dtype,()=>"All tensors passed to stack must have matching dtypes")});const w=[],S=a.map(q=>{const H=iS({inputs:{input:q},backend:c,attrs:{dim:m}});return w.push(H),H}),O=i1({inputs:S,backend:c,attrs:{axis:m}});return w.forEach(q=>c.disposeIntermediateTensorInfo(q)),O}const mh={kernelName:DF,backendName:"webgl",kernelFunc:ml};class mi{constructor(a,c,p){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=c.map((O,q)=>O[0]+a[q]+O[1]);const m=a.length,v=ob(m),b=c.map(O=>O[0]).join(","),w=c.map((O,q)=>O[0]+a[q]).join(","),S=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,m);if(m===1){this.userCode=`
        int start = `+b+`;
        int end = `+w+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      `+v+" start = "+v+"("+b+`);
      `+v+" end = "+v+"("+w+`);

      void main() {
        `+v+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          `+v+` coords = outC - start;
          setOutput(getX(`+S+`));
        }
      }
    `}}class mm{constructor(a,c,p){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=c.map((ee,re)=>ee[0]+a[re]+ee[1]);const m=a.length,v=ob(m),b=c.map(ee=>ee[0]).join(","),w=c.map((ee,re)=>ee[0]+a[re]).join(","),S=lH("rc",m),O=lH("source",m),q=S[m-1]+" < "+this.outputShape[m-1],H=m===1?"source":"vec2("+O.slice(-2).join()+")",j=[v+" rc = outputLoc;",S[m-1]+` += 1;
       if(`+q+`) {
      `,m===1?"":`}
       rc = outputLoc;
       `+S[m-2]+` += 1;
       if(`+S[m-2]+" < "+this.outputShape[m-2]+") {",m===1?"":"  "+S[m-1]+` += 1;
         if(`+q+") {"],$=m===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let J="";for(let ee=0,re=m===1?2:4;ee<re;ee++)J+=`
        `+j[ee]+`
        if (`+$+`) {
          result[`+ee+`] = float(value);
        } else {
          `+v+` source = rc - start;
          result[`+ee+"] = getChannel(getX("+O.join()+"), "+H+`);
        }
      `;J+=m===1?"} ":"}}",this.userCode=`
      const `+v+" start = "+v+"("+b+`);
      const `+v+" end = "+v+"("+w+`);

      void main() {
        `+v+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+J+`
        setOutput(result);
      }
    `}}const mt=u=>{const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{paddings:v,constantValue:b}=p;if(G(m.shape)===0){const O=v.map((q,H)=>q[0]+m.shape[H]+q[1]);return ii({backend:c,attrs:{shape:O,value:b,dtype:m.dtype}})}const w=Hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mm(m.shape,v,b):new mi(m.shape,v,b),S=[[b]];return c.runWebGLProgram(w,[m],m.dtype,S)},mk={kernelName:DY,backendName:"webgl",kernelFunc:mt},mw=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,mU=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+lV+`
  return result;
`,mG=h4({opSnippet:mw,packedOpSnippet:mU}),mz={kernelName:Do,backendName:"webgl",kernelFunc:mG},mW=u=>{const{backend:a,attrs:c}=u,{start:p,stop:m,step:v,dtype:b}=c,w=SK(p,m,v,b);return a.makeTensorInfo([w.length],b,w)},mR={kernelName:Dp,backendName:"webgl",kernelFunc:mW},mj=`
if (a == b) {
  return 1.0;
};
return a / b;`,mA=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,mC=h4({opSnippet:mj,packedOpSnippet:mA,checkOutOfBounds:!0}),mu={kernelName:Hv,backendName:"webgl",kernelFunc:mC},mQ=lF+`
  return (x < 0.0) ? 0.0 : x;
`,mJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mx=h3({opSnippet:mQ,packedOpSnippet:mJ}),mM={kernelName:Dl,backendName:"webgl",kernelFunc:mx},mX=lF+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,mg=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mK=h3({opSnippet:mX,packedOpSnippet:mg}),mb={kernelName:Dt,backendName:"webgl",kernelFunc:mK};class mV{constructor(a,c,p,m,v){this.variableNames=["A"],this.outputShape=[];const[b,w,S,O]=a;this.outputShape=[b,c,p,O];const q=[m&&c>1?w-1:w,m&&p>1?S-1:S],H=[m&&c>1?c-1:c,m&&p>1?p-1:p];let j;v?j="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":j="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+q[0]/H[0]+`,
          `+q[1]/H[1]+`);
      const vec2 inputShapeRC = vec2(`+w+".0, "+S+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+j+`;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class md{constructor(a,c,p,m,v){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[b,w,S,O]=a;this.outputShape=[b,c,p,O];const q=[m&&c>1?w-1:w,m&&p>1?S-1:S],H=[m&&c>1?c-1:c,m&&p>1?p-1:p];let j;v?j="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":j="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+q[0]/H[0]+`,
          `+q[1]/H[1]+`,
          `+q[1]/H[1]+`);
      const vec3 inputShapeRC = vec3(`+w+".0, "+S+`.0,
                                     `+S+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+j+`;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(O-1)+`;
        bool hasNextRow = coords.z < `+(p-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function mP(u){const{inputs:a,backend:c,attrs:p}=u,{images:m}=a,{alignCorners:v,halfPixelCenters:b,size:w}=p,[S,O]=w,q=Hn().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new md(m.shape,S,O,v,b):new mV(m.shape,S,O,v,b);return c.runWebGLProgram(q,[m],"float32")}const mv={kernelName:Dm,backendName:"webgl",kernelFunc:mP};class mT{constructor(a,c){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const p=a[1],m=a[2];this.outputShape=a;let v="";typeof c=="number"?v="float outputValue = "+c.toFixed(2)+";":v=`
        vec3 fill = vec3(`+c.join(",")+`);
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          `+v+`
          if(coordX >= 0 && coordX < `+m+" && coordY >= 0 && coordY < "+p+`) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const mr={kernelName:Dd,backendName:"webgl",kernelFunc:({inputs:u,attrs:a,backend:c})=>{const{image:p}=u,{radians:m,fillValue:v,center:b}=a,w=c,S=new mT(p.shape,v),[O,q]=ZC(b,p.shape[1],p.shape[2]),H=[[O,q,Math.sin(m),Math.cos(m)]];return w.runWebGLProgram(S,[p],p.dtype,H)}},me=h2+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,mB=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mN=h3({opSnippet:me,packedOpSnippet:mB,cpuKernelImpl:Sd}),t0={kernelName:DW,backendName:"webgl",kernelFunc:mN},t1=h2+`
  return sin(x);
`,t2=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  `+lV+`
  return result;
`,t3=h3({opSnippet:t1,packedOpSnippet:t2}),t4={kernelName:Dz,backendName:"webgl",kernelFunc:t3};class t5{constructor(a){this.variableNames=["source"],this.outputShape=a,this.rank=a.length;const c=ob(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const p=t7(this.rank);let m;const v=a.map((b,w)=>"sourceLoc."+t6[w]+" = start["+w+"] + coords."+t6[w]+";");m=`
        `+c+` sourceLoc;
        `+c+` coords = getOutputCoords();
        `+v.join(`
`)+`
      `,this.userCode=`
      void main() {
        `+m+`
        setOutput(getSource(`+p+`));
      }
    `}}const t6=["x","y","z","w","u","v"];function t7(u){if(u===1)return"sourceLoc";if(u<=6)return t6.slice(0,u).map(a=>"sourceLoc."+a).join(",");throw Error("Slicing for rank "+u+" is not yet supported")}class t8{constructor(a){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.rank=a.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const c=ob(this.rank),p=lH("coords",this.rank),m=lH("sourceLoc",this.rank),v=this.rank===1?"sourceLoc":"vec2("+m.slice(-2).join()+")",b="getChannel(getSource("+m.join()+"), "+v+")",w=`
      result.x = `+b+`;
      if (++`+p[this.rank-1]+" < "+a[this.rank-1]+`) {
        ++`+m[this.rank-1]+`;
        result.y = `+b+`;
        --`+m[this.rank-1]+`;
      }
    `,S=this.rank===1?"":`
      --`+p[this.rank-1]+`;
      if (++`+p[this.rank-2]+" < "+a[this.rank-2]+`) {
        ++`+m[this.rank-2]+`;
        result.z = `+b+`;
        if (++`+p[this.rank-1]+" < "+a[this.rank-1]+`) {
          ++`+m[this.rank-1]+`;
          result.w = `+b+`;
        }
      }
    `,O=this.rank<=4?`sourceLoc = coords +
            `+c+"("+a.map((q,H)=>"start["+H+"]").join()+");":a.map((q,H)=>m[H]+" = "+p[H]+" + start["+H+"];").join(`
`);this.userCode=`
      void main() {
        `+c+` coords = getOutputCoords();
        `+c+` sourceLoc;
        `+O+`
        vec4 result = vec4(0.);
        `+w+`
        `+S+`
        setOutput(result);
      }
    `}}function t9(u,a,c,p){const m=p.texData.get(u.dataId),v=p.makeTensorInfo(c,u.dtype),b=p.texData.get(v.dataId);Object.assign(b,m),b.refCount=1,b.shape=c,b.dtype=u.dtype;let w=Ef(a,HD(u.shape));m.slice&&(w+=m.slice.flatOffset),b.slice={flatOffset:w,origDataId:m.slice&&m.slice.origDataId||u.dataId};const S=p.dataRefCount.get(b.slice.origDataId)||1;return p.dataRefCount.set(b.slice.origDataId,S+1),v}function tH(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{begin:v,size:b}=p,[w,S]=EO(m,v,b);if(E4(m,w,S),G(S)===0)return c.makeTensorInfo(S,m.dtype,[]);if(c.shouldExecuteOnCPU([m])||m.dtype==="string"){const H=c.texData.get(m.dataId),j=Sv(H.values,w,S,m.shape,m.dtype);return c.makeTensorInfo(S,m.dtype,j)}const{isPacked:O}=c.texData.get(m.dataId),q=EE(m.shape,w,S);if(O||!q){const H=Hn().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new t8(S):new t5(S),j=[w];return c.runWebGLProgram(H,[m],m.dtype,j)}return c.uploadToGPU(m.dataId),t9(m,w,S,c)}const tD={kernelName:DG,backendName:"webgl",kernelFunc:tH},ty="return sqrt(x);",ta=h3({opSnippet:ty,packedOpSnippet:ty,cpuKernelImpl:SB}),ts={kernelName:DR,backendName:"webgl",kernelFunc:ta},tI="return x * x;",tE=h3({opSnippet:tI}),tf={kernelName:Du,backendName:"webgl",kernelFunc:tE};class tO{constructor(a,c,p){this.variableNames=["x"],this.outputShape=p;const m=p.length,v=ob(p.length),b=ob(p.length);let w="";if(m===1)w="coords * strides + begin";else{let S=0;w=p.map((O,q)=>(S++,p.length===1?"coords * strides["+q+"] + begin["+q+"]":"coords["+(S-1)+"] * strides["+q+"] + begin["+q+"]")).join(",")}this.userCode=`
      `+v+" begin = "+v+"("+a+`);
      `+v+" strides = "+v+"("+c+`);

      void main() {
        `+b+` coords = getOutputCoords();
        setOutput(getX(`+w+`));
      }
    `}}function tc(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{begin:v,end:b,strides:w,beginMask:S,endMask:O,ellipsisMask:q,newAxisMask:H,shrinkAxisMask:j}=p,{finalShapeSparse:$,finalShape:J,isIdentity:ee,sliceDim0:re,isSimpleSlice:de,begin:Te,end:Me,strides:Ae}=Ec(m.shape,v,b,w,S,O,q,H,j);let Ce;if(ee)Ce=hp({inputs:{x:m},backend:c,attrs:{shape:J}});else if(re||de){i(m.shape.length>=1,()=>"Input must have rank at least 1, got: "+m.shape.length);const je=E6(Te,Me,Ae),Ne=tH({inputs:{x:m},backend:c,attrs:{begin:Te,size:je}});Ce=hp({inputs:{x:Ne},backend:c,attrs:{shape:J}}),c.disposeIntermediateTensorInfo(Ne)}else if(c.shouldExecuteOnCPU([m])){const je=c.readSync(m.dataId),Ne=fy(m.shape,m.dtype,je),Qe=l0($,Ne,Ae,Te);Ce=c.makeTensorInfo(J,m.dtype,Qe.values)}else{const je=new tO(Te,Ae,$);Ce=c.runWebGLProgram(je,[m],m.dtype)}const Pe=hp({inputs:{x:Ce},backend:c,attrs:{shape:J}});return c.disposeIntermediateTensorInfo(Ce),Pe}const tZ={kernelName:DQ,backendName:"webgl",kernelFunc:tc},tL="return a - b;",tq=h4({opSnippet:tL,packedOpSnippet:tL,supportsComplex:!0,cpuKernelImpl:l4}),tF={kernelName:DJ,backendName:"webgl",kernelFunc:tq};class tY{constructor(a,c){this.variableNames=["A"];const p=new Array(a.length);for(let b=0;b<p.length;b++)p[b]=a[b]*c[b];this.outputShape=p,this.rank=p.length;const m=ob(this.rank),v=to(a);this.userCode=`
      void main() {
        `+m+` resRC = getOutputCoords();
        setOutput(getA(`+v+`));
      }
    `}}function to(u){const a=u.length;if(a>5)throw Error("Tile for rank "+a+" is not yet supported");if(a===1)return"imod(resRC, "+u[0]+")";const c=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],p=[];for(let m=0;m<u.length;m++)p.push("imod("+c[m]+", "+u[m]+")");return p.join()}function tn(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{reps:v}=p;if(m.dtype==="string"||m.shape.length>5){const w=c.readSync(m.dataId),S=m.dtype==="string"?w.map(H=>ye(H)):w,O=fy(m.shape,m.dtype,S),q=l5(O,v);return c.makeTensorInfo(q.shape,q.dtype,q.values)}const b=new tY(m.shape,v);return c.runWebGLProgram(b,[m],m.dtype)}const tp={kernelName:Dx,backendName:"webgl",kernelFunc:tn};class tS{constructor(a,c,p,m,v,b){this.variableNames=["Image","Transforms"],this.outputShape=b;const w=p==="nearest"?1:2;let S;switch(m){case"constant":S=1;break;case"reflect":S=2;break;case"wrap":S=3;break;case"nearest":S=4;break;default:S=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(`+S+` == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+S+` == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+S+` == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < `+a+" && 0 <= coordX && coordX < "+c+`) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(`+v+`);
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(`+v+`);
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(`+c+`));
                float mapY = mapCoord(inY, float(`+a+`));

                if (`+w+` == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function tl(u){const{inputs:a,backend:c,attrs:p}=u,{image:m,transforms:v}=a,{interpolation:b,fillMode:w,fillValue:S,outputShape:O}=p,[q,H,j,$]=m.shape,[J,ee]=O??[H,j],re=[q,J,ee,$],de=new tS(H,j,b,w,S,re);return c.runWebGLProgram(de,[m,v],"float32")}const th={kernelName:DM,backendName:"webgl",kernelFunc:tl};function ti(u){const{inputs:a,backend:c}=u,{x:p}=a;if(p.dtype==="complex64"){const m=hM({inputs:{input:p},backend:c}),v=ti({inputs:{x:m},backend:c}),b=hB({inputs:{input:p},backend:c}),w=ti({inputs:{x:b},backend:c}),S=lT({inputs:{real:v,imag:w},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(w),S}else return ii({attrs:{shape:p.shape,dtype:p.dtype,value:p.dtype==="string"?"":0},backend:c})}const tm={kernelName:DK,backendName:"webgl",kernelFunc:ti};function tk(u){const{inputs:a,backend:c,attrs:p}=u,{a:m,b:v,bias:b,preluActivationWeights:w}=a,{transposeA:S,transposeB:O,activation:q,leakyreluAlpha:H}=p;return hC({a:m,b:v,transposeA:S,transposeB:O,backend:c,bias:b,preluActivationWeights:w,leakyreluAlpha:H,activation:q})}const tw={kernelName:DP,backendName:"webgl",kernelFunc:tk},tU=cm;class tG extends L{nextDataId(){return tG.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Z(this,s1())}write(a,c,p){this.firstUse&&(this.firstUse=!1,Hn().get("IS_NODE")&&Dr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const m={id:this.nextDataId()};return this.data.set(m,{values:a,dtype:p,refCount:1}),m}makeTensorInfo(a,c,p){let m;if(c==="string"&&p!=null&&p.length>0&&H5(p[0])){const v=p.map(b=>yr(b));m=this.write(v,a,c)}else m=this.write(p,a,c);return{dataId:m,shape:a,dtype:c}}refCount(a){return this.data.has(a)?this.data.get(a).refCount:0}incRef(a){const c=this.data.get(a);c.refCount++}decRef(a){if(this.data.has(a)){const c=this.data.get(a);c.refCount--}}move(a,c,p,m,v){this.data.set(a,{values:c,dtype:m,refCount:v})}numDataIds(){return this.data.numDataIds()}async read(a){return this.readSync(a)}readSync(a){const{dtype:c,complexTensorInfos:p}=this.data.get(a);if(c==="complex64"){const m=this.readSync(p.real.dataId),v=this.readSync(p.imag.dataId);return ZT(m,v)}return Hs(this.data.get(a).values,c)}bufferSync(a){const c=this.readSync(a.dataId);if(a.dtype==="string")try{const p=c.map(m=>ye(m));return fy(a.shape,a.dtype,p)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return fy(a.shape,a.dtype,c)}makeOutput(a,c,p){return s1().makeTensorFromTensorInfo(this.makeTensorInfo(c,p,a),this)}disposeData(a,c=!1){if(this.data.has(a)){if(this.data.get(a).refCount--,!c&&this.data.get(a).refCount>0)return!1;const{complexTensorInfos:p}=this.data.get(a);p!=null&&(this.disposeData(p.real.dataId,!0),this.disposeData(p.imag.dataId,!0)),this.data.delete(a)}return!0}disposeIntermediateTensorInfo(a){this.disposeData(a.dataId)}async time(a){const c=yT();return a(),{kernelMs:yT()-c}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(a){ni([a],"where");const c=this.readSync(a.dataId);return tU(a.shape,c)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}tG.nextDataId=0,s7("cpu",()=>new tG,1);function tz(u){const{inputs:a,backend:c}=u,p=a;ni(a,"addN");const m=p.map(w=>c.data.get(w.dataId).values),v=fy(p[0].shape,p[0].dtype),b=v.values;for(let w=0;w<p.length;w++){const S=m[w];for(let O=0;O<b.length;O++)b[O]+=S[O]}return c.makeTensorInfo(v.shape,v.dtype,v.values)}const tW={kernelName:Hw,backendName:"cpu",kernelFunc:tz},tR=nw((u,a)=>Math.atan2(u,a)),tj=nu(HU,tR),tA={kernelName:HU,backendName:"cpu",kernelFunc:tj};function tC(u,a,c,p,m,v){const b=m.strideHeight,w=m.strideWidth,S=m.dilationHeight,O=m.dilationWidth,q=m.effectiveFilterHeight,H=m.effectiveFilterWidth,j=m.padInfo.top,$=m.padInfo.left,J=v==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,ee=fy(m.outShape,c),re=ee.values,de=m.outShape[1]*m.outShape[2]*m.outShape[3],Te=m.outShape[2]*m.outShape[3],Me=m.outShape[3];for(let Ae=0;Ae<m.batchSize;++Ae){const Ce=Ae*de,Pe=Ae*p[0];for(let je=0;je<m.inChannels;++je)for(let Ne=0;Ne<m.outHeight;++Ne){const Qe=Ne*b-j,Ct=Math.max(0,Qe),dt=Math.min(m.inHeight,q+Qe),Xt=Ce+Ne*Te;for(let Gt=0;Gt<m.outWidth;++Gt){const Vt=Gt*w-$,T0=Math.max(0,Vt),r0=Math.min(m.inWidth,H+Vt);let d0=J,Ut=0,$0=0;for(let Un=Ct;Un<dt;Un+=S){const b0=Pe+Un*p[1];for(let X0=T0;X0<r0;X0+=O){const Rt=b0+X0*p[2],Qt=u[Rt+je];v==="max"&&Qt>d0?d0=Qt:v==="avg"&&(Ut+=Qt,$0++)}if(isNaN(d0))break}const Q0=Xt+Gt*Me+je;re[Q0]=v==="avg"?Ut/$0:d0}}}return ee}function tu(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a;ni(m,"avgPool");const{filterSize:v,strides:b,pad:w,dimRoundingMode:S}=p,O=1;i(Eb(b,O),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+O+"'");const q=Ez(m.shape,v,b,O,w,S);let H;if(q.filterWidth===1&&q.filterHeight===1&&z(q.inShape,q.outShape))H=nz({inputs:{x:m},backend:c});else{const j=c.data.get(m.dataId).values,$=HD(m.shape),J=tC(j,m.shape,m.dtype,$,q,"avg");H=c.makeTensorInfo(q.outShape,m.dtype,J.values)}return H}const tQ={kernelName:HG,backendName:"cpu",kernelFunc:tu};function tJ(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{shape:v}=p,b=G(m.shape),w=V(v,b),S=G(w);i(b===S,()=>"The new shape ("+w+") has "+S+" elements and the old shape ("+m.shape+") has "+b+" elements. The new shape and old shape must have the same number of elements."),c.incRef(m.dataId);const O=c.data.get(m.dataId);if(O.complexTensorInfos!=null){const q=O.complexTensorInfos.real,H=O.complexTensorInfos.imag;q.shape=w,H.shape=w}return{dataId:m.dataId,shape:w,dtype:m.dtype}}const tx={kernelName:Dh,backendName:"cpu",kernelFunc:tJ};function tM(u){const{inputs:a,backend:c,attrs:p}=u,{a:m,b:v}=a,{transposeA:b,transposeB:w}=p;ni([m,v],"matMul");const S=m.shape.length,O=v.shape.length,q=b?m.shape[S-2]:m.shape[S-1],H=w?v.shape[O-1]:v.shape[O-2],j=b?m.shape[S-1]:m.shape[S-2],$=w?v.shape[O-2]:v.shape[O-1],J=m.shape.slice(0,-2),ee=v.shape.slice(0,-2),re=G(J),de=G(ee),Te=IP(m.shape.slice(0,-2),v.shape.slice(0,-2)).concat([j,$]);i(q===H,()=>"Error in matMul: inner shapes ("+q+") and ("+H+") of Tensors with shapes "+m.shape+" and "+v.shape+" and transposeA="+b+" and transposeB="+w+" must match.");const Me=b?[re,q,j]:[re,j,q],Ae=w?[de,$,H]:[de,H,$],Ce=tJ({inputs:{x:m},backend:c,attrs:{shape:Me}}),Pe=tJ({inputs:{x:v},backend:c,attrs:{shape:Ae}}),je=b?Ce.shape[1]:Ce.shape[2],Ne=b?Ce.shape[2]:Ce.shape[1],Qe=w?Pe.shape[1]:Pe.shape[2],Ct=Math.max(re,de),dt=c.data.get(Ce.dataId).values,Xt=c.data.get(Pe.dataId).values,Gt=HD(Ce.shape),Vt=HD(Pe.shape),[T0,r0,d0]=b?[Gt[0],1,Gt[1]]:[Gt[0],Gt[1],1],[Ut,$0,Q0]=w?[1,Vt[1],Vt[0]]:[Vt[1],1,Vt[0]],Un=Ne*Qe,b0=fy([Ct,Ne,Qe],Ce.dtype),X0=b0.values,Rt=c.blockSize;for(let Qt=0;Qt<Ct;Qt++){const A0=Qt%re,J0=Qt%de;for(let Pn=0;Pn<Ne;Pn+=Rt){const dx=Math.min(Pn+Rt,Ne);for(let Bn=0;Bn<Qe;Bn+=Rt){const Wn=Math.min(Bn+Rt,Qe);for(let gx=0;gx<je;gx+=Rt){const Jx=Math.min(gx+Rt,je);for(let er=Pn;er<dx;er++)for(let Cr=Bn;Cr<Wn;Cr++){let Rr=0;for(let xi=gx;xi<Jx;xi++){const Nr=dt[A0*T0+er*r0+xi*d0],rr=Xt[xi*Ut+Cr*$0+J0*Q0];Rr+=Nr*rr}X0[Qt*Un+(er*Qe+Cr)]+=Rr}}}}}return c.disposeIntermediateTensorInfo(Ce),c.disposeIntermediateTensorInfo(Pe),c.makeTensorInfo(Te,b0.dtype,b0.values)}const tX={kernelName:HW,backendName:"cpu",kernelFunc:tM},tg=nd(HC,(u,a)=>{const c=a;return u>c.clipValueMax?c.clipValueMax:u<c.clipValueMin?c.clipValueMin:u}),tK={kernelName:HC,backendName:"cpu",kernelFunc:tg};function tb(u){const{inputs:a,backend:c}=u,{input:p}=a,m=c.data.get(p.dataId).complexTensorInfos.imag,v=c.data.get(m.dataId).values;return c.makeTensorInfo(m.shape,m.dtype,v)}function tV(u){const{inputs:a,backend:c,attrs:p}=u,{axis:m}=p,v=P(m,a[0].shape)[0],b=a.map(ee=>ee.shape);Zk(b,v);let w=Zw(a.map(ee=>ee.shape),v);if(G(w)===0)return c.makeTensorInfo(w,a[0].dtype,[]);const S=a.filter(ee=>G(ee.shape)>0);if(S.length===1)return nz({inputs:{x:S[0]},backend:c});if(S[0].dtype==="complex64"){const ee=S.map(Ae=>nR({inputs:{input:Ae},backend:c})),re=S.map(Ae=>tb({inputs:{input:Ae},backend:c})),de=tV({inputs:ee,backend:c,attrs:{axis:v}}),Te=tV({inputs:re,backend:c,attrs:{axis:v}}),Me=nU({inputs:{real:de,imag:Te},backend:c});return ee.forEach(Ae=>c.disposeIntermediateTensorInfo(Ae)),re.forEach(Ae=>c.disposeIntermediateTensorInfo(Ae)),c.disposeIntermediateTensorInfo(de),c.disposeIntermediateTensorInfo(Te),Me}const O=S.map(ee=>{const re=[-1,G(ee.shape.slice(v))];return tJ({inputs:{x:ee},backend:c,attrs:{shape:re}})}),q=O.map(ee=>({vals:c.data.get(ee.dataId).values,shape:ee.shape}));w=Zw(O.map(ee=>ee.shape),1);const H=O[0].shape[0]===1,j=nT(q,w,a[0].dtype,H),$=Zw(S.map(ee=>ee.shape),v),J=c.makeTensorInfo($,a[0].dtype,j);return O.forEach(ee=>c.disposeIntermediateTensorInfo(ee)),J}const td={kernelName:HJ,backendName:"cpu",kernelFunc:tV};function tP(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v}=a,{strides:b,pad:w,dataFormat:S,dilations:O,dimRoundingMode:q}=p;ni([m,v],"conv2d");const H=Ed(S),j=ER(m.shape,v.shape,b,O,w,q,!1,H),$=j.filterHeight,J=j.filterWidth,ee=j.dilationHeight,re=j.dilationWidth,de=j.padInfo.left,Te=j.padInfo.top,Me=j.dataFormat==="channelsLast",Ae=new as(j.outShape,m.dtype),Ce=HD(m.shape),Pe=HD(v.shape),je=Ce[0],Ne=Me?Ce[1]:Ce[2],Qe=Me?Ce[2]:1,Ct=Me?1:Ce[1],dt=Ae.strides[0],Xt=Me?Ae.strides[1]:Ae.strides[2],Gt=Me?Ae.strides[2]:1,Vt=Me?1:Ae.strides[1],T0=c.data.get(m.dataId).values,r0=c.data.get(v.dataId).values,d0=Ae.values;for(let Ut=0;Ut<j.batchSize;++Ut){const $0=Ut*je,Q0=Ut*dt;for(let Un=0;Un<j.outHeight;++Un){const b0=Q0+Un*Xt,X0=Un*j.strideHeight-Te;for(let Rt=0;Rt<$;++Rt){const Qt=X0+Rt*ee;if(Qt<0||Qt>=j.inHeight)continue;const A0=Rt*Pe[0],J0=$0+Qt*Ne;for(let Pn=0;Pn<j.outWidth;++Pn){const dx=b0+Pn*Gt,Bn=Pn*j.strideWidth-de;for(let Wn=0;Wn<J;++Wn){const gx=Bn+Wn*re;if(gx<0||gx>=j.inWidth)continue;const Jx=A0+Wn*Pe[1],er=J0+gx*Qe;let Cr=Jx;for(let Rr=0;Rr<j.inChannels;++Rr){const xi=T0[er+Rr*Ct];for(let Nr=0;Nr<j.outChannels;++Nr)d0[dx+Nr*Vt]+=xi*r0[Cr+Nr];Cr+=j.outChannels}}}}}}return c.makeTensorInfo(Ae.shape,Ae.dtype,d0)}const tv={kernelName:Hx,backendName:"cpu",kernelFunc:tP},tT=nd(Hg,u=>Math.cos(u)),tr={kernelName:Hg,backendName:"cpu",kernelFunc:tT};function te(u){const{inputs:a,backend:c,attrs:p}=u,{image:m,boxes:v,boxInd:b}=a,{cropSize:w,method:S,extrapolationValue:O}=p,[q,H,j,$]=m.shape,J=v.shape[0],[ee,re]=w,de=fy([J,ee,re,$],"float32"),Te=c.data.get(v.dataId).values,Me=c.data.get(b.dataId).values,Ae=c.data.get(m.dataId).values,Ce=HD(m.shape),Pe=HD(de.shape);for(let je=0;je<J;je++){const Ne=je*4,Qe=Te[Ne],Ct=Te[Ne+1],dt=Te[Ne+2],Xt=Te[Ne+3],Gt=Me[je];if(Gt>=q)continue;const Vt=ee>1?(dt-Qe)*(H-1)/(ee-1):0,T0=re>1?(Xt-Ct)*(j-1)/(re-1):0;for(let r0=0;r0<ee;r0++){const d0=ee>1?Qe*(H-1)+r0*Vt:.5*(Qe+dt)*(H-1);if(d0<0||d0>H-1){for(let Ut=0;Ut<re;Ut++)for(let $0=0;$0<$;$0++){const Q0=$0+Ut*Pe[2]+r0*Pe[1]+je*Pe[0];de.values[Q0]=O}continue}if(S==="bilinear"){const Ut=Math.floor(d0),$0=Math.ceil(d0),Q0=d0-Ut;for(let Un=0;Un<re;Un++){const b0=re>1?Ct*(j-1)+Un*T0:.5*(Ct+Xt)*(j-1);if(b0<0||b0>j-1){for(let A0=0;A0<$;A0++){const J0=A0+Un*Pe[2]+r0*Pe[1]+je*Pe[0];de.values[J0]=O}continue}const X0=Math.floor(b0),Rt=Math.ceil(b0),Qt=b0-X0;for(let A0=0;A0<$;A0++){let J0=A0+X0*Ce[2]+Ut*Ce[1]+Gt*Ce[0];const Pn=Ae[J0];J0=A0+Rt*Ce[2]+Ut*Ce[1]+Gt*Ce[0];const dx=Ae[J0];J0=A0+X0*Ce[2]+$0*Ce[1]+Gt*Ce[0];const Bn=Ae[J0];J0=A0+Rt*Ce[2]+$0*Ce[1]+Gt*Ce[0];const Wn=Ae[J0],gx=Pn+(dx-Pn)*Qt,Jx=Bn+(Wn-Bn)*Qt;J0=A0+Un*Pe[2]+r0*Pe[1]+je*Pe[0],de.values[J0]=gx+(Jx-gx)*Q0}}}else for(let Ut=0;Ut<re;++Ut){const $0=re>1?Ct*(j-1)+Ut*T0:.5*(Ct+Xt)*(j-1);if($0<0||$0>j-1){for(let b0=0;b0<$;b0++){const X0=b0+Ut*Pe[2]+r0*Pe[1]+je*Pe[0];de.values[X0]=O}continue}const Q0=Math.round($0),Un=Math.round(d0);for(let b0=0;b0<$;b0++){const X0=b0+Q0*Ce[2]+Un*Ce[1]+Gt*Ce[0],Rt=b0+Ut*Pe[2]+r0*Pe[1]+je*Pe[0];de.values[Rt]=Ae[X0]}}}}return c.makeTensorInfo(de.shape,de.dtype,de.values)}const tB={kernelName:HK,backendName:"cpu",kernelFunc:te};function tN(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{blockSize:v,dataFormat:b}=p;i(b==="NHWC",()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+b);const w=m.shape[0],S=m.shape[1],O=m.shape[2],q=m.shape[3],H=S*v,j=O*v,$=q/(v*v),J=c.data.get(m.dataId).values,ee=new Float32Array(w*H*j*$);let re=0;for(let de=0;de<w;++de)for(let Te=0;Te<H;++Te){const Me=Math.floor(Te/v),Ae=Te%v;for(let Ce=0;Ce<j;++Ce){const Pe=Math.floor(Ce/v),je=Ce%v,Ne=(Ae*v+je)*$;for(let Qe=0;Qe<$;++Qe){const Ct=Qe+Ne+q*(Pe+O*(Me+S*de));ee[re++]=J[Ct]}}}return c.makeTensorInfo([w,H,j,$],m.dtype,ee)}const k3={kernelName:Hb,backendName:"cpu",kernelFunc:tN};function k4(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v}=a,{strides:b,pad:w,dilations:S,dimRoundingMode:O}=p;ni([m,v],"depthwiseConv2DNative");const q=HD(m.shape),H=HD(v.shape);let j=S;j==null&&(j=[1,1]),i(Eb(b,j),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+j+"'");const $=ER(m.shape,v.shape,b,j,w,O,!0),{filterHeight:J,filterWidth:ee,dilationHeight:re,dilationWidth:de,padInfo:Te}=$,Me=Te.left,Ae=Te.top,Ce=$.outChannels/$.inChannels,Pe=new as($.outShape,m.dtype),je=c.data.get(m.dataId).values,Ne=c.data.get(v.dataId).values,Qe=Pe.values;for(let Ct=0;Ct<$.batchSize;++Ct){const dt=Ct*q[0],Xt=Ct*Pe.strides[0];for(let Gt=0;Gt<$.outHeight;++Gt){const Vt=Xt+Gt*Pe.strides[1],T0=Gt*$.strideHeight-Ae;for(let r0=0;r0<J;++r0){const d0=T0+r0*re;if(d0<0||d0>=$.inHeight)continue;const Ut=r0*H[0],$0=dt+d0*q[1];for(let Q0=0;Q0<$.outWidth;++Q0){const Un=Vt+Q0*Pe.strides[2],b0=Q0*$.strideWidth-Me;for(let X0=0;X0<ee;++X0){const Rt=b0+X0*de;if(Rt<0||Rt>=$.inWidth)continue;const Qt=Ut+X0*H[1],A0=$0+Rt*$.inChannels;let J0=Un,Pn=Qt;for(let dx=0;dx<$.inChannels;++dx){const Bn=je[A0+dx];for(let Wn=0;Wn<Ce;++Wn)Qe[J0+Wn]+=Bn*Ne[Pn+Wn];J0+=Ce,Pn+=Ce}}}}}}return c.makeTensorInfo(Pe.shape,Pe.dtype,Pe.values)}const k5={kernelName:HV,backendName:"cpu",kernelFunc:k4};function k6(u){const{inputs:a,backend:c,attrs:p}=u,{input:m}=a,{dim:v}=p,b=m.shape.length,w=m.shape.slice();let S=v;return v<0&&(i(-(b+1)<=v,()=>"Axis must be in the interval ["+-(b+1)+", "+b+"]"),S=b+v+1),w.splice(S,0,1),tJ({inputs:{x:m},backend:c,attrs:{shape:w}})}const k7={kernelName:He,backendName:"cpu",kernelFunc:k6};function k8(u){const{backend:a,attrs:c}=u,{shape:p,value:m,dtype:v}=c,b=v||H8(m),w=N(b,G(p));return kH(w,m,b),a.makeTensorInfo(p,b,w)}const k9={kernelName:HB,backendName:"cpu",kernelFunc:k8};function kH(u,a,c){u.fill(a)}const kD=nd(Hr,u=>u>=0?u:Math.exp(u)-1);function ky(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{alpha:v}=p;ni([m],"leakyRelu");const b=G(m.shape),w=c.data.get(m.dataId).values,S=e("float32",b);for(let O=0;O<w.length;O++)S[O]=w[O]<0?v*w[O]:w[O];return c.makeTensorInfo(m.shape,"float32",S)}const ka=nw((u,a)=>u<0?a*u:u);function ks(u){const{inputs:a,backend:c}=u,{x:p,alpha:m}=a;ni([p,m],"prelu");const v=c.data.get(p.dataId).values,b=c.data.get(m.dataId).values,[w,S]=ka(p.shape,m.shape,v,b,"float32");return c.makeTensorInfo(S,"float32",w)}const kI={kernelName:Dn,backendName:"cpu",kernelFunc:ks},kE=nd(Dl,u=>Math.max(0,u)),kf={kernelName:Dl,backendName:"cpu",kernelFunc:kE},kO=nd(Dt,u=>Math.min(Math.max(0,u),6)),kc={kernelName:Dt,backendName:"cpu",kernelFunc:kO};function kZ(u,a,c,p,m){if(c==="linear")return nz({inputs:{x:a},backend:u});if(c==="relu")return kE({inputs:{x:a},backend:u});if(c==="elu")return kD({inputs:{x:a},backend:u});if(c==="relu6")return kO({inputs:{x:a},backend:u});if(c==="prelu")return ks({inputs:{x:a,alpha:p},backend:u});if(c==="leakyrelu")return ky({inputs:{x:a},backend:u,attrs:{alpha:m}});if(c==="sigmoid")return pP({inputs:{x:a},backend:u});throw new Error("Activation "+c+" has not been implemented for the CPU backend.")}function kL(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v,bias:b,preluActivationWeights:w}=a,{strides:S,pad:O,dataFormat:q,dilations:H,dimRoundingMode:j,activation:$,leakyreluAlpha:J}=p;let ee=tP({inputs:{x:m,filter:v},backend:c,attrs:{strides:S,pad:O,dataFormat:q,dilations:H,dimRoundingMode:j}});if(b){const re=ee;if(q==="NCHW"&&b.shape.length===1&&b.shape[0]!==1){const de=tJ({inputs:{x:b},backend:c,attrs:{shape:[b.shape[0],1,1]}});ee=nM({inputs:{a:ee,b:de},backend:c}),c.disposeIntermediateTensorInfo(de)}else ee=nM({inputs:{a:ee,b},backend:c});c.disposeIntermediateTensorInfo(re)}if($){const re=ee;if(q==="NCHW"&&$==="prelu"&&w.shape.length===1&&w.shape[0]!==1){const de=tJ({inputs:{x:w},backend:c,attrs:{shape:[w.shape[0],1,1]}});ee=kZ(c,ee,$,de,J),c.disposeIntermediateTensorInfo(de)}else ee=kZ(c,ee,$,w,J);c.disposeIntermediateTensorInfo(re)}return ee}const kq={kernelName:Dv,backendName:"cpu",kernelFunc:kL};function kF(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,filter:v,bias:b,preluActivationWeights:w}=a,{strides:S,pad:O,dataFormat:q,dilations:H,dimRoundingMode:j,activation:$,leakyreluAlpha:J}=p;let ee=k4({inputs:{x:m,filter:v},backend:c,attrs:{strides:S,pad:O,dataFormat:q,dilations:H,dimRoundingMode:j}});if(b){const re=ee;ee=nM({inputs:{a:ee,b},backend:c}),c.disposeIntermediateTensorInfo(re)}if($){const re=ee;ee=kZ(c,ee,$,w,J),c.disposeIntermediateTensorInfo(re)}return ee}const kY={kernelName:DT,backendName:"cpu",kernelFunc:kF};function ko(u){const{inputs:a,backend:c,attrs:p}=u,{x:m,indices:v}=a,{axis:b,batchDims:w}=p;ni([m,v],"gatherV2");const S=P(b,m.shape)[0],O=c.data.get(v.dataId).values,q=m.shape[S];for(let Ae=0;Ae<O.length;++Ae){const Ce=O[Ae];i(Ce<=q-1&&Ce>=0,()=>"GatherV2: the index value "+Ce+" is not in [0, "+(q-1)+"]")}let H=w;w==null&&(H=0);const j=G(v.shape),$=LS(m,v,S,H),J=tJ({inputs:{x:m},backend:c,attrs:{shape:[$.batchSize,$.outerSize,$.dimSize,$.sliceSize]}}),ee=tJ({inputs:{x:v},backend:c,attrs:{shape:[$.batchSize,j/$.batchSize]}}),re=[$.batchSize,$.outerSize,j/$.batchSize,$.sliceSize],de=c.bufferSync(ee),Te=c.bufferSync(J),Me=p4(Te,de,re);return c.disposeIntermediateTensorInfo(J),c.disposeIntermediateTensorInfo(ee),c.makeTensorInfo($.outputShape,Me.dtype,Me.values)}const kn={kernelName:D2,backendName:"cpu",kernelFunc:ko},kp=nw((u,a)=>u&&a),kS=nu(DH,kp,null,"bool"),kl={kernelName:DH,backendName:"cpu",kernelFunc:kS},kh=nw((u,a)=>u||a),ki=nu(DD,kh,null,"bool"),km={kernelName:DD,backendName:"cpu",kernelFunc:ki};function kt(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{reductionIndices:v,keepDims:b}=p,w=c;let S=m.shape;const O=S.length,q=P(v,S);let H=q;const j=fC(H,O);let $=w.data.get(m.dataId).values;if(j!=null){const Ae=new Array(O);for(let Ce=0;Ce<Ae.length;Ce++)Ae[Ce]=S[j[Ce]];$=pm($,S,m.dtype,j,Ae),H=fQ(H.length,O),S=Ae}ni(m,"max"),fA("max",H,O);const[J,ee]=fR(S,H),re=G(ee),de=pf($,re,J,m.dtype),Te=w.write(de,J,m.dtype);let Me=J;return b&&(Me=fj(J,q)),{dataId:Te,shape:Me,dtype:m.dtype}}const kk={kernelName:Dy,backendName:"cpu",kernelFunc:kt};function kw(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a;ni(m,"maxPool");const{filterSize:v,strides:b,pad:w,dimRoundingMode:S}=p,O=1;i(Eb(b,O),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+O+"'");const q=Ez(m.shape,v,b,O,w,S);let H;if(q.filterWidth===1&&q.filterHeight===1&&z(q.inShape,q.outShape))H=nz({inputs:{x:m},backend:c});else{const j=c.data.get(m.dataId).values,$=HD(m.shape),J=tC(j,m.shape,m.dtype,$,q,"max");H=c.makeTensorInfo(q.outShape,m.dtype,J.values)}return H}const kU={kernelName:Ds,backendName:"cpu",kernelFunc:kw},kG=nw((u,a)=>u/a),kz=nu(Hv,kG),kW={kernelName:Hv,backendName:"cpu",kernelFunc:kz};function kR(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{axis:v,keepDims:b}=p;ni(m,"sum");let w;m.dtype==="bool"?w=nA({inputs:{x:m},backend:c,attrs:{dtype:"int32"}}):w=nz({inputs:{x:m},backend:c});const S=w.shape.length,O=P(v,w.shape),q=fC(O,S);let H=O,j=w;q!=null&&(j=pt({inputs:{x:w},backend:c,attrs:{perm:q}}),H=fQ(H.length,S)),fA("sum",H,j.shape.length);const[$,J]=fR(j.shape,H),ee=al(j.dtype,"int32");let re=nG(c,$,ee);const de=G(J),Te=c.data.get(re.dataId).values,Me=c.data.get(j.dataId).values;for(let Ae=0;Ae<Te.length;++Ae){const Ce=Ae*de;let Pe=0;for(let je=0;je<de;++je)Pe+=Me[Ce+je];Te[Ae]=Pe}if(b){const Ae=fj(re.shape,O),Ce=re;re=tJ({inputs:{x:re},backend:c,attrs:{shape:Ae}}),c.disposeIntermediateTensorInfo(Ce)}return c.disposeIntermediateTensorInfo(w),q!=null&&c.disposeIntermediateTensorInfo(j),re}const kj={kernelName:Dj,backendName:"cpu",kernelFunc:kR};function kA(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{axis:v,keepDims:b}=p,w=P(v,m.shape),S=fR(m.shape,w)[1],O=G(S),q=[],H=c.makeTensorInfo([],"float32",new Float32Array([O]));q.push(H);const j=nA({inputs:{x:m},backend:c,attrs:{dtype:"float32"}});q.push(j);const $=kz({inputs:{a:j,b:H},backend:c});q.push($);const J=kR({inputs:{x:$},backend:c,attrs:{axis:v,keepDims:b}});return q.forEach(ee=>c.disposeIntermediateTensorInfo(ee)),J}const kC={kernelName:DI,backendName:"cpu",kernelFunc:kA};function ku(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{axis:v,keepDims:b}=p;ni(m,"min");const w=P(v,m.shape);let S=w;const O=fC(S,m.shape.length);let q=m;O!=null&&(q=pt({inputs:{x:m},backend:c,attrs:{perm:O}}),S=fQ(S.length,m.shape.length)),fA("min",S,q.shape.length);const[H,j]=fR(q.shape,S),$=G(j),J=HE(G(H),q.dtype),ee=c.data.get(q.dataId).values;for(let de=0;de<J.length;++de){const Te=de*$;let Me=ee[Te];for(let Ae=0;Ae<$;++Ae){const Ce=ee[Te+Ae];(Number.isNaN(Ce)||Ce<Me)&&(Me=Ce)}J[de]=Me}O!=null&&c.disposeIntermediateTensorInfo(q);const re=c.makeTensorInfo(H,q.dtype,J);if(b){const de=fj(H,w),Te=tJ({inputs:{x:re},backend:c,attrs:{shape:de}});return c.disposeIntermediateTensorInfo(re),Te}return re}const kQ={kernelName:DE,backendName:"cpu",kernelFunc:ku};function kJ(u){const{inputs:a,backend:c,attrs:p}=u,{axis:m}=p;if(a.length===1)return k6({inputs:{input:a[0]},backend:c,attrs:{dim:m}});const v=a[0].shape,b=a[0].dtype;a.forEach(q=>{t(v,q.shape,"All tensors passed to stack must have matching shapes"),i(b===q.dtype,()=>"All tensors passed to stack must have matching dtypes")});const w=[],S=a.map(q=>{const H=k6({inputs:{input:q},backend:c,attrs:{dim:m}});return w.push(H),H}),O=tV({inputs:S,backend:c,attrs:{axis:m}});return w.forEach(q=>c.disposeIntermediateTensorInfo(q)),O}const kx={kernelName:DF,backendName:"cpu",kernelFunc:kJ};function kM(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{paddings:v,constantValue:b}=p;ni(m,"pad");const w=v.map((de,Te)=>de[0]+m.shape[Te]+de[1]),S=v.map(de=>de[0]),O=c.data.get(m.dataId).values,q=G(m.shape),H=m.shape.length,j=HD(m.shape),$=G(w),J=w.length,ee=HD(w),re=e(m.dtype,$);b!==0&&re.fill(b);for(let de=0;de<q;de++){const Te=Hc(de,H,j).map((Ae,Ce)=>Ae+S[Ce]),Me=HO(Te,J,ee);re[Me]=O[de]}return{dataId:c.write(re,w,m.dtype),shape:w,dtype:m.dtype}}const kX={kernelName:DY,backendName:"cpu",kernelFunc:kM},kg=nw((u,a)=>Math.pow(u,a)),kK=nu(Do,kg),kb={kernelName:Do,backendName:"cpu",kernelFunc:kK};function kV(u){const{backend:a,attrs:c}=u,{start:p,stop:m,dtype:v,step:b}=c,w=pK(p,m,b,v);return a.makeTensorInfo([w.length],v,w)}const kd={kernelName:Dp,backendName:"cpu",kernelFunc:kV};function kP(u){const{inputs:a,backend:c,attrs:p}=u,{images:m}=a,{alignCorners:v,halfPixelCenters:b,size:w}=p;ni(m,"resizeBilinear");const S=HD(m.shape),[O,q]=w,[H,j,$,J]=m.shape,ee=c.data.get(m.dataId).values,re=new Float32Array(G([H,O,q,J])),de=[v&&O>1?j-1:j,v&&q>1?$-1:$],Te=[v&&O>1?O-1:O,v&&q>1?q-1:q];let Me=0;const Ae=de[0]/Te[0],Ce=de[1]/Te[1];for(let Pe=0;Pe<H;Pe++)for(let je=0;je<O;je++){let Ne;b?Ne=Ae*(je+.5)-.5:Ne=Ae*je;const Qe=Math.max(0,Math.floor(Ne)),Ct=Ne-Qe,dt=Math.min(j-1,Math.ceil(Ne)),Xt=Pe*S[0]+Qe*S[1],Gt=Pe*S[0]+dt*S[1];for(let Vt=0;Vt<q;Vt++){let T0;b?T0=Ce*(Vt+.5)-.5:T0=Ce*Vt;const r0=Math.max(0,Math.floor(T0)),d0=T0-r0,Ut=Math.min($-1,Math.ceil(T0)),$0=Xt+r0*S[2],Q0=Gt+r0*S[2],Un=Xt+Ut*S[2],b0=Gt+Ut*S[2];for(let X0=0;X0<J;X0++){const Rt=ee[$0+X0],Qt=ee[Q0+X0],A0=ee[Un+X0],J0=ee[b0+X0],Pn=Rt+(A0-Rt)*d0,dx=Qt+(J0-Qt)*d0,Bn=Pn+(dx-Pn)*Ct;re[Me++]=Bn}}}return c.makeTensorInfo([H,O,q,J],"float32",re)}const kv={kernelName:Dm,backendName:"cpu",kernelFunc:kP},kT={kernelName:Dd,backendName:"cpu",kernelFunc:({inputs:u,attrs:a,backend:c})=>{const{image:p}=u,{radians:m,fillValue:v,center:b}=a,w=c,S=e(p.dtype,G(p.shape)),[O,q,H,j]=p.shape,[$,J]=ZC(b,q,H),ee=255,re=Math.sin(m),de=Math.cos(m),Te=w.data.get(p.dataId).values;for(let Me=0;Me<O;Me++){const Ae=Me*H*q*j;for(let Ce=0;Ce<q;Ce++){const Pe=Ce*(H*j);for(let je=0;je<H;je++){const Ne=je*j;for(let Qe=0;Qe<j;Qe++){const Ct=[O,Ce,je,Qe],dt=Ct[2],Xt=Ct[1];let Gt=(dt-$)*de-(Xt-J)*re,Vt=(dt-$)*re+(Xt-J)*de;Gt=Math.round(Gt+$),Vt=Math.round(Vt+J);let T0=v;if(typeof v!="number"&&(Qe===3?T0=ee:T0=v[Qe]),Gt>=0&&Gt<H&&Vt>=0&&Vt<q){const d0=Vt*(H*j),Ut=Gt*j,$0=Ae+d0+Ut+Qe;T0=Te[$0]}const r0=Ae+Pe+Ne+Qe;S[r0]=T0}}}}return{dataId:w.write(S,p.shape,p.dtype),shape:p.shape,dtype:p.dtype}}},kr=nd(Dz,u=>Math.sin(u)),ke={kernelName:Dz,backendName:"cpu",kernelFunc:kr},kB={kernelName:Du,backendName:"cpu",kernelFunc:({inputs:u,backend:a})=>{const{x:c}=u,p=a;ni(c,"square");const m=p.data.get(c.dataId).values,v=new Float32Array(m.length);for(let b=0;b<m.length;++b){const w=m[b];v[b]=w*w}return{dataId:p.write(v,c.shape,c.dtype),shape:c.shape,dtype:c.dtype}}};function kN(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{begin:v,end:b,strides:w,beginMask:S,endMask:O,ellipsisMask:q,newAxisMask:H,shrinkAxisMask:j}=p;ni(m,"stridedSlice");const{finalShapeSparse:$,finalShape:J,isIdentity:ee,sliceDim0:re,isSimpleSlice:de,begin:Te,end:Me,strides:Ae}=Ec(m.shape,v,b,w,S,O,q,H,j);let Ce;if(ee)Ce=tJ({inputs:{x:m},backend:c,attrs:{shape:J}});else if(re||de){i(m.shape.length>=1,()=>"Input must have rank at least 1, got: "+m.shape.length);const Pe=E6(Te,Me,Ae),je=pr({inputs:{x:m},backend:c,attrs:{begin:Te,size:Pe}});Ce=tJ({inputs:{x:je},backend:c,attrs:{shape:J}}),c.disposeIntermediateTensorInfo(je)}else{const Pe=c.bufferSync(m),je=S6($,Pe,Ae,Te);Ce=c.makeTensorInfo(J,je.dtype,je.values)}return Ce}const w0={kernelName:DQ,backendName:"cpu",kernelFunc:kN};function w1(u){const{inputs:a,backend:c,attrs:p}=u,{x:m}=a,{reps:v}=p;ni(m,"tile");const b=SE(c.bufferSync(m),v);return c.makeTensorInfo(b.shape,b.dtype,b.values)}const w2={kernelName:Dx,backendName:"cpu",kernelFunc:w1};function w3(u){const{inputs:a,attrs:c,backend:p}=u,{image:m,transforms:v}=a,{interpolation:b,fillMode:w,fillValue:S,outputShape:O}=c,[q,H,j,$]=m.shape,[J,ee]=O??[H,j],re=[q,J,ee,$],de=HD(m.shape),Te=de[0],Me=de[1],Ae=de[2],Ce=HD(re),Pe=Ce[0],je=Ce[1],Ne=Ce[2],Qe=e(m.dtype,G(re));Qe.fill(S);const Ct=p.data.get(m.dataId).values,dt=p.data.get(v.dataId).values;for(let Xt=0;Xt<q;++Xt){const Gt=v.shape[0]===1?dt:dt.subarray(Xt*8,Xt*8+8);for(let Vt=0;Vt<J;++Vt)for(let T0=0;T0<ee;++T0)for(let r0=0;r0<$;++r0){let d0;const Ut=Gt[6]*T0+Gt[7]*Vt+1;if(Ut===0)continue;const $0=(Gt[0]*T0+Gt[1]*Vt+Gt[2])/Ut,Q0=(Gt[3]*T0+Gt[4]*Vt+Gt[5])/Ut,Un=w5($0,j,w),b0=w5(Q0,H,w);switch(b){case"nearest":d0=wD(Ct,H,j,Te,Me,Ae,Xt,b0,Un,r0,S);break;case"bilinear":d0=wy(Ct,H,j,Te,Me,Ae,Xt,b0,Un,r0,S);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+b)}const X0=Xt*Pe+Vt*je+T0*Ne+r0;Qe[X0]=d0}return p.makeTensorInfo(re,m.dtype,Qe)}return{dataId:p.write(Qe,re,m.dtype),shape:m.shape,dtype:m.dtype}}const w4={kernelName:DM,backendName:"cpu",kernelFunc:w3};function w5(u,a,c){switch(c){case"reflect":return w6(u,a);case"wrap":return w7(u,a);case"nearest":return w9(u,a);case"constant":default:return w8(u)}}function w6(u,a){let c=u;if(c<0)if(a<=1)c=0;else{const p=2*a;c<p&&(c=p*Math.trunc(-c/p)+c),c=c<-a?c+p:-c-1}else if(c>a-1)if(a<=1)c=0;else{const p=2*a;c-=p*Math.trunc(c/p),c>=a&&(c=p-c-1)}return o(0,c,a-1)}function w7(u,a){let c=u;if(c<0)if(a<=1)c=0;else{const p=a-1;c+=a*(Math.trunc(-c/p)+1)}else if(c>a-1)if(a<=1)c=0;else{const p=a-1;c-=a*Math.trunc(c/p)}return o(0,c,a-1)}function w8(u,a){return u}function w9(u,a){return o(0,u,a-1)}function wH(u,a,c,p,m,v,b,w,S,O,q){const H=b*p+w*m+S*v+O;return 0<=w&&w<a&&0<=S&&S<c?u[H]:q}function wD(u,a,c,p,m,v,b,w,S,O,q){const H=Math.round(w),j=Math.round(S);return wH(u,a,c,p,m,v,b,H,j,O,q)}function wy(u,a,c,p,m,v,b,w,S,O,q){const H=Math.floor(w),j=Math.floor(S),$=H+1,J=j+1,ee=(J-S)*wH(u,a,c,p,m,v,b,H,j,O,q)+(S-j)*wH(u,a,c,p,m,v,b,H,J,O,q),re=(J-S)*wH(u,a,c,p,m,v,b,$,j,O,q)+(S-j)*wH(u,a,c,p,m,v,b,$,J,O,q);return($-w)*ee+(w-H)*re}function wa(u){const{inputs:a,backend:c}=u,{x:p}=a;if(p.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(p.dtype==="complex64"){const m=nR({inputs:{input:p},backend:c}),v=wa({inputs:{x:m},backend:c}),b=tb({inputs:{input:p},backend:c}),w=wa({inputs:{x:b},backend:c}),S=nU({inputs:{real:v,imag:w},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(b),c.disposeIntermediateTensorInfo(w),S}else return k8({backend:c,attrs:{shape:p.shape,value:0,dtype:p.dtype}})}const ws={kernelName:DK,backendName:"cpu",kernelFunc:wa};function wI(u){const{inputs:a,backend:c,attrs:p}=u,{a:m,b:v,bias:b,preluActivationWeights:w}=a,{transposeA:S,transposeB:O,activation:q,leakyreluAlpha:H}=p;let j,$,J;const ee=[];j=tM({inputs:{a:m,b:v},attrs:{transposeA:S,transposeB:O},backend:c}),b&&($=nM({inputs:{a:j,b},backend:c}),ee.push(j),j=$),q&&(J=kZ(c,j,q,w,H),ee.push(j),j=J);for(const re of ee)c.disposeIntermediateTensorInfo(re);return j}const wE={kernelName:DP,backendName:"cpu",kernelFunc:wI};y3(lg),y3(h8),y3(hy),y3(hE),y3(hc),y3(hQ),y3(hb),y3(hv),y3(i2),y3(iH),y3(is),y3(iO),y3(iL),y3(ip),y3(il),y3(im),y3(iw),y3(iz),y3(iC),y3(iQ),y3(iX),y3(iV),y3(lv),y3(iT),y3(iN),y3(m3),y3(m7),y3(mH),y3(my),y3(mE),y3(mO),y3(mZ),y3(mY),y3(ho),y3(mS),y3(mh),y3(mk),y3(mz),y3(h1),y3(mR),y3(mu),y3(mM),y3(mb),y3(hS),y3(mv),y3(mr),y3(t0),y3(t4),y3(tD),y3(ts),y3(tf),y3(tZ),y3(tF),y3(hW),y3(tp),y3(th),y3(hj),y3(tm),y3(tw),y3(nk),y3(nX),y3(tW),y3(tA),y3(tQ),y3(tX),y3(nC),y3(tK),y3(td),y3(tv),y3(tr),y3(tB),y3(k3),y3(k5),y3(k7),y3(k9),y3(p1),y3(kq),y3(kY),y3(kn),y3(p8),y3(nW),y3(pD),y3(ps),y3(kl),y3(km),y3(kk),y3(kU),y3(pZ),y3(kC),y3(kQ),y3(pF),y3(pp),y3(ph),y3(kx),y3(kX),y3(kb),y3(kI),y3(kd),y3(kW),y3(kf),y3(kc),y3(tx),y3(kv),y3(kT),y3(pv),y3(ke),y3(pe),y3(S3),y3(kB),y3(w0),y3(SI),y3(kj),y3(w2),y3(w4),y3(pk),y3(ws),y3(wE);var wf={};(function(U0){var U1=U0;typeof y6<"u"&&(y6.numeric=U1),U1.version="1.2.6",U1.bench=function(u,a){var c,p,m,v;for(typeof a>"u"&&(a=15),m=.5,c=new Date;;){for(m*=2,v=m;v>3;v-=4)u(),u(),u(),u();for(;v>0;)u(),v--;if(p=new Date,p-c>a)break}for(v=m;v>3;v-=4)u(),u(),u(),u();for(;v>0;)u(),v--;return p=new Date,1e3*(3*m-1)/(p-c)},U1._myIndexOf=function(u){var a=this.length,c;for(c=0;c<a;++c)if(this[c]===u)return c;return-1},U1.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:U1._myIndexOf,U1.Function=Function,U1.precision=4,U1.largeArray=50,U1.prettyPrint=function(u){function a(m){if(m===0)return"0";if(isNaN(m))return"NaN";if(m<0)return"-"+a(-m);if(isFinite(m)){var v=Math.floor(Math.log(m)/Math.log(10)),b=m/Math.pow(10,v),w=b.toPrecision(U1.precision);return parseFloat(w)===10&&(v++,b=1,w=b.toPrecision(U1.precision)),parseFloat(w).toString()+"e"+v.toString()}return"Infinity"}var c=[];function p(m){var v;if(typeof m>"u")return c.push(Array(U1.precision+8).join(" ")),!1;if(typeof m=="string")return c.push('"'+m+'"'),!1;if(typeof m=="boolean")return c.push(m.toString()),!1;if(typeof m=="number"){var b=a(m),w=m.toPrecision(U1.precision),S=parseFloat(m.toString()).toString(),O=[b,w,S,parseFloat(w).toString(),parseFloat(S).toString()];for(v=1;v<O.length;v++)O[v].length<b.length&&(b=O[v]);return c.push(Array(U1.precision+8-b.length).join(" ")+b),!1}if(m===null)return c.push("null"),!1;if(typeof m=="function"){c.push(m.toString());var q=!1;for(v in m)m.hasOwnProperty(v)&&(q?c.push(`,
`):c.push(`
{`),q=!0,c.push(v),c.push(`: 
`),p(m[v]));return q&&c.push(`}
`),!0}if(m instanceof Array){if(m.length>U1.largeArray)return c.push("...Large Array..."),!0;var q=!1;for(c.push("["),v=0;v<m.length;v++)v>0&&(c.push(","),q&&c.push(`
 `)),q=p(m[v]);return c.push("]"),!0}c.push("{");var q=!1;for(v in m)m.hasOwnProperty(v)&&(q&&c.push(`,
`),q=!0,c.push(v),c.push(`: 
`),p(m[v]));return c.push("}"),!0}return p(u),c.join("")},U1.parseDate=function(u){function a(c){if(typeof c=="string")return Date.parse(c.replace(/-/g,"/"));if(!(c instanceof Array))throw new Error("parseDate: parameter must be arrays of strings");var p=[],m;for(m=0;m<c.length;m++)p[m]=a(c[m]);return p}return a(u)},U1.parseFloat=function(u){function a(c){if(typeof c=="string")return parseFloat(c);if(!(c instanceof Array))throw new Error("parseFloat: parameter must be arrays of strings");var p=[],m;for(m=0;m<c.length;m++)p[m]=a(c[m]);return p}return a(u)},U1.parseCSV=function(u){var a=u.split(`
`),c,p,m=[],v=/(([^'",]*)|('[^']*')|("[^"]*")),/g,b=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,w=function(H){return H.substr(0,H.length-1)},S=0;for(p=0;p<a.length;p++){var O=(a[p]+",").match(v),q;if(O.length>0){for(m[S]=[],c=0;c<O.length;c++)q=w(O[c]),b.test(q)?m[S][c]=parseFloat(q):m[S][c]=q;S++}}return m},U1.toCSV=function(u){var a=U1.dim(u),c,p,m,v,b;for(m=a[0],a[1],b=[],c=0;c<m;c++){for(v=[],p=0;p<m;p++)v[p]=u[c][p].toString();b[c]=v.join(", ")}return b.join(`
`)+`
`},U1.getURL=function(u){var a=new XMLHttpRequest;return a.open("GET",u,!1),a.send(),a},U1.imageURL=function(u){function a(re){var de=re.length,Te,Me,Ae,Ce,Pe,je,Ne,Qe,Ct="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",dt="";for(Te=0;Te<de;Te+=3)Me=re[Te],Ae=re[Te+1],Ce=re[Te+2],Pe=Me>>2,je=((Me&3)<<4)+(Ae>>4),Ne=((Ae&15)<<2)+(Ce>>6),Qe=Ce&63,Te+1>=de?Ne=Qe=64:Te+2>=de&&(Qe=64),dt+=Ct.charAt(Pe)+Ct.charAt(je)+Ct.charAt(Ne)+Ct.charAt(Qe);return dt}function c(re,de,Te){typeof de>"u"&&(de=0),typeof Te>"u"&&(Te=re.length);var Me=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],Ae=-1,Ce=0;re.length;var Pe;for(Pe=de;Pe<Te;Pe++)Ce=(Ae^re[Pe])&255,Ae=Ae>>>8^Me[Ce];return Ae^-1}var p=u[0].length,m=u[0][0].length,v,b,w,S,O,q,H,j,$,J,ee=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,m>>24&255,m>>16&255,m>>8&255,m&255,p>>24&255,p>>16&255,p>>8&255,p&255,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(J=c(ee,12,29),ee[29]=J>>24&255,ee[30]=J>>16&255,ee[31]=J>>8&255,ee[32]=J&255,v=1,b=0,H=0;H<p;H++){for(H<p-1?ee.push(0):ee.push(1),O=3*m+1+(H===0)&255,q=3*m+1+(H===0)>>8&255,ee.push(O),ee.push(q),ee.push(~O&255),ee.push(~q&255),H===0&&ee.push(0),j=0;j<m;j++)for(w=0;w<3;w++)O=u[w][H][j],O>255?O=255:O<0?O=0:O=Math.round(O),v=(v+O)%65521,b=(b+v)%65521,ee.push(O);ee.push(0)}return $=(b<<16)+v,ee.push($>>24&255),ee.push($>>16&255),ee.push($>>8&255),ee.push($&255),S=ee.length-41,ee[33]=S>>24&255,ee[34]=S>>16&255,ee[35]=S>>8&255,ee[36]=S&255,J=c(ee,37),ee.push(J>>24&255),ee.push(J>>16&255),ee.push(J>>8&255),ee.push(J&255),ee.push(0),ee.push(0),ee.push(0),ee.push(0),ee.push(73),ee.push(69),ee.push(78),ee.push(68),ee.push(174),ee.push(66),ee.push(96),ee.push(130),"data:image/png;base64,"+a(ee)},U1._dim=function(u){for(var a=[];typeof u=="object";)a.push(u.length),u=u[0];return a},U1.dim=function(u){var a,c;return typeof u=="object"?(a=u[0],typeof a=="object"?(c=a[0],typeof c=="object"?U1._dim(u):[u.length,a.length]):[u.length]):[]},U1.mapreduce=function(u,a){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+a+`;
if(typeof x === "number") { var xi = x; `+u+`; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    `+u+`;
    xi = x[i-1];
    `+u+`;
}
if(i === 0) {
    xi = x[i];
    `+u+`
}
return accum;`)},U1.mapreduce2=function(u,a){return Function("x",`var n = x.length;
var i,xi;
`+a+`;
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    `+u+`;
}
return accum;`)},U1.same=function u(a,c){var p,m;if(!(a instanceof Array)||!(c instanceof Array)||(m=a.length,m!==c.length))return!1;for(p=0;p<m;p++)if(a[p]!==c[p])if(typeof a[p]=="object"){if(!u(a[p],c[p]))return!1}else return!1;return!0},U1.rep=function(u,a,c){typeof c>"u"&&(c=0);var p=u[c],m=Array(p),v;if(c===u.length-1){for(v=p-2;v>=0;v-=2)m[v+1]=a,m[v]=a;return v===-1&&(m[0]=a),m}for(v=p-1;v>=0;v--)m[v]=U1.rep(u,a,c+1);return m},U1.dotMMsmall=function(u,a){var c,p,m,v,b,w,S,O,q,H,j;for(v=u.length,b=a.length,w=a[0].length,S=Array(v),c=v-1;c>=0;c--){for(O=Array(w),q=u[c],m=w-1;m>=0;m--){for(H=q[b-1]*a[b-1][m],p=b-2;p>=1;p-=2)j=p-1,H+=q[p]*a[p][m]+q[j]*a[j][m];p===0&&(H+=q[0]*a[0][m]),O[m]=H}S[c]=O}return S},U1._getCol=function(u,a,c){var p=u.length,m;for(m=p-1;m>0;--m)c[m]=u[m][a],--m,c[m]=u[m][a];m===0&&(c[0]=u[0][a])},U1.dotMMbig=function(u,a){var c=U1._getCol,p=a.length,m=Array(p),v=u.length,b=a[0].length,w=new Array(v),S,O=U1.dotVV,q,H;for(--p,--v,q=v;q!==-1;--q)w[q]=Array(b);for(--b,q=b;q!==-1;--q)for(c(a,q,m),H=v;H!==-1;--H)S=u[H],w[H][q]=O(S,m);return w},U1.dotMV=function(u,a){var c=u.length;a.length;var p,m=Array(c),v=U1.dotVV;for(p=c-1;p>=0;p--)m[p]=v(u[p],a);return m},U1.dotVM=function(u,a){var c,p,m,v,b,w,S;for(m=u.length,v=a[0].length,b=Array(v),p=v-1;p>=0;p--){for(w=u[m-1]*a[m-1][p],c=m-2;c>=1;c-=2)S=c-1,w+=u[c]*a[c][p]+u[S]*a[S][p];c===0&&(w+=u[0]*a[0][p]),b[p]=w}return b},U1.dotVV=function(u,a){var c,p=u.length,m,v=u[p-1]*a[p-1];for(c=p-2;c>=1;c-=2)m=c-1,v+=u[c]*a[c]+u[m]*a[m];return c===0&&(v+=u[0]*a[0]),v},U1.dot=function(u,a){var c=U1.dim;switch(c(u).length*1e3+c(a).length){case 2002:return a.length<10?U1.dotMMsmall(u,a):U1.dotMMbig(u,a);case 2001:return U1.dotMV(u,a);case 1002:return U1.dotVM(u,a);case 1001:return U1.dotVV(u,a);case 1e3:return U1.mulVS(u,a);case 1:return U1.mulSV(u,a);case 0:return u*a;default:throw new Error("numeric.dot only works on vectors and matrices")}},U1.diag=function(u){var a,c,p,m=u.length,v=Array(m),b;for(a=m-1;a>=0;a--){for(b=Array(m),c=a+2,p=m-1;p>=c;p-=2)b[p]=0,b[p-1]=0;for(p>a&&(b[p]=0),b[a]=u[a],p=a-1;p>=1;p-=2)b[p]=0,b[p-1]=0;p===0&&(b[0]=0),v[a]=b}return v},U1.getDiag=function(u){var a=Math.min(u.length,u[0].length),c,p=Array(a);for(c=a-1;c>=1;--c)p[c]=u[c][c],--c,p[c]=u[c][c];return c===0&&(p[0]=u[0][0]),p},U1.identity=function(u){return U1.diag(U1.rep([u],1))},U1.pointwise=function(u,a,c){typeof c>"u"&&(c="");var p=[],m,v=/\[i\]$/,b,w="",S=!1;for(m=0;m<u.length;m++)v.test(u[m])?(b=u[m].substring(0,u[m].length-3),w=b):b=u[m],b==="ret"&&(S=!0),p.push(b);return p[u.length]="_s",p[u.length+1]="_k",p[u.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+w+`);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i`+(S?"":", ret = Array(_n)")+`;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(`+u.join(",")+`,_s,_k+1);
    return ret;
}
`+c+`
for(i=_n-1;i!==-1;--i) {
    `+a+`
}
return ret;`,Function.apply(null,p)},U1.pointwise2=function(u,a,c){typeof c>"u"&&(c="");var p=[],m,v=/\[i\]$/,b,w="",S=!1;for(m=0;m<u.length;m++)v.test(u[m])?(b=u[m].substring(0,u[m].length-3),w=b):b=u[m],b==="ret"&&(S=!0),p.push(b);return p[u.length]="var _n = "+w+`.length;
var i`+(S?"":", ret = Array(_n)")+`;
`+c+`
for(i=_n-1;i!==-1;--i) {
`+a+`
}
return ret;`,Function.apply(null,p)},U1._biforeach=function u(a,c,p,m,v){if(m===p.length-1){v(a,c);return}var b,w=p[m];for(b=w-1;b>=0;b--)u(typeof a=="object"?a[b]:a,typeof c=="object"?c[b]:c,p,m+1,v)},U1._biforeach2=function u(a,c,p,m,v){if(m===p.length-1)return v(a,c);var b,w=p[m],S=Array(w);for(b=w-1;b>=0;--b)S[b]=u(typeof a=="object"?a[b]:a,typeof c=="object"?c[b]:c,p,m+1,v);return S},U1._foreach=function u(a,c,p,m){if(p===c.length-1){m(a);return}var v,b=c[p];for(v=b-1;v>=0;v--)u(a[v],c,p+1,m)},U1._foreach2=function u(a,c,p,m){if(p===c.length-1)return m(a);var v,b=c[p],w=Array(b);for(v=b-1;v>=0;v--)w[v]=u(a[v],c,p+1,m);return w},U1.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},U1.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},U1.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],U1.mathfuns2=["atan2","pow","max","min"],U1.ops1={neg:"-",not:"!",bnot:"~",clone:""},U1.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var u,a;for(u=0;u<U1.mathfuns2.length;++u)a=U1.mathfuns2[u],U1.ops2[a]=a;for(u in U1.ops2)if(U1.ops2.hasOwnProperty(u)){a=U1.ops2[u];var c,p,m="";U1.myIndexOf.call(U1.mathfuns2,u)!==-1?(m="var "+a+" = Math."+a+`;
`,c=function(v,b,w){return v+" = "+a+"("+b+","+w+")"},p=function(v,b){return v+" = "+a+"("+v+","+b+")"}):(c=function(v,b,w){return v+" = "+b+" "+a+" "+w},U1.opseq.hasOwnProperty(u+"eq")?p=function(v,b){return v+" "+a+"= "+b}:p=function(v,b){return v+" = "+v+" "+a+" "+b}),U1[u+"VV"]=U1.pointwise2(["x[i]","y[i]"],c("ret[i]","x[i]","y[i]"),m),U1[u+"SV"]=U1.pointwise2(["x","y[i]"],c("ret[i]","x","y[i]"),m),U1[u+"VS"]=U1.pointwise2(["x[i]","y"],c("ret[i]","x[i]","y"),m),U1[u]=Function(`var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.`+u+"VV, VS = numeric."+u+"VS, SV = numeric."+u+`SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else `+p("x","y")+`
}
return x;
`),U1[a]=U1[u],U1[u+"eqV"]=U1.pointwise2(["ret[i]","x[i]"],p("ret[i]","x[i]"),m),U1[u+"eqS"]=U1.pointwise2(["ret[i]","x"],p("ret[i]","x"),m),U1[u+"eq"]=Function(`var n = arguments.length, i, x = arguments[0], y;
var V = numeric.`+u+"eqV, S = numeric."+u+`eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`)}for(u=0;u<U1.mathfuns2.length;++u)a=U1.mathfuns2[u],delete U1.ops2[a];for(u=0;u<U1.mathfuns.length;++u)a=U1.mathfuns[u],U1.ops1[a]=a;for(u in U1.ops1)U1.ops1.hasOwnProperty(u)&&(m="",a=U1.ops1[u],U1.myIndexOf.call(U1.mathfuns,u)!==-1&&Math.hasOwnProperty(a)&&(m="var "+a+" = Math."+a+`;
`),U1[u+"eqV"]=U1.pointwise2(["ret[i]"],"ret[i] = "+a+"(ret[i]);",m),U1[u+"eq"]=Function("x",'if(typeof x !== "object") return '+a+`x
var i;
var V = numeric.`+u+`eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`),U1[u+"V"]=U1.pointwise2(["x[i]"],"ret[i] = "+a+"(x[i]);",m),U1[u]=Function("x",'if(typeof x !== "object") return '+a+`(x)
var i;
var V = numeric.`+u+`V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`));for(u=0;u<U1.mathfuns.length;++u)a=U1.mathfuns[u],delete U1.ops1[a];for(u in U1.mapreducers)U1.mapreducers.hasOwnProperty(u)&&(a=U1.mapreducers[u],U1[u+"V"]=U1.mapreduce2(a[0],a[1]),U1[u]=Function("x","s","k",a[1]+`if(typeof x !== "object") {    xi = x;
`+a[0]+`;
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.`+u+`V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
`+a[0]+`;
}
return accum;
`))}(),U1.truncVV=U1.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),U1.truncVS=U1.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),U1.truncSV=U1.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),U1.trunc=function(u,a){return typeof u=="object"?typeof a=="object"?U1.truncVV(u,a):U1.truncVS(u,a):typeof a=="object"?U1.truncSV(u,a):Math.round(u/a)*a},U1.inv=function(J){var a=U1.dim(J),c=Math.abs,p=a[0],m=a[1],v=U1.clone(J),b,w,S=U1.identity(p),O,q,H,j,$,J;for(j=0;j<m;++j){var ee=-1,re=-1;for(H=j;H!==p;++H)$=c(v[H][j]),$>re&&(ee=H,re=$);for(w=v[ee],v[ee]=v[j],v[j]=w,q=S[ee],S[ee]=S[j],S[j]=q,J=w[j],$=j;$!==m;++$)w[$]/=J;for($=m-1;$!==-1;--$)q[$]/=J;for(H=p-1;H!==-1;--H)if(H!==j){for(b=v[H],O=S[H],J=b[j],$=j+1;$!==m;++$)b[$]-=w[$]*J;for($=m-1;$>0;--$)O[$]-=q[$]*J,--$,O[$]-=q[$]*J;$===0&&(O[0]-=q[0]*J)}}return S},U1.det=function(u){var a=U1.dim(u);if(a.length!==2||a[0]!==a[1])throw new Error("numeric: det() only works on square matrices");var c=a[0],p=1,m,v,b,w=U1.clone(u),S,O,q,H,j;for(v=0;v<c-1;v++){for(b=v,m=v+1;m<c;m++)Math.abs(w[m][v])>Math.abs(w[b][v])&&(b=m);for(b!==v&&(H=w[b],w[b]=w[v],w[v]=H,p*=-1),S=w[v],m=v+1;m<c;m++){for(O=w[m],q=O[v]/S[v],b=v+1;b<c-1;b+=2)j=b+1,O[b]-=S[b]*q,O[j]-=S[j]*q;b!==c&&(O[b]-=S[b]*q)}if(S[v]===0)return 0;p*=S[v]}return p*w[v][v]},U1.transpose=function(u){var a,c,p=u.length,m=u[0].length,v=Array(m),b,w,S;for(c=0;c<m;c++)v[c]=Array(p);for(a=p-1;a>=1;a-=2){for(w=u[a],b=u[a-1],c=m-1;c>=1;--c)S=v[c],S[a]=w[c],S[a-1]=b[c],--c,S=v[c],S[a]=w[c],S[a-1]=b[c];c===0&&(S=v[0],S[a]=w[0],S[a-1]=b[0])}if(a===0){for(b=u[0],c=m-1;c>=1;--c)v[c][0]=b[c],--c,v[c][0]=b[c];c===0&&(v[0][0]=b[0])}return v},U1.negtranspose=function(u){var a,c,p=u.length,m=u[0].length,v=Array(m),b,w,S;for(c=0;c<m;c++)v[c]=Array(p);for(a=p-1;a>=1;a-=2){for(w=u[a],b=u[a-1],c=m-1;c>=1;--c)S=v[c],S[a]=-w[c],S[a-1]=-b[c],--c,S=v[c],S[a]=-w[c],S[a-1]=-b[c];c===0&&(S=v[0],S[a]=-w[0],S[a-1]=-b[0])}if(a===0){for(b=u[0],c=m-1;c>=1;--c)v[c][0]=-b[c],--c,v[c][0]=-b[c];c===0&&(v[0][0]=-b[0])}return v},U1._random=function u(a,c){var p,m=a[c],v=Array(m),b;if(c===a.length-1){for(b=Math.random,p=m-1;p>=1;p-=2)v[p]=b(),v[p-1]=b();return p===0&&(v[0]=b()),v}for(p=m-1;p>=0;p--)v[p]=u(a,c+1);return v},U1.random=function(u){return U1._random(u,0)},U1.norm2=function(u){return Math.sqrt(U1.norm2Squared(u))},U1.linspace=function(u,a,c){if(typeof c>"u"&&(c=Math.max(Math.round(a-u)+1,1)),c<2)return c===1?[u]:[];var p,m=Array(c);for(c--,p=c;p>=0;p--)m[p]=(p*a+(c-p)*u)/c;return m},U1.getBlock=function(u,a,c){var p=U1.dim(u);function m(v,b){var w,S=a[b],O=c[b]-S,q=Array(O);if(b===p.length-1){for(w=O;w>=0;w--)q[w]=v[w+S];return q}for(w=O;w>=0;w--)q[w]=m(v[w+S],b+1);return q}return m(u,0)},U1.setBlock=function(u,a,c,p){var m=U1.dim(u);function v(b,w,S){var O,q=a[S],H=c[S]-q;if(S===m.length-1)for(O=H;O>=0;O--)b[O+q]=w[O];for(O=H;O>=0;O--)v(b[O+q],w[O],S+1)}return v(u,p,0),u},U1.getRange=function(u,a,c){var p=a.length,m=c.length,v,b,w=Array(p),S,O;for(v=p-1;v!==-1;--v)for(w[v]=Array(m),S=w[v],O=u[a[v]],b=m-1;b!==-1;--b)S[b]=O[c[b]];return w},U1.blockMatrix=function(u){var a=U1.dim(u);if(a.length<4)return U1.blockMatrix([u]);var c=a[0],p=a[1],m,v,b,w,S;for(m=0,v=0,b=0;b<c;++b)m+=u[b][0].length;for(w=0;w<p;++w)v+=u[0][w][0].length;var O=Array(m);for(b=0;b<m;++b)O[b]=Array(v);var q=0,H,j,$,J,ee;for(b=0;b<c;++b){for(H=v,w=p-1;w!==-1;--w)for(S=u[b][w],H-=S[0].length,$=S.length-1;$!==-1;--$)for(ee=S[$],j=O[q+$],J=ee.length-1;J!==-1;--J)j[H+J]=ee[J];q+=u[b][0].length}return O},U1.tensor=function(u,a){if(typeof u=="number"||typeof a=="number")return U1.mul(u,a);var c=U1.dim(u),p=U1.dim(a);if(c.length!==1||p.length!==1)throw new Error("numeric: tensor product is only defined for vectors");var m=c[0],v=p[0],b=Array(m),w,S,O,q;for(S=m-1;S>=0;S--){for(w=Array(v),q=u[S],O=v-1;O>=3;--O)w[O]=q*a[O],--O,w[O]=q*a[O],--O,w[O]=q*a[O],--O,w[O]=q*a[O];for(;O>=0;)w[O]=q*a[O],--O;b[S]=w}return b},U1.T=function(u,a){this.x=u,this.y=a},U1.t=function(u,a){return new U1.T(u,a)},U1.Tbinop=function(u,a,c,p,m){if(U1.indexOf,typeof m!="string"){var v;m="";for(v in U1)U1.hasOwnProperty(v)&&(u.indexOf(v)>=0||a.indexOf(v)>=0||c.indexOf(v)>=0||p.indexOf(v)>=0)&&v.length>1&&(m+="var "+v+" = numeric."+v+`;
`)}return Function(["y"],`var x = this;
if(!(y instanceof numeric.T)) { y = new numeric.T(y); }
`+m+`
if(x.y) {  if(y.y) {    return new numeric.T(`+p+`);
  }
  return new numeric.T(`+c+`);
}
if(y.y) {
  return new numeric.T(`+a+`);
}
return new numeric.T(`+u+`);
`)},U1.T.prototype.add=U1.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),U1.T.prototype.sub=U1.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),U1.T.prototype.mul=U1.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),U1.T.prototype.reciprocal=function(){var u=U1.mul,a=U1.div;if(this.y){var c=U1.add(u(this.x,this.x),u(this.y,this.y));return new U1.T(a(this.x,c),a(U1.neg(this.y),c))}return new T(a(1,this.x))},U1.T.prototype.div=function(u){if(u instanceof U1.T||(u=new U1.T(u)),u.y)return this.mul(u.reciprocal());var a=U1.div;return this.y?new U1.T(a(this.x,u.x),a(this.y,u.x)):new U1.T(a(this.x,u.x))},U1.T.prototype.dot=U1.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),U1.T.prototype.transpose=function(){var u=U1.transpose,a=this.x,c=this.y;return c?new U1.T(u(a),u(c)):new U1.T(u(a))},U1.T.prototype.transjugate=function(){var u=U1.transpose,a=this.x,c=this.y;return c?new U1.T(u(a),U1.negtranspose(c)):new U1.T(u(a))},U1.Tunop=function(u,a,c){return typeof c!="string"&&(c=""),Function(`var x = this;
`+c+`
if(x.y) {  `+a+`;
}
`+u+`;
`)},U1.T.prototype.exp=U1.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),U1.T.prototype.conj=U1.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),U1.T.prototype.neg=U1.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),U1.T.prototype.sin=U1.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),U1.T.prototype.cos=U1.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),U1.T.prototype.abs=U1.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),U1.T.prototype.log=U1.Tunop("return new numeric.T(numeric.log(x.x));",`var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();
return new numeric.T(numeric.log(r.x),theta.x);`),U1.T.prototype.norm2=U1.Tunop("return numeric.norm2(x.x);",`var f = numeric.norm2Squared;
return Math.sqrt(f(x.x)+f(x.y));`),U1.T.prototype.inv=function(){var u=this;if(typeof u.y>"u")return new U1.T(U1.inv(u.x));var a=u.x.length,J,ee,re,c=U1.identity(a),p=U1.rep([a,a],0),m=U1.clone(u.x),v=U1.clone(u.y),b,w,S,O,q,H,j,$,J,ee,re,de,Te,Me,Ae,Ce,Pe,je;for(J=0;J<a;J++){for(Me=m[J][J],Ae=v[J][J],de=Me*Me+Ae*Ae,re=J,ee=J+1;ee<a;ee++)Me=m[ee][J],Ae=v[ee][J],Te=Me*Me+Ae*Ae,Te>de&&(re=ee,de=Te);for(re!==J&&(je=m[J],m[J]=m[re],m[re]=je,je=v[J],v[J]=v[re],v[re]=je,je=c[J],c[J]=c[re],c[re]=je,je=p[J],p[J]=p[re],p[re]=je),b=m[J],w=v[J],q=c[J],H=p[J],Me=b[J],Ae=w[J],ee=J+1;ee<a;ee++)Ce=b[ee],Pe=w[ee],b[ee]=(Ce*Me+Pe*Ae)/de,w[ee]=(Pe*Me-Ce*Ae)/de;for(ee=0;ee<a;ee++)Ce=q[ee],Pe=H[ee],q[ee]=(Ce*Me+Pe*Ae)/de,H[ee]=(Pe*Me-Ce*Ae)/de;for(ee=J+1;ee<a;ee++){for(S=m[ee],O=v[ee],j=c[ee],$=p[ee],Me=S[J],Ae=O[J],re=J+1;re<a;re++)Ce=b[re],Pe=w[re],S[re]-=Ce*Me-Pe*Ae,O[re]-=Pe*Me+Ce*Ae;for(re=0;re<a;re++)Ce=q[re],Pe=H[re],j[re]-=Ce*Me-Pe*Ae,$[re]-=Pe*Me+Ce*Ae}}for(J=a-1;J>0;J--)for(q=c[J],H=p[J],ee=J-1;ee>=0;ee--)for(j=c[ee],$=p[ee],Me=m[ee][J],Ae=v[ee][J],re=a-1;re>=0;re--)Ce=q[re],Pe=H[re],j[re]-=Me*Ce-Ae*Pe,$[re]-=Me*Pe+Ae*Ce;return new U1.T(c,p)},U1.T.prototype.get=function(u){var a=this.x,c=this.y,p=0,m,v=u.length;if(c){for(;p<v;)m=u[p],a=a[m],c=c[m],p++;return new U1.T(a,c)}for(;p<v;)m=u[p],a=a[m],p++;return new U1.T(a)},U1.T.prototype.set=function(u,a){var c=this.x,p=this.y,m=0,v,b=u.length,w=a.x,S=a.y;if(b===0)return S?this.y=S:p&&(this.y=void 0),this.x=c,this;if(S){for(p||(p=U1.rep(U1.dim(c),0),this.y=p);m<b-1;)v=u[m],c=c[v],p=p[v],m++;return v=u[m],c[v]=w,p[v]=S,this}if(p){for(;m<b-1;)v=u[m],c=c[v],p=p[v],m++;return v=u[m],c[v]=w,w instanceof Array?p[v]=U1.rep(U1.dim(w),0):p[v]=0,this}for(;m<b-1;)v=u[m],c=c[v],m++;return v=u[m],c[v]=w,this},U1.T.prototype.getRows=function(u,a){var c=a-u+1,p,m=Array(c),v,b=this.x,w=this.y;for(p=u;p<=a;p++)m[p-u]=b[p];if(w){for(v=Array(c),p=u;p<=a;p++)v[p-u]=w[p];return new U1.T(m,v)}return new U1.T(m)},U1.T.prototype.setRows=function(u,a,c){var p,m=this.x,v=this.y,b=c.x,w=c.y;for(p=u;p<=a;p++)m[p]=b[p-u];if(w)for(v||(v=U1.rep(U1.dim(m),0),this.y=v),p=u;p<=a;p++)v[p]=w[p-u];else if(v)for(p=u;p<=a;p++)v[p]=U1.rep([b[p-u].length],0);return this},U1.T.prototype.getRow=function(u){var a=this.x,c=this.y;return c?new U1.T(a[u],c[u]):new U1.T(a[u])},U1.T.prototype.setRow=function(u,a){var c=this.x,p=this.y,m=a.x,v=a.y;return c[u]=m,v?(p||(p=U1.rep(U1.dim(c),0),this.y=p),p[u]=v):p&&(p=U1.rep([m.length],0)),this},U1.T.prototype.getBlock=function(u,a){var c=this.x,p=this.y,m=U1.getBlock;return p?new U1.T(m(c,u,a),m(p,u,a)):new U1.T(m(c,u,a))},U1.T.prototype.setBlock=function(u,a,c){c instanceof U1.T||(c=new U1.T(c));var p=this.x,m=this.y,v=U1.setBlock,b=c.x,w=c.y;if(w)return m||(this.y=U1.rep(U1.dim(this),0),m=this.y),v(p,u,a,b),v(m,u,a,w),this;v(p,u,a,b),m&&v(m,u,a,U1.rep(U1.dim(b),0))},U1.T.rep=function(u,a){var c=U1.T;a instanceof c||(a=new c(a));var p=a.x,m=a.y,v=U1.rep;return m?new c(v(u,p),v(u,m)):new c(v(u,p))},U1.T.diag=function(u){u instanceof U1.T||(u=new U1.T(u));var a=u.x,c=u.y,p=U1.diag;return c?new U1.T(p(a),p(c)):new U1.T(p(a))},U1.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return U1.eig(this.x)},U1.T.identity=function(u){return new U1.T(U1.identity(u))},U1.T.prototype.getDiag=function(){var u=U1,a=this.x,c=this.y;return c?new u.T(u.getDiag(a),u.getDiag(c)):new u.T(u.getDiag(a))},U1.house=function(u){var a=U1.clone(u),c=u[0]>=0?1:-1,p=c*U1.norm2(u);a[0]+=p;var m=U1.norm2(a);if(m===0)throw new Error("eig: internal error");return U1.div(a,m)},U1.toUpperHessenberg=function(u){var a=U1.dim(u);if(a.length!==2||a[0]!==a[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var c=a[0],p,m,v,b,w,S=U1.clone(u),O,q,H,j,$=U1.identity(c),J;for(m=0;m<c-2;m++){for(b=Array(c-m-1),p=m+1;p<c;p++)b[p-m-1]=S[p][m];if(U1.norm2(b)>0){for(w=U1.house(b),O=U1.getBlock(S,[m+1,m],[c-1,c-1]),q=U1.tensor(w,U1.dot(w,O)),p=m+1;p<c;p++)for(H=S[p],j=q[p-m-1],v=m;v<c;v++)H[v]-=2*j[v-m];for(O=U1.getBlock(S,[0,m+1],[c-1,c-1]),q=U1.tensor(U1.dot(O,w),w),p=0;p<c;p++)for(H=S[p],j=q[p],v=m+1;v<c;v++)H[v]-=2*j[v-m-1];for(O=Array(c-m-1),p=m+1;p<c;p++)O[p-m-1]=$[p];for(q=U1.tensor(w,U1.dot(w,O)),p=m+1;p<c;p++)for(J=$[p],j=q[p-m-1],v=0;v<c;v++)J[v]-=2*j[v]}}return{H:S,Q:$}},U1.epsilon=2220446049250313e-31,U1.QRFrancis=function(u,a){typeof a>"u"&&(a=1e4),u=U1.clone(u),U1.clone(u);var c=U1.dim(u),p=c[0],m,v,b,w,S,O,q,H,j,$=U1.identity(p),J,ee,re,de,Te,Me,Ae,Ce,Pe;if(p<3)return{Q:$,B:[[0,p-1]]};var je=U1.epsilon;for(Pe=0;Pe<a;Pe++){for(Ae=0;Ae<p-1;Ae++)if(Math.abs(u[Ae+1][Ae])<je*(Math.abs(u[Ae][Ae])+Math.abs(u[Ae+1][Ae+1]))){var Ne=U1.QRFrancis(U1.getBlock(u,[0,0],[Ae,Ae]),a),Qe=U1.QRFrancis(U1.getBlock(u,[Ae+1,Ae+1],[p-1,p-1]),a);for(re=Array(Ae+1),Me=0;Me<=Ae;Me++)re[Me]=$[Me];for(de=U1.dot(Ne.Q,re),Me=0;Me<=Ae;Me++)$[Me]=de[Me];for(re=Array(p-Ae-1),Me=Ae+1;Me<p;Me++)re[Me-Ae-1]=$[Me];for(de=U1.dot(Qe.Q,re),Me=Ae+1;Me<p;Me++)$[Me]=de[Me-Ae-1];return{Q:$,B:Ne.B.concat(U1.add(Qe.B,Ae+1))}}if(b=u[p-2][p-2],w=u[p-2][p-1],S=u[p-1][p-2],O=u[p-1][p-1],H=b+O,q=b*O-w*S,j=U1.getBlock(u,[0,0],[2,2]),H*H>=4*q){var Ct,dt;Ct=.5*(H+Math.sqrt(H*H-4*q)),dt=.5*(H-Math.sqrt(H*H-4*q)),j=U1.add(U1.sub(U1.dot(j,j),U1.mul(j,Ct+dt)),U1.diag(U1.rep([3],Ct*dt)))}else j=U1.add(U1.sub(U1.dot(j,j),U1.mul(j,H)),U1.diag(U1.rep([3],q)));for(m=[j[0][0],j[1][0],j[2][0]],v=U1.house(m),re=[u[0],u[1],u[2]],de=U1.tensor(v,U1.dot(v,re)),Me=0;Me<3;Me++)for(ee=u[Me],Te=de[Me],Ce=0;Ce<p;Ce++)ee[Ce]-=2*Te[Ce];for(re=U1.getBlock(u,[0,0],[p-1,2]),de=U1.tensor(U1.dot(re,v),v),Me=0;Me<p;Me++)for(ee=u[Me],Te=de[Me],Ce=0;Ce<3;Ce++)ee[Ce]-=2*Te[Ce];for(re=[$[0],$[1],$[2]],de=U1.tensor(v,U1.dot(v,re)),Me=0;Me<3;Me++)for(J=$[Me],Te=de[Me],Ce=0;Ce<p;Ce++)J[Ce]-=2*Te[Ce];var Xt;for(Ae=0;Ae<p-2;Ae++){for(Ce=Ae;Ce<=Ae+1;Ce++)if(Math.abs(u[Ce+1][Ce])<je*(Math.abs(u[Ce][Ce])+Math.abs(u[Ce+1][Ce+1]))){var Ne=U1.QRFrancis(U1.getBlock(u,[0,0],[Ce,Ce]),a),Qe=U1.QRFrancis(U1.getBlock(u,[Ce+1,Ce+1],[p-1,p-1]),a);for(re=Array(Ce+1),Me=0;Me<=Ce;Me++)re[Me]=$[Me];for(de=U1.dot(Ne.Q,re),Me=0;Me<=Ce;Me++)$[Me]=de[Me];for(re=Array(p-Ce-1),Me=Ce+1;Me<p;Me++)re[Me-Ce-1]=$[Me];for(de=U1.dot(Qe.Q,re),Me=Ce+1;Me<p;Me++)$[Me]=de[Me-Ce-1];return{Q:$,B:Ne.B.concat(U1.add(Qe.B,Ce+1))}}for(Xt=Math.min(p-1,Ae+3),m=Array(Xt-Ae),Me=Ae+1;Me<=Xt;Me++)m[Me-Ae-1]=u[Me][Ae];for(v=U1.house(m),re=U1.getBlock(u,[Ae+1,Ae],[Xt,p-1]),de=U1.tensor(v,U1.dot(v,re)),Me=Ae+1;Me<=Xt;Me++)for(ee=u[Me],Te=de[Me-Ae-1],Ce=Ae;Ce<p;Ce++)ee[Ce]-=2*Te[Ce-Ae];for(re=U1.getBlock(u,[0,Ae+1],[p-1,Xt]),de=U1.tensor(U1.dot(re,v),v),Me=0;Me<p;Me++)for(ee=u[Me],Te=de[Me],Ce=Ae+1;Ce<=Xt;Ce++)ee[Ce]-=2*Te[Ce-Ae-1];for(re=Array(Xt-Ae),Me=Ae+1;Me<=Xt;Me++)re[Me-Ae-1]=$[Me];for(de=U1.tensor(v,U1.dot(v,re)),Me=Ae+1;Me<=Xt;Me++)for(J=$[Me],Te=de[Me-Ae-1],Ce=0;Ce<p;Ce++)J[Ce]-=2*Te[Ce]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},U1.eig=function(u,a){var c=U1.toUpperHessenberg(u),p=U1.QRFrancis(c.H,a),m=U1.T,Xt=u.length,v,b,w=p.B,S=U1.dot(p.Q,U1.dot(c.H,U1.transpose(p.Q))),O=new m(U1.dot(p.Q,c.Q)),q,H=w.length,j,$,J,ee,re,de,Te,Me,Ae,Ce,Pe,je,Ne,Qe,Ct=Math.sqrt;for(b=0;b<H;b++)if(v=w[b][0],v!==w[b][1]){if(j=v+1,$=S[v][v],J=S[v][j],ee=S[j][v],re=S[j][j],J===0&&ee===0)continue;de=-$-re,Te=$*re-J*ee,Me=de*de-4*Te,Me>=0?(de<0?Ae=-.5*(de-Ct(Me)):Ae=-.5*(de+Ct(Me)),Ne=($-Ae)*($-Ae)+J*J,Qe=ee*ee+(re-Ae)*(re-Ae),Ne>Qe?(Ne=Ct(Ne),Pe=($-Ae)/Ne,je=J/Ne):(Qe=Ct(Qe),Pe=ee/Qe,je=(re-Ae)/Qe),q=new m([[je,-Pe],[Pe,je]]),O.setRows(v,j,q.dot(O.getRows(v,j)))):(Ae=-.5*de,Ce=.5*Ct(-Me),Ne=($-Ae)*($-Ae)+J*J,Qe=ee*ee+(re-Ae)*(re-Ae),Ne>Qe?(Ne=Ct(Ne+Ce*Ce),Pe=($-Ae)/Ne,je=J/Ne,Ae=0,Ce/=Ne):(Qe=Ct(Qe+Ce*Ce),Pe=ee/Qe,je=(re-Ae)/Qe,Ae=Ce/Qe,Ce=0),q=new m([[je,-Pe],[Pe,je]],[[Ae,Ce],[Ce,-Ae]]),O.setRows(v,j,q.dot(O.getRows(v,j))))}var dt=O.dot(u).dot(O.transjugate()),Xt=u.length,Gt=U1.T.identity(Xt);for(j=0;j<Xt;j++)if(j>0)for(b=j-1;b>=0;b--){var Vt=dt.get([b,b]),T0=dt.get([j,j]);if(U1.neq(Vt.x,T0.x)||U1.neq(Vt.y,T0.y))Ae=dt.getRow(b).getBlock([b],[j-1]),Ce=Gt.getRow(j).getBlock([b],[j-1]),Gt.set([j,b],dt.get([b,j]).neg().sub(Ae.dot(Ce)).div(Vt.sub(T0)));else{Gt.setRow(j,Gt.getRow(b));continue}}for(j=0;j<Xt;j++)Ae=Gt.getRow(j),Gt.setRow(j,Ae.div(Ae.norm2()));return Gt=Gt.transpose(),Gt=O.transjugate().dot(Gt),{lambda:dt.getDiag(),E:Gt}},U1.ccsSparse=function(u){var a=u.length,b,c,p,m,v=[];for(p=a-1;p!==-1;--p){c=u[p];for(m in c){for(m=parseInt(m);m>=v.length;)v[v.length]=0;c[m]!==0&&v[m]++}}var b=v.length,w=Array(b+1);for(w[0]=0,p=0;p<b;++p)w[p+1]=w[p]+v[p];var S=Array(w[b]),O=Array(w[b]);for(p=a-1;p!==-1;--p){c=u[p];for(m in c)c[m]!==0&&(v[m]--,S[w[m]+v[m]]=p,O[w[m]+v[m]]=c[m])}return[w,S,O]},U1.ccsFull=function(u){var a=u[0],c=u[1],p=u[2],m=U1.ccsDim(u),v=m[0],b=m[1],w,S,O,q,H=U1.rep([v,b],0);for(w=0;w<b;w++)for(O=a[w],q=a[w+1],S=O;S<q;++S)H[c[S]][w]=p[S];return H},U1.ccsTSolve=function(u,a,c,p,m){var v=u[0],b=u[1],w=u[2],S=v.length-1,O=Math.max,q=0;typeof p>"u"&&(c=U1.rep([S],0)),typeof p>"u"&&(p=U1.linspace(0,c.length-1)),typeof m>"u"&&(m=[]);function H(Me){var Ae;if(c[Me]===0){for(c[Me]=1,Ae=v[Me];Ae<v[Me+1];++Ae)H(b[Ae]);m[q]=Me,++q}}var j,$,J,ee,re,de,Te;for(j=p.length-1;j!==-1;--j)H(p[j]);for(m.length=q,j=m.length-1;j!==-1;--j)c[m[j]]=0;for(j=p.length-1;j!==-1;--j)$=p[j],c[$]=a[$];for(j=m.length-1;j!==-1;--j){for($=m[j],J=v[$],ee=O(v[$+1],J),re=J;re!==ee;++re)if(b[re]===$){c[$]/=w[re];break}for(Te=c[$],re=J;re!==ee;++re)de=b[re],de!==$&&(c[de]-=Te*w[re])}return c},U1.ccsDFS=function(u){this.k=Array(u),this.k1=Array(u),this.j=Array(u)},U1.ccsDFS.prototype.dfs=function(u,a,c,p,m,v){var b=0,w,S=m.length,O=this.k,q=this.k1,H=this.j,j,$;if(p[u]===0)for(p[u]=1,H[0]=u,O[0]=j=a[u],q[0]=$=a[u+1];;)if(j>=$){if(m[S]=H[b],b===0)return;++S,--b,j=O[b],$=q[b]}else w=v[c[j]],p[w]===0?(p[w]=1,O[b]=j,++b,H[b]=w,j=a[w],q[b]=$=a[w+1]):++j},U1.ccsLPSolve=function(u,a,c,p,m,v,b){var w=u[0],S=u[1],O=u[2];w.length-1;var q=a[0],H=a[1],j=a[2],$,J,ee,re,de,Te,Me,Ae,Ce;for(J=q[m],ee=q[m+1],p.length=0,$=J;$<ee;++$)b.dfs(v[H[$]],w,S,c,p,v);for($=p.length-1;$!==-1;--$)c[p[$]]=0;for($=J;$!==ee;++$)re=v[H[$]],c[re]=j[$];for($=p.length-1;$!==-1;--$){for(re=p[$],de=w[re],Te=w[re+1],Me=de;Me<Te;++Me)if(v[S[Me]]===re){c[re]/=O[Me];break}for(Ce=c[re],Me=de;Me<Te;++Me)Ae=v[S[Me]],Ae!==re&&(c[Ae]-=Ce*O[Me])}return c},U1.ccsLUP1=function(u,a){var c=u[0].length-1,p=[U1.rep([c+1],0),[],[]],m=[U1.rep([c+1],0),[],[]],v=p[0],b=p[1],w=p[2],S=m[0],O=m[1],q=m[2],H=U1.rep([c],0),j=U1.rep([c],0),$,J,ee,re,de,Te,Me,Ae=U1.ccsLPSolve,Ce=Math.abs,Pe=U1.linspace(0,c-1),je=U1.linspace(0,c-1),Ne=new U1.ccsDFS(c);for(typeof a>"u"&&(a=1),$=0;$<c;++$){for(Ae(p,u,H,j,$,je,Ne),re=-1,de=-1,J=j.length-1;J!==-1;--J)ee=j[J],!(ee<=$)&&(Te=Ce(H[ee]),Te>re&&(de=ee,re=Te));for(Ce(H[$])<a*re&&(J=Pe[$],re=Pe[de],Pe[$]=re,je[re]=$,Pe[de]=J,je[J]=de,re=H[$],H[$]=H[de],H[de]=re),re=v[$],de=S[$],Me=H[$],b[re]=Pe[$],w[re]=1,++re,J=j.length-1;J!==-1;--J)ee=j[J],Te=H[ee],j[J]=0,H[ee]=0,ee<=$?(O[de]=ee,q[de]=Te,++de):(b[re]=Pe[ee],w[re]=Te/Me,++re);v[$+1]=re,S[$+1]=de}for(J=b.length-1;J!==-1;--J)b[J]=je[b[J]];return{L:p,U:m,P:Pe,Pinv:je}},U1.ccsDFS0=function(u){this.k=Array(u),this.k1=Array(u),this.j=Array(u)},U1.ccsDFS0.prototype.dfs=function(u,a,c,p,m,v,b){var w=0,S,O=m.length,q=this.k,H=this.k1,j=this.j,$,J;if(p[u]===0)for(p[u]=1,j[0]=u,q[0]=$=a[v[u]],H[0]=J=a[v[u]+1];;){if(isNaN($))throw new Error("Ow!");if($>=J){if(m[O]=v[j[w]],w===0)return;++O,--w,$=q[w],J=H[w]}else S=c[$],p[S]===0?(p[S]=1,q[w]=$,++w,j[w]=S,S=v[S],$=a[S],H[w]=J=a[S+1]):++$}},U1.ccsLPSolve0=function(u,a,c,p,m,v,b,w){var S=u[0],O=u[1],q=u[2];S.length-1;var H=a[0],j=a[1],$=a[2],J,ee,re,de,Te,Me,Ae,Ce,Pe;for(ee=H[m],re=H[m+1],p.length=0,J=ee;J<re;++J)w.dfs(j[J],S,O,c,p,v,b);for(J=p.length-1;J!==-1;--J)de=p[J],c[b[de]]=0;for(J=ee;J!==re;++J)de=j[J],c[de]=$[J];for(J=p.length-1;J!==-1;--J){for(de=p[J],Ce=b[de],Te=S[de],Me=S[de+1],Ae=Te;Ae<Me;++Ae)if(O[Ae]===Ce){c[Ce]/=q[Ae];break}for(Pe=c[Ce],Ae=Te;Ae<Me;++Ae)c[O[Ae]]-=Pe*q[Ae];c[Ce]=Pe}},U1.ccsLUP0=function(u,a){var c=u[0].length-1,p=[U1.rep([c+1],0),[],[]],m=[U1.rep([c+1],0),[],[]],v=p[0],b=p[1],w=p[2],S=m[0],O=m[1],q=m[2],H=U1.rep([c],0),j=U1.rep([c],0),$,J,ee,re,de,Te,Me,Ae=U1.ccsLPSolve0,Ce=Math.abs,Pe=U1.linspace(0,c-1),je=U1.linspace(0,c-1),Ne=new U1.ccsDFS0(c);for(typeof a>"u"&&(a=1),$=0;$<c;++$){for(Ae(p,u,H,j,$,je,Pe,Ne),re=-1,de=-1,J=j.length-1;J!==-1;--J)ee=j[J],!(ee<=$)&&(Te=Ce(H[Pe[ee]]),Te>re&&(de=ee,re=Te));for(Ce(H[Pe[$]])<a*re&&(J=Pe[$],re=Pe[de],Pe[$]=re,je[re]=$,Pe[de]=J,je[J]=de),re=v[$],de=S[$],Me=H[Pe[$]],b[re]=Pe[$],w[re]=1,++re,J=j.length-1;J!==-1;--J)ee=j[J],Te=H[Pe[ee]],j[J]=0,H[Pe[ee]]=0,ee<=$?(O[de]=ee,q[de]=Te,++de):(b[re]=Pe[ee],w[re]=Te/Me,++re);v[$+1]=re,S[$+1]=de}for(J=b.length-1;J!==-1;--J)b[J]=je[b[J]];return{L:p,U:m,P:Pe,Pinv:je}},U1.ccsLUP=U1.ccsLUP0,U1.ccsDim=function(u){return[U1.sup(u[1])+1,u[0].length-1]},U1.ccsGetBlock=function(u,a,c){var p=U1.ccsDim(u),m=p[0],v=p[1];typeof a>"u"?a=U1.linspace(0,m-1):typeof a=="number"&&(a=[a]),typeof c>"u"?c=U1.linspace(0,v-1):typeof c=="number"&&(c=[c]);var b,w=a.length,S,O=c.length,q,H,j,$=U1.rep([v],0),J=[],ee=[],re=[$,J,ee],de=u[0],Te=u[1],Me=u[2],Ae=U1.rep([m],0),Ce=0,Pe=U1.rep([m],0);for(S=0;S<O;++S){H=c[S];var je=de[H],Ne=de[H+1];for(b=je;b<Ne;++b)q=Te[b],Pe[q]=1,Ae[q]=Me[b];for(b=0;b<w;++b)j=a[b],Pe[j]&&(J[Ce]=b,ee[Ce]=Ae[a[b]],++Ce);for(b=je;b<Ne;++b)q=Te[b],Pe[q]=0;$[S+1]=Ce}return re},U1.ccsDot=function(u,a){var c=u[0],p=u[1],m=u[2],v=a[0],b=a[1],w=a[2],S=U1.ccsDim(u),O=U1.ccsDim(a),q=S[0];S[1];var H=O[1],j=U1.rep([q],0),$=U1.rep([q],0),J=Array(q),ee=U1.rep([H],0),re=[],de=[],Te=[ee,re,de],Me,Ae,Ce,Pe,je,Ne,Qe,Ct,dt,Xt,Gt;for(Ce=0;Ce!==H;++Ce){for(Pe=v[Ce],je=v[Ce+1],dt=0,Ae=Pe;Ae<je;++Ae)for(Xt=b[Ae],Gt=w[Ae],Ne=c[Xt],Qe=c[Xt+1],Me=Ne;Me<Qe;++Me)Ct=p[Me],$[Ct]===0&&(J[dt]=Ct,$[Ct]=1,dt=dt+1),j[Ct]=j[Ct]+m[Me]*Gt;for(Pe=ee[Ce],je=Pe+dt,ee[Ce+1]=je,Ae=dt-1;Ae!==-1;--Ae)Gt=Pe+Ae,Me=J[Ae],re[Gt]=Me,de[Gt]=j[Me],$[Me]=0,j[Me]=0;ee[Ce+1]=ee[Ce]+dt}return Te},U1.ccsLUPSolve=function(u,a){var c=u.L,p=u.U;u.P;var m=a[0],v=!1;typeof m!="object"&&(a=[[0,a.length],U1.linspace(0,a.length-1),a],m=a[0],v=!0);var b=a[1],w=a[2],S=c[0].length-1,O=m.length-1,q=U1.rep([S],0),H=Array(S),j=U1.rep([S],0),$=Array(S),J=U1.rep([O+1],0),ee=[],re=[],de=U1.ccsTSolve,Te,Me,Ae,Ce,Pe,je,Ne=0;for(Te=0;Te<O;++Te){for(Pe=0,Ae=m[Te],Ce=m[Te+1],Me=Ae;Me<Ce;++Me)je=u.Pinv[b[Me]],$[Pe]=je,j[je]=w[Me],++Pe;for($.length=Pe,de(c,j,q,$,H),Me=$.length-1;Me!==-1;--Me)j[$[Me]]=0;if(de(p,q,j,H,$),v)return j;for(Me=H.length-1;Me!==-1;--Me)q[H[Me]]=0;for(Me=$.length-1;Me!==-1;--Me)je=$[Me],ee[Ne]=je,re[Ne]=j[je],j[je]=0,++Ne;J[Te+1]=Ne}return[J,ee,re]},U1.ccsbinop=function(u,a){return typeof a>"u"&&(a=""),Function("X","Y",`var Xi = X[0], Xj = X[1], Xv = X[2];
var Yi = Y[0], Yj = Y[1], Yv = Y[2];
var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;
var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];
var x = numeric.rep([m],0),y = numeric.rep([m],0);
var xk,yk,zk;
var i,j,j0,j1,k,p=0;
`+a+`for(i=0;i<n;++i) {
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Xj[j];
    x[k] = 1;
    Zj[p] = k;
    ++p;
  }
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Yj[j];
    y[k] = Yv[j];
    if(x[k] === 0) {
      Zj[p] = k;
      ++p;
    }
  }
  Zi[i+1] = p;
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];
  j0 = Zi[i]; j1 = Zi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Zj[j];
    xk = x[k];
    yk = y[k];
`+u+`
    Zv[j] = zk;
  }
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;
}
return [Zi,Zj,Zv];`)},function(){var U8,U9,UH,UD;for(U8 in U1.ops2)isFinite(eval("1"+U1.ops2[U8]+"0"))?U9="[Y[0],Y[1],numeric."+U8+"(X,Y[2])]":U9="NaN",isFinite(eval("0"+U1.ops2[U8]+"1"))?UH="[X[0],X[1],numeric."+U8+"(X[2],Y)]":UH="NaN",isFinite(eval("1"+U1.ops2[U8]+"0"))&&isFinite(eval("0"+U1.ops2[U8]+"1"))?UD="numeric.ccs"+U8+"MM(X,Y)":UD="NaN",U1["ccs"+U8+"MM"]=U1.ccsbinop("zk = xk "+U1.ops2[U8]+"yk;"),U1["ccs"+U8]=Function("X","Y",'if(typeof X === "number") return '+U9+`;
if(typeof Y === "number") return `+UH+`;
return `+UD+`;
`)}(),U1.ccsScatter=function u(a){var c=a[0],p=a[1],m=a[2],v=U1.sup(p)+1,b=c.length,w=U1.rep([v],0),S=Array(b),O=Array(b),q=U1.rep([v],0),H;for(H=0;H<b;++H)q[p[H]]++;for(H=0;H<v;++H)w[H+1]=w[H]+q[H];var j=w.slice(0),$,J;for(H=0;H<b;++H)J=p[H],$=j[J],S[$]=c[H],O[$]=m[H],j[J]=j[J]+1;return[w,S,O]},U1.ccsGather=function u(a){var c=a[0],p=a[1],m=a[2],v=c.length-1,b=p.length,w=Array(b),S=Array(b),O=Array(b),q,H,j,$,J;for(J=0,q=0;q<v;++q)for(j=c[q],$=c[q+1],H=j;H!==$;++H)S[J]=q,w[J]=p[H],O[J]=m[H],++J;return[w,S,O]},U1.sdim=function u(a,c,p){if(typeof c>"u"&&(c=[]),typeof a!="object")return c;typeof p>"u"&&(p=0),p in c||(c[p]=0),a.length>c[p]&&(c[p]=a.length);var m;for(m in a)a.hasOwnProperty(m)&&u(a[m],c,p+1);return c},U1.sclone=function u(a,c,p){typeof c>"u"&&(c=0),typeof p>"u"&&(p=U1.sdim(a).length);var m,v=Array(a.length);if(c===p-1){for(m in a)a.hasOwnProperty(m)&&(v[m]=a[m]);return v}for(m in a)a.hasOwnProperty(m)&&(v[m]=u(a[m],c+1,p));return v},U1.sdiag=function u(a){var c=a.length,p,m=Array(c),v;for(p=c-1;p>=1;p-=2)v=p-1,m[p]=[],m[p][p]=a[p],m[v]=[],m[v][v]=a[v];return p===0&&(m[0]=[],m[0][0]=a[p]),m},U1.sidentity=function u(a){return U1.sdiag(U1.rep([a],1))},U1.stranspose=function u(a){var c=[];a.length;var p,m,v;for(p in a)if(a.hasOwnProperty(p)){v=a[p];for(m in v)v.hasOwnProperty(m)&&(typeof c[m]!="object"&&(c[m]=[]),c[m][p]=v[m])}return c},U1.sLUP=function u(a,c){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},U1.sdotMM=function u(a,c){var p=a.length;c.length;var m=U1.stranspose(c),v=m.length,b,w,S,O,q,H,j=Array(p),$;for(S=p-1;S>=0;S--){for($=[],b=a[S],q=v-1;q>=0;q--){H=0,w=m[q];for(O in b)b.hasOwnProperty(O)&&O in w&&(H+=b[O]*w[O]);H&&($[q]=H)}j[S]=$}return j},U1.sdotMV=function u(a,c){var p=a.length,m,v,b,w=Array(p),S;for(v=p-1;v>=0;v--){m=a[v],S=0;for(b in m)m.hasOwnProperty(b)&&c[b]&&(S+=m[b]*c[b]);S&&(w[v]=S)}return w},U1.sdotVM=function u(a,c){var p,m,v,b,w=[];for(p in a)if(a.hasOwnProperty(p)){v=c[p],b=a[p];for(m in v)v.hasOwnProperty(m)&&(w[m]||(w[m]=0),w[m]+=b*v[m])}return w},U1.sdotVV=function u(a,c){var p,m=0;for(p in a)a[p]&&c[p]&&(m+=a[p]*c[p]);return m},U1.sdot=function u(a,c){var p=U1.sdim(a).length,m=U1.sdim(c).length,v=p*1e3+m;switch(v){case 0:return a*c;case 1001:return U1.sdotVV(a,c);case 2001:return U1.sdotMV(a,c);case 1002:return U1.sdotVM(a,c);case 2002:return U1.sdotMM(a,c);default:throw new Error("numeric.sdot not implemented for tensors of order "+p+" and "+m)}},U1.sscatter=function u(a){var c=a[0].length,p,m,v,b=a.length,w=[],S;for(m=c-1;m>=0;--m)if(a[b-1][m]){for(S=w,v=0;v<b-2;v++)p=a[v][m],S[p]||(S[p]=[]),S=S[p];S[a[v][m]]=a[v+1][m]}return w},U1.sgather=function u(a,c,p){typeof c>"u"&&(c=[]),typeof p>"u"&&(p=[]);var m,v,b;m=p.length;for(v in a)if(a.hasOwnProperty(v))if(p[m]=parseInt(v),b=a[v],typeof b=="number"){if(b){if(c.length===0)for(v=m+1;v>=0;--v)c[v]=[];for(v=m;v>=0;--v)c[v].push(p[v]);c[m+1].push(b)}}else u(b,c,p);return p.length>m&&p.pop(),c},U1.cLU=function u(a){var c=a[0],p=a[1],m=a[2],Qe=c.length,v=0,b,w,S,O,q,H;for(b=0;b<Qe;b++)c[b]>v&&(v=c[b]);v++;var j=Array(v),$=Array(v),J=U1.rep([v],1/0),ee=U1.rep([v],-1/0),Me,Ae,re;for(S=0;S<Qe;S++)b=c[S],w=p[S],w<J[b]&&(J[b]=w),w>ee[b]&&(ee[b]=w);for(b=0;b<v-1;b++)ee[b]>ee[b+1]&&(ee[b+1]=ee[b]);for(b=v-1;b>=1;b--)J[b]<J[b-1]&&(J[b-1]=J[b]);var de=0,Te=0;for(b=0;b<v;b++)$[b]=U1.rep([ee[b]-J[b]+1],0),j[b]=U1.rep([b-J[b]],0),de+=b-J[b]+1,Te+=ee[b]-b+1;for(S=0;S<Qe;S++)b=c[S],$[b][p[S]-J[b]]=m[S];for(b=0;b<v-1;b++)for(O=b-J[b],Me=$[b],w=b+1;J[w]<=b&&w<v;w++)if(q=b-J[w],H=ee[b]-b,Ae=$[w],re=Ae[q]/Me[O],re){for(S=1;S<=H;S++)Ae[S+q]-=re*Me[S+O];j[w][b-J[w]]=re}var Me=[],Ae=[],Ce=[],Pe=[],je=[],Ne=[],Qe,Ct,dt;for(Qe=0,Ct=0,b=0;b<v;b++){for(O=J[b],q=ee[b],dt=$[b],w=b;w<=q;w++)dt[w-O]&&(Me[Qe]=b,Ae[Qe]=w,Ce[Qe]=dt[w-O],Qe++);for(dt=j[b],w=O;w<b;w++)dt[w-O]&&(Pe[Ct]=b,je[Ct]=w,Ne[Ct]=dt[w-O],Ct++);Pe[Ct]=b,je[Ct]=b,Ne[Ct]=1,Ct++}return{U:[Me,Ae,Ce],L:[Pe,je,Ne]}},U1.cLUsolve=function u(a,c){var p=a.L,m=a.U,v=U1.clone(c),b=p[0],w=p[1],S=p[2],O=m[0],q=m[1],H=m[2],j=O.length;b.length;var $=v.length,J,ee;for(ee=0,J=0;J<$;J++){for(;w[ee]<J;)v[J]-=S[ee]*v[w[ee]],ee++;ee++}for(ee=j-1,J=$-1;J>=0;J--){for(;q[ee]>J;)v[J]-=H[ee]*v[q[ee]],ee--;v[J]/=H[ee],ee--}return v},U1.cgrid=function u(a,c){typeof a=="number"&&(a=[a,a]);var p=U1.rep(a,-1),m,v,b;if(typeof c!="function")switch(c){case"L":c=function(w,S){return w>=a[0]/2||S<a[1]/2};break;default:c=function(w,S){return!0};break}for(b=0,m=1;m<a[0]-1;m++)for(v=1;v<a[1]-1;v++)c(m,v)&&(p[m][v]=b,b++);return p},U1.cdelsq=function u(a){var c=[[-1,0],[0,-1],[0,1],[1,0]],p=U1.dim(a),m=p[0],v=p[1],b,w,S,O,q,H=[],j=[],$=[];for(b=1;b<m-1;b++)for(w=1;w<v-1;w++)if(!(a[b][w]<0)){for(S=0;S<4;S++)O=b+c[S][0],q=w+c[S][1],!(a[O][q]<0)&&(H.push(a[b][w]),j.push(a[O][q]),$.push(-1));H.push(a[b][w]),j.push(a[b][w]),$.push(4)}return[H,j,$]},U1.cdotMV=function u(a,c){var p,m=a[0],v=a[1],b=a[2],w,S=m.length,O;for(O=0,w=0;w<S;w++)m[w]>O&&(O=m[w]);for(O++,p=U1.rep([O],0),w=0;w<S;w++)p[m[w]]+=b[w]*c[v[w]];return p},U1.Spline=function u(a,c,p,m,v){this.x=a,this.yl=c,this.yr=p,this.kl=m,this.kr=v},U1.Spline.prototype._at=function u(S,c){var p=this.x,m=this.yl,v=this.yr,b=this.kl,w=this.kr,S,O,q,H,j=U1.add,$=U1.sub,J=U1.mul;O=$(J(b[c],p[c+1]-p[c]),$(v[c+1],m[c])),q=j(J(w[c+1],p[c]-p[c+1]),$(v[c+1],m[c])),H=(S-p[c])/(p[c+1]-p[c]);var ee=H*(1-H);return j(j(j(J(1-H,m[c]),J(H,v[c+1])),J(O,ee*(1-H))),J(q,ee*H))},U1.Spline.prototype.at=function u(a){if(typeof a=="number"){var c=this.x,w=c.length,p,m,v,b=Math.floor;for(p=0,m=w-1;m-p>1;)v=b((p+m)/2),c[v]<=a?p=v:m=v;return this._at(a,p)}var w=a.length,S,O=Array(w);for(S=w-1;S!==-1;--S)O[S]=this.at(a[S]);return O},U1.Spline.prototype.diff=function u(){var a=this.x,c=this.yl,p=this.yr,m=this.kl,v=this.kr,b=c.length,w,S,O,q=m,H=v,j=Array(b),$=Array(b),J=U1.add,ee=U1.mul,re=U1.div,de=U1.sub;for(w=b-1;w!==-1;--w)S=a[w+1]-a[w],O=de(p[w+1],c[w]),j[w]=re(J(ee(O,6),ee(m[w],-4*S),ee(v[w+1],-2*S)),S*S),$[w+1]=re(J(ee(O,-6),ee(m[w],2*S),ee(v[w+1],4*S)),S*S);return new U1.Spline(a,q,H,j,$)},U1.Spline.prototype.roots=function u(){function a($0){return $0*$0}var re=[],c=this.x,p=this.yl,m=this.yr,v=this.kl,b=this.kr;typeof p[0]=="number"&&(p=[p],m=[m],v=[v],b=[b]);var w=p.length,S=c.length-1,O,q,H,j,$,J,ee,re=Array(w),de,Te,Me,Ae,Ce,Pe,je,Ne,Qe,Ct,dt,Xt,Gt,Vt,T0,r0,d0=Math.sqrt;for(O=0;O!==w;++O){for(j=p[O],$=m[O],J=v[O],ee=b[O],de=[],q=0;q!==S;q++){for(q>0&&$[q]*j[q]<0&&de.push(c[q]),Qe=c[q+1]-c[q],c[q],Ae=j[q],Ce=$[q+1],Te=J[q]/Qe,Me=ee[q+1]/Qe,Ne=a(Te-Me+3*(Ae-Ce))+12*Me*Ae,Pe=Me+3*Ae+2*Te-3*Ce,je=3*(Me+Te+2*(Ae-Ce)),Ne<=0?(dt=Pe/je,dt>c[q]&&dt<c[q+1]?Ct=[c[q],dt,c[q+1]]:Ct=[c[q],c[q+1]]):(dt=(Pe-d0(Ne))/je,Xt=(Pe+d0(Ne))/je,Ct=[c[q]],dt>c[q]&&dt<c[q+1]&&Ct.push(dt),Xt>c[q]&&Xt<c[q+1]&&Ct.push(Xt),Ct.push(c[q+1])),Vt=Ct[0],dt=this._at(Vt,q),H=0;H<Ct.length-1;H++){if(T0=Ct[H+1],Xt=this._at(T0,q),dt===0){de.push(Vt),Vt=T0,dt=Xt;continue}if(Xt===0||dt*Xt>0){Vt=T0,dt=Xt;continue}for(var Ut=0;r0=(dt*T0-Xt*Vt)/(dt-Xt),!(r0<=Vt||r0>=T0);)if(Gt=this._at(r0,q),Gt*Xt>0)T0=r0,Xt=Gt,Ut===-1&&(dt*=.5),Ut=-1;else if(Gt*dt>0)Vt=r0,dt=Gt,Ut===1&&(Xt*=.5),Ut=1;else break;de.push(r0),Vt=Ct[H+1],dt=this._at(Vt,q)}Xt===0&&de.push(T0)}re[O]=de}return typeof this.yl[0]=="number"?re[0]:re},U1.spline=function u(a,c,p,m){var v=a.length,b=[],w=[],S=[],O,q=U1.sub,H=U1.mul,j=U1.add;for(O=v-2;O>=0;O--)w[O]=a[O+1]-a[O],S[O]=q(c[O+1],c[O]);(typeof p=="string"||typeof m=="string")&&(p=m="periodic");var $=[[],[],[]];switch(typeof p){case"undefined":b[0]=H(3/(w[0]*w[0]),S[0]),$[0].push(0,0),$[1].push(0,1),$[2].push(2/w[0],1/w[0]);break;case"string":b[0]=j(H(3/(w[v-2]*w[v-2]),S[v-2]),H(3/(w[0]*w[0]),S[0])),$[0].push(0,0,0),$[1].push(v-2,0,1),$[2].push(1/w[v-2],2/w[v-2]+2/w[0],1/w[0]);break;default:b[0]=p,$[0].push(0),$[1].push(0),$[2].push(1);break}for(O=1;O<v-1;O++)b[O]=j(H(3/(w[O-1]*w[O-1]),S[O-1]),H(3/(w[O]*w[O]),S[O])),$[0].push(O,O,O),$[1].push(O-1,O,O+1),$[2].push(1/w[O-1],2/w[O-1]+2/w[O],1/w[O]);switch(typeof m){case"undefined":b[v-1]=H(3/(w[v-2]*w[v-2]),S[v-2]),$[0].push(v-1,v-1),$[1].push(v-2,v-1),$[2].push(1/w[v-2],2/w[v-2]);break;case"string":$[1][$[1].length-1]=0;break;default:b[v-1]=m,$[0].push(v-1),$[1].push(v-1),$[2].push(1);break}typeof b[0]!="number"?b=U1.transpose(b):b=[b];var J=Array(b.length);if(typeof p=="string")for(O=J.length-1;O!==-1;--O)J[O]=U1.ccsLUPSolve(U1.ccsLUP(U1.ccsScatter($)),b[O]),J[O][v-1]=J[O][0];else for(O=J.length-1;O!==-1;--O)J[O]=U1.cLUsolve(U1.cLU($),b[O]);return typeof c[0]=="number"?J=J[0]:J=U1.transpose(J),new U1.Spline(a,c,c,J,J)},U1.fftpow2=function u(a,c){var p=a.length;if(p!==1){var m=Math.cos,v=Math.sin,b,w,S=Array(p/2),O=Array(p/2),q=Array(p/2),H=Array(p/2);for(w=p/2,b=p-1;b!==-1;--b)--w,q[w]=a[b],H[w]=c[b],--b,S[w]=a[b],O[w]=c[b];u(S,O),u(q,H),w=p/2;var j,$=-6.283185307179586/p,J,ee;for(b=p-1;b!==-1;--b)--w,w===-1&&(w=p/2-1),j=$*b,J=m(j),ee=v(j),a[b]=S[w]+J*q[w]-ee*H[w],c[b]=O[w]+J*H[w]+ee*q[w]}},U1._ifftpow2=function u(a,c){var p=a.length;if(p!==1){var m=Math.cos,v=Math.sin,b,w,S=Array(p/2),O=Array(p/2),q=Array(p/2),H=Array(p/2);for(w=p/2,b=p-1;b!==-1;--b)--w,q[w]=a[b],H[w]=c[b],--b,S[w]=a[b],O[w]=c[b];u(S,O),u(q,H),w=p/2;var j,$=6.283185307179586/p,J,ee;for(b=p-1;b!==-1;--b)--w,w===-1&&(w=p/2-1),j=$*b,J=m(j),ee=v(j),a[b]=S[w]+J*q[w]-ee*H[w],c[b]=O[w]+J*H[w]+ee*q[w]}},U1.ifftpow2=function u(a,c){U1._ifftpow2(a,c),U1.diveq(a,a.length),U1.diveq(c,c.length)},U1.convpow2=function u(a,c,p,m){U1.fftpow2(a,c),U1.fftpow2(p,m);var v,b=a.length,w,S,O,q;for(v=b-1;v!==-1;--v)w=a[v],O=c[v],S=p[v],q=m[v],a[v]=w*S-O*q,c[v]=w*q+O*S;U1.ifftpow2(a,c)},U1.T.prototype.fft=function u(){var a=this.x,c=this.y,p=a.length,m=Math.log,v=m(2),b=Math.ceil(m(2*p-1)/v),w=Math.pow(2,b),S=U1.rep([w],0),O=U1.rep([w],0),q=Math.cos,H=Math.sin,j,$=-3.141592653589793/p,J,ee=U1.rep([w],0),re=U1.rep([w],0);for(j=0;j<p;j++)ee[j]=a[j];if(typeof c<"u")for(j=0;j<p;j++)re[j]=c[j];for(S[0]=1,j=1;j<=w/2;j++)J=$*j*j,S[j]=q(J),O[j]=H(J),S[w-j]=q(J),O[w-j]=H(J);var de=new U1.T(ee,re),Te=new U1.T(S,O);return de=de.mul(Te),U1.convpow2(de.x,de.y,U1.clone(Te.x),U1.neg(Te.y)),de=de.mul(Te),de.x.length=p,de.y.length=p,de},U1.T.prototype.ifft=function u(){var a=this.x,c=this.y,p=a.length,m=Math.log,v=m(2),b=Math.ceil(m(2*p-1)/v),w=Math.pow(2,b),S=U1.rep([w],0),O=U1.rep([w],0),q=Math.cos,H=Math.sin,j,$=3.141592653589793/p,J,ee=U1.rep([w],0),re=U1.rep([w],0);for(j=0;j<p;j++)ee[j]=a[j];if(typeof c<"u")for(j=0;j<p;j++)re[j]=c[j];for(S[0]=1,j=1;j<=w/2;j++)J=$*j*j,S[j]=q(J),O[j]=H(J),S[w-j]=q(J),O[w-j]=H(J);var de=new U1.T(ee,re),Te=new U1.T(S,O);return de=de.mul(Te),U1.convpow2(de.x,de.y,U1.clone(Te.x),U1.neg(Te.y)),de=de.mul(Te),de.x.length=p,de.y.length=p,de.div(p)},U1.gradient=function u(a,c){var p=c.length,m=a(c);if(isNaN(m))throw new Error("gradient: f(x) is a NaN!");var H=Math.max,v,b=U1.clone(c),w,S,O=Array(p);U1.div,U1.sub;var q,H=Math.max,j=.001,$=Math.abs,J=Math.min,ee,re,de,Te=0,Me,Ae,Ce;for(v=0;v<p;v++)for(var Pe=H(1e-6*m,1e-8);;){if(++Te,Te>20)throw new Error("Numerical gradient fails");if(b[v]=c[v]+Pe,w=a(b),b[v]=c[v]-Pe,S=a(b),b[v]=c[v],isNaN(w)||isNaN(S)){Pe/=16;continue}if(O[v]=(w-S)/(2*Pe),ee=c[v]-Pe,re=c[v],de=c[v]+Pe,Me=(w-m)/Pe,Ae=(m-S)/Pe,Ce=H($(O[v]),$(m),$(w),$(S),$(ee),$(re),$(de),1e-8),q=J(H($(Me-O[v]),$(Ae-O[v]),$(Me-Ae))/Ce,Pe/Ce),q>j)Pe/=16;else break}return O},U1.uncmin=function u(a,c,p,m,v,b,w){var S=U1.gradient;typeof w>"u"&&(w={}),typeof p>"u"&&(p=1e-8),typeof m>"u"&&(m=function(Un){return S(a,Un)}),typeof v>"u"&&(v=1e3),c=U1.clone(c);var O=c.length,q=a(c),H,j;if(isNaN(q))throw new Error("uncmin: f(x0) is a NaN!");var $=Math.max,J=U1.norm2;p=$(p,U1.epsilon);var ee,re,de,Te=w.Hinv||U1.identity(O),Me=U1.dot;U1.inv;var Ae=U1.sub,Ce=U1.add,Pe=U1.tensor,je=U1.div,Ne=U1.mul,Qe=U1.all,Ct=U1.isFinite,dt=U1.neg,Xt=0,Gt,Vt,T0,r0,d0,Ut,$0,Q0="";for(re=m(c);Xt<v;){if(typeof b=="function"&&b(Xt,c,q,re,Te)){Q0="Callback returned true";break}if(!Qe(Ct(re))){Q0="Gradient has Infinity or NaN";break}if(ee=dt(Me(Te,re)),!Qe(Ct(ee))){Q0="Search direction has Infinity or NaN";break}if($0=J(ee),$0<p){Q0="Newton step smaller than tol";break}for(Ut=1,j=Me(re,ee),Vt=c;Xt<v&&!(Ut*$0<p);){if(Gt=Ne(ee,Ut),Vt=Ce(c,Gt),H=a(Vt),H-q>=.1*Ut*j||isNaN(H)){Ut*=.5,++Xt;continue}break}if(Ut*$0<p){Q0="Line search step size smaller than tol";break}if(Xt===v){Q0="maxit reached during line search";break}de=m(Vt),T0=Ae(de,re),d0=Me(T0,Gt),r0=Me(Te,T0),Te=Ae(Ce(Te,Ne((d0+Me(T0,r0))/(d0*d0),Pe(Gt,Gt))),je(Ce(Pe(r0,Gt),Pe(Gt,r0)),d0)),c=Vt,q=H,re=de,++Xt}return{solution:c,f:q,gradient:re,invHessian:Te,iterations:Xt,message:Q0}},U1.Dopri=function u(a,c,p,m,v,b,w){this.x=a,this.y=c,this.f=p,this.ymid=m,this.iterations=v,this.events=w,this.message=b},U1.Dopri.prototype._at=function u(ee,c){function p(Ne){return Ne*Ne}var m=this,v=m.x,b=m.y,w=m.f,S=m.ymid;v.length;var O,q,H,j,$,J,ee,re,de=.5,Te=U1.add,Me=U1.mul,Ae=U1.sub,Ce,Pe,je;return O=v[c],q=v[c+1],j=b[c],$=b[c+1],re=q-O,H=O+de*re,J=S[c],Ce=Ae(w[c],Me(j,1/(O-H)+2/(O-q))),Pe=Ae(w[c+1],Me($,1/(q-H)+2/(q-O))),je=[p(ee-q)*(ee-H)/p(O-q)/(O-H),p(ee-O)*p(ee-q)/p(O-H)/p(q-H),p(ee-O)*(ee-H)/p(q-O)/(q-H),(ee-O)*p(ee-q)*(ee-H)/p(O-q)/(O-H),(ee-q)*p(ee-O)*(ee-H)/p(O-q)/(q-H)],Te(Te(Te(Te(Me(j,je[0]),Me(J,je[1])),Me($,je[2])),Me(Ce,je[3])),Me(Pe,je[4]))},U1.Dopri.prototype.at=function u(a){var c,p,m,v=Math.floor;if(typeof a!="number"){var b=a.length,w=Array(b);for(c=b-1;c!==-1;--c)w[c]=this.at(a[c]);return w}var S=this.x;for(c=0,p=S.length-1;p-c>1;)m=v(.5*(c+p)),S[m]<=a?c=m:p=m;return this._at(a,c)},U1.dopri=function u(a,c,p,m,v,b,w){typeof v>"u"&&(v=1e-6),typeof b>"u"&&(b=1e3);var S=[a],O=[p],q=[m(a,p)],H,j,$,J,ee,re,de=[],Te=1/5,Me=[3/40,9/40],Ae=[44/45,-56/15,32/9],Ce=[19372/6561,-25360/2187,64448/6561,-212/729],Pe=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],je=[35/384,0,500/1113,125/192,-2187/6784,11/84],Ne=[.5*6025192743/30085553152,0,.5*51252292925/65400821598,.5*-2691868925/45128329728,.5*187940372067/1594534317056,.5*-1776094331/19743644256,.5*11237099/235043384],Qe=[1/5,3/10,4/5,8/9,1,1],Ct=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40],dt=0,Xt,Gt,Vt=(c-a)/10,T0=0,r0=U1.add,d0=U1.mul,Ut,$0,Q0=Math.min,Un=Math.abs,b0=U1.norminf,X0=Math.pow,Rt=U1.any,Qt=U1.lt,A0=U1.and;U1.sub;var J0,Pn,dx,Bn=new U1.Dopri(S,O,q,de,-1,"");for(typeof w=="function"&&(J0=w(a,p));a<c&&T0<b;){if(++T0,a+Vt>c&&(Vt=c-a),H=m(a+Qe[0]*Vt,r0(p,d0(Te*Vt,q[dt]))),j=m(a+Qe[1]*Vt,r0(r0(p,d0(Me[0]*Vt,q[dt])),d0(Me[1]*Vt,H))),$=m(a+Qe[2]*Vt,r0(r0(r0(p,d0(Ae[0]*Vt,q[dt])),d0(Ae[1]*Vt,H)),d0(Ae[2]*Vt,j))),J=m(a+Qe[3]*Vt,r0(r0(r0(r0(p,d0(Ce[0]*Vt,q[dt])),d0(Ce[1]*Vt,H)),d0(Ce[2]*Vt,j)),d0(Ce[3]*Vt,$))),ee=m(a+Qe[4]*Vt,r0(r0(r0(r0(r0(p,d0(Pe[0]*Vt,q[dt])),d0(Pe[1]*Vt,H)),d0(Pe[2]*Vt,j)),d0(Pe[3]*Vt,$)),d0(Pe[4]*Vt,J))),Ut=r0(r0(r0(r0(r0(p,d0(q[dt],Vt*je[0])),d0(j,Vt*je[2])),d0($,Vt*je[3])),d0(J,Vt*je[4])),d0(ee,Vt*je[5])),re=m(a+Vt,Ut),Xt=r0(r0(r0(r0(r0(d0(q[dt],Vt*Ct[0]),d0(j,Vt*Ct[2])),d0($,Vt*Ct[3])),d0(J,Vt*Ct[4])),d0(ee,Vt*Ct[5])),d0(re,Vt*Ct[6])),typeof Xt=="number"?$0=Un(Xt):$0=b0(Xt),$0>v){if(Vt=.2*Vt*X0(v/$0,.25),a+Vt===a){Bn.msg="Step size became too small";break}continue}if(de[dt]=r0(r0(r0(r0(r0(r0(p,d0(q[dt],Vt*Ne[0])),d0(j,Vt*Ne[2])),d0($,Vt*Ne[3])),d0(J,Vt*Ne[4])),d0(ee,Vt*Ne[5])),d0(re,Vt*Ne[6])),++dt,S[dt]=a+Vt,O[dt]=Ut,q[dt]=re,typeof w=="function"){var Wn,gx=a,Jx=a+.5*Vt,er;if(Pn=w(Jx,de[dt-1]),dx=A0(Qt(J0,0),Qt(0,Pn)),Rt(dx)||(gx=Jx,Jx=a+Vt,J0=Pn,Pn=w(Jx,Ut),dx=A0(Qt(J0,0),Qt(0,Pn))),Rt(dx)){for(var Cr,Rr,xi=0,Nr=1,rr=1;;){if(typeof J0=="number")er=(rr*Pn*gx-Nr*J0*Jx)/(rr*Pn-Nr*J0);else for(er=Jx,Gt=J0.length-1;Gt!==-1;--Gt)J0[Gt]<0&&Pn[Gt]>0&&(er=Q0(er,(rr*Pn[Gt]*gx-Nr*J0[Gt]*Jx)/(rr*Pn[Gt]-Nr*J0[Gt])));if(er<=gx||er>=Jx)break;Wn=Bn._at(er,dt-1),Rr=w(er,Wn),Cr=A0(Qt(J0,0),Qt(0,Rr)),Rt(Cr)?(Jx=er,Pn=Rr,dx=Cr,rr=1,xi===-1?Nr*=.5:Nr=1,xi=-1):(gx=er,J0=Rr,Nr=1,xi===1?rr*=.5:rr=1,xi=1)}return Ut=Bn._at(.5*(a+er),dt-1),Bn.f[dt]=m(er,Wn),Bn.x[dt]=er,Bn.y[dt]=Wn,Bn.ymid[dt-1]=Ut,Bn.events=dx,Bn.iterations=T0,Bn}}a+=Vt,p=Ut,J0=Pn,Vt=Q0(.8*Vt*X0(v/$0,.25),4*Vt)}return Bn.iterations=T0,Bn},U1.LU=function(u,a){a=a||!1;var c=Math.abs,p,m,v,b,w,S,O,q,H,j=u.length,$=j-1,J=new Array(j);for(a||(u=U1.clone(u)),v=0;v<j;++v){for(O=v,S=u[v],H=c(S[v]),m=v+1;m<j;++m)b=c(u[m][v]),H<b&&(H=b,O=m);for(J[v]=O,O!=v&&(u[v]=u[O],u[O]=S,S=u[v]),w=S[v],p=v+1;p<j;++p)u[p][v]/=w;for(p=v+1;p<j;++p){for(q=u[p],m=v+1;m<$;++m)q[m]-=q[v]*S[m],++m,q[m]-=q[v]*S[m];m===$&&(q[m]-=q[v]*S[m])}}return{LU:u,P:J}},U1.LUsolve=function u(a,c){var p,m,v=a.LU,b=v.length,w=U1.clone(c),S=a.P,O,q,H;for(p=b-1;p!==-1;--p)w[p]=c[p];for(p=0;p<b;++p)for(O=S[p],S[p]!==p&&(H=w[p],w[p]=w[O],w[O]=H),q=v[p],m=0;m<p;++m)w[p]-=w[m]*q[m];for(p=b-1;p>=0;--p){for(q=v[p],m=p+1;m<b;++m)w[p]-=w[m]*q[m];w[p]/=q[p]}return w},U1.solve=function u(a,c,p){return U1.LUsolve(U1.LU(a,p),c)},U1.echelonize=function u(a){var c=U1.dim(a),p=c[0],m=c[1],v=U1.identity(p),b=Array(p),w,S,O,q,H,j,$,J,ee=Math.abs,re=U1.diveq;for(a=U1.clone(a),w=0;w<p;++w){for(O=0,H=a[w],j=v[w],S=1;S<m;++S)ee(H[O])<ee(H[S])&&(O=S);for(b[w]=O,re(j,H[O]),re(H,H[O]),S=0;S<p;++S)if(S!==w){for($=a[S],J=$[O],q=m-1;q!==-1;--q)$[q]-=H[q]*J;for($=v[S],q=p-1;q!==-1;--q)$[q]-=j[q]*J}}return{I:v,A:a,P:b}},U1.__solveLP=function u(a,c,p,m,v,b,w){var S=U1.sum;U1.log;var O=U1.mul,q=U1.sub,H=U1.dot,j=U1.div,$=U1.add,J=a.length,ee=p.length,re,de=!1,Te=0,Me=1;U1.transpose(c),U1.svd;var Ae=U1.transpose;U1.leq;var Ce=Math.sqrt,Pe=Math.abs;U1.muleq,U1.norminf,U1.any;var je=Math.min,Ne=U1.all,Qe=U1.gt,Ct=Array(J),dt=Array(ee);U1.rep([ee],1);var Xt,Gt=U1.solve,Vt=q(p,H(c,b)),T0,r0=H(a,a),d0;for(T0=Te;T0<v;++T0){var Ut,$0;for(Ut=ee-1;Ut!==-1;--Ut)dt[Ut]=j(c[Ut],Vt[Ut]);var Q0=Ae(dt);for(Ut=J-1;Ut!==-1;--Ut)Ct[Ut]=S(Q0[Ut]);Me=.25*Pe(r0/H(a,Ct));var Un=100*Ce(r0/H(Ct,Ct));for((!isFinite(Me)||Me>Un)&&(Me=Un),d0=$(a,O(Me,Ct)),Xt=H(Q0,dt),Ut=J-1;Ut!==-1;--Ut)Xt[Ut][Ut]+=1;$0=Gt(Xt,j(d0,Me),!0);var b0=j(Vt,H(c,$0)),X0=1;for(Ut=ee-1;Ut!==-1;--Ut)b0[Ut]<0&&(X0=je(X0,-.999*b0[Ut]));if(re=q(b,O($0,X0)),Vt=q(p,H(c,re)),!Ne(Qe(Vt,0)))return{solution:b,message:"",iterations:T0};if(b=re,Me<m)return{solution:re,message:"",iterations:T0};if(w){var Rt=H(a,d0),Qt=H(c,d0);for(de=!0,Ut=ee-1;Ut!==-1;--Ut)if(Rt*Qt[Ut]<0){de=!1;break}}else b[J-1]>=0?de=!1:de=!0;if(de)return{solution:re,message:"Unbounded",iterations:T0}}return{solution:b,message:"maximum iteration count exceeded",iterations:T0}},U1._solveLP=function u(a,c,p,m,v){var b=a.length,w=p.length,J;U1.sum,U1.log,U1.mul;var S=U1.sub,O=U1.dot;U1.div,U1.add;var q=U1.rep([b],0).concat([1]),H=U1.rep([w,1],-1),j=U1.blockMatrix([[c,H]]),$=p,J=U1.rep([b],0).concat(Math.max(0,U1.sup(U1.neg(p)))+1),ee=U1.__solveLP(q,j,$,m,v,J,!1),re=U1.clone(ee.solution);re.length=b;var de=U1.inf(S(p,O(c,re)));if(de<0)return{solution:NaN,message:"Infeasible",iterations:ee.iterations};var Te=U1.__solveLP(a,c,p,m,v-ee.iterations,re,!0);return Te.iterations+=ee.iterations,Te},U1.solveLP=function u(a,c,p,m,v,b,w){if(typeof w>"u"&&(w=1e3),typeof b>"u"&&(b=U1.epsilon),typeof m>"u")return U1._solveLP(a,c,p,b,w);var S=m.length,O=m[0].length,q=c.length,H=U1.echelonize(m),j=U1.rep([O],0),$=H.P,J=[],ee;for(ee=$.length-1;ee!==-1;--ee)j[$[ee]]=1;for(ee=O-1;ee!==-1;--ee)j[ee]===0&&J.push(ee);var re=U1.getRange,de=U1.linspace(0,S-1),Te=U1.linspace(0,q-1),Me=re(m,de,J),Ae=re(c,Te,$),Ce=re(c,Te,J),Pe=U1.dot,je=U1.sub,Ne=Pe(Ae,H.I),Qe=je(Ce,Pe(Ne,Me)),Ct=je(p,Pe(Ne,v)),dt=Array($.length),Xt=Array(J.length);for(ee=$.length-1;ee!==-1;--ee)dt[ee]=a[$[ee]];for(ee=J.length-1;ee!==-1;--ee)Xt[ee]=a[J[ee]];var Gt=je(Xt,Pe(dt,Pe(H.I,Me))),Vt=U1._solveLP(Gt,Qe,Ct,b,w),T0=Vt.solution;if(T0!==T0)return Vt;var r0=Pe(H.I,je(v,Pe(Me,T0))),d0=Array(a.length);for(ee=$.length-1;ee!==-1;--ee)d0[$[ee]]=r0[ee];for(ee=J.length-1;ee!==-1;--ee)d0[J[ee]]=T0[ee];return{solution:d0,message:Vt.message,iterations:Vt.iterations}},U1.MPStoLP=function u(a){a instanceof String&&a.split(`
`);var c=0,p=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],m=a.length,v,b,w,S=0,O={},q=[],H=0,j={},$=0,J,ee=[],re=[],de=[];function Te(je){throw new Error("MPStoLP: "+je+`
Line `+v+": "+a[v]+`
Current state: `+p[c]+`
`)}for(v=0;v<m;++v){w=a[v];var Me=w.match(/\S*/g),Ae=[];for(b=0;b<Me.length;++b)Me[b]!==""&&Ae.push(Me[b]);if(Ae.length!==0){for(b=0;b<p.length&&w.substr(0,p[b].length)!==p[b];++b);if(b<p.length){if(c=b,b===1&&(J=Ae[1]),b===6)return{name:J,c:ee,A:U1.transpose(re),b:de,rows:O,vars:j};continue}switch(c){case 0:case 1:Te("Unexpected line");case 2:switch(Ae[0]){case"N":S===0?S=Ae[1]:Te("Two or more N rows");break;case"L":O[Ae[1]]=H,q[H]=1,de[H]=0,++H;break;case"G":O[Ae[1]]=H,q[H]=-1,de[H]=0,++H;break;case"E":O[Ae[1]]=H,q[H]=0,de[H]=0,++H;break;default:Te("Parse error "+U1.prettyPrint(Ae))}break;case 3:j.hasOwnProperty(Ae[0])||(j[Ae[0]]=$,ee[$]=0,re[$]=U1.rep([H],0),++$);var Ce=j[Ae[0]];for(b=1;b<Ae.length;b+=2){if(Ae[b]===S){ee[Ce]=parseFloat(Ae[b+1]);continue}var Pe=O[Ae[b]];re[Ce][Pe]=(q[Pe]<0?-1:1)*parseFloat(Ae[b+1])}break;case 4:for(b=1;b<Ae.length;b+=2)de[O[Ae[b]]]=(q[O[Ae[b]]]<0?-1:1)*parseFloat(Ae[b+1]);break;case 5:break;case 6:Te("Internal error")}}}Te("Reached end of file without ENDATA")},U1.seedrandom={pow:Math.pow,random:Math.random},function(u,a,c,p,m,v,b){a.seedrandom=function(H,j){var $=[],J;return H=O(S(j?[H,u]:arguments.length?H:[new Date().getTime(),u,window],3),$),J=new w($),O(J.S,u),a.random=function(){for(var ee=J.g(p),re=b,de=0;ee<m;)ee=(ee+de)*c,re*=c,de=J.g(1);for(;ee>=v;)ee/=2,re/=2,de>>>=1;return(ee+de)/re},H};function w(H){var j,$,J=this,ee=H.length,re=0,de=J.i=J.j=J.m=0;for(J.S=[],J.c=[],ee||(H=[ee++]);re<c;)J.S[re]=re++;for(re=0;re<c;re++)j=J.S[re],de=q(de+j+H[re%ee]),$=J.S[de],J.S[re]=$,J.S[de]=j;J.g=function(Te){var Me=J.S,Ae=q(J.i+1),Ce=Me[Ae],Pe=q(J.j+Ce),je=Me[Pe];Me[Ae]=je,Me[Pe]=Ce;for(var Ne=Me[q(Ce+je)];--Te;)Ae=q(Ae+1),Ce=Me[Ae],Pe=q(Pe+Ce),je=Me[Pe],Me[Ae]=je,Me[Pe]=Ce,Ne=Ne*c+Me[q(Ce+je)];return J.i=Ae,J.j=Pe,Ne},J.g(c)}function S(H,j,$,J,ee){if($=[],ee=typeof H,j&&ee=="object"){for(J in H)if(J.indexOf("S")<5)try{$.push(S(H[J],j-1))}catch{}}return $.length?$:H+(ee!="string"?"\0":"")}function O(H,j,$,J){for(H+="",$=0,J=0;J<H.length;J++)j[q(J)]=q(($^=j[q(J)]*19)+H.charCodeAt(J));H="";for(J in j)H+=String.fromCharCode(j[J]);return H}function q(H){return H&c-1}b=a.pow(c,p),m=a.pow(2,m),v=m*2,O(a.random(),u)}([],U1.seedrandom,256,6,52),function(u){function a(S){if(typeof S!="object")return S;var O=[],q,H=S.length;for(q=0;q<H;q++)O[q+1]=a(S[q]);return O}function c(S){if(typeof S!="object")return S;var O=[],q,H=S.length;for(q=1;q<H;q++)O[q-1]=c(S[q]);return O}function p(S,O,q){var H,j,$,J,ee;for($=1;$<=q;$=$+1){for(S[$][$]=1/S[$][$],ee=-S[$][$],H=1;H<$;H=H+1)S[H][$]=ee*S[H][$];if(J=$+1,q<J)break;for(j=J;j<=q;j=j+1)for(ee=S[$][j],S[$][j]=0,H=1;H<=$;H=H+1)S[H][j]=S[H][j]+ee*S[H][$]}}function m(S,O,q,H){var j,$,J,ee;for($=1;$<=q;$=$+1){for(ee=0,j=1;j<$;j=j+1)ee=ee+S[j][$]*H[j];H[$]=(H[$]-ee)/S[$][$]}for(J=1;J<=q;J=J+1)for($=q+1-J,H[$]=H[$]/S[$][$],ee=-H[$],j=1;j<$;j=j+1)H[j]=H[j]+ee*S[j][$]}function v(S,O,q,H){var j,$,J,ee,re,de;for($=1;$<=q;$=$+1){if(H[1]=$,de=0,J=$-1,J<1){if(de=S[$][$]-de,de<=0)break;S[$][$]=Math.sqrt(de)}else{for(ee=1;ee<=J;ee=ee+1){for(re=S[ee][$],j=1;j<ee;j=j+1)re=re-S[j][$]*S[j][ee];re=re/S[ee][ee],S[ee][$]=re,de=de+re*re}if(de=S[$][$]-de,de<=0)break;S[$][$]=Math.sqrt(de)}H[1]=0}}function b(S,O,q,H,j,$,J,ee,re,de,Te,Me,Ae,Ce,Pe,je){var Ne,Qe,Ct,dt,Xt,Gt,Vt,T0,r0,d0,Ut,$0,Q0,Un,b0,X0,Rt,Qt,A0,J0,Pn,dx,Bn,Wn,gx,Jx,er;Q0=Math.min(H,de),Ct=2*H+Q0*(Q0+5)/2+2*de+1,Wn=1e-60;do Wn=Wn+Wn,gx=1+.1*Wn,Jx=1+.2*Wn;while(gx<=1||Jx<=1);for(Ne=1;Ne<=H;Ne=Ne+1)Pe[Ne]=O[Ne];for(Ne=H+1;Ne<=Ct;Ne=Ne+1)Pe[Ne]=0;for(Ne=1;Ne<=de;Ne=Ne+1)Me[Ne]=0;if(Xt=[],je[1]===0){if(v(S,q,H,Xt),Xt[1]!==0){je[1]=2;return}m(S,q,H,O),p(S,q,H)}else{for(Qe=1;Qe<=H;Qe=Qe+1)for(j[Qe]=0,Ne=1;Ne<=Qe;Ne=Ne+1)j[Qe]=j[Qe]+S[Ne][Qe]*O[Ne];for(Qe=1;Qe<=H;Qe=Qe+1)for(O[Qe]=0,Ne=Qe;Ne<=H;Ne=Ne+1)O[Qe]=O[Qe]+S[Qe][Ne]*j[Ne]}for($[1]=0,Qe=1;Qe<=H;Qe=Qe+1)for(j[Qe]=O[Qe],$[1]=$[1]+Pe[Qe]*j[Qe],Pe[Qe]=0,Ne=Qe+1;Ne<=H;Ne=Ne+1)S[Ne][Qe]=0;for($[1]=-$[1]/2,je[1]=0,Vt=H,T0=Vt+H,Ut=T0+Q0,r0=Ut+Q0+1,d0=r0+Q0*(Q0+1)/2,Un=d0+de,Ne=1;Ne<=de;Ne=Ne+1){for(X0=0,Qe=1;Qe<=H;Qe=Qe+1)X0=X0+J[Qe][Ne]*J[Qe][Ne];Pe[Un+Ne]=Math.sqrt(X0)}Ae=0,Ce[1]=0,Ce[2]=0;function Cr(){for(Ce[1]=Ce[1]+1,Ct=d0,Ne=1;Ne<=de;Ne=Ne+1){for(Ct=Ct+1,X0=-ee[Ne],Qe=1;Qe<=H;Qe=Qe+1)X0=X0+J[Qe][Ne]*j[Qe];if(Math.abs(X0)<Wn&&(X0=0),Ne>Te)Pe[Ct]=X0;else if(Pe[Ct]=-Math.abs(X0),X0>0){for(Qe=1;Qe<=H;Qe=Qe+1)J[Qe][Ne]=-J[Qe][Ne];ee[Ne]=-ee[Ne]}}for(Ne=1;Ne<=Ae;Ne=Ne+1)Pe[d0+Me[Ne]]=0;for($0=0,b0=0,Ne=1;Ne<=de;Ne=Ne+1)Pe[d0+Ne]<b0*Pe[Un+Ne]&&($0=Ne,b0=Pe[d0+Ne]/Pe[Un+Ne]);return $0===0?999:0}function Rr(){for(Ne=1;Ne<=H;Ne=Ne+1){for(X0=0,Qe=1;Qe<=H;Qe=Qe+1)X0=X0+S[Qe][Ne]*J[Qe][$0];Pe[Ne]=X0}for(dt=Vt,Ne=1;Ne<=H;Ne=Ne+1)Pe[dt+Ne]=0;for(Qe=Ae+1;Qe<=H;Qe=Qe+1)for(Ne=1;Ne<=H;Ne=Ne+1)Pe[dt+Ne]=Pe[dt+Ne]+S[Ne][Qe]*Pe[Qe];for(dx=!0,Ne=Ae;Ne>=1;Ne=Ne-1){for(X0=Pe[Ne],Ct=r0+Ne*(Ne+3)/2,dt=Ct-Ne,Qe=Ne+1;Qe<=Ae;Qe=Qe+1)X0=X0-Pe[Ct]*Pe[T0+Qe],Ct=Ct+Qe;if(X0=X0/Pe[dt],Pe[T0+Ne]=X0,Me[Ne]<Te||X0<0)break;dx=!1,Gt=Ne}if(!dx)for(Rt=Pe[Ut+Gt]/Pe[T0+Gt],Ne=1;Ne<=Ae&&!(Me[Ne]<Te||Pe[T0+Ne]<0);Ne=Ne+1)b0=Pe[Ut+Ne]/Pe[T0+Ne],b0<Rt&&(Rt=b0,Gt=Ne);for(X0=0,Ne=Vt+1;Ne<=Vt+H;Ne=Ne+1)X0=X0+Pe[Ne]*Pe[Ne];if(Math.abs(X0)<=Wn){if(dx)return je[1]=1,999;for(Ne=1;Ne<=Ae;Ne=Ne+1)Pe[Ut+Ne]=Pe[Ut+Ne]-Rt*Pe[T0+Ne];return Pe[Ut+Ae+1]=Pe[Ut+Ae+1]+Rt,700}else{for(X0=0,Ne=1;Ne<=H;Ne=Ne+1)X0=X0+Pe[Vt+Ne]*J[Ne][$0];for(Qt=-Pe[d0+$0]/X0,Bn=!0,dx||Rt<Qt&&(Qt=Rt,Bn=!1),Ne=1;Ne<=H;Ne=Ne+1)j[Ne]=j[Ne]+Qt*Pe[Vt+Ne],Math.abs(j[Ne])<Wn&&(j[Ne]=0);for($[1]=$[1]+Qt*X0*(Qt/2+Pe[Ut+Ae+1]),Ne=1;Ne<=Ae;Ne=Ne+1)Pe[Ut+Ne]=Pe[Ut+Ne]-Qt*Pe[T0+Ne];if(Pe[Ut+Ae+1]=Pe[Ut+Ae+1]+Qt,Bn){for(Ae=Ae+1,Me[Ae]=$0,Ct=r0+(Ae-1)*Ae/2+1,Ne=1;Ne<=Ae-1;Ne=Ne+1)Pe[Ct]=Pe[Ne],Ct=Ct+1;if(Ae===H)Pe[Ct]=Pe[H];else{for(Ne=H;Ne>=Ae+1&&!(Pe[Ne]===0||(A0=Math.max(Math.abs(Pe[Ne-1]),Math.abs(Pe[Ne])),J0=Math.min(Math.abs(Pe[Ne-1]),Math.abs(Pe[Ne])),Pe[Ne-1]>=0?b0=Math.abs(A0*Math.sqrt(1+J0*J0/(A0*A0))):b0=-Math.abs(A0*Math.sqrt(1+J0*J0/(A0*A0))),A0=Pe[Ne-1]/b0,J0=Pe[Ne]/b0,A0===1));Ne=Ne-1)if(A0===0)for(Pe[Ne-1]=J0*b0,Qe=1;Qe<=H;Qe=Qe+1)b0=S[Qe][Ne-1],S[Qe][Ne-1]=S[Qe][Ne],S[Qe][Ne]=b0;else for(Pe[Ne-1]=b0,Pn=J0/(1+A0),Qe=1;Qe<=H;Qe=Qe+1)b0=A0*S[Qe][Ne-1]+J0*S[Qe][Ne],S[Qe][Ne]=Pn*(S[Qe][Ne-1]+b0)-S[Qe][Ne],S[Qe][Ne-1]=b0;Pe[Ct]=Pe[Ae]}}else{for(X0=-ee[$0],Qe=1;Qe<=H;Qe=Qe+1)X0=X0+j[Qe]*J[Qe][$0];if($0>Te)Pe[d0+$0]=X0;else if(Pe[d0+$0]=-Math.abs(X0),X0>0){for(Qe=1;Qe<=H;Qe=Qe+1)J[Qe][$0]=-J[Qe][$0];ee[$0]=-ee[$0]}return 700}}return 0}function xi(){if(Ct=r0+Gt*(Gt+1)/2+1,dt=Ct+Gt,Pe[dt]===0||(A0=Math.max(Math.abs(Pe[dt-1]),Math.abs(Pe[dt])),J0=Math.min(Math.abs(Pe[dt-1]),Math.abs(Pe[dt])),Pe[dt-1]>=0?b0=Math.abs(A0*Math.sqrt(1+J0*J0/(A0*A0))):b0=-Math.abs(A0*Math.sqrt(1+J0*J0/(A0*A0))),A0=Pe[dt-1]/b0,J0=Pe[dt]/b0,A0===1))return 798;if(A0===0){for(Ne=Gt+1;Ne<=Ae;Ne=Ne+1)b0=Pe[dt-1],Pe[dt-1]=Pe[dt],Pe[dt]=b0,dt=dt+Ne;for(Ne=1;Ne<=H;Ne=Ne+1)b0=S[Ne][Gt],S[Ne][Gt]=S[Ne][Gt+1],S[Ne][Gt+1]=b0}else{for(Pn=J0/(1+A0),Ne=Gt+1;Ne<=Ae;Ne=Ne+1)b0=A0*Pe[dt-1]+J0*Pe[dt],Pe[dt]=Pn*(Pe[dt-1]+b0)-Pe[dt],Pe[dt-1]=b0,dt=dt+Ne;for(Ne=1;Ne<=H;Ne=Ne+1)b0=A0*S[Ne][Gt]+J0*S[Ne][Gt+1],S[Ne][Gt+1]=Pn*(S[Ne][Gt]+b0)-S[Ne][Gt+1],S[Ne][Gt]=b0}return 0}function Nr(){for(dt=Ct-Gt,Ne=1;Ne<=Gt;Ne=Ne+1)Pe[dt]=Pe[Ct],Ct=Ct+1,dt=dt+1;return Pe[Ut+Gt]=Pe[Ut+Gt+1],Me[Gt]=Me[Gt+1],Gt=Gt+1,Gt<Ae?797:0}function rr(){return Pe[Ut+Ae]=Pe[Ut+Ae+1],Pe[Ut+Ae+1]=0,Me[Ae]=0,Ae=Ae-1,Ce[2]=Ce[2]+1,0}for(er=0;;){if(er=Cr(),er===999)return;for(;er=Rr(),er!==0;){if(er===999)return;if(er===700)if(Gt===Ae)rr();else{for(;xi(),er=Nr(),er===797;);rr()}}}}function w(S,O,q,H,j,$){S=a(S),O=a(O),q=a(q);var J,ee,re,de,Te,Me=[],Ae=[],Ce=[],Pe=[],je=[],Ne;if(j=j||0,$=$?a($):[void 0,0],H=H?a(H):[],ee=S.length-1,re=q[1].length-1,!H)for(J=1;J<=re;J=J+1)H[J]=0;for(J=1;J<=re;J=J+1)Ae[J]=0;for(de=0,Te=Math.min(ee,re),J=1;J<=ee;J=J+1)Ce[J]=0;for(Me[1]=0,J=1;J<=2*ee+Te*(Te+5)/2+2*re+1;J=J+1)Pe[J]=0;for(J=1;J<=2;J=J+1)je[J]=0;return b(S,O,ee,ee,Ce,Me,q,H,ee,re,j,Ae,de,je,Pe,$),Ne="",$[1]===1&&(Ne="constraints are inconsistent, no solution!"),$[1]===2&&(Ne="matrix D in quadratic function is not positive definite!"),{solution:c(Ce),value:c(Me),unconstrained_solution:c(O),iterations:c(je),iact:c(Ae),message:Ne}}u.solveQP=w}(U1),U1.svd=function u(a){var c,p=U1.epsilon,m=1e-64/p,v=50,b=0,w=0,S=0,O=0,q=0,H=U1.clone(a),j=H.length,$=H[0].length;if(j<$)throw"Need more rows than columns";var J=new Array($),ee=new Array($);for(w=0;w<$;w++)J[w]=ee[w]=0;var re=U1.rep([$,$],0);function de(Xt,Gt){return Xt=Math.abs(Xt),Gt=Math.abs(Gt),Xt>Gt?Xt*Math.sqrt(1+Gt*Gt/Xt/Xt):Gt==0?Xt:Gt*Math.sqrt(1+Xt*Xt/Gt/Gt)}var Te=0,Me=0,Ae=0,Ce=0,Pe=0,je=0,Ne=0;for(w=0;w<$;w++){for(J[w]=Me,Ne=0,q=w+1,S=w;S<j;S++)Ne+=H[S][w]*H[S][w];if(Ne<=m)Me=0;else for(Te=H[w][w],Me=Math.sqrt(Ne),Te>=0&&(Me=-Me),Ae=Te*Me-Ne,H[w][w]=Te-Me,S=q;S<$;S++){for(Ne=0,O=w;O<j;O++)Ne+=H[O][w]*H[O][S];for(Te=Ne/Ae,O=w;O<j;O++)H[O][S]+=Te*H[O][w]}for(ee[w]=Me,Ne=0,S=q;S<$;S++)Ne=Ne+H[w][S]*H[w][S];if(Ne<=m)Me=0;else{for(Te=H[w][w+1],Me=Math.sqrt(Ne),Te>=0&&(Me=-Me),Ae=Te*Me-Ne,H[w][w+1]=Te-Me,S=q;S<$;S++)J[S]=H[w][S]/Ae;for(S=q;S<j;S++){for(Ne=0,O=q;O<$;O++)Ne+=H[S][O]*H[w][O];for(O=q;O<$;O++)H[S][O]+=Ne*J[O]}}Pe=Math.abs(ee[w])+Math.abs(J[w]),Pe>Ce&&(Ce=Pe)}for(w=$-1;w!=-1;w+=-1){if(Me!=0){for(Ae=Me*H[w][w+1],S=q;S<$;S++)re[S][w]=H[w][S]/Ae;for(S=q;S<$;S++){for(Ne=0,O=q;O<$;O++)Ne+=H[w][O]*re[O][S];for(O=q;O<$;O++)re[O][S]+=Ne*re[O][w]}}for(S=q;S<$;S++)re[w][S]=0,re[S][w]=0;re[w][w]=1,Me=J[w],q=w}for(w=$-1;w!=-1;w+=-1){for(q=w+1,Me=ee[w],S=q;S<$;S++)H[w][S]=0;if(Me!=0){for(Ae=H[w][w]*Me,S=q;S<$;S++){for(Ne=0,O=q;O<j;O++)Ne+=H[O][w]*H[O][S];for(Te=Ne/Ae,O=w;O<j;O++)H[O][S]+=Te*H[O][w]}for(S=w;S<j;S++)H[S][w]=H[S][w]/Me}else for(S=w;S<j;S++)H[S][w]=0;H[w][w]+=1}for(p=p*Ce,O=$-1;O!=-1;O+=-1)for(var Qe=0;Qe<v;Qe++){var Ct=!1;for(q=O;q!=-1;q+=-1){if(Math.abs(J[q])<=p){Ct=!0;break}if(Math.abs(ee[q-1])<=p)break}if(!Ct){b=0,Ne=1;var dt=q-1;for(w=q;w<O+1&&(Te=Ne*J[w],J[w]=b*J[w],!(Math.abs(Te)<=p));w++)for(Me=ee[w],Ae=de(Te,Me),ee[w]=Ae,b=Me/Ae,Ne=-Te/Ae,S=0;S<j;S++)Pe=H[S][dt],je=H[S][w],H[S][dt]=Pe*b+je*Ne,H[S][w]=-Pe*Ne+je*b}if(je=ee[O],q==O){if(je<0)for(ee[O]=-je,S=0;S<$;S++)re[S][O]=-re[S][O];break}if(Qe>=v-1)throw"Error: no convergence.";for(Ce=ee[q],Pe=ee[O-1],Me=J[O-1],Ae=J[O],Te=((Pe-je)*(Pe+je)+(Me-Ae)*(Me+Ae))/(2*Ae*Pe),Me=de(Te,1),Te<0?Te=((Ce-je)*(Ce+je)+Ae*(Pe/(Te-Me)-Ae))/Ce:Te=((Ce-je)*(Ce+je)+Ae*(Pe/(Te+Me)-Ae))/Ce,b=1,Ne=1,w=q+1;w<O+1;w++){for(Me=J[w],Pe=ee[w],Ae=Ne*Me,Me=b*Me,je=de(Te,Ae),J[w-1]=je,b=Te/je,Ne=Ae/je,Te=Ce*b+Me*Ne,Me=-Ce*Ne+Me*b,Ae=Pe*Ne,Pe=Pe*b,S=0;S<$;S++)Ce=re[S][w-1],je=re[S][w],re[S][w-1]=Ce*b+je*Ne,re[S][w]=-Ce*Ne+je*b;for(je=de(Te,Ae),ee[w-1]=je,b=Te/je,Ne=Ae/je,Te=b*Me+Ne*Pe,Ce=-Ne*Me+b*Pe,S=0;S<j;S++)Pe=H[S][w-1],je=H[S][w],H[S][w-1]=Pe*b+je*Ne,H[S][w]=-Pe*Ne+je*b}J[q]=0,J[O]=Te,ee[O]=Ce}for(w=0;w<ee.length;w++)ee[w]<p&&(ee[w]=0);for(w=0;w<$;w++)for(S=w-1;S>=0;S--)if(ee[S]<ee[w]){for(b=ee[S],ee[S]=ee[w],ee[w]=b,O=0;O<H.length;O++)c=H[O][w],H[O][w]=H[O][S],H[O][S]=c;for(O=0;O<re.length;O++)c=re[O][w],re[O][w]=re[O][S],re[O][S]=c;w=S}return{U:H,S:ee,V:re}}})(wf);class wO{constructor(){this.bodyTracks=[],this.poseFilters=[],this.angle=.08333333333333333*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.poseScore=.6,this.alignScore=.9,this.alignVisibility=.9,this.skipCount=2,this.skipMax=2}async process(a,c){var p,m;if(this.bodyTracks.length<1&&this.skipCount<this.skipMax)return this.skipCount++,[];this.skipCount=0;const v=s2(()=>{const j=IA(Ie(a,3),"float32"),$=Oq(ES(j,255*.5),1);return O3($,0)}),[b,w]=[v.shape[1],v.shape[2]];if(this.bodyTracks.length===0){const j=await((p=this.bodyDetector)==null?void 0:p.process(v))||[];this.bodyTracks=j.map($=>({center:$.points[0],top:$.points[1]})),this.bodyTracks.forEach(()=>this.poseFilters.push(new Lb))}const S=this.bodyTracks.length>0?await((m=this.poseDetector)==null?void 0:m.process(v,this.bodyTracks))||[]:[];S.forEach((j,$)=>{var J;if(c!==void 0){const ee=w/b,re=j.top[0]-j.center[0],de=(j.top[1]-j.center[1])/ee,Te=Math.sqrt(re*re+de*de)*2*(1+ee)*.5;S[$]=this.poseFilters[$].filter(j,c,1/Te)}(J=this.poseAligner)==null||J.alignPoints(S[$].keypoints)}),v.dispose();let O=[],q=[],H=[];for(let j=0;j<this.bodyTracks.length;j++){const $={center:[this.bodyTracks[j].center[0]*w,this.bodyTracks[j].center[1]*b],top:[this.bodyTracks[j].top[0]*w,this.bodyTracks[j].top[1]*b]};let J={center:[S[j].center[0]*w,S[j].center[1]*b],top:[S[j].top[0]*w,S[j].top[1]*b]};const ee=[$,J].map(re=>{const{center:de,top:Te}=re,Me=[Te[0]-de[0],Te[1]-de[1]],Ae=Math.sqrt(Me[0]*Me[0]+Me[1]*Me[1]);return[[de[0]-Ae,de[1]-Ae],[de[0]+Ae,de[1]+Ae]]});Ld(ee[0],ee[1])>.5&&S[j].score>this.poseScore&&(O.push({center:[...S[j].center],top:[...S[j].top]}),q.push(this.poseFilters[j]),H.push(S[j]))}return this.bodyTracks=O,this.poseFilters=q,H}setCamera(a,c,p=1){var m;this.angle=a,this.ratio=c,this.near=p,(m=this.poseAligner)==null||m.setCamera(a,c,p)}async init(a,c="./",p=!1,m=!1,v="webgl"){const b=await Lr({locateFile:j=>c+j});b.Loader.prototype.promisify=function(j,...$){return j.call(this,...$),new Promise(J=>{const ee=setInterval(()=>{if(this.ready)return clearInterval(ee),J(this.status)},5)})},b.Loader.prototype.load=function(j){return this.promisify(this.loadAsync,j,p)},b.Loader.prototype.remove=function(j){return this.promisify(this.removeAsync,j)},b.DictLoader.prototype.loadDict=function(j){return this.promisify(this.loadDictAsync,a,j)};const w=new b.ParseLoader(c);if(p||(await w.remove("pose.wasm"),await w.remove("poseutils.wasm")),!await w.loadDict(["pose.wasm","poseutils.wasm"])||!await w.load("pose.wasm")||!w.parse())return;Hn().set("WEBGL_USE_SHAPES_UNIFORMS",!0),s0(),await s5(v);const S={weightUrlConverter:async j=>j,fetchFunc:async j=>{const $=new Blob([w.file(j)]);return fetch(URL.createObjectURL($))}},O=await Fr("bodymodel.def",S),q=await Fr("posemodel.def",S);if(this.bodyDetector=new Lu(O),this.poseDetector=new LQ(q,m),!await w.load("poseutils.wasm"))return;const H=await LT({wasmBinary:w.data()});w.delete(),H.PoseAligner.prototype.alignPoints=function(j){const $=new H.VectorFloat,J=new H.VectorFloat,ee=new H.VectorFloat,re=new H.VectorFloat;j.forEach(Te=>{$.push_back(Te.pixel[0]),$.push_back(Te.pixel[1]),$.push_back(Te.pixel[2]),J.push_back(Te.metric[0]),J.push_back(Te.metric[1]),J.push_back(Te.metric[2]),ee.push_back(Te.score),re.push_back(Te.visibility)});const de=this.align($,J,ee,re);j.forEach((Te,Me)=>{Te.metric=[de.get(Me*3),de.get(Me*3+1),de.get(Me*3+2)]}),$.delete(),J.delete(),ee.delete(),re.delete(),de.delete()},this.poseModule=H,this.poseAligner=new this.poseModule.PoseAligner,this.poseAligner.setThresh(this.alignScore,this.alignVisibility)}reset(){this.bodyTracks=[],this.poseFilters=[],this.skipCount=this.skipMax}async prepare(){var a,c;Hn().set("ENGINE_COMPILE_ONLY",!0),await((a=this.bodyDetector)==null?void 0:a.prepare()),await((c=this.poseDetector)==null?void 0:c.prepare());const p=s8();p instanceof lJ&&(p.checkCompileCompletion(),p.getUniformLocations()),Hn().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var a,c,p;this.reset(),(a=this.bodyDetector)==null||a.dispose(),(c=this.poseDetector)==null||c.dispose(),(p=this.poseAligner)==null||p.delete()}}function wc(u,a){const c=2*Math.tan(.5*a.angle),p=a.ratio*c,m=u.map(S=>({pixel:[(S.pixel[0]-.5)*p,(S.pixel[1]-.5)*c],world:S.world})),v=[];m.forEach(S=>v.push([0,1,-S.pixel[1],S.world[1]-S.pixel[1]*S.world[2]],[-1,0,S.pixel[0],S.pixel[0]*S.world[2]-S.world[0]]));const{V:b}=wf.svd(v),w=b[3][3];return[b[0][3]/w,b[1][3]/w,b[2][3]/w]}var wZ=Object.defineProperty,wL=Object.getOwnPropertySymbols,wq=Object.prototype.hasOwnProperty,wF=Object.prototype.propertyIsEnumerable,wY=(u,a,c)=>a in u?wZ(u,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):u[a]=c,wo=(u,a)=>{for(var c in a||(a={}))wq.call(a,c)&&wY(u,c,a[c]);if(wL)for(var c of wL(a))wF.call(a,c)&&wY(u,c,a[c]);return u};class wn{constructor(a){this.model=a,this.facesMax=3,this.iouThresh=.3,this.scoreThresh=.5,this.keypointCount=6,this.model=a,this.modelSize=a.inputs[0].shape?{width:a.inputs[0].shape[2],height:a.inputs[0].shape[1]}:{width:128,height:128},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchors=cS(this.anchorsData),this.size=cp([this.modelSize.width,this.modelSize.height])}async process(a,c){let p={x:0,y:0};const[m,v,b]=s2(()=>{const ee={width:a.shape[2],height:a.shape[1]},re=ee.width/ee.height;let de=wo({},ee),Te={x:0,y:0};re>this.modelRatio?(de.height=ee.width/this.modelRatio,Te.y=Math.floor((de.height-ee.height)*.5),p.y=Te.y/de.height):re<this.modelRatio&&(de.width=ee.height*this.modelRatio,Te.x=Math.floor((de.width-ee.width)*.5),p.x=Te.x/de.width);const Me=OG(a,[[0,0],[Te.y,Te.y],[Te.x,Te.x],[0,0]],0),Ae=Zi.resizeBilinear(Me,[this.modelSize.height,this.modelSize.width]),Ce=cZ(this.model.execute(Ae,"objects")),Pe=f5(Ce,[0,0],[-1,1]),je=cZ(f3(Pe)),Ne=this.decodeBoxes(Ce,this.anchors,this.size);return[Ce,Ne,je]}),w=await Zi.nonMaxSuppressionAsync(v,b,this.facesMax,this.iouThresh,this.scoreThresh),S=await w.data();w.dispose();const O=[];for(let ee=0;ee<S.length;ee++){const re=S[ee];O.push({box:f5(v,[re,0],[1,-1]),score:f5(b,re,1),anchorI:re,points:c?f5(m,[re,5],[1,-1]):void 0})}const q=await Promise.all(O.map(async ee=>{var re,de;const Te=await ee.box.data(),Me=await ee.score.data(),Ae=await((re=ee.points)==null?void 0:re.data());return ee.box.dispose(),ee.score.dispose(),(de=ee.points)==null||de.dispose(),{box:Te,score:Me[0],anchorI:ee.anchorI,points:Ae}})),H={width:1-2*p.x,height:1-2*p.y};p.x/=H.width,p.y/=H.height;const j=this.modelSize.width*H.width,$=this.modelSize.height*H.height,J=[];for(let ee=0;ee<q.length;ee++){const re=q[ee].box,de=this.anchorsData[q[ee].anchorI],Te=q[ee].points,Me=[];for(let Ae=0;Ae<this.keypointCount&&Te;Ae++)Me.push({x:(Te[Ae*2+0]+de[0])/j-p.x,y:(Te[Ae*2+1]+de[1])/$-p.y});J.push({rect:{xy:{x:re[0]/j-p.x,y:re[1]/$-p.y},size:{width:(re[2]-re[0])/j,height:(re[3]-re[1])/$}},score:q[ee].score,keypoints:Te&&Me})}return m.dispose(),v.dispose(),b.dispose(),J}decodeBoxes(a,c,p){const m=f5(a,[0,1],[-1,2]),v=EY(m,c),b=f5(a,[0,3],[-1,2]),w=ES(b,2),S=Oq(v,w),O=EY(v,w);return ff([S,O],1)}buildAnchors(a){const c=[8,16],p=[2,6],m=[];for(let v=0;v<c.length;v++){const b=c[v],w=Math.floor((a.height+b-1)/b),S=Math.floor((a.width+b-1)/b),O=p[v];for(let q=0;q<w;q++){const H=b*(q+.5);for(let j=0;j<S;j++){const $=b*(j+.5);for(let J=0;J<O;J++)m.push([$,H])}}}return m}async prepare(){const{width:a,height:c}=this.modelSize,p=Ot([1,c,a,3]),m=this.model.execute(p,"objects");await m.data(),p.dispose(),m.dispose()}dispose(){this.model.dispose(),this.anchors.dispose()}}var wp=(u=>(u[u.EyeR=0]="EyeR",u[u.EyeL=1]="EyeL",u[u.Nose=2]="Nose",u[u.Mouth=3]="Mouth",u[u.EarR=4]="EarR",u[u.EarL=5]="EarL",u))(wp||{}),wS=Object.defineProperty,wl=Object.defineProperties,wh=Object.getOwnPropertyDescriptors,wi=Object.getOwnPropertySymbols,wm=Object.prototype.hasOwnProperty,wt=Object.prototype.propertyIsEnumerable,wk=(u,a,c)=>a in u?wS(u,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):u[a]=c,ww=(u,a)=>{for(var c in a||(a={}))wm.call(a,c)&&wk(u,c,a[c]);if(wi)for(var c of wi(a))wt.call(a,c)&&wk(u,c,a[c]);return u},wU=(u,a)=>wl(u,wh(a));class wG{constructor(a){this.model=a,this.boxFactor=1.5,this.symmetryPoints=[13,168],this.model=a,this.modelSize=a.inputs[0].shape?{width:a.inputs[0].shape[2],height:a.inputs[0].shape[1]}:{width:192,height:192},this.modelHighP=this.model.outputs.length===7}async process(a,c){const p=c.map(w=>{const{xy:S,size:O}=w.rect,q={width:O.width*this.boxFactor,height:O.height*this.boxFactor},H={x:S.x+O.width/2,y:S.y+O.height/2},j={xy:{x:H.x-q.width/2,y:H.y-q.height/2},size:q};return wU(ww({},w),{rect:j})}),[m,v]=[a.shape[1],a.shape[2]],{modelSize:b}=this;return s2(()=>p.map(w=>{const S=Math.atan2((w.symmetry[1].x-w.symmetry[0].x)*v,(w.symmetry[0].y-w.symmetry[1].y)*m),{xy:O,size:q}=w.rect,H=[O.x+q.width/2,O.y+q.height/2],j=[O.y*m,O.x*v,(O.y+q.height)*m,(O.x+q.width)*v],$=this.rotatedRect(a,j,S,b),J=this.modelHighP?["output_mesh_identity","output_faceflag","output_lips","Identity_1:0","Identity_5:0","Identity_2:0","Identity_6:0"]:["output_mesh","output_faceflag"],[ee,re,de,Te,Me,Ae,Ce]=this.model.execute($,J),Pe=ee.dataSync(),je=re.dataSync()[0];let Ne=[];for(let Ut=0;Ut<Pe.length/3;Ut++)Ne.push([Pe[Ut*3+0],Pe[Ut*3+1],Pe[Ut*3+2]]);if(de){const Ut=de.dataSync();wW(Ne,Ut,wj)}if(Te&&Me){const Ut=Te.dataSync(),$0=Me.dataSync();wW(Ne,Ut,wA),wW(Ne,$0,wC)}if(Ae&&Ce){const Ut=Ae.dataSync(),$0=Ce.dataSync(),Q0=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173].map(b0=>Ne[b0]),Un=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398].map(b0=>Ne[b0]);for(let b0=0;b0<Ut.length/2;b0++){const X0=[Ut[b0*2+0],Ut[b0*2+1]];Ne.push([X0[0],X0[1],wR(X0,Q0)])}for(let b0=0;b0<$0.length/2;b0++){const X0=[$0[b0*2+0],$0[b0*2+1]];Ne.push([X0[0],X0[1],wR(X0,Un)])}}const Qe=[q.width*v/b.width,q.height*m/b.height],Ct=Ne.map(Ut=>[(Ut[0]-b.width/2)*Qe[0],(Ut[1]-b.height/2)*Qe[1],Ut[2]*Qe[0]]),dt=Math.sin(S),Xt=Math.cos(S),Gt=Ct.map(Ut=>[(Ut[0]*Xt-Ut[1]*dt)/v+H[0],(Ut[0]*dt+Ut[1]*Xt)/m+H[1],Ut[2]/v]),Vt=Ct.map(Ut=>Ut[0]),T0=Ct.map(Ut=>Ut[1]),r0=[Math.min(...Vt)/v,Math.min(...T0)/m],d0=[Math.max(...Vt)/v,Math.max(...T0)/m];return{keypoints:Gt,score:je,rect:[r0[0]+H[0],r0[1]+H[1],d0[0]-r0[0],d0[1]-r0[1]]}}))}rotatedRect(a,c,p,m){const[v,b]=[c[2]-c[0],c[3]-c[1]],[w,S]=[(c[2]+c[0])*.5,(c[3]+c[1])*.5],[O,q]=[v/m.height,b/m.width],[H,j]=[Math.cos(p),Math.sin(p)],$=[H*q,-j*O,(-H*b+j*v)*.5+S,j*q,H*O,(-j*b-H*v)*.5+w,0,0];return Zi.transform(a,[$],"bilinear","constant",0,[m.height,m.width])}async prepare(){const{width:a,height:c}=this.modelSize,p=Ot([1,c,a,3]),m=this.model.execute(p);await Promise.all(m.map(async v=>{await v.data(),v.dispose()})),p.dispose()}dispose(){this.model.dispose()}}function wz(u,a){return u.keypoints.forEach(c=>{c[0]*=a,c[1]*=a,c[2]*=a}),u.rect.forEach(c=>{}),u}function wW(u,a,c){for(let p=0;p<c.length;p++)u[c[p]][0]=a[p*2+0],u[c[p]][1]=a[p*2+1]}function wR(u,a){let c=0,p=Number.MAX_VALUE;for(let m=0;m<a.length;m++){const v=[a[m][0]-u[0],a[m][1]-u[1]],b=v[0]*v[0]+v[1]*v[1];b<p&&(p=b,c=m)}return a[c][2]}const wj=[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],wA=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],wC=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417];var wu=(()=>{var u=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(a){a=a||{};var c=typeof a<"u"?a:{},p,m;c.ready=new Promise(function(Ue,ze){p=Ue,m=ze});var v=Object.assign({},c),b=!0,w="";function S(Ue){return c.locateFile?c.locateFile(Ue,w):w+Ue}var O;typeof document<"u"&&document.currentScript&&(w=document.currentScript.src),u&&(w=u),w.indexOf("blob:")!==0?w=w.substr(0,w.replace(/[?#].*/,"").lastIndexOf("/")+1):w="",c.print||console.log.bind(console);var q=c.printErr||console.warn.bind(console);Object.assign(c,v),v=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&c.quit;var H;c.wasmBinary&&(H=c.wasmBinary),c.noExitRuntime,typeof WebAssembly!="object"&&Rr("no native wasm support detected");var j,$=!1;function J(Ue,ze){Ue||Rr(ze)}var ee=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function re(Ue,ze,We){for(var _t=ze+We,jt=ze;Ue[jt]&&!(jt>=_t);)++jt;if(jt-ze>16&&Ue.buffer&&ee)return ee.decode(Ue.subarray(ze,jt));for(var e0="";ze<jt;){var u0=Ue[ze++];if(!(u0&128)){e0+=String.fromCharCode(u0);continue}var Jt=Ue[ze++]&63;if((u0&224)==192){e0+=String.fromCharCode((u0&31)<<6|Jt);continue}var B0=Ue[ze++]&63;if((u0&240)==224?u0=(u0&15)<<12|Jt<<6|B0:u0=(u0&7)<<18|Jt<<12|B0<<6|Ue[ze++]&63,u0<65536)e0+=String.fromCharCode(u0);else{var dn=u0-65536;e0+=String.fromCharCode(55296|dn>>10,56320|dn&1023)}}return e0}function de(Ue,ze){return Ue?re(Vt,Ue,ze):""}function Te(Ue,ze,We,_t){if(!(_t>0))return 0;for(var jt=We,e0=We+_t-1,u0=0;u0<Ue.length;++u0){var Jt=Ue.charCodeAt(u0);if(Jt>=55296&&Jt<=57343){var B0=Ue.charCodeAt(++u0);Jt=65536+((Jt&1023)<<10)|B0&1023}if(Jt<=127){if(We>=e0)break;ze[We++]=Jt}else if(Jt<=2047){if(We+1>=e0)break;ze[We++]=192|Jt>>6,ze[We++]=128|Jt&63}else if(Jt<=65535){if(We+2>=e0)break;ze[We++]=224|Jt>>12,ze[We++]=128|Jt>>6&63,ze[We++]=128|Jt&63}else{if(We+3>=e0)break;ze[We++]=240|Jt>>18,ze[We++]=128|Jt>>12&63,ze[We++]=128|Jt>>6&63,ze[We++]=128|Jt&63}}return ze[We]=0,We-jt}function Me(Ue,ze,We){return Te(Ue,Vt,ze,We)}function Ae(Ue){for(var ze=0,We=0;We<Ue.length;++We){var _t=Ue.charCodeAt(We);_t>=55296&&_t<=57343&&(_t=65536+((_t&1023)<<10)|Ue.charCodeAt(++We)&1023),_t<=127?++ze:_t<=2047?ze+=2:_t<=65535?ze+=3:ze+=4}return ze}var Ce=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function Pe(Ue,ze){for(var We=Ue,_t=We>>1,jt=_t+ze/2;!(_t>=jt)&&r0[_t];)++_t;if(We=_t<<1,We-Ue>32&&Ce)return Ce.decode(Vt.subarray(Ue,We));for(var e0="",u0=0;!(u0>=ze/2);++u0){var Jt=T0[Ue+u0*2>>1];if(Jt==0)break;e0+=String.fromCharCode(Jt)}return e0}function je(Ue,ze,We){if(We===void 0&&(We=2147483647),We<2)return 0;We-=2;for(var _t=ze,jt=We<Ue.length*2?We/2:Ue.length,e0=0;e0<jt;++e0){var u0=Ue.charCodeAt(e0);T0[ze>>1]=u0,ze+=2}return T0[ze>>1]=0,ze-_t}function Ne(Ue){return Ue.length*2}function Qe(Ue,ze){for(var We=0,_t="";!(We>=ze/4);){var jt=d0[Ue+We*4>>2];if(jt==0)break;if(++We,jt>=65536){var e0=jt-65536;_t+=String.fromCharCode(55296|e0>>10,56320|e0&1023)}else _t+=String.fromCharCode(jt)}return _t}function Ct(Ue,ze,We){if(We===void 0&&(We=2147483647),We<4)return 0;for(var _t=ze,jt=_t+We-4,e0=0;e0<Ue.length;++e0){var u0=Ue.charCodeAt(e0);if(u0>=55296&&u0<=57343){var Jt=Ue.charCodeAt(++e0);u0=65536+((u0&1023)<<10)|Jt&1023}if(d0[ze>>2]=u0,ze+=4,ze+4>jt)break}return d0[ze>>2]=0,ze-_t}function dt(Ue){for(var ze=0,We=0;We<Ue.length;++We){var _t=Ue.charCodeAt(We);_t>=55296&&_t<=57343&&++We,ze+=4}return ze}var Xt,Gt,Vt,T0,r0,d0,Ut,$0,Q0;function Un(Ue){Xt=Ue,c.HEAP8=Gt=new Int8Array(Ue),c.HEAP16=T0=new Int16Array(Ue),c.HEAP32=d0=new Int32Array(Ue),c.HEAPU8=Vt=new Uint8Array(Ue),c.HEAPU16=r0=new Uint16Array(Ue),c.HEAPU32=Ut=new Uint32Array(Ue),c.HEAPF32=$0=new Float32Array(Ue),c.HEAPF64=Q0=new Float64Array(Ue)}c.INITIAL_MEMORY;var b0,X0=[],Rt=[],Qt=[];function A0(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)dx(c.preRun.shift());Po(X0)}function J0(){Po(Rt)}function Pn(){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)Wn(c.postRun.shift());Po(Qt)}function dx(Ue){X0.unshift(Ue)}function Bn(Ue){Rt.unshift(Ue)}function Wn(Ue){Qt.unshift(Ue)}var gx=0,Jx=null;function er(Ue){gx++,c.monitorRunDependencies&&c.monitorRunDependencies(gx)}function Cr(Ue){if(gx--,c.monitorRunDependencies&&c.monitorRunDependencies(gx),gx==0&&Jx){var ze=Jx;Jx=null,ze()}}function Rr(Ue){c.onAbort&&c.onAbort(Ue),Ue="Aborted("+Ue+")",q(Ue),$=!0,Ue+=". Build with -sASSERTIONS for more info.";var ze=new WebAssembly.RuntimeError(Ue);throw m(ze),ze}var xi="data:application/octet-stream;base64,";function Nr(Ue){return Ue.startsWith(xi)}var rr;rr="faceutils.wasm",Nr(rr)||(rr=S(rr));function ja(Ue){try{if(Ue==rr&&H)return new Uint8Array(H);throw"both async and sync fetching of the wasm failed"}catch(ze){Rr(ze)}}function xn(){return!H&&b&&typeof fetch=="function"?fetch(rr,{credentials:"same-origin"}).then(function(Ue){if(!Ue.ok)throw"failed to load wasm binary file at '"+rr+"'";return Ue.arrayBuffer()}).catch(function(){return ja(rr)}):Promise.resolve().then(function(){return ja(rr)})}function io(){var Ue={a:Cl};function ze(u0,Jt){var B0=u0.exports;c.asm=B0,j=c.asm.B,Un(j.buffer),b0=c.asm.F,Bn(c.asm.C),Cr()}er();function We(u0){ze(u0.instance)}function _t(u0){return xn().then(function(Jt){return WebAssembly.instantiate(Jt,Ue)}).then(function(Jt){return Jt}).then(u0,function(Jt){q("failed to asynchronously prepare wasm: "+Jt),Rr(Jt)})}function jt(){return!H&&typeof WebAssembly.instantiateStreaming=="function"&&!Nr(rr)&&typeof fetch=="function"?fetch(rr,{credentials:"same-origin"}).then(function(u0){var Jt=WebAssembly.instantiateStreaming(u0,Ue);return Jt.then(We,function(B0){return q("wasm streaming compile failed: "+B0),q("falling back to ArrayBuffer instantiation"),_t(We)})}):_t(We)}if(c.instantiateWasm)try{var e0=c.instantiateWasm(Ue,ze);return e0}catch(u0){return q("Module.instantiateWasm callback failed with error: "+u0),!1}return jt().catch(m),{}}function Po(Ue){for(;Ue.length>0;){var ze=Ue.shift();if(typeof ze=="function"){ze(c);continue}var We=ze.func;typeof We=="number"?ze.arg===void 0?Ji(We)():Ji(We)(ze.arg):We(ze.arg===void 0?null:ze.arg)}}var Ka=[];function Ji(Ue){var ze=Ka[Ue];return ze||(Ue>=Ka.length&&(Ka.length=Ue+1),Ka[Ue]=ze=b0.get(Ue)),ze}function W2(Ue){return g2(Ue+24)+24}function Vc(Ue){this.excPtr=Ue,this.ptr=Ue-24,this.set_type=function(ze){Ut[this.ptr+4>>2]=ze},this.get_type=function(){return Ut[this.ptr+4>>2]},this.set_destructor=function(ze){Ut[this.ptr+8>>2]=ze},this.get_destructor=function(){return Ut[this.ptr+8>>2]},this.set_refcount=function(ze){d0[this.ptr>>2]=ze},this.set_caught=function(ze){ze=ze?1:0,Gt[this.ptr+12>>0]=ze},this.get_caught=function(){return Gt[this.ptr+12>>0]!=0},this.set_rethrown=function(ze){ze=ze?1:0,Gt[this.ptr+13>>0]=ze},this.get_rethrown=function(){return Gt[this.ptr+13>>0]!=0},this.init=function(ze,We){this.set_adjusted_ptr(0),this.set_type(ze),this.set_destructor(We),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var ze=d0[this.ptr>>2];d0[this.ptr>>2]=ze+1},this.release_ref=function(){var ze=d0[this.ptr>>2];return d0[this.ptr>>2]=ze-1,ze===1},this.set_adjusted_ptr=function(ze){Ut[this.ptr+16>>2]=ze},this.get_adjusted_ptr=function(){return Ut[this.ptr+16>>2]},this.get_exception_ptr=function(){var ze=Je(this.get_type());if(ze)return Ut[this.excPtr>>2];var We=this.get_adjusted_ptr();return We!==0?We:this.excPtr}}function Ql(Ue,ze,We){var _t=new Vc(Ue);throw _t.init(ze,We),Ue}var ba={};function uo(Ue){for(;Ue.length;){var ze=Ue.pop(),We=Ue.pop();We(ze)}}function Wi(Ue){return this.fromWireType(Ut[Ue>>2])}var $a={},Rs={},C2={},vd=48,Gu=57;function R2(Ue){if(Ue===void 0)return"_unknown";Ue=Ue.replace(/[^a-zA-Z0-9_]/g,"$");var ze=Ue.charCodeAt(0);return ze>=vd&&ze<=Gu?"_"+Ue:Ue}function ul(Ue,ze){return Ue=R2(Ue),function(){return ze.apply(this,arguments)}}function Q2(Ue,ze){var We=ul(ze,function(_t){this.name=ze,this.message=_t;var jt=new Error(_t).stack;jt!==void 0&&(this.stack=this.toString()+`
`+jt.replace(/^Error(:[^\n]*)?\n/,""))});return We.prototype=Object.create(Ue.prototype),We.prototype.constructor=We,We.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},We}var Ns=void 0;function Js(Ue){throw new Ns(Ue)}function Pi(Ue,ze,We){Ue.forEach(function(Jt){C2[Jt]=ze});function _t(Jt){var B0=We(Jt);B0.length!==Ue.length&&Js("Mismatched type converter count");for(var dn=0;dn<Ue.length;++dn)Ui(Ue[dn],B0[dn])}var jt=new Array(ze.length),e0=[],u0=0;ze.forEach((Jt,B0)=>{Rs.hasOwnProperty(Jt)?jt[B0]=Rs[Jt]:(e0.push(Jt),$a.hasOwnProperty(Jt)||($a[Jt]=[]),$a[Jt].push(()=>{jt[B0]=Rs[Jt],++u0,u0===e0.length&&_t(jt)}))}),e0.length===0&&_t(jt)}function _a(Ue){var ze=ba[Ue];delete ba[Ue];var We=ze.elements,_t=We.length,jt=We.map(function(Jt){return Jt.getterReturnType}).concat(We.map(function(Jt){return Jt.setterArgumentType})),e0=ze.rawConstructor,u0=ze.rawDestructor;Pi([Ue],jt,function(Jt){return We.forEach((B0,dn)=>{var zn=Jt[dn],Jn=B0.getter,Wx=B0.getterContext,br=Jt[dn+_t],Qr=B0.setter,gr=B0.setterContext;B0.read=Qi=>zn.fromWireType(Jn(Wx,Qi)),B0.write=(Qi,es)=>{var Xs=[];Qr(gr,Qi,br.toWireType(Xs,es)),uo(Xs)}}),[{name:ze.name,fromWireType:function(B0){for(var dn=new Array(_t),zn=0;zn<_t;++zn)dn[zn]=We[zn].read(B0);return u0(B0),dn},toWireType:function(B0,dn){if(_t!==dn.length)throw new TypeError("Incorrect number of tuple elements for "+ze.name+": expected="+_t+", actual="+dn.length);for(var zn=e0(),Jn=0;Jn<_t;++Jn)We[Jn].write(zn,dn[Jn]);return B0!==null&&B0.push(u0,zn),zn},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:u0}]})}var Ta={};function vs(Ue){var ze=Ta[Ue];delete Ta[Ue];var We=ze.rawConstructor,_t=ze.rawDestructor,jt=ze.fields,e0=jt.map(u0=>u0.getterReturnType).concat(jt.map(u0=>u0.setterArgumentType));Pi([Ue],e0,u0=>{var Jt={};return jt.forEach((B0,dn)=>{var zn=B0.fieldName,Jn=u0[dn],Wx=B0.getter,br=B0.getterContext,Qr=u0[dn+jt.length],gr=B0.setter,Qi=B0.setterContext;Jt[zn]={read:es=>Jn.fromWireType(Wx(br,es)),write:(es,Xs)=>{var ji=[];gr(Qi,es,Qr.toWireType(ji,Xs)),uo(ji)}}}),[{name:ze.name,fromWireType:function(B0){var dn={};for(var zn in Jt)dn[zn]=Jt[zn].read(B0);return _t(B0),dn},toWireType:function(B0,dn){for(var zn in Jt)if(!(zn in dn))throw new TypeError('Missing field:  "'+zn+'"');var Jn=We();for(zn in Jt)Jt[zn].write(Jn,dn[zn]);return B0!==null&&B0.push(_t,Jn),Jn},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:_t}]})}function Ba(Ue,ze,We,_t,jt){}function Aa(Ue){switch(Ue){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+Ue)}}function Bi(){for(var Ue=new Array(256),ze=0;ze<256;++ze)Ue[ze]=String.fromCharCode(ze);Ws=Ue}var Ws=void 0;function Nn(Ue){for(var ze="",We=Ue;Vt[We];)ze+=Ws[Vt[We++]];return ze}var bs=void 0;function _r(Ue){throw new bs(Ue)}function Ui(Ue,ze,We={}){if(!("argPackAdvance"in ze))throw new TypeError("registerType registeredInstance requires argPackAdvance");var _t=ze.name;if(Ue||_r('type "'+_t+'" must have a positive integer typeid pointer'),Rs.hasOwnProperty(Ue)){if(We.ignoreDuplicateRegistrations)return;_r("Cannot register type '"+_t+"' twice")}if(Rs[Ue]=ze,delete C2[Ue],$a.hasOwnProperty(Ue)){var jt=$a[Ue];delete $a[Ue],jt.forEach(e0=>e0())}}function go(Ue,ze,We,_t,jt){var e0=Aa(We);ze=Nn(ze),Ui(Ue,{name:ze,fromWireType:function(u0){return!!u0},toWireType:function(u0,Jt){return Jt?_t:jt},argPackAdvance:8,readValueFromPointer:function(u0){var Jt;if(We===1)Jt=Gt;else if(We===2)Jt=T0;else if(We===4)Jt=d0;else throw new TypeError("Unknown boolean type size: "+ze);return this.fromWireType(Jt[u0>>e0])},destructorFunction:null})}function dl(Ue){if(!(this instanceof Go)||!(Ue instanceof Go))return!1;for(var ze=this.$$.ptrType.registeredClass,We=this.$$.ptr,_t=Ue.$$.ptrType.registeredClass,jt=Ue.$$.ptr;ze.baseClass;)We=ze.upcast(We),ze=ze.baseClass;for(;_t.baseClass;)jt=_t.upcast(jt),_t=_t.baseClass;return ze===_t&&We===jt}function Uc(Ue){return{count:Ue.count,deleteScheduled:Ue.deleteScheduled,preservePointerOnDelete:Ue.preservePointerOnDelete,ptr:Ue.ptr,ptrType:Ue.ptrType,smartPtr:Ue.smartPtr,smartPtrType:Ue.smartPtrType}}function ec(Ue){function ze(We){return We.$$.ptrType.registeredClass.name}_r(ze(Ue)+" instance already deleted")}var xc=!1;function rc(Ue){}function gl(Ue){Ue.smartPtr?Ue.smartPtrType.rawDestructor(Ue.smartPtr):Ue.ptrType.registeredClass.rawDestructor(Ue.ptr)}function vl(Ue){Ue.count.value-=1;var ze=Ue.count.value===0;ze&&gl(Ue)}function uc(Ue,ze,We){if(ze===We)return Ue;if(We.baseClass===void 0)return null;var _t=uc(Ue,ze,We.baseClass);return _t===null?null:We.downcast(_t)}var dc={};function N2(){return Object.keys(gc).length}function bl(){var Ue=[];for(var ze in gc)gc.hasOwnProperty(ze)&&Ue.push(gc[ze]);return Ue}var vo=[];function Wo(){for(;vo.length;){var Ue=vo.pop();Ue.$$.deleteScheduled=!1,Ue.delete()}}var Qo=void 0;function bo(Ue){Qo=Ue,vo.length&&Qo&&Qo(Wo)}function Xu(){c.getInheritedInstanceCount=N2,c.getLiveInheritedInstances=bl,c.flushPendingDeletes=Wo,c.setDelayFunction=bo}var gc={};function Bo(Ue,ze){for(ze===void 0&&_r("ptr should not be undefined");Ue.baseClass;)ze=Ue.upcast(ze),Ue=Ue.baseClass;return ze}function ju(Ue,ze){return ze=Bo(Ue,ze),gc[ze]}function zo(Ue,ze){(!ze.ptrType||!ze.ptr)&&Js("makeClassHandle requires ptr and ptrType");var We=!!ze.smartPtrType,_t=!!ze.smartPtr;return We!==_t&&Js("Both smartPtrType and smartPtr must be specified"),ze.count={value:1},Vo(Object.create(Ue,{$$:{value:ze}}))}function Gc(Ue){var ze=this.getPointee(Ue);if(!ze)return this.destructor(Ue),null;var We=ju(this.registeredClass,ze);if(We!==void 0){if(We.$$.count.value===0)return We.$$.ptr=ze,We.$$.smartPtr=Ue,We.clone();var _t=We.clone();return this.destructor(Ue),_t}function jt(){return this.isSmartPointer?zo(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:ze,smartPtrType:this,smartPtr:Ue}):zo(this.registeredClass.instancePrototype,{ptrType:this,ptr:Ue})}var e0=this.registeredClass.getActualType(ze),u0=dc[e0];if(!u0)return jt.call(this);var Jt;this.isConst?Jt=u0.constPointerType:Jt=u0.pointerType;var B0=uc(ze,this.registeredClass,Jt.registeredClass);return B0===null?jt.call(this):this.isSmartPointer?zo(Jt.registeredClass.instancePrototype,{ptrType:Jt,ptr:B0,smartPtrType:this,smartPtr:Ue}):zo(Jt.registeredClass.instancePrototype,{ptrType:Jt,ptr:B0})}function Vo(Ue){return typeof FinalizationRegistry>"u"?(Vo=ze=>ze,Ue):(xc=new FinalizationRegistry(ze=>{vl(ze.$$)}),Vo=ze=>{var We=ze.$$,_t=!!We.smartPtr;if(_t){var jt={$$:We};xc.register(ze,jt,ze)}return ze},rc=ze=>xc.unregister(ze),Vo(Ue))}function vc(){if(this.$$.ptr||ec(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var Ue=Vo(Object.create(Object.getPrototypeOf(this),{$$:{value:Uc(this.$$)}}));return Ue.$$.count.value+=1,Ue.$$.deleteScheduled=!1,Ue}function Ku(){this.$$.ptr||ec(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&_r("Object already scheduled for deletion"),rc(this),vl(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)}function $u(){return!this.$$.ptr}function Uo(){return this.$$.ptr||ec(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&_r("Object already scheduled for deletion"),vo.push(this),vo.length===1&&Qo&&Qo(Wo),this.$$.deleteScheduled=!0,this}function bc(){Go.prototype.isAliasOf=dl,Go.prototype.clone=vc,Go.prototype.delete=Ku,Go.prototype.isDeleted=$u,Go.prototype.deleteLater=Uo}function Go(){}function _o(Ue,ze,We){if(Ue[ze].overloadTable===void 0){var _t=Ue[ze];Ue[ze]=function(){return Ue[ze].overloadTable.hasOwnProperty(arguments.length)||_r("Function '"+We+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+Ue[ze].overloadTable+")!"),Ue[ze].overloadTable[arguments.length].apply(this,arguments)},Ue[ze].overloadTable=[],Ue[ze].overloadTable[_t.argCount]=_t}}function Ma(Ue,ze,We){c.hasOwnProperty(Ue)?((We===void 0||c[Ue].overloadTable!==void 0&&c[Ue].overloadTable[We]!==void 0)&&_r("Cannot register public name '"+Ue+"' twice"),_o(c,Ue,Ue),c.hasOwnProperty(We)&&_r("Cannot register multiple overloads of a function with the same number of arguments ("+We+")!"),c[Ue].overloadTable[We]=ze):(c[Ue]=ze,We!==void 0&&(c[Ue].numArguments=We))}function Ju(Ue,ze,We,_t,jt,e0,u0,Jt){this.name=Ue,this.constructor=ze,this.instancePrototype=We,this.rawDestructor=_t,this.baseClass=jt,this.getActualType=e0,this.upcast=u0,this.downcast=Jt,this.pureVirtualFunctions=[]}function Xc(Ue,ze,We){for(;ze!==We;)ze.upcast||_r("Expected null or instance of "+We.name+", got an instance of "+ze.name),Ue=ze.upcast(Ue),ze=ze.baseClass;return Ue}function jc(Ue,ze){if(ze===null)return this.isReference&&_r("null is not a valid "+this.name),0;ze.$$||_r('Cannot pass "'+Ts(ze)+'" as a '+this.name),ze.$$.ptr||_r("Cannot pass deleted object as a pointer of type "+this.name);var We=ze.$$.ptrType.registeredClass,_t=Xc(ze.$$.ptr,We,this.registeredClass);return _t}function Wu(Ue,ze){var We;if(ze===null)return this.isReference&&_r("null is not a valid "+this.name),this.isSmartPointer?(We=this.rawConstructor(),Ue!==null&&Ue.push(this.rawDestructor,We),We):0;ze.$$||_r('Cannot pass "'+Ts(ze)+'" as a '+this.name),ze.$$.ptr||_r("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&ze.$$.ptrType.isConst&&_r("Cannot convert argument of type "+(ze.$$.smartPtrType?ze.$$.smartPtrType.name:ze.$$.ptrType.name)+" to parameter type "+this.name);var _t=ze.$$.ptrType.registeredClass;if(We=Xc(ze.$$.ptr,_t,this.registeredClass),this.isSmartPointer)switch(ze.$$.smartPtr===void 0&&_r("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:ze.$$.smartPtrType===this?We=ze.$$.smartPtr:_r("Cannot convert argument of type "+(ze.$$.smartPtrType?ze.$$.smartPtrType.name:ze.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:We=ze.$$.smartPtr;break;case 2:if(ze.$$.smartPtrType===this)We=ze.$$.smartPtr;else{var jt=ze.clone();We=this.rawShare(We,r2.toHandle(function(){jt.delete()})),Ue!==null&&Ue.push(this.rawDestructor,We)}break;default:_r("Unsupporting sharing policy")}return We}function Qu(Ue,ze){if(ze===null)return this.isReference&&_r("null is not a valid "+this.name),0;ze.$$||_r('Cannot pass "'+Ts(ze)+'" as a '+this.name),ze.$$.ptr||_r("Cannot pass deleted object as a pointer of type "+this.name),ze.$$.ptrType.isConst&&_r("Cannot convert argument of type "+ze.$$.ptrType.name+" to parameter type "+this.name);var We=ze.$$.ptrType.registeredClass,_t=Xc(ze.$$.ptr,We,this.registeredClass);return _t}function eh(Ue){return this.rawGetPointee&&(Ue=this.rawGetPointee(Ue)),Ue}function _c(Ue){this.rawDestructor&&this.rawDestructor(Ue)}function To(Ue){Ue!==null&&Ue.delete()}function _l(){_s.prototype.getPointee=eh,_s.prototype.destructor=_c,_s.prototype.argPackAdvance=8,_s.prototype.readValueFromPointer=Wi,_s.prototype.deleteObject=To,_s.prototype.fromWireType=Gc}function _s(Ue,ze,We,_t,jt,e0,u0,Jt,B0,dn,zn){this.name=Ue,this.registeredClass=ze,this.isReference=We,this.isConst=_t,this.isSmartPointer=jt,this.pointeeType=e0,this.sharingPolicy=u0,this.rawGetPointee=Jt,this.rawConstructor=B0,this.rawShare=dn,this.rawDestructor=zn,!jt&&ze.baseClass===void 0?_t?(this.toWireType=jc,this.destructorFunction=null):(this.toWireType=Qu,this.destructorFunction=null):this.toWireType=Wu}function e2(Ue,ze,We){c.hasOwnProperty(Ue)||Js("Replacing nonexistant public symbol"),c[Ue].overloadTable!==void 0&&We!==void 0?c[Ue].overloadTable[We]=ze:(c[Ue]=ze,c[Ue].argCount=We)}function Qs(Ue,ze,We){var _t=c["dynCall_"+Ue];return We&&We.length?_t.apply(null,[ze].concat(We)):_t.call(null,ze)}function Ps(Ue,ze,We){return Ue.includes("j")?Qs(Ue,ze,We):Ji(ze).apply(null,We)}function P2(Ue,ze){var We=[];return function(){return We.length=0,Object.assign(We,arguments),Ps(Ue,ze,We)}}function Ri(Ue,ze){Ue=Nn(Ue);function We(){return Ue.includes("j")?P2(Ue,ze):Ji(ze)}var _t=We();return typeof _t!="function"&&_r("unknown function pointer with signature "+Ue+": "+ze),_t}var Gi=void 0;function ea(Ue){var ze=et(Ue),We=Nn(ze);return ra(ze),We}function gi(Ue,ze){var We=[],_t={};function jt(e0){if(!_t[e0]&&!Rs[e0]){if(C2[e0]){C2[e0].forEach(jt);return}We.push(e0),_t[e0]=!0}}throw ze.forEach(jt),new Gi(Ue+": "+We.map(ea).join([", "]))}function Tc(Ue,ze,We,_t,jt,e0,u0,Jt,B0,dn,zn,Jn,Wx){zn=Nn(zn),e0=Ri(jt,e0),Jt&&(Jt=Ri(u0,Jt)),dn&&(dn=Ri(B0,dn)),Wx=Ri(Jn,Wx);var br=R2(zn);Ma(br,function(){gi("Cannot construct "+zn+" due to unbound types",[_t])}),Pi([Ue,ze,We],_t?[_t]:[],function(Qr){Qr=Qr[0];var gr,Qi;_t?(gr=Qr.registeredClass,Qi=gr.instancePrototype):Qi=Go.prototype;var es=ul(br,function(){if(Object.getPrototypeOf(this)!==Xs)throw new bs("Use 'new' to construct "+zn);if(ji.constructor_body===void 0)throw new bs(zn+" has no accessible constructor");var Ja=ji.constructor_body[arguments.length];if(Ja===void 0)throw new bs("Tried to invoke ctor of "+zn+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(ji.constructor_body).toString()+") parameters instead!");return Ja.apply(this,arguments)}),Xs=Object.create(Qi,{constructor:{value:es}});es.prototype=Xs;var ji=new Ju(zn,es,Xs,Wx,gr,e0,Jt,dn),gh=new _s(zn,ji,!0,!1,!1),bd=new _s(zn+"*",ji,!1,!1,!1),_d=new _s(zn+" const*",ji,!1,!0,!1);return dc[Ue]={pointerType:bd,constPointerType:_d},e2(br,es),[gh,bd,_d]})}function k2(Ue,ze){for(var We=[],_t=0;_t<Ue;_t++)We.push(d0[(ze>>2)+_t]);return We}function x2(Ue,ze,We,_t,jt,e0){J(ze>0);var u0=k2(ze,We);jt=Ri(_t,jt),Pi([],[Ue],function(Jt){Jt=Jt[0];var B0="constructor "+Jt.name;if(Jt.registeredClass.constructor_body===void 0&&(Jt.registeredClass.constructor_body=[]),Jt.registeredClass.constructor_body[ze-1]!==void 0)throw new bs("Cannot register multiple constructors with identical number of parameters ("+(ze-1)+") for class '"+Jt.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return Jt.registeredClass.constructor_body[ze-1]=()=>{gi("Cannot construct "+Jt.name+" due to unbound types",u0)},Pi([],u0,function(dn){return dn.splice(1,0,null),Jt.registeredClass.constructor_body[ze-1]=Tl(B0,dn,null,jt,e0),[]}),[]})}function Tl(Ue,ze,We,_t,jt){var e0=ze.length;e0<2&&_r("argTypes array size mismatch! Must at least get return value and 'this' types!");for(var u0=ze[1]!==null&&We!==null,Jt=!1,B0=1;B0<ze.length;++B0)if(ze[B0]!==null&&ze[B0].destructorFunction===void 0){Jt=!0;break}var dn=ze[0].name!=="void",zn=e0-2,Jn=new Array(zn),Wx=[],br=[];return function(){arguments.length!==zn&&_r("function "+Ue+" called with "+arguments.length+" arguments, expected "+zn+" args!"),br.length=0;var Qr;Wx.length=u0?2:1,Wx[0]=jt,u0&&(Qr=ze[1].toWireType(br,this),Wx[1]=Qr);for(var gr=0;gr<zn;++gr)Jn[gr]=ze[gr+2].toWireType(br,arguments[gr]),Wx.push(Jn[gr]);var Qi=_t.apply(null,Wx);function es(Xs){if(Jt)uo(br);else for(var ji=u0?1:2;ji<ze.length;ji++){var gh=ji===1?Qr:Jn[ji-2];ze[ji].destructorFunction!==null&&ze[ji].destructorFunction(gh)}if(dn)return ze[0].fromWireType(Xs)}return es(Qi)}}function ui(Ue,ze,We,_t,jt,e0,u0,Jt){var B0=k2(We,_t);ze=Nn(ze),e0=Ri(jt,e0),Pi([],[Ue],function(dn){dn=dn[0];var zn=dn.name+"."+ze;ze.startsWith("@@")&&(ze=Symbol[ze.substring(2)]),Jt&&dn.registeredClass.pureVirtualFunctions.push(ze);function Jn(){gi("Cannot call "+zn+" due to unbound types",B0)}var Wx=dn.registeredClass.instancePrototype,br=Wx[ze];return br===void 0||br.overloadTable===void 0&&br.className!==dn.name&&br.argCount===We-2?(Jn.argCount=We-2,Jn.className=dn.name,Wx[ze]=Jn):(_o(Wx,ze,zn),Wx[ze].overloadTable[We-2]=Jn),Pi([],B0,function(Qr){var gr=Tl(zn,Qr,dn,e0,u0);return Wx[ze].overloadTable===void 0?(gr.argCount=We-2,Wx[ze]=gr):Wx[ze].overloadTable[We-2]=gr,[]}),[]})}function Xo(Ue,ze,We){return Ue instanceof Object||_r(We+' with invalid "this": '+Ue),Ue instanceof ze.registeredClass.constructor||_r(We+' incompatible with "this" of type '+Ue.constructor.name),Ue.$$.ptr||_r("cannot call emscripten binding method "+We+" on deleted object"),Xc(Ue.$$.ptr,Ue.$$.ptrType.registeredClass,ze.registeredClass)}function za(Ue,ze,We,_t,jt,e0,u0,Jt,B0,dn){ze=Nn(ze),jt=Ri(_t,jt),Pi([],[Ue],function(zn){zn=zn[0];var Jn=zn.name+"."+ze,Wx={get:function(){gi("Cannot access "+Jn+" due to unbound types",[We,u0])},enumerable:!0,configurable:!0};return B0?Wx.set=()=>{gi("Cannot access "+Jn+" due to unbound types",[We,u0])}:Wx.set=br=>{_r(Jn+" is a read-only property")},Object.defineProperty(zn.registeredClass.instancePrototype,ze,Wx),Pi([],B0?[We,u0]:[We],function(br){var Qr=br[0],gr={get:function(){var es=Xo(this,zn,Jn+" getter");return Qr.fromWireType(jt(e0,es))},enumerable:!0};if(B0){B0=Ri(Jt,B0);var Qi=br[1];gr.set=function(es){var Xs=Xo(this,zn,Jn+" setter"),ji=[];B0(dn,Xs,Qi.toWireType(ji,es)),uo(ji)}}return Object.defineProperty(zn.registeredClass.instancePrototype,ze,gr),[]}),[]})}var Us=[],Va=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Ao(Ue){Ue>4&&--Va[Ue].refcount===0&&(Va[Ue]=void 0,Us.push(Ue))}function Al(){for(var Ue=0,ze=5;ze<Va.length;++ze)Va[ze]!==void 0&&++Ue;return Ue}function Gs(){for(var Ue=5;Ue<Va.length;++Ue)if(Va[Ue]!==void 0)return Va[Ue];return null}function Ac(){c.count_emval_handles=Al,c.get_first_emval=Gs}var r2={toValue:Ue=>(Ue||_r("Cannot use deleted val. handle = "+Ue),Va[Ue].value),toHandle:Ue=>{switch(Ue){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var ze=Us.length?Us.pop():Va.length;return Va[ze]={refcount:1,value:Ue},ze}}}};function jo(Ue,ze){ze=Nn(ze),Ui(Ue,{name:ze,fromWireType:function(We){var _t=r2.toValue(We);return Ao(We),_t},toWireType:function(We,_t){return r2.toHandle(_t)},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:null})}function Ts(Ue){if(Ue===null)return"null";var ze=typeof Ue;return ze==="object"||ze==="array"||ze==="function"?Ue.toString():""+Ue}function Xi(Ue,ze){switch(ze){case 2:return function(We){return this.fromWireType($0[We>>2])};case 3:return function(We){return this.fromWireType(Q0[We>>3])};default:throw new TypeError("Unknown float type: "+Ue)}}function eu(Ue,ze,We){var _t=Aa(We);ze=Nn(ze),Ui(Ue,{name:ze,fromWireType:function(jt){return jt},toWireType:function(jt,e0){return e0},argPackAdvance:8,readValueFromPointer:Xi(ze,_t),destructorFunction:null})}function Kc(Ue,ze,We){switch(ze){case 0:return We?function(_t){return Gt[_t]}:function(_t){return Vt[_t]};case 1:return We?function(_t){return T0[_t>>1]}:function(_t){return r0[_t>>1]};case 2:return We?function(_t){return d0[_t>>2]}:function(_t){return Ut[_t>>2]};default:throw new TypeError("Unknown integer type: "+Ue)}}function u2(Ue,ze,We,_t,jt){ze=Nn(ze);var e0=Aa(We),u0=Jn=>Jn;if(_t===0){var Jt=32-8*We;u0=Jn=>Jn<<Jt>>>Jt}var B0=ze.includes("unsigned"),dn=(Jn,Wx)=>{},zn;B0?zn=function(Jn,Wx){return dn(Wx,this.name),Wx>>>0}:zn=function(Jn,Wx){return dn(Wx,this.name),Wx},Ui(Ue,{name:ze,fromWireType:u0,toWireType:zn,argPackAdvance:8,readValueFromPointer:Kc(ze,e0,_t!==0),destructorFunction:null})}function xh(Ue,ze,We){var _t=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],jt=_t[ze];function e0(u0){u0=u0>>2;var Jt=Ut,B0=Jt[u0],dn=Jt[u0+1];return new jt(Xt,dn,B0)}We=Nn(We),Ui(Ue,{name:We,fromWireType:e0,argPackAdvance:8,readValueFromPointer:e0},{ignoreDuplicateRegistrations:!0})}function xa(Ue,ze){ze=Nn(ze);var We=ze==="std::string";Ui(Ue,{name:ze,fromWireType:function(_t){var jt=Ut[_t>>2],e0;if(We)for(var u0=_t+4,Jt=0;Jt<=jt;++Jt){var B0=_t+4+Jt;if(Jt==jt||Vt[B0]==0){var dn=B0-u0,zn=de(u0,dn);e0===void 0?e0=zn:(e0+=String.fromCharCode(0),e0+=zn),u0=B0+1}}else{for(var Jn=new Array(jt),Jt=0;Jt<jt;++Jt)Jn[Jt]=String.fromCharCode(Vt[_t+4+Jt]);e0=Jn.join("")}return ra(_t),e0},toWireType:function(_t,jt){jt instanceof ArrayBuffer&&(jt=new Uint8Array(jt));var e0,u0=typeof jt=="string";u0||jt instanceof Uint8Array||jt instanceof Uint8ClampedArray||jt instanceof Int8Array||_r("Cannot pass non-string to std::string"),We&&u0?e0=()=>Ae(jt):e0=()=>jt.length;var Jt=e0(),B0=g2(4+Jt+1);if(Ut[B0>>2]=Jt,We&&u0)Me(jt,B0+4,Jt+1);else if(u0)for(var dn=0;dn<Jt;++dn){var zn=jt.charCodeAt(dn);zn>255&&(ra(B0),_r("String has UTF-16 code units that do not fit in 8 bits")),Vt[B0+4+dn]=zn}else for(var dn=0;dn<Jt;++dn)Vt[B0+4+dn]=jt[dn];return _t!==null&&_t.push(ra,B0),B0},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:function(_t){ra(_t)}})}function rh(Ue,ze,We){We=Nn(We);var _t,jt,e0,u0,Jt;ze===2?(_t=Pe,jt=je,u0=Ne,e0=()=>r0,Jt=1):ze===4&&(_t=Qe,jt=Ct,u0=dt,e0=()=>Ut,Jt=2),Ui(Ue,{name:We,fromWireType:function(B0){for(var dn=Ut[B0>>2],zn=e0(),Jn,Wx=B0+4,br=0;br<=dn;++br){var Qr=B0+4+br*ze;if(br==dn||zn[Qr>>Jt]==0){var gr=Qr-Wx,Qi=_t(Wx,gr);Jn===void 0?Jn=Qi:(Jn+=String.fromCharCode(0),Jn+=Qi),Wx=Qr+ze}}return ra(B0),Jn},toWireType:function(B0,dn){typeof dn!="string"&&_r("Cannot pass non-string to C++ string type "+We);var zn=u0(dn),Jn=g2(4+zn+ze);return Ut[Jn>>2]=zn>>Jt,jt(dn,Jn+4,zn+ze),B0!==null&&B0.push(ra,Jn),Jn},argPackAdvance:8,readValueFromPointer:Wi,destructorFunction:function(B0){ra(B0)}})}function uh(Ue,ze,We,_t,jt,e0){ba[Ue]={name:Nn(ze),rawConstructor:Ri(We,_t),rawDestructor:Ri(jt,e0),elements:[]}}function d2(Ue,ze,We,_t,jt,e0,u0,Jt,B0){ba[Ue].elements.push({getterReturnType:ze,getter:Ri(We,_t),getterContext:jt,setterArgumentType:e0,setter:Ri(u0,Jt),setterContext:B0})}function B2(Ue,ze,We,_t,jt,e0){Ta[Ue]={name:Nn(ze),rawConstructor:Ri(We,_t),rawDestructor:Ri(jt,e0),fields:[]}}function dh(Ue,ze,We,_t,jt,e0,u0,Jt,B0,dn){Ta[Ue].fields.push({fieldName:Nn(ze),getterReturnType:We,getter:Ri(_t,jt),getterContext:e0,setterArgumentType:u0,setter:Ri(Jt,B0),setterContext:dn})}function xu(Ue,ze){ze=Nn(ze),Ui(Ue,{isVoid:!0,name:ze,argPackAdvance:0,fromWireType:function(){},toWireType:function(We,_t){}})}function ru(Ue){Ue>4&&(Va[Ue].refcount+=1)}function uu(Ue,ze){var We=Rs[Ue];return We===void 0&&_r(ze+" has unknown type "+ea(Ue)),We}function du(Ue,ze){Ue=uu(Ue,"_emval_take_value");var We=Ue.readValueFromPointer(ze);return r2.toHandle(We)}function $c(){Rr("")}function Jc(Ue,ze,We){Vt.copyWithin(Ue,ze,ze+We)}function Ua(){return 2147483648}function z2(Ue){try{return j.grow(Ue-Xt.byteLength+65535>>>16),Un(j.buffer),1}catch{}}function Ml(Ue){var ze=Vt.length;Ue=Ue>>>0;var We=Ua();if(Ue>We)return!1;let _t=(B0,dn)=>B0+(dn-B0%dn)%dn;for(var jt=1;jt<=4;jt*=2){var e0=ze*(1+.2/jt);e0=Math.min(e0,Ue+100663296);var u0=Math.min(We,_t(Math.max(Ue,e0),65536)),Jt=z2(u0);if(Jt)return!0}return!1}Ns=c.InternalError=Q2(Error,"InternalError"),Bi(),bs=c.BindingError=Q2(Error,"BindingError"),bc(),Xu(),_l(),Gi=c.UnboundTypeError=Q2(Error,"UnboundTypeError"),Ac();var Cl={b:W2,a:Ql,i:_a,x:vs,q:Ba,v:go,m:Tc,h:x2,c:ui,g:za,u:jo,o:eu,f:u2,d:xh,n:xa,k:rh,j:uh,e:d2,y:B2,l:dh,w:xu,z:Ao,A:ru,p:du,r:$c,t:Jc,s:Ml};io(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.C).apply(null,arguments)};var ra=c._free=function(){return(ra=c._free=c.asm.D).apply(null,arguments)},g2=c._malloc=function(){return(g2=c._malloc=c.asm.E).apply(null,arguments)},et=c.___getTypeName=function(){return(et=c.___getTypeName=c.asm.G).apply(null,arguments)};c.___embind_register_native_and_builtin_types=function(){return(c.___embind_register_native_and_builtin_types=c.asm.H).apply(null,arguments)};var Je=c.___cxa_is_pointer_type=function(){return(Je=c.___cxa_is_pointer_type=c.asm.I).apply(null,arguments)},Nt;Jx=function Ue(){Nt||_0(),Nt||(Jx=Ue)};function _0(Ue){if(gx>0||(A0(),gx>0))return;function ze(){Nt||(Nt=!0,c.calledRun=!0,!$&&(J0(),p(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),Pn()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),ze()},1)):ze()}if(c.run=_0,c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();return _0(),a.ready}})();class wQ{constructor(){this.faceTracks=[],this.faceFilters=[],this.meshScore=.9}async process(a,c){var p,m,v,b;const w=s2(()=>{const $=IA(Ie(a,3),"float32"),J=Oq(ES($,255*.5),1);return O3(J,0)});let S=[];this.faceTracks.length===0&&(S=await((p=this.faceDetector)==null?void 0:p.process(w,!0))||[],S.forEach($=>{if(!$.keypoints)return;const{xy:J,size:ee}=$.rect,re=J.y+ee.height/2,de=ee.height*1.3;this.faceTracks.push({rect:{xy:{x:J.x,y:re-de/2},size:{width:ee.width,height:de}},symmetry:[$.keypoints[wp.Mouth],$.keypoints[wp.Nose]]}),this.faceFilters.push(new this.faceModule.FaceFilter({minCutOff:1,minCutOffD:2,beta:30},{minCutOff:1,minCutOffD:2,beta:30},1))}));const O=this.faceTracks.length>0?await((m=this.meshDetector)==null?void 0:m.process(w,this.faceTracks))||[]:[];w.dispose();const q=[],H=[],j=[];for(let $=0;$<this.faceTracks.length;$++){const J=O[$],{rect:ee}=J,re={xy:{x:ee[0],y:ee[1]},size:{width:ee[2],height:ee[3]}},de=[J.keypoints[((v=this.meshDetector)==null?void 0:v.symmetryPoints[0])||0],J.keypoints[((b=this.meshDetector)==null?void 0:b.symmetryPoints[1])||0]];if(LV(this.faceTracks[$].rect,re)>.5&&J.score>this.meshScore){if(j.push(J),q.push({rect:re,symmetry:[{x:de[0][0],y:de[0][1]},{x:de[1][0],y:de[1][1]}]}),c===void 0)continue;const[Te,Me]=[w.shape[1],w.shape[2]],{width:Ae,height:Ce}=this.faceTracks[$].rect.size,Pe=(Ae+Ce*Me/Te)*.5;this.faceFilters[$].smoothFilter(J,c,1/Pe),J.keypoints=this.faceFilters[$].smoothPixel(),H.push(this.faceFilters[$])}else this.faceFilters[$].delete()}return this.faceTracks=q,this.faceFilters=H,j}align(a){var c;const p=new this.faceModule.VectorFloat;return a.flat().forEach(m=>p.push_back(m)),(c=this.faceAligner)==null||c.align(p),p.delete(),this.alignTransform()}alignTransform(){if(!this.faceAligner)return;const a=this.faceAligner.rotation,c=this.faceAligner.translation,p=this.faceAligner.scale,m=this.faceAligner.shapeScale;return{rotation:[a[0],a[1],a[2],a[3]],translation:[c[0],c[1],c[2]],scale:p,shapeScale:[m[0],m[1],m[2]]}}metricPoints(){if(!this.faceAligner)return;let a=[];const c=this.faceAligner.metricPoints();for(let p=0;p<c.size();p+=3)a.push([c.get(p+0),c.get(p+1),c.get(p+2)]);return c.delete(),a}referencePoints(){if(!this.faceAligner)return;let a=[];const c=this.faceAligner.referencePoints();for(let p=0;p<c.size();p+=3)a.push([c.get(p+0),c.get(p+1),c.get(p+2)]);return c.delete(),a}backprojPoints(){if(!this.faceAligner)return;let a=[];const c=this.faceAligner.backprojPoints();for(let p=0;p<c.size();p+=3)a.push([c.get(p+0),c.get(p+1),c.get(p+2)]);return c.delete(),a}setCamera(a,c,p){var m;(m=this.faceAligner)==null||m.setCamera(a,c,p)}async init(a,c="./",p=!1,m=!1,v="webgl"){const b=await Lr({locateFile:J=>c+J});b.Loader.prototype.promisify=function(J,...ee){return J.call(this,...ee),new Promise(re=>{const de=setInterval(()=>{if(this.ready)return clearInterval(de),re(this.status)},5)})},b.Loader.prototype.load=function(J){return this.promisify(this.loadAsync,J,p)},b.Loader.prototype.remove=function(J){return this.promisify(this.removeAsync,J)},b.DictLoader.prototype.loadDict=function(J){return this.promisify(this.loadDictAsync,a,J)};const w=new b.ParseLoader(c),[S,O]=m?["faceext.wasm","meshextmodel.def"]:["face.wasm","meshmodel.def"];if(p||(await w.remove(S),await w.remove("faceutils.wasm")),!await w.loadDict([S,"faceutils.wasm"])||!await w.load(S)||!w.parse())return;Hn().set("WEBGL_USE_SHAPES_UNIFORMS",!0),s0(),await s5(v);const q={weightUrlConverter:async J=>J,fetchFunc:async J=>{const ee=new Blob([w.file(J)]);return fetch(URL.createObjectURL(ee))}},H=await Fr("facemodel.def",q),j=await Fr(O,q);if(this.faceDetector=new wn(H),this.meshDetector=new wG(j),!await w.load("faceutils.wasm"))return;const $=await wu({wasmBinary:w.data()});w.delete(),$.FaceFilter.prototype.smoothFilter=function(J,ee){const re=new $.VectorFloat,de=new $.VectorFloat;J.keypoints.flat().forEach(Te=>re.push_back(Te)),J.rect.forEach(Te=>de.push_back(Te)),this.filter(re,de,J.score,ee,1),re.delete(),de.delete()},$.FaceFilter.prototype.smoothPixel=function(){let J=[];const ee=this.pixel();for(let re=0;re<ee.size();re+=3)J.push([ee.get(re+0),ee.get(re+1),ee.get(re+2)]);return ee.delete(),J},this.faceModule=$,this.faceAligner=new this.faceModule.FaceAligner}reset(){this.faceFilters.forEach(a=>a.delete()),this.faceFilters=[],this.faceTracks=[]}async prepare(){var a,c;Hn().set("ENGINE_COMPILE_ONLY",!0),await((a=this.faceDetector)==null?void 0:a.prepare()),await((c=this.meshDetector)==null?void 0:c.prepare());const p=s8();p instanceof lJ&&(p.checkCompileCompletion(),p.getUniformLocations()),Hn().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var a,c,p;this.reset(),(a=this.faceDetector)==null||a.dispose(),(c=this.meshDetector)==null||c.dispose(),(p=this.faceAligner)==null||p.delete()}}var wJ=Object.defineProperty,wx=Object.getOwnPropertySymbols,wM=Object.prototype.hasOwnProperty,wX=Object.prototype.propertyIsEnumerable,wg=(u,a,c)=>a in u?wJ(u,a,{enumerable:!0,configurable:!0,writable:!0,value:c}):u[a]=c,wK=(u,a)=>{for(var c in a||(a={}))wM.call(a,c)&&wg(u,c,a[c]);if(wx)for(var c of wx(a))wX.call(a,c)&&wg(u,c,a[c]);return u};class wb{constructor(a){this.model=a,this.handsMax=1,this.iouThresh=.3,this.scoreThresh=.45,this.model=a,this.modelSize=a.inputs[0].shape?{width:a.inputs[0].shape[2],height:a.inputs[0].shape[1]}:{width:192,height:192},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=cp(this.anchorsData.map(c=>c.x)),this.anchorsY=cp(this.anchorsData.map(c=>c.y))}async process(a){let c={x:0,y:0};const[p,m]=s2(()=>{const O={width:a.shape[2],height:a.shape[1]},q=O.width/O.height;let H=wK({},O),j={x:0,y:0};q>this.modelRatio?(H.height=a.shape[2]/this.modelRatio,j.y=Math.floor((H.height-a.shape[1])*.5),c.y=j.y/H.height):q<this.modelRatio&&(H.width=a.shape[1]*this.modelRatio,j.x=Math.floor((H.width-a.shape[2])*.5),c.x=j.x/H.width);const $=OG(a,[[0,0],[j.y,j.y],[j.x,j.x],[0,0]],0),J=Zi.resizeBilinear($,[this.modelSize.height,this.modelSize.width]),ee=this.model.execute(J,"palm"),re=cZ(f5(ee,[0,0,1],[1,-1,-1])),de=cZ(f5(ee,[0,0,0],[1,-1,1])),Te=f3(fI(de,-100,100));return[this.decodeBoxes(re,[this.anchorsX,this.anchorsY],this.modelSize),Te]}),v=await p.data(),b=await m.data();let w=[];for(let O=0;O<b.length;O++){if(b[O]<this.scoreThresh)continue;const q=v[O*18+2]-v[O*18+0],H=v[O*18+3]-v[O*18+1];q<0||H<0||w.push({box:[[v[O*18+0],v[O*18+1]],[v[O*18+2],v[O*18+3]]],points:[[v[O*18+4],v[O*18+5]],[v[O*18+6],v[O*18+7]],[v[O*18+8],v[O*18+9]],[v[O*18+10],v[O*18+11]],[v[O*18+12],v[O*18+13]],[v[O*18+14],v[O*18+15]],[v[O*18+16],v[O*18+17]]],score:b[O]})}if(p.dispose(),m.dispose(),w.length<1)return[];if(w.length>1){const O=cS(w.map(J=>[J.box[0][1],J.box[0][0],J.box[1][1],J.box[1][0]])),q=cp(w.map(J=>J.score)),H=await Zi.nonMaxSuppressionAsync(O,q,this.handsMax,this.iouThresh,this.scoreThresh),j=await H.data();H.dispose();const $=[];for(let J=0;J<j.length;J++)$.push(w[j[J]]);w=$}if(w.length<1)return[];const S={width:1-2*c.x,height:1-2*c.y};return w.map(O=>({points:O.points.map(q=>[(q[0]-c.x)/S.width,(q[1]-c.y)/S.height]),box:O.box.map(q=>[(q[0]-c.x)/S.width,(q[1]-c.y)/S.height]),score:O.score}))}decodeBoxes(a,c,p){let m=cZ(f5(a,[0,0],[-1,1])),v=cZ(f5(a,[0,1],[-1,1])),b=cZ(f5(a,[0,2],[-1,1])),w=cZ(f5(a,[0,3],[-1,1]));m=EY(ES(m,p.width),c[0]),v=EY(ES(v,p.height),c[1]),b=ES(b,p.width*2),w=ES(w,p.height*2);const S=ET(Oq(m,b),[2016,1]),O=ET(Oq(v,w),[2016,1]),q=ET(EY(m,b),[2016,1]),H=ET(EY(v,w),[2016,1]);let j=ff([S,O,q,H],1);for(let $=0;$<7;$++){let J=cZ(f5(a,[0,4+$*2],[-1,1])),ee=cZ(f5(a,[0,4+$*2+1],[-1,1]));J=ET(EY(ES(J,p.width),c[0]),[2016,1]),ee=ET(EY(ES(ee,p.height),c[1]),[2016,1]),j=ff([j,J,ee],1)}return j}buildAnchors(a){const c=[8,16,16,16],p=[];let m=0;for(;m<4;){let v=0,b=m;for(;b<c.length&&c[b]===c[m];)v+=2,b++;const w=c[m],S=Math.ceil(a.height/w),O=Math.ceil(a.width/w);for(let q=0;q<S;++q)for(let H=0;H<O;++H)for(let j=0;j<v;++j)p.push({x:(H+.5)/O,y:(q+.5)/S});m=b}return p}async prepare(){const{width:a,height:c}=this.modelSize,p=Ot([1,c,a,3]),m=this.model.execute(p,"palm");await m.data(),p.dispose(),m.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}var wV;(u=>(u.add=(a,c)=>[a[0]+c[0],a[1]+c[1],a[2]+c[2]],u.sub=(a,c)=>[a[0]-c[0],a[1]-c[1],a[2]-c[2]],u.cross=(a,c)=>[a[1]*c[2]-a[2]*c[1],a[2]*c[0]-a[0]*c[2],a[0]*c[1]-a[1]*c[0]],u.lerp=(a,c,p)=>[a[0]+(c[0]-a[0])*p,a[1]+(c[1]-a[1])*p,a[2]+(c[2]-a[2])*p],u.scale=(a,c)=>[a[0]*c,a[1]*c,a[2]*c],u.negate=a=>[-a[0],-a[1],-a[2]],u.normalize=a=>(0,u.scale)(a,1/(0,u.length)(a)),u.normalizeToLen=(a,c)=>(0,u.scale)(a,c/(0,u.length)(a)),u.dot=(a,c)=>a[0]*c[0]+a[1]*c[1]+a[2]*c[2],u.lengthSqr=a=>a[0]**2+a[1]**2+a[2]**2,u.length=a=>Math.sqrt(a[0]**2+a[1]**2+a[2]**2)))(wV||(wV={}));class wd{constructor(a,c=!0){this.model=a,this.wrist=c,this.localMaxSize={width:256,height:256},this.circlePoints=[],this.colorWeights=[.5,1,.8],this.colorThresh=.05,this.edgeThresh=.003,this.edgeStop=.01,this.model=a,this.modelSize=a.inputs[0].shape?{width:a.inputs[0].shape[2],height:a.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.buildCircle(31)}async process(a,c){const[p,m]=[a.shape[1],a.shape[2]],{modelSize:v,modelRatio:b,localMaxSize:w}=this;return c.map(S=>{const O=[S.start[0]*m,S.start[1]*p],q=[S.end[0]*m,S.end[1]*p];let[H,j]=[q[0]-O[0],O[1]-q[1]];const $=Math.sqrt(H**2+j**2);H/=$,j/=$;const J=Math.atan2(H,j),ee=[.5*(S.box[0][0]+S.box[1][0])*m,.5*(S.box[0][1]+S.box[1][1])*p];let re=.5*(S.box[1][0]-S.box[0][0])*m,de=.5*(S.box[1][1]-S.box[0][1])*p;const Te=re/de/b;Te>1?re*=Te:de/=Te;const Me=[ee[1]-de,ee[0]-re,ee[1]+de,ee[0]+re],Ae=s2(()=>this.rotatedRect(a,Me,J,!1,v)),Ce=["Identity_2:0","Identity_1:0","Identity:0","Identity_3:0"],[Pe,je,Ne,Qe]=this.model.execute(Ae,Ce),Ct=Pe.dataSync(),dt=Qe.dataSync(),Xt=je.dataSync()[0],Gt=2*Ne.dataSync()[0]-1;let Vt=[];for(let Rt=0;Rt<21;Rt++)Vt.push([Ct[3*Rt+0]/v.width,Ct[3*Rt+1]/v.height,Ct[3*Rt+2]/v.width/.4]);const T0=[Vt[0][0],Vt[0][1]];let r0=T0[0],d0=T0[1];r0=(r0-.5)*2*re,d0=(d0-.5)*2*de,T0[0]=r0*j-d0*H+ee[0],T0[1]=r0*H+d0*j+ee[1];const Ut=[T0[1]-de,T0[0]-re,T0[1]+de,T0[0]+re],$0=this.wrist?s2(()=>this.rotatedRect(a,Ut,J,!0,w)):void 0;let Q0=[],Un=[];const b0=$0?s2(()=>{const Rt=cZ($0,[0]),Qt=Iu(Rt,[[.299,-.14713,.615],[.587,-.28886,-.51499],[.114,.436,-.10001]]),A0=[[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]],[[[-.5],[-.5],[-.5]],[[0],[0],[0]],[[.5],[.5],[.5]]],[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]]],J0=[[[[-.25],[-.25],[-.25]],[[-.5],[-.5],[-.5]],[[-.25],[-.25],[-.25]]],[[[0],[0],[0]],[[0],[0],[0]],[[0],[0],[0]]],[[[.25],[.25],[.25]],[[.5],[.5],[.5]],[[.25],[.25],[.25]]]],Pn=fl(Qt,A0,1,"same"),dx=fl(Qt,J0,1,"same"),Bn=fr(fv(Pn),2,!0),Wn=fr(fv(dx),2,!0),gx=fr(Eh(Pn,dx),2,!0),Jx=EY(Bn,Wn),er=fd(EY(fv(Oq(Bn,Wn)),Eh(fv(gx),4))),Cr=Eh(EY(Jx,er),.5);let Rr=fc([Oq(Cr,Wn),gx],2);Rr=ES(Rr,O1(Rr,2,!0));let xi=er;if(this.backend&&this.localMax){const ba=this.backend.compileAndRun(this.localMax,[xi,Rr]);xi=s1().makeTensorFromTensorInfo(ba)}const Nr=Eh(Ee(Qt,4,4,"valid"),this.colorWeights),rr=Nr.shape,ja=[rr[0]/2,rr[1]/2],xn=ET(Nr,[rr[0],rr[1],1,3]),io=cE(Nr,[ja[0]-3,ja[1]-4,0],[7,9,3]),Po=fX(O1(Oq(xn,ET(io,[-1,3])),3,!1),2,!0),Ka=cE(Nr,[ja[0]-4,8,0],[2,8,3]),Ji=cE(Nr,[ja[0]-4,rr[1]-16,0],[2,8,3]),W2=f1([ET(Ka,[-1,3]),ET(Ji,[-1,3])],0),Vc=fX(O1(Oq(xn,W2),3,!1),2,!0),Ql=OC(On(Of(Po,Vc),Of(Po,[this.colorThresh])),9,"max","same");return{yuv:Qt,rgb:Rt,edgeVal:xi,edgeXY:Rr,fg:Ql}}):void 0,X0=b0?s2(()=>{const Rt=OS(b0.edgeVal,4,4,"valid");let Qt=Ee(b0.edgeXY,4,4,"valid");Qt=ES(Qt,O1(Qt,2,!0));const A0=Rt.dataSync(),J0=Qt.dataSync(),Pn=b0.fg.dataSync(),dx=this.circlePoints.map(Cr=>this.evaluateLine([64/2,64/2],Cr,A0,J0,Pn));let Bn=0,Wn=0,gx=-1;for(let Cr=0;Cr<dx.length;Cr++){const Rr=dx[Cr].strengthL;for(let xi=Cr;xi<Cr+12&&xi<dx.length;xi++){const Nr=Rr+dx[xi].strengthR;Nr>=gx&&(gx=Nr,Bn=Cr,Wn=xi)}}Q0.push([...this.circlePoints[Math.round(.5*(Bn+Wn))]]);const Jx=dx[Bn].anchorsL.map(Cr=>[Cr[0],Cr[1]]),er=dx[Wn].anchorsR.map(Cr=>[Cr[0],Cr[1]]);Q0.push(...Jx),Q0.push(...er),Un.push(this.fitLine(Jx)),Un.push(this.fitLine(er))}):void 0;return Ae.dispose(),Pe.dispose(),Qe.dispose(),je.dispose(),Ne.dispose(),$0?.dispose(),b0?.yuv.dispose(),b0?.rgb.dispose(),b0?.edgeVal.dispose(),b0?.edgeXY.dispose(),{points:Vt,metricData:dt,score:Xt,handedness:Gt,radiusX:re,radiusY:de,angle:J,anchors:Q0,lines:Un,center:ee,wristCenter:T0,wristDebug:X0}}).map((S,O)=>{const{points:q,metricData:H,score:j,handedness:$,radiusX:J,radiusY:ee,angle:re,anchors:de,lines:Te,center:Me,wristCenter:Ae,wristDebug:Ce}=S,Pe=q.map((dt,Xt)=>({pixel:dt,metric:[H[3*Xt+0],H[3*Xt+1],H[3*Xt+2]]}));Pe.forEach(dt=>{dt.pixel[0]=(dt.pixel[0]-.5)*2*J,dt.pixel[1]=(dt.pixel[1]-.5)*2*ee,dt.pixel[2]*=2*J});const je=Math.sin(re),Ne=Math.cos(re);Pe.forEach(dt=>{const Xt=dt.pixel[0],Gt=dt.pixel[1];dt.pixel[0]=(Xt*Ne-Gt*je+Me[0])/m,dt.pixel[1]=(Xt*je+Gt*Ne+Me[1])/p,dt.pixel[2]/=m;const Vt=dt.metric[0],T0=dt.metric[1];dt.metric[0]=Vt*Ne-T0*je,dt.metric[1]=Vt*je+T0*Ne});const Qe=this.circlePoints.map(dt=>[dt[0]/64,dt[1]/64]);de.forEach(dt=>{dt[0]=(dt[0]+.5)/64,dt[1]=(dt[1]+.5)/64}),de.forEach(dt=>{const Xt=(dt[0]-.5)*2*J,Gt=(dt[1]-.5)*2*ee;dt[0]=(Xt*Ne-Gt*je+Ae[0])/m,dt[1]=(Xt*je+Gt*Ne+Ae[1])/p}),Te.forEach(dt=>{dt.point[0]=(dt.point[0]+.5)/64,dt.point[1]=(dt.point[1]+.5)/64});const Ct=this.normalizeLines(Te[0],Te[1],[.5,.5]);return Ct.forEach(dt=>{const Xt=(dt.point[0]-.5)*2*J,Gt=(dt.point[1]-.5)*2*ee;dt.point[0]=(Xt*Ne-Gt*je+Ae[0])/m,dt.point[1]=(Xt*je+Gt*Ne+Ae[1])/p;const Vt=dt.vector[0],T0=dt.vector[1];dt.vector[0]=Vt*Ne-T0*je,dt.vector[1]=Vt*je+T0*Ne}),{keypoints:Pe,score:j,handedness:$,wrist:{lines:Ct},debug:{box:c[O],anchors:de,circle:Qe,tensors:Ce}}})}evaluateLine(a,c,p,m,v){const b=[c[0]-a[0],c[1]-a[1]],w=this.buildLine(b[0],b[1]).slice(0,24),S=w.map(Me=>[Me[1],-Me[0]]),O=Math.sqrt(b[0]**2+b[1]**2);b[0]/=O,b[1]/=O;const q=[b[1],-b[0]];w.forEach(Me=>{Me[0]+=a[0],Me[1]+=a[1]});let H=[],j=[];const $=new Array(16).fill(0),J=new Array(16).fill(0);for(let Me=6;Me<w.length;Me++){const Ae=w[Me];let Ce=2,Pe=[0,0],je=-1,Ne=-1,Qe=[0,0];for(Ce=2;Ce<16;Ce++){Pe=[Ae[0]+S[Ce][0],Ae[1]+S[Ce][1]];const Ct=Pe[1]*64+Pe[0];if(v[Ct]<.5)break;if(p[Ct]<this.edgeThresh)continue;const dt=m[2*Ct],Xt=m[2*Ct+1];if(!(Math.abs(dt*q[0]+Xt*q[1])<.95)){if(p[Ct]>this.edgeStop){Ne=Ce,Qe=Pe,je=p[Ct];break}p[Ct]>je&&(Ne=Ce,Qe=Pe,je=p[Ct])}}for(Ne<16&&Ne>3&&(H.push([...Qe,Ne]),$[Ne]++),Ce=2,je=-1,Ne=-1,Qe=[0,0],Ce=2;Ce<16;Ce++){Pe=[Ae[0]-S[Ce][0],Ae[1]-S[Ce][1]];const Ct=Pe[1]*64+Pe[0];if(v[Ct]<.5)break;if(p[Ct]<this.edgeThresh)continue;const dt=m[2*Ct],Xt=m[2*Ct+1];if(!(Math.abs(dt*q[0]+Xt*q[1])<.95)){if(p[Ct]>this.edgeStop){Ne=Ce,Qe=Pe,je=p[Ct];break}p[Ct]>je&&(Ne=Ce,Qe=Pe,je=p[Ct])}}Ne<16&&Ne>3&&(j.push([...Qe,Ne]),J[Ne]++)}let ee=0,re=0,de=0,Te=0;for(let Me=1;Me<16;Me++){const Ae=.5*$[Me-1]+$[Me]+.5*$[Me+1],Ce=.5*J[Me-1]+J[Me]+.5*J[Me+1];Ae>ee&&(ee=Ae,de=Me),Ce>re&&(re=Ce,Te=Me)}return H=H.filter(Me=>Math.abs(Me[2]-de)<=1),j=j.filter(Me=>Math.abs(Me[2]-Te)<=1),{anchorsL:H,anchorsR:j,strengthL:ee,strengthR:re}}fitLine(a){const c=a.reduce((w,S)=>[w[0]+S[0],w[1]+S[1]],[0,0]);c[0]/=a.length,c[1]/=a.length;const p=a.reduce((w,S)=>{const O=[S[0]-c[0],S[1]-c[1]];return[w[0]+O[0]**2-O[1]**2,w[1]+2*O[0]*O[1]]},[0,0]),m=Math.sqrt(p[0]**2+p[1]**2),v=[Math.sqrt(.5*(m+p[0])),Math.sqrt(.5*(m-p[0]))],b=Math.sqrt(v[0]**2+v[1]**2);return v[0]/=b,v[1]/=b,p[1]<0&&(v[0]=-v[0]),{point:c,vector:v}}normalizeLines(a,c,p){const m=Pe=>[Pe[0]/Pe[2],Pe[1]/Pe[2],1],v=[...a.point,1],b=[...c.point,1],w=[...a.vector,0],S=[...c.vector,0],O=wV.lerp(w,S,.5),q=[O[1],-O[0],0],H=wV.cross(v,wV.add(v,w)),j=wV.cross(b,wV.add(b,S)),$=wV.cross(v,wV.add(v,q)),J=m(wV.cross($,j)),ee=wV.lerp(v,J,.5),re=[...p,1],de=wV.add(ee,wV.scale(O,wV.dot(O,wV.sub(re,ee)))),Te=wV.add(de,wV.scale(O,.15)),Me=wV.cross(Te,wV.add(Te,q)),Ae=m(wV.cross(H,Me)),Ce=m(wV.cross(j,Me));return[{point:[Ae[0],Ae[1]],vector:a.vector},{point:[Ce[0],Ce[1]],vector:c.vector},{point:Te,vector:O}]}buildLine(a,c){let[p,m]=[Math.abs(a),Math.abs(c)],v=!1;p<m&&([p,m]=[m,p],v=!0);let b=[],w=0,S=0,O=2*m,q=O-p;for(;w<p-2;w++)b.push([w,S]),q+=O,q>=0&&(S++,q-=2*p);return v&&(b=b.map(H=>[H[1],H[0]])),a<0&&b.forEach(H=>{H[0]*=-1}),c<0&&b.forEach(H=>{H[1]*=-1}),b}buildCircle(a){let c=a,p=0,m=3-2*a;for(;p<c;)this.circlePoints.push([c,p]),p++,m>0?(c--,m=m+4*(p-c)+10):m=m+4*p+6;p--;for(let v=p;v>=0;v--){const b=this.circlePoints[v];this.circlePoints.push([b[1],b[0]])}for(let v=2*p;v>=0;v--){const b=this.circlePoints[v];this.circlePoints.push([-b[0],b[1]])}this.circlePoints.forEach(v=>{v[0]+=32,v[1]+=32})}rotatedRect(a,c,p,m,v){const[b,w]=[c[2]-c[0],c[3]-c[1]],[S,O]=[(c[2]+c[0])*.5,(c[3]+c[1])*.5],[q,H]=[b/v.height,w/v.width],[j,$]=[Math.cos(p),Math.sin(p)],J=[j*H,-$*q,(-j*w+$*b)*.5+O,$*H,j*q,(-$*w-j*b)*.5+S,0,0];return Zi.transform(a,[J],"bilinear",m?"reflect":"constant",0,[v.height,v.width])}async prepare(){const{width:a,height:c}=this.modelSize,p=Ot([1,c,a,3]),m=this.model.execute(p);if(await Promise.all(m.map(async v=>{await v.data(),v.dispose()})),p.dispose(),s6()==="webgl"){const{width:v,height:b}=this.localMaxSize;this.backend=s8(),this.localMax={variableNames:["val","dir"],outputShape:[b,v,1],userCode:`
                    void main() {
                        ivec3 c = getOutputCoords();
                        float dx = getDir(c[0], c[1], 0);
                        float dy = getDir(c[0], c[1], 1);
                        vec2 d = vec2(dx, dy) / max(abs(dx), abs(dy));
                        vec2 cf = vec2(c[1], c[0]);
                        float v0 = getVal(round(cf.y - 2.0 * d.y),
                                          round(cf.x - 2.0 * d.x), 0);
                        float v1 = getVal(round(cf.y - d.y),
                                          round(cf.x - d.x), 0);
                        float v2 = getVal(round(cf.y), round(cf.x), 0);
                        float v3 = getVal(round(cf.x + d.y),
                                          round(cf.x + d.x), 0);
                        float v4 = getVal(round(cf.y + 2.0 * d.y),
                                          round(cf.x + 2.0 * d.x), 0);
                        float vmax = max(max(v0, v1), max(v3, v4));
                        setOutput(v2 >= vmax ? v2 : 0.0);
                    }
            `};const w=Ot([b,v,1]),S=this.backend.compileAndRun(this.localMax,[w,w]),O=s1().makeTensorFromTensorInfo(S);w.dispose(),O.dispose()}}async dispose(){var a;(a=this.model)==null||a.dispose()}}class wP{constructor(){this.freq=30,this.pixelParams={minCutOff:2,minCutOffD:4,beta:50},this.metricParams={minCutOff:.1,minCutOffD:1,beta:20},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(a,c,p=1){if(this.time>=c)return a;if(this.time!==0&&(this.freq=1/(c-this.time)),this.time=c,!this.raw||!this.smooth||!this.der)return this.raw=this.clonePose(a),this.smooth=this.clonePose(a),this.der={keypoints:a.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0]})),score:0,handedness:.5,wrist:{lines:a.wrist.lines.map(()=>({point:[0,0],vector:[0,0]}))}},this.clonePose(this.smooth);const m=[...this.smooth.keypoints[0].pixel];this.filterKeypoints(a.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,p);const v=[...this.smooth.keypoints[0].pixel],{raw:b,smooth:w,der:S}=this;for(let q=0;q<a.wrist.lines.length;q++){const H=a.wrist.lines[q],j=b.wrist.lines[q],$=S.wrist.lines[q],J=w.wrist.lines[q];if(isNaN(J.point[0])||isNaN(J.point[0])||isNaN(J.vector[0])||isNaN(J.vector[0])){J.point=[...H.point],J.vector=[...H.vector];continue}if(isNaN(H.point[0])||isNaN(H.point[0])||isNaN(H.vector[0])||isNaN(H.vector[0])){J.point[0]+=v[0]-m[0],J.point[1]+=v[1]-m[1];continue}this.filterCoord2D(H.point,j.point,$.point,J.point,p,{minCutOff:.5,minCutOffD:4,beta:75}),this.filterCoord2D(H.vector,j.vector,$.vector,J.vector,p,{minCutOff:.1,minCutOffD:.5,beta:10});const ee=Math.sqrt(J.vector[0]**2+J.vector[1]**2);J.vector[0]/=ee,J.vector[1]/=ee}const O=this.alpha(this.scoreCutOff);return this.smooth.score=this.smooth.score+O*(a.score-this.smooth.score),this.smooth.debug=a.debug&&{box:{box:[[...a.debug.box.box[0]],[...a.debug.box.box[1]]],points:a.debug.box.points.map(q=>[...q]),start:[...a.debug.box.start],end:[...a.debug.box.end]},circle:a.debug.circle,anchors:a.debug.anchors,tensors:a.debug.tensors},this.clonePose(this.smooth)}filterKeypoints(a,c,p,m,v){for(let b=0;b<a.length;b++)this.filterCoord3D(a[b].pixel,c[b].pixel,p[b].pixel,m[b].pixel,v,this.pixelParams),this.filterCoord3D(a[b].metric,c[b].metric,p[b].metric,m[b].metric,v,this.metricParams)}filterCoord3D(a,c,p,m,v,b){const w=[(a[0]-m[0])*v*this.freq,(a[1]-m[1])*v*this.freq,(a[2]-m[2])*v*this.freq],S=this.alpha(b.minCutOffD);p[0]=p[0]+S*(w[0]-p[0]),p[1]=p[1]+S*(w[1]-p[1]),p[2]=p[2]+S*(w[2]-p[2]);const O=[this.alpha(b.minCutOff+b.beta*Math.abs(p[0])),this.alpha(b.minCutOff+b.beta*Math.abs(p[1])),this.alpha(b.minCutOff+b.beta*Math.abs(p[2]))];m[0]=m[0]+O[0]*(a[0]-m[0]),m[1]=m[1]+O[1]*(a[1]-m[1]),m[2]=m[2]+O[2]*(a[2]-m[2]),c[0]=a[0],c[1]=a[1],c[2]=a[2]}filterCoord2D(a,c,p,m,v,b){const w=[(a[0]-m[0])*v*this.freq,(a[1]-m[1])*v*this.freq],S=this.alpha(b.minCutOffD);p[0]=p[0]+S*(w[0]-p[0]),p[1]=p[1]+S*(w[1]-p[1]);const O=[this.alpha(b.minCutOff+b.beta*Math.abs(p[0])),this.alpha(b.minCutOff+b.beta*Math.abs(p[1]))];m[0]=m[0]+O[0]*(a[0]-m[0]),m[1]=m[1]+O[1]*(a[1]-m[1]),c[0]=a[0],c[1]=a[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(a){return 1/(1+this.freq/(2*Math.PI*a))}clonePose(a){return{keypoints:a.keypoints.map(c=>({pixel:[...c.pixel],metric:[...c.metric]})),score:a.score,handedness:a.handedness,wrist:{lines:a.wrist.lines.map(c=>({point:[...c.point],vector:[...c.vector]}))},debug:a.debug&&{box:{box:[[...a.debug.box.box[0]],[...a.debug.box.box[1]]],points:a.debug.box.points.map(c=>[...c]),start:[...a.debug.box.start],end:[...a.debug.box.end]},circle:a.debug.circle.map(c=>[...c]),anchors:a.debug.anchors.map(c=>[...c]),tensors:a.debug.tensors}}}}class wv{constructor(){this.handTracks=[],this.handFilters=[],this.angle=.05555555555555555*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.handScore=.55}async process(a,c){var p,m;const v=s2(()=>{const J=IA(Ie(a,3),"float32"),ee=ES(J,255);return O3(ee,0)}),[b,w]=[v.shape[1],v.shape[2]],S=(J,ee)=>{const re=[J[0]*w,J[1]*b],de=[ee[0]*w,ee[1]*b];let[Te,Me]=[de[0]-re[0],re[1]-de[1]];const Ae=Math.sqrt(Te**2+Me**2);return Te/=Ae,Me/=Ae,[Te,Me]},O=(J,ee,re,de,Te,Me)=>{const Ae=[.5*(J[0][0]+J[1][0])*w,.5*(J[0][1]+J[1][1])*b],Ce={width:(J[1][0]-J[0][0])*w,height:(J[1][1]-J[0][1])*b},[Pe,je]=S(ee,re),Ne=[Te*Ce.width,Me*Ce.height];Ae[0]+=Ne[0]*je-Ne[1]*Pe,Ae[1]+=Ne[0]*Pe+Ne[1]*je,Ae[0]/=w,Ae[1]/=b;const Qe=.5*de*Math.max(Ce.width,Ce.height);let Ct=Qe/w,dt=Qe/b;return[[Ae[0]-Ct,Ae[1]-dt],[Ae[0]+Ct,Ae[1]+dt]]};if(this.handTracks.length===0){const J=await((p=this.palmDetector)==null?void 0:p.process(v))||[];this.handTracks=J.map(ee=>({box:O(ee.box,ee.points[0],ee.points[2],2.6,0,-.5),points:ee.points,start:ee.points[0],end:ee.points[2]})),this.handTracks.forEach(()=>this.handFilters.push(new wP))}const q=this.handTracks.length>0?await((m=this.handDetector)==null?void 0:m.process(v,this.handTracks))||[]:[];q.forEach((J,ee)=>{if(c===void 0)return;const re=w/b,de=this.handTracks[ee].box[1][0]-this.handTracks[ee].box[0][0],Te=(this.handTracks[ee].box[1][1]-this.handTracks[ee].box[0][1])/re,Me=Math.sqrt(de*de+Te*Te)*(1+re);q[ee]=this.handFilters[ee].filter(J,c,1/Me)}),v.dispose();const H=[],j=[],$=[];for(let J=0;J<q.length;J++){const ee=q[J],{keypoints:re,score:de}=ee;if(de<this.handScore)continue;const Te=[re[0].pixel[0],re[0].pixel[1]],Me=[re[5].pixel[0],re[5].pixel[1]],Ae=[re[10].pixel[0],re[10].pixel[1]],Ce=[re[14].pixel[0],re[14].pixel[1]],Pe=[.25*Me[0]+.5*Ae[0]+.25*Ce[0],.25*Me[1]+.5*Ae[1]+.25*Ce[1]],[je,Ne]=S(Te,Pe),[Qe,Ct]=[-je,Ne],dt=[...re.slice(0,4),...re.slice(5,7),...re.slice(9,11),...re.slice(13,15),...re.slice(17,19)].map(Q0=>[Q0.pixel[0],Q0.pixel[1]]),Xt=[[10,10],[-10,-10]];for(let Q0=0;Q0<dt.length;Q0++)Xt[0][0]=Math.min(Xt[0][0],dt[Q0][0]),Xt[0][1]=Math.min(Xt[0][1],dt[Q0][1]),Xt[1][0]=Math.max(Xt[1][0],dt[Q0][0]),Xt[1][1]=Math.max(Xt[1][1],dt[Q0][1]);const Gt=[(Xt[0][0]+Xt[1][0])*.5,(Xt[0][1]+Xt[1][1])*.5],Vt=[[10,10],[-10,-10]];for(let Q0=0;Q0<dt.length;Q0++){const Un=[(dt[Q0][0]-Gt[0])*w,(dt[Q0][1]-Gt[1])*b],b0=[Ct*Un[0]-Qe*Un[1],Qe*Un[0]+Ct*Un[1]];Vt[0][0]=Math.min(Vt[0][0],b0[0]),Vt[0][1]=Math.min(Vt[0][1],b0[1]),Vt[1][0]=Math.max(Vt[1][0],b0[0]),Vt[1][1]=Math.max(Vt[1][1],b0[1])}const T0=[(Vt[0][0]+Vt[1][0])*.5,(Vt[0][1]+Vt[1][1])*.5],r0=[(Ne*T0[0]-je*T0[1])/w+Gt[0],(je*T0[0]+Ne*T0[1])/b+Gt[1]],d0=.5*(Vt[1][0]-Vt[0][0])/w,Ut=.5*(Vt[1][1]-Vt[0][1])/b,$0=O([[r0[0]-d0,Gt[1]-Ut],[r0[0]+d0,Gt[1]+Ut]],Te,Pe,2,0,-.1);Ld($0,this.handTracks[J].box)<.5||(this.align(q[J].keypoints),H.push({box:$0,start:Te,end:Pe,points:[]}),j.push(this.handFilters[J]),$.push(q[J]))}return this.handTracks=H,this.handFilters=j,$}align(a){const c=2*Math.tan(.5*this.angle),p=this.ratio*c,m=a.map(O=>{const q=[(O.pixel[0]-.5)*p,(O.pixel[1]-.5)*c],H=[...O.metric];return{pixel:q,world:H}}),v=[];m.forEach(O=>{v.push([0,1,-O.pixel[1],O.world[1]-O.pixel[1]*O.world[2]],[-1,0,O.pixel[0],O.pixel[0]*O.world[2]-O.world[0]])});const{V:b}=wf.svd(v),w=b[3][3],S=[b[0][3]/w,b[1][3]/w,b[2][3]/w];a.forEach(O=>{O.metric[0]+=S[0],O.metric[1]+=S[1],O.metric[2]+=S[2]}),a.forEach(O=>{const q=[(O.pixel[0]-.5)*p,(O.pixel[1]-.5)*c],H=O.metric;H[0]=q[0]*H[2],H[1]=q[1]*H[2],O.metric[1]=-O.metric[1],O.metric[2]=-O.metric[2]})}setCamera(a,c,p=1){this.angle=a,this.ratio=c,this.near=p}async init(a,c="./",p=!1,m="webgl"){const v=await Lr({locateFile:q=>c+q});v.Loader.prototype.promisify=function(q,...H){return q.call(this,...H),new Promise(j=>{const $=setInterval(()=>{if(this.ready)return clearInterval($),j(this.status)},5)})},v.Loader.prototype.load=function(q){return this.promisify(this.loadAsync,q,p)},v.Loader.prototype.remove=function(q){return this.promisify(this.removeAsync,q)},v.DictLoader.prototype.loadDict=function(q){return this.promisify(this.loadDictAsync,a,q)};const b=new v.ParseLoader(c);if(p||await b.remove("hand.wasm"),!await b.loadDict(["hand.wasm"])||!await b.load("hand.wasm")||!b.parse())return;Hn().set("WEBGL_USE_SHAPES_UNIFORMS",!0),s0(),await s5(m);const w={weightUrlConverter:async q=>q,fetchFunc:async q=>{const H=new Blob([b.file(q)]);return fetch(URL.createObjectURL(H))}},S=await Fr("palmmodel.def",w),O=await Fr("handmodel.def",w);this.palmDetector=new wb(S),this.handDetector=new wd(O)}reset(){this.handTracks=[],this.handFilters=[]}async prepare(){var a,c;Hn().set("ENGINE_COMPILE_ONLY",!0),await((a=this.palmDetector)==null?void 0:a.prepare()),await((c=this.handDetector)==null?void 0:c.prepare());const p=s8();p instanceof lJ&&(p.checkCompileCompletion(),p.getUniformLocations()),Hn().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var a;this.reset(),(a=this.palmDetector)==null||a.dispose()}}const wT={lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyebrowUpper:[156,70,63,105,66,107,55],rightEyebrowLower:[124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyebrowUpper:[383,300,293,334,296,336,285],leftEyebrowLower:[353,276,283,282,295],leftEyeIris:[468,469,470,471,472]},wr=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],we=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],wB=[[0,-.03406405,.05979506],[0,-.01126867,.07475604],[0,-.02089025,.06058267],[-.00463928,.00955356,.06633583],[0,-.00463172,.0758658],[0,.00365668,.0724287],[0,.02473254,.05788627],[-.04253081,.02577645,.03279702],[0,.04019041,.05284765],[0,.04885978,.05385259],[0,.08261777,.04481537],[0,-.03706812,.05864923],[0,-.03918302,.05569429],[0,-.03994437,.05219482],[0,-.04542401,.05404753],[0,-.04745578,.05529456],[0,-.05019568,.05601447],[0,-.05365124,.0553544],[0,-.06149625,.05071371],[0,-.01501096,.07112196],[-.00416106,-.0146645,.06447657],[-.0708796,.05434801,99621e-8],[-.02628638,.02035898,.03848121],[-.03198363,.01985814,.03796952],[-.03775151,.02039402,.03646194],[-.04465819,.02422949,.03155169],[-.02164288,.02189867,.03851822],[-.03208229,.03223925,.04115823],[-.02673803,.03205336,.04092203],[-.03745193,.03165285,.03972409],[-.04161018,.03059068,.03719554],[-.05062005,.01934418,.02776093],[-.02266659,-.07425769,.04389811],[-.04445859,.0266399,.03173422],[-.0721453,.02263009,7315e-7],[-.05799793,.02349546,.02204059],[-.02844939,-.00720869,.0443313],[-.00711452,-.03329356,.05877044],[-.00606033,-.03924563,.05444922],[-.01431615,-.03500954,.05496188],[-.0191491,-.03803147,.05028929],[-.01131043,-.03973938,.05189647],[-.01563548,-.04082763,.04842262],[-.02650112,-.05003649,.04188482],[-.00427049,-.01094135,.07360528],[-.00496396,-.0047566,.07440358],[-.05253307,.03881582,.0336316],[-.01718698,.00974608,.04558359],[-.01608635,-.00942517,.05814193],[-.01651267,-.00610869,.05581319],[-.04765501,-.00701555,.03534632],[-.00478306,.00295764,.07101013],[-.03734964,.04508229,.04550455],[-.04588603,.04302036,.04048485],[-.06279331,.06615427,.01425851],[-.01220941,.04142164,.05106035],[-.02193489,.03100317,.04000575],[-.03102642,-.04352985,.04095904],[-.06719682,-.04788644,-.01745402],[-.01193824,-.01306796,.05737746],[-.00729766,-.01593713,.05833207],[-.02456206,-.04342622,.04283883],[-.02204823,-.04304509,.04162498],[-.04985894,.0480246,.03751978],[-.01592294,-.0125771,.05456949],[-.02644548,.04524653,.0492156],[-.02760292,.0510097,.05015991],[-.03523964,.08005974,.03729165],[-.05599763,.05715469,.0272426],[-.03063932,.06566143,.04529982],[-.05720968,.04254583,.02830853],[-.06374393,.04785589,.01591692],[-.00672728,-.03688017,.05737803],[-.0126256,-.03787692,.05417778],[-.01732553,-.03952768,.05000578],[-.01043625,-.01464974,.05662455],[-.02321234,-.0432907,.04258155],[-.02056846,-.04477672,.04520882],[-.02153084,-.04276323,.04038092],[-.00946874,-.0103525,.06512274],[-.01469132,-.04036351,.04604907],[-.0102434,-.03989852,.04926693],[-.00533422,-.03993222,.05138201],[-.0076972,-.06095395,.04985882],[-.00699606,-.05291851,.05448303],[-.00669687,-.0494977,.05509611],[-.00630947,-.04695102,.0544937],[-.00583218,-.04517983,.05339869],[-.0153717,-.04423207,.04745469],[-.016156,-.04475943,.04813631],[-.01729053,-.0461868,.04854462],[-.01838624,-.04828747,.04823736],[-.0236825,-.03106238,.04868095],[-.07542244,-.01049282,-.02431321],[0,-.01724004,.0660139],[-.01826614,-.04399532,.0439902],[-.01929558,-.04411831,.04497051],[-.00597442,-.02013687,.05866456],[-.01405627,-.01714197,.05241086],[-.00662449,-.01819322,.05863759],[-.02342339,.00572221,.04294303],[-.03327324,.00104862,.0411386],[-.01726175,-.00919166,.05273354],[-.05133204,.07485601,.02660443],[-.04538641,.06319907,.03683425],[-.03986562,.05109486,.04466315],[-.02169681,-.05440434,.04455873],[-.01395634,.05011962,.05316032],[-.016195,.06599216,.04921107],[-.01891399,.08236376,.04274999],[-.04195832,.02235205,.03375099],[-.05733342,.01411738,.02431726],[-.01859888,.02355756,.03843182],[-.04988612,.03074653,.03083858],[-.01303263,.01416452,.04831091],[-.01305757,-.0067278,.06415959],[-.0646517,.00937119,.01689873],[-.05258659,.00945811,.02974312],[-.04432338,.00722095,.03522615],[-.03300681,.0086164,.03872784],[-.02430178,.01131491,.04039035],[-.01820731,.01467953,.04224124],[-.00563221,.02307693,.05566789],[-.06338145,-.00529279,.01881175],[-.05587698,.03208071,.0268784],[-.00242624,-.01462858,.07071491],[-.01611251,.00339325,.0489542],[-.07743095,.02364999,-.02005167],[-.01391142,.01851047,.04448999],[-.01785794,-.00978285,.0485047],[-.04670959,.0266446,.03084075],[-.0133397,-.00283762,.06097047],[-.07270896,-.02890916,-.02252455],[-.01856432,.02585245,.03757904],[-.00923388,73075e-8,.06671944],[-.05000589,-.06135128,.01892522],[-.05085276,-.0717859,.0071471],[-.07159291,-.0081182,-72044e-8],[-.05843051,-.05248023,.0092409],[-.06847258,.03662916,.00724696],[-.02412942,-.08258854,.04119211],[-.00179909,-.01689865,.06573301],[-.02103655,-.00163946,.04566119],[-.06407571,.02236021,.01560843],[-.03670075,.02360153,.0363523],[-.03177186,.02294264,.03775705],[-.02196121,-.04598323,.04479785],[-.06234883,-.0194443,.01663542],[-.01292924,-.09295921,.04094062],[-.03210651,-.08533278,.02802],[-.04068926,-.07993109,.01925118],[0,.06545389,.05027312],[0,-.09403378,.0426449],[-.02724032,.02315802,.03777151],[-.0228846,.0239889,.03697603],[-.01998311,.02496546,.03689148],[-.0613004,.03399261,.02038516],[-.0228846,.02886503,.03775031],[-.02724032,.02961809,.03871767],[-.03177186,.02964135,.03876973],[-.03670075,.02927713,.03724325],[-.04018389,.02857356,.03482983],[-.07555811,.04106811,-.00991916],[-.04018389,.02483694,.03440898],[0,-.02521946,.05932265],[-.01776217,-.02683947,.05213116],[-.01222237,-.01182445,.05952464],[-.00731493,-.02536684,.05815343],[0,.03271026,.05236015],[-.04135272,-.06996639,.02671969],[-.03311811,-.07660816,.03382962],[-.01313701,-.08639995,.04702454],[-.05940524,-.06223629,-.00631469],[-.01998311,.02743837,.0374403],[-.00901447,.01236991,.05754256],[0,-.08765243,.04891439],[-.02308977,-.08974197,.03609069],[-.06954154,-.02439843,-.00131163],[-.01098819,-.04458788,.05120726],[-.01181124,-.04579997,.05189563],[-.01255818,-.04787901,.0523705],[-.01325085,-.05106508,.05205009],[-.01546388,-.05819392,.04757892],[-.01953754,-.04183893,.04431712],[-.02117802,-.04137093,.04555095],[-.02285339,-.04051196,.04582437],[-.0285016,-.03665721,.04484993],[-.05278538,-.02238942,.02861224],[-.00946709,.01907627,.0519678],[-.01314173,.03104912,.04231405],[-.0178,.02859999,.03881555],[-.0184511,-.0409888,.04247263],[-.05436186,-.04030482,.02109851],[-.00766444,.0318213,.04861453],[-.01938616,-.06614411,.04521083],[0,.01059412,.06774605],[-.00516573,.01583571,.06148363],[0,.01728368,.0631675],[-.01246815,.00230296,.05681035],[0,-.07942194,.05181172],[0,-.069915,.05153477],[-.00997827,-.06930922,.04979575],[-.03288807,-.05382515,.03795751],[-.02311631,-.01566238,.04590084],[-.0268025,-.06111567,.04096151],[-.03832928,-.01537327,.04137731],[-.0296186,-.02274216,.04440943],[-.04386901,-.02683286,.03643886],[-.01217295,-.07834466,.04969285],[-.01542374,-.00136843,.05201008],[-.03878377,-.06041764,.03311078],[-.03084037,-.06809843,.03814194],[-.03747321,-.04503546,.03726452],[-.06094129,-.03205992,.01473481],[-.04588995,-.04728726,.0298322],[-.06583231,-.03941269,70267e-8],[-.0349258,-.03195821,.04130198],[-.01255543,.0080234,.05307551],[-.01126122,-.00933603,.06538785],[-.01443109,-.01142775,.05905127],[-.00923043,-.00529043,.07003423],[-.01755386,.03529116,.04327697],[-.02632589,.03713828,.0436463],[-.03388062,.03721975,.04309029],[-.04075766,.03675412,.04076063],[-.0462291,.0347469,.03646322],[-.05171755,.02535752,.02670867],[-.0729733,.00763172,-48769e-8],[-.04706828,.01651,.03109532],[-.04071712,.01476821,.03476944],[-.03269817,.01470658,.03731945],[-.02527572,.0161731,.03865444],[-.01970894,.01858504,.03961782],[-.01579543,.0209794,.04084997],[-.07664182,.00673132,-.02435867],[-.01397041,-.0134014,.05630378],[-.00884838,.00658739,.06233231],[-.00767097,-.00968036,.07077932],[-.00460213,-.01334107,.06787448],[-.00748618,-.01067995,.06798303],[-.01236408,-.01585569,.05480489],[-.00387306,-.01409991,.06957705],[-.00319925,-.01607932,.06508676],[-.01639633,.02556297,.03863737],[-.01255645,.02467143,.042038],[-.01031362,.02382662,.04615849],[-.04253081,.02772296,.03315305],[-.0453,.0291,.03339685],[.00463928,.00955356,.06633583],[.04253081,.02577645,.03279702],[.00416106,-.0146645,.06447657],[.0708796,.05434801,99621e-8],[.02628638,.02035898,.03848121],[.03198363,.01985814,.03796952],[.03775151,.02039402,.03646194],[.04465819,.02422949,.03155169],[.02164288,.02189867,.03851822],[.03208229,.03223925,.04115823],[.02673803,.03205336,.04092203],[.03745193,.03165285,.03972409],[.04161018,.03059068,.03719554],[.05062005,.01934418,.02776093],[.02266659,-.07425769,.04389811],[.04445859,.0266399,.03173422],[.0721453,.02263009,7315e-7],[.05799793,.02349546,.02204059],[.02844939,-.00720869,.0443313],[.00711452,-.03329356,.05877044],[.00606033,-.03924563,.05444922],[.01431615,-.03500954,.05496188],[.0191491,-.03803147,.05028929],[.01131043,-.03973938,.05189647],[.01563548,-.04082763,.04842262],[.02650112,-.05003649,.04188482],[.00427049,-.01094135,.07360528],[.00496396,-.0047566,.07440358],[.05253307,.03881582,.0336316],[.01718698,.00974608,.04558359],[.01608635,-.00942517,.05814193],[.01651267,-.00610869,.05581319],[.04765501,-.00701555,.03534632],[.00478306,.00295764,.07101013],[.03734964,.04508229,.04550455],[.04588603,.04302036,.04048485],[.06279331,.06615427,.01425851],[.01220941,.04142164,.05106035],[.02193489,.03100317,.04000575],[.03102642,-.04352985,.04095904],[.06719682,-.04788644,-.01745402],[.01193824,-.01306796,.05737746],[.00729766,-.01593713,.05833207],[.02456206,-.04342622,.04283883],[.02204823,-.04304509,.04162498],[.04985894,.0480246,.03751978],[.01592294,-.0125771,.05456949],[.02644548,.04524653,.0492156],[.02760292,.0510097,.05015991],[.03523964,.08005974,.03729165],[.05599763,.05715469,.0272426],[.03063932,.06566143,.04529982],[.05720968,.04254583,.02830853],[.06374393,.04785589,.01591692],[.00672728,-.03688017,.05737803],[.0126256,-.03787692,.05417778],[.01732553,-.03952768,.05000578],[.01043625,-.01464974,.05662455],[.02321234,-.0432907,.04258155],[.02056846,-.04477672,.04520882],[.02153084,-.04276323,.04038092],[.00946874,-.0103525,.06512274],[.01469132,-.04036351,.04604907],[.0102434,-.03989852,.04926693],[.00533422,-.03993222,.05138201],[.0076972,-.06095395,.04985882],[.00699606,-.05291851,.05448303],[.00669687,-.0494977,.05509611],[.00630947,-.04695102,.0544937],[.00583218,-.04517983,.05339869],[.0153717,-.04423207,.04745469],[.016156,-.04475943,.04813631],[.01729053,-.0461868,.04854462],[.01838624,-.04828747,.04823736],[.0236825,-.03106238,.04868095],[.07542244,-.01049282,-.02431321],[.01826614,-.04399532,.0439902],[.01929558,-.04411831,.04497051],[.00597442,-.02013687,.05866456],[.01405627,-.01714197,.05241086],[.00662449,-.01819322,.05863759],[.02342339,.00572221,.04294303],[.03327324,.00104862,.0411386],[.01726175,-.00919166,.05273354],[.05133204,.07485601,.02660443],[.04538641,.06319907,.03683425],[.03986562,.05109486,.04466315],[.02169681,-.05440434,.04455873],[.01395634,.05011962,.05316032],[.016195,.06599216,.04921107],[.01891399,.08236376,.04274999],[.04195832,.02235205,.03375099],[.05733342,.01411738,.02431726],[.01859888,.02355756,.03843182],[.04988612,.03074653,.03083858],[.01303263,.01416452,.04831091],[.01305757,-.0067278,.06415959],[.0646517,.00937119,.01689873],[.05258659,.00945811,.02974312],[.04432338,.00722095,.03522615],[.03300681,.0086164,.03872784],[.02430178,.01131491,.04039035],[.01820731,.01467953,.04224124],[.00563221,.02307693,.05566789],[.06338145,-.00529279,.01881175],[.05587698,.03208071,.0268784],[.00242624,-.01462858,.07071491],[.01611251,.00339325,.0489542],[.07743095,.02364999,-.02005167],[.01391142,.01851047,.04448999],[.01785794,-.00978285,.0485047],[.04670959,.0266446,.03084075],[.0133397,-.00283762,.06097047],[.07270896,-.02890916,-.02252455],[.01856432,.02585245,.03757904],[.00923388,73075e-8,.06671944],[.05000589,-.06135128,.01892522],[.05085276,-.0717859,.0071471],[.07159291,-.0081182,-72044e-8],[.05843051,-.05248023,.0092409],[.06847258,.03662916,.00724696],[.02412942,-.08258854,.04119211],[.00179909,-.01689865,.06573301],[.02103655,-.00163946,.04566119],[.06407571,.02236021,.01560843],[.03670075,.02360153,.0363523],[.03177186,.02294264,.03775705],[.02196121,-.04598323,.04479785],[.06234883,-.0194443,.01663542],[.01292924,-.09295921,.04094062],[.03210651,-.08533278,.02802],[.04068926,-.07993109,.01925118],[.02724032,.02315802,.03777151],[.0228846,.0239889,.03697603],[.01998311,.02496546,.03689148],[.0613004,.03399261,.02038516],[.0228846,.02886503,.03775031],[.02724032,.02961809,.03871767],[.03177186,.02964135,.03876973],[.03670075,.02927713,.03724325],[.04018389,.02857356,.03482983],[.07555811,.04106811,-.00991916],[.04018389,.02483694,.03440898],[.01776217,-.02683947,.05213116],[.01222237,-.01182445,.05952464],[.00731493,-.02536684,.05815343],[.04135272,-.06996639,.02671969],[.03311811,-.07660816,.03382962],[.01313701,-.08639995,.04702454],[.05940524,-.06223629,-.00631469],[.01998311,.02743837,.0374403],[.00901447,.01236991,.05754256],[.02308977,-.08974197,.03609069],[.06954154,-.02439843,-.00131163],[.01098819,-.04458788,.05120726],[.01181124,-.04579997,.05189563],[.01255818,-.04787901,.0523705],[.01325085,-.05106508,.05205009],[.01546388,-.05819392,.04757892],[.01953754,-.04183893,.04431712],[.02117802,-.04137093,.04555095],[.02285339,-.04051196,.04582437],[.0285016,-.03665721,.04484993],[.05278538,-.02238942,.02861224],[.00946709,.01907627,.0519678],[.01314173,.03104912,.04231405],[.0178,.02859999,.03881555],[.0184511,-.0409888,.04247263],[.05436186,-.04030482,.02109851],[.00766444,.0318213,.04861453],[.01938616,-.06614411,.04521083],[.00516573,.01583571,.06148363],[.01246815,.00230296,.05681035],[.00997827,-.06930922,.04979575],[.03288807,-.05382515,.03795751],[.02311631,-.01566238,.04590084],[.0268025,-.06111567,.04096151],[.03832928,-.01537327,.04137731],[.0296186,-.02274216,.04440943],[.04386901,-.02683286,.03643886],[.01217295,-.07834466,.04969285],[.01542374,-.00136843,.05201008],[.03878377,-.06041764,.03311078],[.03084037,-.06809843,.03814194],[.03747321,-.04503546,.03726452],[.06094129,-.03205992,.01473481],[.04588995,-.04728726,.0298322],[.06583231,-.03941269,70267e-8],[.0349258,-.03195821,.04130198],[.01255543,.0080234,.05307551],[.01126122,-.00933603,.06538785],[.01443109,-.01142775,.05905127],[.00923043,-.00529043,.07003423],[.01755386,.03529116,.04327697],[.02632589,.03713828,.0436463],[.03388062,.03721975,.04309029],[.04075766,.03675412,.04076063],[.0462291,.0347469,.03646322],[.05171755,.02535752,.02670867],[.0729733,.00763172,-48769e-8],[.04706828,.01651,.03109532],[.04071712,.01476821,.03476944],[.03269817,.01470658,.03731945],[.02527572,.0161731,.03865444],[.01970894,.01858504,.03961782],[.01579543,.0209794,.04084997],[.07664182,.00673132,-.02435867],[.01397041,-.0134014,.05630378],[.00884838,.00658739,.06233231],[.00767097,-.00968036,.07077932],[.00460213,-.01334107,.06787448],[.00748618,-.01067995,.06798303],[.01236408,-.01585569,.05480489],[.00387306,-.01409991,.06957705],[.00319925,-.01607932,.06508676],[.01639633,.02556297,.03863737],[.01255645,.02467143,.042038],[.01031362,.02382662,.04615849],[.04253081,.02772296,.03315305],[.0453,.0291,.03339685]];class wN{constructor(){this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.meancolor",this.canvas.hidden=!0,this.canvas.width=1,this.canvas.height=1,this.context=this.canvas.getContext("2d",{alpha:!1,desynchronized:!0})}mean(a){if(!this.context)return;this.context.drawImage(a,0,0,1,1);const c=this.context.getImageData(0,0,1,1);return[c.data[0],c.data[1],c.data[2]]}brightness(a){const c=this.mean(a);return c?(.2989*c[0]+.587*c[1]+.1141*c[2])/255:void 0}dispose(){this.context=null,this.canvas&&document.removeChild(this.canvas),delete this.canvas}}},924:function(u,a,c){"use strict";var p=c(210),m=c(559),v=m(p("String.prototype.indexOf"));u.exports=function(w,S){var O=p(w,!!S);return typeof O=="function"&&v(w,".prototype.")>-1?m(O):O}},559:function(u,a,c){"use strict";var p=c(612),m=c(210),v=c(771),b=m("%TypeError%"),w=m("%Function.prototype.apply%"),S=m("%Function.prototype.call%"),O=m("%Reflect.apply%",!0)||p.call(S,w),q=m("%Object.defineProperty%",!0),H=m("%Math.max%");if(q)try{q({},"a",{value:1})}catch{q=null}u.exports=function(J){if(typeof J!="function")throw new b("a function is required");var ee=O(p,S,arguments);return v(ee,1+H(0,J.length-(arguments.length-1)),!0)};var j=function(){return O(p,w,arguments)};q?q(u.exports,"apply",{value:j}):u.exports.apply=j},296:function(u,a,c){"use strict";var p=c(44)(),m=c(210),v=p&&m("%Object.defineProperty%",!0);if(v)try{v({},"a",{value:1})}catch{v=!1}var b=m("%SyntaxError%"),w=m("%TypeError%"),S=c(275);u.exports=function(q,H,j){if(!q||typeof q!="object"&&typeof q!="function")throw new w("`obj` must be an object or a function`");if(typeof H!="string"&&typeof H!="symbol")throw new w("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new w("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new w("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new w("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new w("`loose`, if provided, must be a boolean");var $=arguments.length>3?arguments[3]:null,J=arguments.length>4?arguments[4]:null,ee=arguments.length>5?arguments[5]:null,re=arguments.length>6?arguments[6]:!1,de=!!S&&S(q,H);if(v)v(q,H,{configurable:ee===null&&de?de.configurable:!ee,enumerable:$===null&&de?de.enumerable:!$,value:j,writable:J===null&&de?de.writable:!J});else if(re||!$&&!J&&!ee)q[H]=j;else throw new b("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")}},187:function(u){"use strict";var a=typeof Reflect=="object"?Reflect:null,c=a&&typeof a.apply=="function"?a.apply:function(Pe,je,Ne){return Function.prototype.apply.call(Pe,je,Ne)},p;a&&typeof a.ownKeys=="function"?p=a.ownKeys:Object.getOwnPropertySymbols?p=function(Pe){return Object.getOwnPropertyNames(Pe).concat(Object.getOwnPropertySymbols(Pe))}:p=function(Pe){return Object.getOwnPropertyNames(Pe)};function m(Ce){console&&console.warn&&console.warn(Ce)}var v=Number.isNaN||function(Pe){return Pe!==Pe};function b(){b.init.call(this)}u.exports=b,u.exports.once=Te,b.EventEmitter=b,b.prototype._events=void 0,b.prototype._eventsCount=0,b.prototype._maxListeners=void 0;var w=10;function S(Ce){if(typeof Ce!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof Ce)}Object.defineProperty(b,"defaultMaxListeners",{enumerable:!0,get:function(){return w},set:function(Ce){if(typeof Ce!="number"||Ce<0||v(Ce))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+Ce+".");w=Ce}}),b.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},b.prototype.setMaxListeners=function(Pe){if(typeof Pe!="number"||Pe<0||v(Pe))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+Pe+".");return this._maxListeners=Pe,this};function O(Ce){return Ce._maxListeners===void 0?b.defaultMaxListeners:Ce._maxListeners}b.prototype.getMaxListeners=function(){return O(this)},b.prototype.emit=function(Pe){for(var je=[],Ne=1;Ne<arguments.length;Ne++)je.push(arguments[Ne]);var Qe=Pe==="error",Ct=this._events;if(Ct!==void 0)Qe=Qe&&Ct.error===void 0;else if(!Qe)return!1;if(Qe){var dt;if(je.length>0&&(dt=je[0]),dt instanceof Error)throw dt;var Xt=new Error("Unhandled error."+(dt?" ("+dt.message+")":""));throw Xt.context=dt,Xt}var Gt=Ct[Pe];if(Gt===void 0)return!1;if(typeof Gt=="function")c(Gt,this,je);else for(var Vt=Gt.length,T0=ee(Gt,Vt),Ne=0;Ne<Vt;++Ne)c(T0[Ne],this,je);return!0};function q(Ce,Pe,je,Ne){var Qe,Ct,dt;if(S(je),Ct=Ce._events,Ct===void 0?(Ct=Ce._events=Object.create(null),Ce._eventsCount=0):(Ct.newListener!==void 0&&(Ce.emit("newListener",Pe,je.listener?je.listener:je),Ct=Ce._events),dt=Ct[Pe]),dt===void 0)dt=Ct[Pe]=je,++Ce._eventsCount;else if(typeof dt=="function"?dt=Ct[Pe]=Ne?[je,dt]:[dt,je]:Ne?dt.unshift(je):dt.push(je),Qe=O(Ce),Qe>0&&dt.length>Qe&&!dt.warned){dt.warned=!0;var Xt=new Error("Possible EventEmitter memory leak detected. "+dt.length+" "+String(Pe)+" listeners added. Use emitter.setMaxListeners() to increase limit");Xt.name="MaxListenersExceededWarning",Xt.emitter=Ce,Xt.type=Pe,Xt.count=dt.length,m(Xt)}return Ce}b.prototype.addListener=function(Pe,je){return q(this,Pe,je,!1)},b.prototype.on=b.prototype.addListener,b.prototype.prependListener=function(Pe,je){return q(this,Pe,je,!0)};function H(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function j(Ce,Pe,je){var Ne={fired:!1,wrapFn:void 0,target:Ce,type:Pe,listener:je},Qe=H.bind(Ne);return Qe.listener=je,Ne.wrapFn=Qe,Qe}b.prototype.once=function(Pe,je){return S(je),this.on(Pe,j(this,Pe,je)),this},b.prototype.prependOnceListener=function(Pe,je){return S(je),this.prependListener(Pe,j(this,Pe,je)),this},b.prototype.removeListener=function(Pe,je){var Ne,Qe,Ct,dt,Xt;if(S(je),Qe=this._events,Qe===void 0)return this;if(Ne=Qe[Pe],Ne===void 0)return this;if(Ne===je||Ne.listener===je)--this._eventsCount===0?this._events=Object.create(null):(delete Qe[Pe],Qe.removeListener&&this.emit("removeListener",Pe,Ne.listener||je));else if(typeof Ne!="function"){for(Ct=-1,dt=Ne.length-1;dt>=0;dt--)if(Ne[dt]===je||Ne[dt].listener===je){Xt=Ne[dt].listener,Ct=dt;break}if(Ct<0)return this;Ct===0?Ne.shift():re(Ne,Ct),Ne.length===1&&(Qe[Pe]=Ne[0]),Qe.removeListener!==void 0&&this.emit("removeListener",Pe,Xt||je)}return this},b.prototype.off=b.prototype.removeListener,b.prototype.removeAllListeners=function(Pe){var je,Ne,Qe;if(Ne=this._events,Ne===void 0)return this;if(Ne.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):Ne[Pe]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete Ne[Pe]),this;if(arguments.length===0){var Ct=Object.keys(Ne),dt;for(Qe=0;Qe<Ct.length;++Qe)dt=Ct[Qe],dt!=="removeListener"&&this.removeAllListeners(dt);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(je=Ne[Pe],typeof je=="function")this.removeListener(Pe,je);else if(je!==void 0)for(Qe=je.length-1;Qe>=0;Qe--)this.removeListener(Pe,je[Qe]);return this};function $(Ce,Pe,je){var Ne=Ce._events;if(Ne===void 0)return[];var Qe=Ne[Pe];return Qe===void 0?[]:typeof Qe=="function"?je?[Qe.listener||Qe]:[Qe]:je?de(Qe):ee(Qe,Qe.length)}b.prototype.listeners=function(Pe){return $(this,Pe,!0)},b.prototype.rawListeners=function(Pe){return $(this,Pe,!1)},b.listenerCount=function(Ce,Pe){return typeof Ce.listenerCount=="function"?Ce.listenerCount(Pe):J.call(Ce,Pe)},b.prototype.listenerCount=J;function J(Ce){var Pe=this._events;if(Pe!==void 0){var je=Pe[Ce];if(typeof je=="function")return 1;if(je!==void 0)return je.length}return 0}b.prototype.eventNames=function(){return this._eventsCount>0?p(this._events):[]};function ee(Ce,Pe){for(var je=new Array(Pe),Ne=0;Ne<Pe;++Ne)je[Ne]=Ce[Ne];return je}function re(Ce,Pe){for(;Pe+1<Ce.length;Pe++)Ce[Pe]=Ce[Pe+1];Ce.pop()}function de(Ce){for(var Pe=new Array(Ce.length),je=0;je<Pe.length;++je)Pe[je]=Ce[je].listener||Ce[je];return Pe}function Te(Ce,Pe){return new Promise(function(je,Ne){function Qe(dt){Ce.removeListener(Pe,Ct),Ne(dt)}function Ct(){typeof Ce.removeListener=="function"&&Ce.removeListener("error",Qe),je([].slice.call(arguments))}Ae(Ce,Pe,Ct,{once:!0}),Pe!=="error"&&Me(Ce,Qe,{once:!0})})}function Me(Ce,Pe,je){typeof Ce.on=="function"&&Ae(Ce,"error",Pe,je)}function Ae(Ce,Pe,je,Ne){if(typeof Ce.on=="function")Ne.once?Ce.once(Pe,je):Ce.on(Pe,je);else if(typeof Ce.addEventListener=="function")Ce.addEventListener(Pe,function Qe(Ct){Ne.once&&Ce.removeEventListener(Pe,Qe),je(Ct)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof Ce)}},29:function(u,a,c){"use strict";var p=c(320),m=Object.prototype.toString,v=Object.prototype.hasOwnProperty,b=function(H,j,$){for(var J=0,ee=H.length;J<ee;J++)v.call(H,J)&&($==null?j(H[J],J,H):j.call($,H[J],J,H))},w=function(H,j,$){for(var J=0,ee=H.length;J<ee;J++)$==null?j(H.charAt(J),J,H):j.call($,H.charAt(J),J,H)},S=function(H,j,$){for(var J in H)v.call(H,J)&&($==null?j(H[J],J,H):j.call($,H[J],J,H))},O=function(H,j,$){if(!p(j))throw new TypeError("iterator must be a function");var J;arguments.length>=3&&(J=$),m.call(H)==="[object Array]"?b(H,j,J):typeof H=="string"?w(H,j,J):S(H,j,J)};u.exports=O},648:function(u){"use strict";var a="Function.prototype.bind called on incompatible ",c=Object.prototype.toString,p=Math.max,m="[object Function]",v=function(O,q){for(var H=[],j=0;j<O.length;j+=1)H[j]=O[j];for(var $=0;$<q.length;$+=1)H[$+O.length]=q[$];return H},b=function(O,q){for(var H=[],j=q||0,$=0;j<O.length;j+=1,$+=1)H[$]=O[j];return H},w=function(S,O){for(var q="",H=0;H<S.length;H+=1)q+=S[H],H+1<S.length&&(q+=O);return q};u.exports=function(O){var q=this;if(typeof q!="function"||c.apply(q)!==m)throw new TypeError(a+q);for(var H=b(arguments,1),j,$=function(){if(this instanceof j){var Te=q.apply(this,v(H,arguments));return Object(Te)===Te?Te:this}return q.apply(O,v(H,arguments))},J=p(0,q.length-H.length),ee=[],re=0;re<J;re++)ee[re]="$"+re;if(j=Function("binder","return function ("+w(ee,",")+"){ return binder.apply(this,arguments); }")($),q.prototype){var de=function(){};de.prototype=q.prototype,j.prototype=new de,de.prototype=null}return j}},612:function(u,a,c){"use strict";var p=c(648);u.exports=Function.prototype.bind||p},210:function(u,a,c){"use strict";var p,m=SyntaxError,v=Function,b=TypeError,w=function(T0){try{return v('"use strict"; return ('+T0+").constructor;")()}catch{}},S=Object.getOwnPropertyDescriptor;if(S)try{S({},"")}catch{S=null}var O=function(){throw new b},q=S?function(){try{return arguments.callee,O}catch{try{return S(arguments,"callee").get}catch{return O}}}():O,H=c(405)(),j=c(185)(),$=Object.getPrototypeOf||(j?function(T0){return T0.__proto__}:null),J={},ee=typeof Uint8Array>"u"||!$?p:$(Uint8Array),re={"%AggregateError%":typeof AggregateError>"u"?p:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?p:ArrayBuffer,"%ArrayIteratorPrototype%":H&&$?$([][Symbol.iterator]()):p,"%AsyncFromSyncIteratorPrototype%":p,"%AsyncFunction%":J,"%AsyncGenerator%":J,"%AsyncGeneratorFunction%":J,"%AsyncIteratorPrototype%":J,"%Atomics%":typeof Atomics>"u"?p:Atomics,"%BigInt%":typeof BigInt>"u"?p:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?p:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?p:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?p:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":typeof Float32Array>"u"?p:Float32Array,"%Float64Array%":typeof Float64Array>"u"?p:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?p:FinalizationRegistry,"%Function%":v,"%GeneratorFunction%":J,"%Int8Array%":typeof Int8Array>"u"?p:Int8Array,"%Int16Array%":typeof Int16Array>"u"?p:Int16Array,"%Int32Array%":typeof Int32Array>"u"?p:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":H&&$?$($([][Symbol.iterator]())):p,"%JSON%":typeof JSON=="object"?JSON:p,"%Map%":typeof Map>"u"?p:Map,"%MapIteratorPrototype%":typeof Map>"u"||!H||!$?p:$(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?p:Promise,"%Proxy%":typeof Proxy>"u"?p:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":typeof Reflect>"u"?p:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?p:Set,"%SetIteratorPrototype%":typeof Set>"u"||!H||!$?p:$(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?p:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":H&&$?$(""[Symbol.iterator]()):p,"%Symbol%":H?Symbol:p,"%SyntaxError%":m,"%ThrowTypeError%":q,"%TypedArray%":ee,"%TypeError%":b,"%Uint8Array%":typeof Uint8Array>"u"?p:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?p:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?p:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?p:Uint32Array,"%URIError%":URIError,"%WeakMap%":typeof WeakMap>"u"?p:WeakMap,"%WeakRef%":typeof WeakRef>"u"?p:WeakRef,"%WeakSet%":typeof WeakSet>"u"?p:WeakSet};if($)try{null.error}catch(T0){var de=$($(T0));re["%Error.prototype%"]=de}var Te=function T0(r0){var d0;if(r0==="%AsyncFunction%")d0=w("async function () {}");else if(r0==="%GeneratorFunction%")d0=w("function* () {}");else if(r0==="%AsyncGeneratorFunction%")d0=w("async function* () {}");else if(r0==="%AsyncGenerator%"){var Ut=T0("%AsyncGeneratorFunction%");Ut&&(d0=Ut.prototype)}else if(r0==="%AsyncIteratorPrototype%"){var $0=T0("%AsyncGenerator%");$0&&$&&(d0=$($0.prototype))}return re[r0]=d0,d0},Me={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},Ae=c(612),Ce=c(1),Pe=Ae.call(Function.call,Array.prototype.concat),je=Ae.call(Function.apply,Array.prototype.splice),Ne=Ae.call(Function.call,String.prototype.replace),Qe=Ae.call(Function.call,String.prototype.slice),Ct=Ae.call(Function.call,RegExp.prototype.exec),dt=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Xt=/\\(\\)?/g,Gt=function(r0){var d0=Qe(r0,0,1),Ut=Qe(r0,-1);if(d0==="%"&&Ut!=="%")throw new m("invalid intrinsic syntax, expected closing `%`");if(Ut==="%"&&d0!=="%")throw new m("invalid intrinsic syntax, expected opening `%`");var $0=[];return Ne(r0,dt,function(Q0,Un,b0,X0){$0[$0.length]=b0?Ne(X0,Xt,"$1"):Un||Q0}),$0},Vt=function(r0,d0){var Ut=r0,$0;if(Ce(Me,Ut)&&($0=Me[Ut],Ut="%"+$0[0]+"%"),Ce(re,Ut)){var Q0=re[Ut];if(Q0===J&&(Q0=Te(Ut)),typeof Q0>"u"&&!d0)throw new b("intrinsic "+r0+" exists, but is not available. Please file an issue!");return{alias:$0,name:Ut,value:Q0}}throw new m("intrinsic "+r0+" does not exist!")};u.exports=function(r0,d0){if(typeof r0!="string"||r0.length===0)throw new b("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof d0!="boolean")throw new b('"allowMissing" argument must be a boolean');if(Ct(/^%?[^%]*%?$/,r0)===null)throw new m("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var Ut=Gt(r0),$0=Ut.length>0?Ut[0]:"",Q0=Vt("%"+$0+"%",d0),Un=Q0.name,b0=Q0.value,X0=!1,Rt=Q0.alias;Rt&&($0=Rt[0],je(Ut,Pe([0,1],Rt)));for(var Qt=1,A0=!0;Qt<Ut.length;Qt+=1){var J0=Ut[Qt],Pn=Qe(J0,0,1),dx=Qe(J0,-1);if((Pn==='"'||Pn==="'"||Pn==="`"||dx==='"'||dx==="'"||dx==="`")&&Pn!==dx)throw new m("property names with quotes must have matching quotes");if((J0==="constructor"||!A0)&&(X0=!0),$0+="."+J0,Un="%"+$0+"%",Ce(re,Un))b0=re[Un];else if(b0!=null){if(!(J0 in b0)){if(!d0)throw new b("base intrinsic for "+r0+" exists, but the property is not available.");return}if(S&&Qt+1>=Ut.length){var Bn=S(b0,J0);A0=!!Bn,A0&&"get"in Bn&&!("originalValue"in Bn.get)?b0=Bn.get:b0=b0[J0]}else A0=Ce(b0,J0),b0=b0[J0];A0&&!X0&&(re[Un]=b0)}}return b0}},275:function(u,a,c){"use strict";var p=c(210),m=p("%Object.getOwnPropertyDescriptor%",!0);if(m)try{m([],"length")}catch{m=null}u.exports=m},44:function(u,a,c){"use strict";var p=c(210),m=p("%Object.defineProperty%",!0),v=function(){if(m)try{return m({},"a",{value:1}),!0}catch{return!1}return!1};v.hasArrayLengthDefineBug=function(){if(!v())return null;try{return m([],"length",{value:1}).length!==1}catch{return!0}},u.exports=v},185:function(u){"use strict";var a={foo:{}},c=Object;u.exports=function(){return{__proto__:a}.foo===a.foo&&!({__proto__:null}instanceof c)}},405:function(u,a,c){"use strict";var p=typeof Symbol<"u"&&Symbol,m=c(419);u.exports=function(){return typeof p!="function"||typeof Symbol!="function"||typeof p("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:m()}},419:function(u){"use strict";u.exports=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var c={},p=Symbol("test"),m=Object(p);if(typeof p=="string"||Object.prototype.toString.call(p)!=="[object Symbol]"||Object.prototype.toString.call(m)!=="[object Symbol]")return!1;var v=42;c[p]=v;for(p in c)return!1;if(typeof Object.keys=="function"&&Object.keys(c).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(c).length!==0)return!1;var b=Object.getOwnPropertySymbols(c);if(b.length!==1||b[0]!==p||!Object.prototype.propertyIsEnumerable.call(c,p))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var w=Object.getOwnPropertyDescriptor(c,p);if(w.value!==v||w.enumerable!==!0)return!1}return!0}},410:function(u,a,c){"use strict";var p=c(419);u.exports=function(){return p()&&!!Symbol.toStringTag}},1:function(u,a,c){"use strict";var p=Function.prototype.call,m=Object.prototype.hasOwnProperty,v=c(612);u.exports=v.call(p,m)},717:function(u){typeof Object.create=="function"?u.exports=function(c,p){p&&(c.super_=p,c.prototype=Object.create(p.prototype,{constructor:{value:c,enumerable:!1,writable:!0,configurable:!0}}))}:u.exports=function(c,p){if(p){c.super_=p;var m=function(){};m.prototype=p.prototype,c.prototype=new m,c.prototype.constructor=c}}},584:function(u,a,c){"use strict";var p=c(410)(),m=c(924),v=m("Object.prototype.toString"),b=function(q){return p&&q&&typeof q=="object"&&Symbol.toStringTag in q?!1:v(q)==="[object Arguments]"},w=function(q){return b(q)?!0:q!==null&&typeof q=="object"&&typeof q.length=="number"&&q.length>=0&&v(q)!=="[object Array]"&&v(q.callee)==="[object Function]"},S=function(){return b(arguments)}();b.isLegacyArguments=w,u.exports=S?b:w},320:function(u){"use strict";var a=Function.prototype.toString,c=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,p,m;if(typeof c=="function"&&typeof Object.defineProperty=="function")try{p=Object.defineProperty({},"length",{get:function(){throw m}}),m={},c(function(){throw 42},null,p)}catch(Me){Me!==m&&(c=null)}else c=null;var v=/^\s*class\b/,b=function(Ae){try{var Ce=a.call(Ae);return v.test(Ce)}catch{return!1}},w=function(Ae){try{return b(Ae)?!1:(a.call(Ae),!0)}catch{return!1}},S=Object.prototype.toString,O="[object Object]",q="[object Function]",H="[object GeneratorFunction]",j="[object HTMLAllCollection]",$="[object HTML document.all class]",J="[object HTMLCollection]",ee=typeof Symbol=="function"&&!!Symbol.toStringTag,re=!(0 in[,]),de=function(){return!1};if(typeof document=="object"){var Te=document.all;S.call(Te)===S.call(document.all)&&(de=function(Ae){if((re||!Ae)&&(typeof Ae>"u"||typeof Ae=="object"))try{var Ce=S.call(Ae);return(Ce===j||Ce===$||Ce===J||Ce===O)&&Ae("")==null}catch{}return!1})}u.exports=c?function(Ae){if(de(Ae))return!0;if(!Ae||typeof Ae!="function"&&typeof Ae!="object")return!1;try{c(Ae,null,p)}catch(Ce){if(Ce!==m)return!1}return!b(Ae)&&w(Ae)}:function(Ae){if(de(Ae))return!0;if(!Ae||typeof Ae!="function"&&typeof Ae!="object")return!1;if(ee)return w(Ae);if(b(Ae))return!1;var Ce=S.call(Ae);return Ce!==q&&Ce!==H&&!/^\[object HTML/.test(Ce)?!1:w(Ae)}},662:function(u,a,c){"use strict";var p=Object.prototype.toString,m=Function.prototype.toString,v=/^\s*(?:function)?\*/,b=c(410)(),w=Object.getPrototypeOf,S=function(){if(!b)return!1;try{return Function("return function*() {}")()}catch{}},O;u.exports=function(H){if(typeof H!="function")return!1;if(v.test(m.call(H)))return!0;if(!b){var j=p.call(H);return j==="[object GeneratorFunction]"}if(!w)return!1;if(typeof O>"u"){var $=S();O=$?w($):!1}return w(H)===O}},692:function(u,a,c){"use strict";var p=c(430);u.exports=function(v){return!!p(v)}},300:function(u,a,c){"use strict";var p=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof c.g<"u")return c.g;throw new Error("unable to locate global object")},m=p();u.exports=a=m.fetch,m.fetch&&(a.default=m.fetch.bind(m)),a.Headers=m.Headers,a.Request=m.Request,a.Response=m.Response},908:function(u){"use strict";u.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},771:function(u,a,c){"use strict";var p=c(210),m=c(296),v=c(44)(),b=c(275),w=p("%TypeError%"),S=p("%Math.floor%");u.exports=function(q,H){if(typeof q!="function")throw new w("`fn` is not a function");if(typeof H!="number"||H<0||H>4294967295||S(H)!==H)throw new w("`length` must be a positive 32-bit integer");var j=arguments.length>2&&!!arguments[2],$=!0,J=!0;if("length"in q&&b){var ee=b(q,"length");ee&&!ee.configurable&&($=!1),ee&&!ee.writable&&(J=!1)}return($||J||!j)&&(v?m(q,"length",H,!0,!0):m(q,"length",H)),q}},384:function(u){u.exports=function(c){return c&&typeof c=="object"&&typeof c.copy=="function"&&typeof c.fill=="function"&&typeof c.readUInt8=="function"}},955:function(u,a,c){"use strict";var p=c(584),m=c(662),v=c(430),b=c(692);function w(xn){return xn.call.bind(xn)}var S=typeof BigInt<"u",O=typeof Symbol<"u",q=w(Object.prototype.toString),H=w(Number.prototype.valueOf),j=w(String.prototype.valueOf),$=w(Boolean.prototype.valueOf);if(S)var J=w(BigInt.prototype.valueOf);if(O)var ee=w(Symbol.prototype.valueOf);function re(xn,io){if(typeof xn!="object")return!1;try{return io(xn),!0}catch{return!1}}a.isArgumentsObject=p,a.isGeneratorFunction=m,a.isTypedArray=b;function de(xn){return typeof Promise<"u"&&xn instanceof Promise||xn!==null&&typeof xn=="object"&&typeof xn.then=="function"&&typeof xn.catch=="function"}a.isPromise=de;function Te(xn){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(xn):b(xn)||Qt(xn)}a.isArrayBufferView=Te;function Me(xn){return v(xn)==="Uint8Array"}a.isUint8Array=Me;function Ae(xn){return v(xn)==="Uint8ClampedArray"}a.isUint8ClampedArray=Ae;function Ce(xn){return v(xn)==="Uint16Array"}a.isUint16Array=Ce;function Pe(xn){return v(xn)==="Uint32Array"}a.isUint32Array=Pe;function je(xn){return v(xn)==="Int8Array"}a.isInt8Array=je;function Ne(xn){return v(xn)==="Int16Array"}a.isInt16Array=Ne;function Qe(xn){return v(xn)==="Int32Array"}a.isInt32Array=Qe;function Ct(xn){return v(xn)==="Float32Array"}a.isFloat32Array=Ct;function dt(xn){return v(xn)==="Float64Array"}a.isFloat64Array=dt;function Xt(xn){return v(xn)==="BigInt64Array"}a.isBigInt64Array=Xt;function Gt(xn){return v(xn)==="BigUint64Array"}a.isBigUint64Array=Gt;function Vt(xn){return q(xn)==="[object Map]"}Vt.working=typeof Map<"u"&&Vt(new Map);function T0(xn){return typeof Map>"u"?!1:Vt.working?Vt(xn):xn instanceof Map}a.isMap=T0;function r0(xn){return q(xn)==="[object Set]"}r0.working=typeof Set<"u"&&r0(new Set);function d0(xn){return typeof Set>"u"?!1:r0.working?r0(xn):xn instanceof Set}a.isSet=d0;function Ut(xn){return q(xn)==="[object WeakMap]"}Ut.working=typeof WeakMap<"u"&&Ut(new WeakMap);function $0(xn){return typeof WeakMap>"u"?!1:Ut.working?Ut(xn):xn instanceof WeakMap}a.isWeakMap=$0;function Q0(xn){return q(xn)==="[object WeakSet]"}Q0.working=typeof WeakSet<"u"&&Q0(new WeakSet);function Un(xn){return Q0(xn)}a.isWeakSet=Un;function b0(xn){return q(xn)==="[object ArrayBuffer]"}b0.working=typeof ArrayBuffer<"u"&&b0(new ArrayBuffer);function X0(xn){return typeof ArrayBuffer>"u"?!1:b0.working?b0(xn):xn instanceof ArrayBuffer}a.isArrayBuffer=X0;function Rt(xn){return q(xn)==="[object DataView]"}Rt.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&Rt(new DataView(new ArrayBuffer(1),0,1));function Qt(xn){return typeof DataView>"u"?!1:Rt.working?Rt(xn):xn instanceof DataView}a.isDataView=Qt;var A0=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function J0(xn){return q(xn)==="[object SharedArrayBuffer]"}function Pn(xn){return typeof A0>"u"?!1:(typeof J0.working>"u"&&(J0.working=J0(new A0)),J0.working?J0(xn):xn instanceof A0)}a.isSharedArrayBuffer=Pn;function dx(xn){return q(xn)==="[object AsyncFunction]"}a.isAsyncFunction=dx;function Bn(xn){return q(xn)==="[object Map Iterator]"}a.isMapIterator=Bn;function Wn(xn){return q(xn)==="[object Set Iterator]"}a.isSetIterator=Wn;function gx(xn){return q(xn)==="[object Generator]"}a.isGeneratorObject=gx;function Jx(xn){return q(xn)==="[object WebAssembly.Module]"}a.isWebAssemblyCompiledModule=Jx;function er(xn){return re(xn,H)}a.isNumberObject=er;function Cr(xn){return re(xn,j)}a.isStringObject=Cr;function Rr(xn){return re(xn,$)}a.isBooleanObject=Rr;function xi(xn){return S&&re(xn,J)}a.isBigIntObject=xi;function Nr(xn){return O&&re(xn,ee)}a.isSymbolObject=Nr;function rr(xn){return er(xn)||Cr(xn)||Rr(xn)||xi(xn)||Nr(xn)}a.isBoxedPrimitive=rr;function ja(xn){return typeof Uint8Array<"u"&&(X0(xn)||Pn(xn))}a.isAnyArrayBuffer=ja,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(xn){Object.defineProperty(a,xn,{enumerable:!1,value:function(){throw new Error(xn+" is not supported in userland")}})})},539:function(u,a,c){var p=Object.getOwnPropertyDescriptors||function(Qt){for(var A0=Object.keys(Qt),J0={},Pn=0;Pn<A0.length;Pn++)J0[A0[Pn]]=Object.getOwnPropertyDescriptor(Qt,A0[Pn]);return J0},m=/%[sdj%]/g;a.format=function(Rt){if(!je(Rt)){for(var Qt=[],A0=0;A0<arguments.length;A0++)Qt.push(S(arguments[A0]));return Qt.join(" ")}for(var A0=1,J0=arguments,Pn=J0.length,dx=String(Rt).replace(m,function(Wn){if(Wn==="%%")return"%";if(A0>=Pn)return Wn;switch(Wn){case"%s":return String(J0[A0++]);case"%d":return Number(J0[A0++]);case"%j":try{return JSON.stringify(J0[A0++])}catch{return"[Circular]"}default:return Wn}}),Bn=J0[A0];A0<Pn;Bn=J0[++A0])Ae(Bn)||!dt(Bn)?dx+=" "+Bn:dx+=" "+S(Bn);return dx},a.deprecate=function(Rt,Qt){if(typeof process<"u"&&process.noDeprecation===!0)return Rt;if(typeof process>"u")return function(){return a.deprecate(Rt,Qt).apply(this,arguments)};var A0=!1;function J0(){if(!A0){if(process.throwDeprecation)throw new Error(Qt);process.traceDeprecation?console.trace(Qt):console.error(Qt),A0=!0}return Rt.apply(this,arguments)}return J0};var v={},b=/^$/;if(process.env.NODE_DEBUG){var w=process.env.NODE_DEBUG;w=w.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),b=new RegExp("^"+w+"$","i")}a.debuglog=function(Rt){if(Rt=Rt.toUpperCase(),!v[Rt])if(b.test(Rt)){var Qt=process.pid;v[Rt]=function(){var A0=a.format.apply(a,arguments);console.error("%s %d: %s",Rt,Qt,A0)}}else v[Rt]=function(){};return v[Rt]};function S(Rt,Qt){var A0={seen:[],stylize:q};return arguments.length>=3&&(A0.depth=arguments[2]),arguments.length>=4&&(A0.colors=arguments[3]),Me(Qt)?A0.showHidden=Qt:Qt&&a._extend(A0,Qt),Qe(A0.showHidden)&&(A0.showHidden=!1),Qe(A0.depth)&&(A0.depth=2),Qe(A0.colors)&&(A0.colors=!1),Qe(A0.customInspect)&&(A0.customInspect=!0),A0.colors&&(A0.stylize=O),j(A0,Rt,A0.depth)}a.inspect=S,S.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},S.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function O(Rt,Qt){var A0=S.styles[Qt];return A0?"\x1B["+S.colors[A0][0]+"m"+Rt+"\x1B["+S.colors[A0][1]+"m":Rt}function q(Rt,Qt){return Rt}function H(Rt){var Qt={};return Rt.forEach(function(A0,J0){Qt[A0]=!0}),Qt}function j(Rt,Qt,A0){if(Rt.customInspect&&Qt&&Vt(Qt.inspect)&&Qt.inspect!==a.inspect&&!(Qt.constructor&&Qt.constructor.prototype===Qt)){var J0=Qt.inspect(A0,Rt);return je(J0)||(J0=j(Rt,J0,A0)),J0}var Pn=$(Rt,Qt);if(Pn)return Pn;var dx=Object.keys(Qt),Bn=H(dx);if(Rt.showHidden&&(dx=Object.getOwnPropertyNames(Qt)),Gt(Qt)&&(dx.indexOf("message")>=0||dx.indexOf("description")>=0))return J(Qt);if(dx.length===0){if(Vt(Qt)){var Wn=Qt.name?": "+Qt.name:"";return Rt.stylize("[Function"+Wn+"]","special")}if(Ct(Qt))return Rt.stylize(RegExp.prototype.toString.call(Qt),"regexp");if(Xt(Qt))return Rt.stylize(Date.prototype.toString.call(Qt),"date");if(Gt(Qt))return J(Qt)}var gx="",Jx=!1,er=["{","}"];if(Te(Qt)&&(Jx=!0,er=["[","]"]),Vt(Qt)){var Cr=Qt.name?": "+Qt.name:"";gx=" [Function"+Cr+"]"}if(Ct(Qt)&&(gx=" "+RegExp.prototype.toString.call(Qt)),Xt(Qt)&&(gx=" "+Date.prototype.toUTCString.call(Qt)),Gt(Qt)&&(gx=" "+J(Qt)),dx.length===0&&(!Jx||Qt.length==0))return er[0]+gx+er[1];if(A0<0)return Ct(Qt)?Rt.stylize(RegExp.prototype.toString.call(Qt),"regexp"):Rt.stylize("[Object]","special");Rt.seen.push(Qt);var Rr;return Jx?Rr=ee(Rt,Qt,A0,Bn,dx):Rr=dx.map(function(xi){return re(Rt,Qt,A0,Bn,xi,Jx)}),Rt.seen.pop(),de(Rr,gx,er)}function $(Rt,Qt){if(Qe(Qt))return Rt.stylize("undefined","undefined");if(je(Qt)){var A0="'"+JSON.stringify(Qt).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return Rt.stylize(A0,"string")}if(Pe(Qt))return Rt.stylize(""+Qt,"number");if(Me(Qt))return Rt.stylize(""+Qt,"boolean");if(Ae(Qt))return Rt.stylize("null","null")}function J(Rt){return"["+Error.prototype.toString.call(Rt)+"]"}function ee(Rt,Qt,A0,J0,Pn){for(var dx=[],Bn=0,Wn=Qt.length;Bn<Wn;++Bn)Q0(Qt,String(Bn))?dx.push(re(Rt,Qt,A0,J0,String(Bn),!0)):dx.push("");return Pn.forEach(function(gx){gx.match(/^\d+$/)||dx.push(re(Rt,Qt,A0,J0,gx,!0))}),dx}function re(Rt,Qt,A0,J0,Pn,dx){var Bn,Wn,gx;if(gx=Object.getOwnPropertyDescriptor(Qt,Pn)||{value:Qt[Pn]},gx.get?gx.set?Wn=Rt.stylize("[Getter/Setter]","special"):Wn=Rt.stylize("[Getter]","special"):gx.set&&(Wn=Rt.stylize("[Setter]","special")),Q0(J0,Pn)||(Bn="["+Pn+"]"),Wn||(Rt.seen.indexOf(gx.value)<0?(Ae(A0)?Wn=j(Rt,gx.value,null):Wn=j(Rt,gx.value,A0-1),Wn.indexOf(`
`)>-1&&(dx?Wn=Wn.split(`
`).map(function(Jx){return"  "+Jx}).join(`
`).slice(2):Wn=`
`+Wn.split(`
`).map(function(Jx){return"   "+Jx}).join(`
`))):Wn=Rt.stylize("[Circular]","special")),Qe(Bn)){if(dx&&Pn.match(/^\d+$/))return Wn;Bn=JSON.stringify(""+Pn),Bn.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(Bn=Bn.slice(1,-1),Bn=Rt.stylize(Bn,"name")):(Bn=Bn.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),Bn=Rt.stylize(Bn,"string"))}return Bn+": "+Wn}function de(Rt,Qt,A0){var J0=0,Pn=Rt.reduce(function(dx,Bn){return J0++,Bn.indexOf(`
`)>=0&&J0++,dx+Bn.replace(/\u001b\[\d\d?m/g,"").length+1},0);return Pn>60?A0[0]+(Qt===""?"":Qt+`
 `)+" "+Rt.join(`,
  `)+" "+A0[1]:A0[0]+Qt+" "+Rt.join(", ")+" "+A0[1]}a.types=c(955);function Te(Rt){return Array.isArray(Rt)}a.isArray=Te;function Me(Rt){return typeof Rt=="boolean"}a.isBoolean=Me;function Ae(Rt){return Rt===null}a.isNull=Ae;function Ce(Rt){return Rt==null}a.isNullOrUndefined=Ce;function Pe(Rt){return typeof Rt=="number"}a.isNumber=Pe;function je(Rt){return typeof Rt=="string"}a.isString=je;function Ne(Rt){return typeof Rt=="symbol"}a.isSymbol=Ne;function Qe(Rt){return Rt===void 0}a.isUndefined=Qe;function Ct(Rt){return dt(Rt)&&r0(Rt)==="[object RegExp]"}a.isRegExp=Ct,a.types.isRegExp=Ct;function dt(Rt){return typeof Rt=="object"&&Rt!==null}a.isObject=dt;function Xt(Rt){return dt(Rt)&&r0(Rt)==="[object Date]"}a.isDate=Xt,a.types.isDate=Xt;function Gt(Rt){return dt(Rt)&&(r0(Rt)==="[object Error]"||Rt instanceof Error)}a.isError=Gt,a.types.isNativeError=Gt;function Vt(Rt){return typeof Rt=="function"}a.isFunction=Vt;function T0(Rt){return Rt===null||typeof Rt=="boolean"||typeof Rt=="number"||typeof Rt=="string"||typeof Rt=="symbol"||typeof Rt>"u"}a.isPrimitive=T0,a.isBuffer=c(384);function r0(Rt){return Object.prototype.toString.call(Rt)}function d0(Rt){return Rt<10?"0"+Rt.toString(10):Rt.toString(10)}var Ut=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function $0(){var Rt=new Date,Qt=[d0(Rt.getHours()),d0(Rt.getMinutes()),d0(Rt.getSeconds())].join(":");return[Rt.getDate(),Ut[Rt.getMonth()],Qt].join(" ")}a.log=function(){console.log("%s - %s",$0(),a.format.apply(a,arguments))},a.inherits=c(717),a._extend=function(Rt,Qt){if(!Qt||!dt(Qt))return Rt;for(var A0=Object.keys(Qt),J0=A0.length;J0--;)Rt[A0[J0]]=Qt[A0[J0]];return Rt};function Q0(Rt,Qt){return Object.prototype.hasOwnProperty.call(Rt,Qt)}var Un=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;a.promisify=function(Qt){if(typeof Qt!="function")throw new TypeError('The "original" argument must be of type Function');if(Un&&Qt[Un]){var A0=Qt[Un];if(typeof A0!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(A0,Un,{value:A0,enumerable:!1,writable:!1,configurable:!0}),A0}function A0(){for(var J0,Pn,dx=new Promise(function(gx,Jx){J0=gx,Pn=Jx}),Bn=[],Wn=0;Wn<arguments.length;Wn++)Bn.push(arguments[Wn]);Bn.push(function(gx,Jx){gx?Pn(gx):J0(Jx)});try{Qt.apply(this,Bn)}catch(gx){Pn(gx)}return dx}return Object.setPrototypeOf(A0,Object.getPrototypeOf(Qt)),Un&&Object.defineProperty(A0,Un,{value:A0,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(A0,p(Qt))},a.promisify.custom=Un;function b0(Rt,Qt){if(!Rt){var A0=new Error("Promise was rejected with a falsy value");A0.reason=Rt,Rt=A0}return Qt(Rt)}function X0(Rt){if(typeof Rt!="function")throw new TypeError('The "original" argument must be of type Function');function Qt(){for(var A0=[],J0=0;J0<arguments.length;J0++)A0.push(arguments[J0]);var Pn=A0.pop();if(typeof Pn!="function")throw new TypeError("The last argument must be of type Function");var dx=this,Bn=function(){return Pn.apply(dx,arguments)};Rt.apply(this,A0).then(function(Wn){process.nextTick(Bn.bind(null,null,Wn))},function(Wn){process.nextTick(b0.bind(null,Wn,Bn))})}return Object.setPrototypeOf(Qt,Object.getPrototypeOf(Rt)),Object.defineProperties(Qt,p(Rt)),Qt}a.callbackify=X0},430:function(u,a,c){"use strict";var p=c(29),m=c(83),v=c(559),b=c(924),w=c(275),S=b("Object.prototype.toString"),O=c(410)(),q=typeof globalThis>"u"?c.g:globalThis,H=m(),j=b("String.prototype.slice"),$=Object.getPrototypeOf,J=b("Array.prototype.indexOf",!0)||function(Me,Ae){for(var Ce=0;Ce<Me.length;Ce+=1)if(Me[Ce]===Ae)return Ce;return-1},ee={__proto__:null};O&&w&&$?p(H,function(Te){var Me=new q[Te];if(Symbol.toStringTag in Me){var Ae=$(Me),Ce=w(Ae,Symbol.toStringTag);if(!Ce){var Pe=$(Ae);Ce=w(Pe,Symbol.toStringTag)}ee["$"+Te]=v(Ce.get)}}):p(H,function(Te){var Me=new q[Te],Ae=Me.slice||Me.set;Ae&&(ee["$"+Te]=v(Ae))});var re=function(Me){var Ae=!1;return p(ee,function(Ce,Pe){if(!Ae)try{"$"+Ce(Me)===Pe&&(Ae=j(Pe,1))}catch{}}),Ae},de=function(Me){var Ae=!1;return p(ee,function(Ce,Pe){if(!Ae)try{Ce(Me),Ae=j(Pe,1)}catch{}}),Ae};u.exports=function(Me){if(!Me||typeof Me!="object")return!1;if(!O){var Ae=j(S(Me),8,-1);return J(H,Ae)>-1?Ae:Ae!=="Object"?!1:de(Me)}return w?re(Me):null}},653:function(){},83:function(u,a,c){"use strict";var p=c(908),m=typeof globalThis>"u"?c.g:globalThis;u.exports=function(){for(var b=[],w=0;w<p.length;w++)typeof m[p[w]]=="function"&&(b[b.length]=p[w]);return b}}},__webpack_module_cache__={};function __webpack_require__(u){var a=__webpack_module_cache__[u];if(a!==void 0)return a.exports;var c=__webpack_module_cache__[u]={exports:{}};return __webpack_modules__[u](c,c.exports,__webpack_require__),c.exports}(function(){__webpack_require__.d=function(u,a){for(var c in a)__webpack_require__.o(a,c)&&!__webpack_require__.o(u,c)&&Object.defineProperty(u,c,{enumerable:!0,get:a[c]})}})(),function(){__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}()}(),function(){__webpack_require__.o=function(u,a){return Object.prototype.hasOwnProperty.call(u,a)}}();var __webpack_exports__={};(function(){"use strict";var u=__webpack_require__(862),a=__webpack_require__(187);class c extends a.EventEmitter{}var p=Object.defineProperty,m=Object.getOwnPropertySymbols,v=Object.prototype.hasOwnProperty,b=Object.prototype.propertyIsEnumerable,w=(I,r,d)=>r in I?p(I,r,{enumerable:!0,configurable:!0,writable:!0,value:d}):I[r]=d,S=(I,r)=>{for(var d in r||(r={}))v.call(r,d)&&w(I,d,r[d]);if(m)for(var d of m(r))b.call(r,d)&&w(I,d,r[d]);return I};class O{constructor(r="canvas"){this.size={width:0,height:0},this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.capture."+r,this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}capture(r){const{context:d}=this;if(!d)return!1;const{width:g,height:y}=this.size;return d.drawImage(r,0,0,g,y),!0}data(){const{context:r}=this;if(!r)return;const{width:d,height:g}=this.size;return r.getImageData(0,0,d,g)}setSize(r){this.size=S({},r),this.canvas.width=r.width,this.canvas.height=r.height}fill(){const{context:r}=this;r&&(r.fillStyle="rgba(255, 255, 255, 1)",r.fillRect(0,0,this.size.width,this.size.height))}dispose(){this.context=null,this.canvas.remove()}}class q extends c{constructor(){super(),this.buffer=new O("capture"),this.captureTime=0}async setup(r){const d=r&&(g=>typeof g!="string"&&"size"in g)(r)&&r.size||{width:1920,height:1080};return this.updateSize(d),this.buffer.fill(),!0}dispose(){this.reset(),this.buffer.dispose()}async start(){this.captureTime=0,this.timer=Date.now()}pause(){}reset(){this.pause(),delete this.timer}capture(){return this.timer===void 0?!1:(this.captureTime=(Date.now()-this.timer)*1e3,!0)}size(){return S({},this.buffer.size)}ratio(){const r=this.buffer.size;return r.width/r.height}updateSize(r){let{width:d,height:g}=r;const{sizeMax:y}=this;if(y&&(d>y||g>y)){const _=d/g;_>1?(d=y,g=y/_):(g=y,d=_*y),r={width:d,height:g}}this.buffer.setSize(r),this.emit("resize",this.buffer.size)}}class H extends q{constructor(){super(),this.timeShift=0,this.videoRef=document.createElement("video"),this.videoRef.id="engeenee.capture.source",this.videoRef.muted=!0,this.videoRef.loop=!0,this.videoRef.playsInline=!0}async setup(r){const d=K=>typeof K=="string"||"url"in K&&typeof K.url=="string",g=K=>d(K)||"getVideoTracks"in K,y=K=>d(K)&&typeof K!="string"?(this.sizeMax=K.sizeMax,K.url):K,_=K=>"video"in K,R=K=>{if(!K)return{video:!0,audio:!1};if(_(K))return K;const Q=K.size;return{video:{facingMode:K.rear?"environment":"user",width:Q?.width,height:Q?.height,frameRate:K.fps},audio:!1}};delete this.sizeMax;const k=r!==void 0&&g(r)?y(r):await navigator.mediaDevices.getUserMedia(R(r)).catch(()=>{});if(!k)return!1;const{videoRef:X}=this;return new Promise(K=>{X.onloadedmetadata=()=>{this.updateSize({width:X.videoWidth,height:X.videoHeight}),X.onresize=()=>{this.updateSize({width:X.videoWidth,height:X.videoHeight})},X.onseeked=()=>{this.timeShift=this.captureTime,this.captureTime=0},K(!0)},typeof k=="string"?X.src=k:X.srcObject=k})}dispose(){super.dispose(),this.videoRef.remove()}async start(){this.captureTime=0,this.timeShift=0,(this.videoRef.srcObject||this.videoRef.src)&&await this.videoRef.play()}pause(){this.videoRef.pause()}reset(){this.pause(),this.videoRef.srcObject&&(this.videoRef.srcObject.getTracks().forEach(r=>r.stop()),this.videoRef.srcObject=null)}capture(){const{videoRef:r,buffer:d}=this,g=r.currentTime+this.timeShift;return g<=this.captureTime?!1:(this.captureTime=g,d.capture(r))}}class j extends c{constructor(r,d,g=H){super(),this.engineParams=d,this.renderers=[],this.videoRatio=1920/1080,this.streamSize={width:1920,height:1080},this.processSize={width:1920,height:1080},this.resizeEnabled=!1,this.loopState=!1,this.init=async y=>{const _=await this.setupProcessor(y);return this.emit("init",_),_},this.setup=async y=>{this.pause();const _=await this.setupVideo(y);return this.emit("setup",_),_},this.start=async()=>{await this.video.start(),this.loopState=!0,this.emit("start"),this.enqueue()},this.pause=()=>{this.loopState=!1,this.loopId&&(window.cancelAnimationFrame(this.loopId),delete this.loopId),this.video.pause(),this.emit("pause")},this.reset=()=>{this.pause(),this.video.reset(),delete this.streamCanvas,delete this.processCanvas,this.processor.reset()},this.iterate=async()=>{var y;const{video:_,streamCanvas:R,processCanvas:k}=this;if(!_.capture()||!R||!k)return this.enqueue();this.resizeEnabled&&((y=this.resizeBuffer)==null||y.capture(_.buffer.canvas));const X=await this.processor.process(k,_.captureTime);X&&await Promise.all(this.renderers.map(K=>K.update(X,R))),this.enqueue()},this.processor=typeof r=="function"?new r:r,this.video=typeof g=="function"?new g:g,this.video.on("resize",this.resizeVideo.bind(this))}async addRenderer(r){this.renderers.push(r),await r.load(),r.setupVideo(this.video.size(),this.video.ratio()),r.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle)}removeRenderer(r){const{renderers:d}=this,g=d.indexOf(r);g<0||(d[g].dispose(),d.splice(g,1))}enqueue(){this.loopId=this.loopState?window.requestAnimationFrame(this.iterate):void 0}async setupProcessor(r){var d;const g=this.resizeEnabled&&((d=this.resizeBuffer)==null?void 0:d.size)||this.video.size();return this.processor.init(r,g,this.video.ratio())}async setupVideo(r){return this.video.reset(),await this.video.setup(r)?(this.setupSize(this.video.size()),!0):!1}async setupSize(r){var d,g;const{width:y,height:_}=r;this.videoRatio=y/_;const R=Math.max(y,_),k=((d=this.engineParams)==null?void 0:d.max)||this.processor.optimalSize;if(this.resizeEnabled=!1,k<R){this.resizeEnabled=!0;const X=R/k;this.resizeBuffer||(this.resizeBuffer=new O("resize")),this.resizeBuffer.setSize({width:y/X,height:_/X})}this.resizeEnabled&&this.resizeBuffer?(this.processCanvas=this.resizeBuffer.canvas,this.processSize=this.resizeBuffer.size):(this.processCanvas=this.video.buffer.canvas,this.processSize=this.video.size()),((g=this.engineParams)==null?void 0:g.orig)!==!1?(this.streamCanvas=this.video.buffer.canvas,this.streamSize=this.video.size()):(this.streamCanvas=this.processCanvas,this.streamSize=this.streamSize)}resizeVideo(r){this.setupSize(r),this.processor.setupVideo(this.processSize,this.videoRatio),this.renderers.forEach(d=>d.setupVideo(this.streamSize,this.videoRatio)),this.renderers.forEach(d=>d.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle))}}var $=Object.defineProperty,J=Object.getOwnPropertySymbols,ee=Object.prototype.hasOwnProperty,re=Object.prototype.propertyIsEnumerable,de=(I,r,d)=>r in I?$(I,r,{enumerable:!0,configurable:!0,writable:!0,value:d}):I[r]=d,Te=(I,r)=>{for(var d in r||(r={}))ee.call(r,d)&&de(I,d,r[d]);if(J)for(var d of J(r))re.call(r,d)&&de(I,d,r[d]);return I};class Me extends c{constructor(){super(),this.params={},this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.optimalSize=1024,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async process(r,d){return{}}async init(r,d,g){return this.params=r,!g&&d&&(g=d.width/d.height),this.setupVideo(d||this.videoSize,g||this.videoRatio),this.emit("init",!0),!0}reset(){this.emit("reset")}dispose(){}setupVideo(r,d){d=d||r.width/r.height,this.videoSize=Te({},r),this.videoRatio=d,this.cameraRatio=d}}class Ae extends c{constructor(r,d="crop",g=1,y=!1,_=1){super(),this.container=r,this.mode=d,this.layerCount=g,this.mirror=y,this.aspectRatio=_,this.layers=[],this.padsSize=[1,1],this.setAspectRatio=R=>{this.aspectRatio=R,this.updateSizes(this.container.clientWidth/this.container.clientHeight)},this.setMirror=R=>{this.mirror=R,this.layers.forEach(k=>{k.style.transform=R?"scaleX(-1)":""})},this.setMode=R=>{if(this.mode=R,this.mode==="pad"&&!this.pads){this.pads=[document.createElement("canvas"),document.createElement("canvas")];const k=-10*(this.layerCount+1)+"";for(let X=0;X<2;X++)this.pads[X].id="engeenee.canvas.pad"+X,this.pads[X].style.position="absolute",this.pads[X].style.zIndex=k,this.container.appendChild(this.pads[X])}this.mode!=="pad"&&this.pads&&(this.pads.forEach(k=>k.remove()),delete this.pads),this.setAspectRatio(this.aspectRatio)},this.dispose=()=>{var R,k;(R=this.observer)==null||R.disconnect(),delete this.observer,(k=this.pads)==null||k.forEach(X=>X.remove()),delete this.pads,this.layers.forEach(X=>X.remove()),this.layers=[]},this.updateSizes=R=>{let k=1,X=1;R>this.aspectRatio?this.mode==="crop"?X=R/this.aspectRatio:k=this.aspectRatio/R:this.mode==="crop"?k=this.aspectRatio/R:X=R/this.aspectRatio;const K=(1-k)/2,Q=(1-X)/2,xe=k*100+"%",ue=X*100+"%",ge=K*100+"%",_e=Q*100+"%";for(const Re of this.layers)Re.style.width=xe,Re.style.height=ue,Re.style.left=ge,Re.style.top=_e;if(this.pads){this.padsSize=K>0?[K,1]:[1,Q];const Re=10,{clientWidth:be,clientHeight:ve}=this.container,Xe=[2*Re/be,2*Re/ve],Be=(this.padsSize[0]+2*Xe[0])*100+"%",Ke=(this.padsSize[1]+2*Xe[1])*100+"%";this.pads[0].style.width=Be,this.pads[0].style.height=Ke,this.pads[1].style.width=Be,this.pads[1].style.height=Ke;const bt=-Xe[0]*100+"%",rt=-Xe[1]*100+"%";this.pads[0].style.top=rt,this.pads[1].style.bottom=rt,this.pads[0].style.left="unset",this.pads[0].style.right="unset",this.pads[1].style.left="unset",this.pads[1].style.right="unset",this.pads[this.mirror?1:0].style.left=bt,this.pads[this.mirror?0:1].style.right=bt;const xt=K>0?this.mirror?"":"scaleX(-1)":"scaleY(-1) "+(this.mirror?"scaleX(-1)":"");this.pads[0].style.transform=xt,this.pads[1].style.transform=xt;const Mt="blur("+Re+"px)";this.pads[0].style.filter=Mt,this.pads[1].style.filter=Mt}this.emit("resize")},this.handleResize=R=>{if(R.length<1)return;const k=R[0].contentRect;this.updateSizes(k.width/k.height)};for(let R=0;R<g;R++){const k=document.createElement("canvas");k.id="engeenee.canvas.layer"+R,k.style.position="absolute",k.style.zIndex=-10*(g-R)+"",this.mirror&&(k.style.transform="scaleX(-1)"),this.container.appendChild(k),this.layers.push(k)}this.setMode(d),this.observer=new ResizeObserver(this.handleResize),this.observer.observe(this.container),this.container.style.overflow="hidden"}}var Ce=Object.defineProperty,Pe=Object.getOwnPropertySymbols,je=Object.prototype.hasOwnProperty,Ne=Object.prototype.propertyIsEnumerable,Qe=(I,r,d)=>r in I?Ce(I,r,{enumerable:!0,configurable:!0,writable:!0,value:d}):I[r]=d,Ct=(I,r)=>{for(var d in r||(r={}))je.call(r,d)&&Qe(I,d,r[d]);if(Pe)for(var d of Pe(r))Ne.call(r,d)&&Qe(I,d,r[d]);return I};class dt extends c{constructor(){super(),this.loaded=!1,this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.cameraRatio=this.videoRatio,this.cameraAngle=10/180*Math.PI}async load(){this.loaded||(this.loaded=!0,this.emit("load"))}unload(){this.loaded&&(this.loaded=!1)}async update(r,d){this.loaded&&(this.updateVideo(d),this.updateScene(),this.emit("render"))}updateVideo(r){}updateScene(){}dispose(){this.unload()}setupVideo(r,d){this.videoSize=Ct({},r),this.videoRatio=d||r.width/r.height,this.emit("resize",this.videoSize,this.videoRatio)}setupCamera(r,d){this.cameraRatio=r,this.cameraAngle=d}}class Xt extends dt{constructor(){super(...arguments),this.plugins=[]}async load(){if(!this.loaded)return await Promise.all(this.plugins.map(r=>r.load(this))),super.load()}unload(){this.plugins.forEach(r=>r.unload()),super.unload()}async update(r,d){if(this.loaded)return await this.updatePlugins(r,d),super.update(r,d)}async updatePlugins(r,d){for(let g of this.plugins)g.loaded&&await g.update(r,d)}dispose(){this.plugins.forEach(r=>r.dispose()),this.plugins=[],super.dispose()}async addPlugin(r){const{plugins:d}=this;this.loaded&&!r.loaded&&await r.load(this),d.push(r),d.sort((g,y)=>g.ordinal-y.ordinal)}removePlugin(r){const{plugins:d}=this,g=d.indexOf(r);g<0||(d[g].dispose(),d.splice(g,1))}removeAllPlugins(){this.plugins.forEach(r=>r.dispose()),this.plugins=[]}setupVideo(r,d){super.setupVideo(r,d),this.plugins.forEach(g=>g.setupVideo(r))}setupCamera(r,d){super.setupCamera(r,d),this.plugins.forEach(g=>g.setupCamera(r,d))}}class Gt extends Xt{constructor(r){super(),this.padCtx=[null,null],this.setupPadding=()=>{if(!this.canvas.pads)return;const{width:d,height:g}=this.videoSize,{padsSize:y}=this.canvas,_=d*y[0]/(y[0]<.5?1-2*y[0]:1),R=g*y[1]/(y[1]<.5?1-2*y[1]:1);this.canvas.pads[0].width=_,this.canvas.pads[0].height=R,this.canvas.pads[1].width=_,this.canvas.pads[1].height=R},this.canvas=new Ae(r.container,r.mode,r.layerCount,r.mirror,r.aspectRatio),this.canvas.pads&&(this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]),this.canvas.addListener("resize",this.setupPadding)}updateVideo(r){super.updateVideo(r),this.updatePads(r)}dispose(){this.padCtx=[null,null],this.canvas.dispose(),super.dispose()}setupVideo(r,d){super.setupVideo(r,d),this.canvas.setAspectRatio(this.videoRatio)}setMirror(r){this.canvas.setMirror(r)}setMode(r){this.canvas.setMode(r),this.canvas.pads?this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]:this.padCtx=[null,null]}updatePads(r){if(!this.padCtx[0]||!this.padCtx[1]||!this.canvas.pads)return;const{videoSize:{width:d,height:g}}=this,{width:y,height:_}=this.canvas.pads[0];this.padCtx[0].clearRect(0,0,y,_),this.padCtx[0].drawImage(r,0,0,y,_,0,0,y,_),this.padCtx[1].clearRect(0,0,y,_),this.padCtx[1].drawImage(r,d-y,g-_,y,_,0,0,y,_)}}class Vt extends null{constructor(r){super(r),this.videoCtx=null;const d=this.canvas.layers[0];this.videoCtx=d.getContext("2d")}updateVideo(r){const{videoCtx:d}=this;if(!d)return;const{width:g,height:y}=this.videoSize;d.clearRect(0,0,g,y),d.drawImage(r,0,0),super.updateVideo(r)}setupVideo(r,d){super.setupVideo(r,d);const{width:g,height:y}=this.videoSize;this.canvas.layers[0].width=g,this.canvas.layers[0].height=y}}class T0{constructor(r,d={width:1920,height:1080},g=!1,y=!1){this.gl=r,this.size=d,this.grayscale=g,this.linear=y,this.buffer=null,this.resize(d)}update(r){const{gl:d,size:{width:g,height:y}}=this,_=d.getParameter(d.TEXTURE_BINDING_2D),R=d.getParameter(d.UNPACK_FLIP_Y_WEBGL);return d.bindTexture(d.TEXTURE_2D,this.buffer),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,!1),r instanceof Uint8Array?d.texSubImage2D(d.TEXTURE_2D,0,0,0,g,y,this.grayscale?d.RED:d.RGBA,d.UNSIGNED_BYTE,r):d.texSubImage2D(d.TEXTURE_2D,0,0,0,g,y,this.grayscale?d.RED:d.RGBA,d.UNSIGNED_BYTE,r),d.bindTexture(d.TEXTURE_2D,_),d.pixelStorei(d.UNPACK_FLIP_Y_WEBGL,R),this.buffer}resize(r){const{width:d,height:g}=r;if(d===this.size.width&&g===this.size.height&&this.buffer)return!0;const{gl:y}=this;if(y.deleteTexture(this.buffer),this.buffer=null,(d>0||g>0)&&(this.buffer=y.createTexture()),!this.buffer)return!1;const _=this.linear?y.LINEAR:y.NEAREST,R=y.getParameter(y.TEXTURE_BINDING_2D),k=y.getParameter(y.UNPACK_FLIP_Y_WEBGL);return y.bindTexture(y.TEXTURE_2D,this.buffer),y.pixelStorei(y.UNPACK_FLIP_Y_WEBGL,!1),y.texParameteri(y.TEXTURE_2D,y.TEXTURE_WRAP_S,y.CLAMP_TO_EDGE),y.texParameteri(y.TEXTURE_2D,y.TEXTURE_WRAP_T,y.CLAMP_TO_EDGE),y.texParameteri(y.TEXTURE_2D,y.TEXTURE_MIN_FILTER,_),y.texParameteri(y.TEXTURE_2D,y.TEXTURE_MAG_FILTER,_),this.size={width:d,height:g},y.texStorage2D(y.TEXTURE_2D,1,this.grayscale?y.R8:y.RGBA8,d,g),y.bindTexture(y.TEXTURE_2D,R),y.pixelStorei(y.UNPACK_FLIP_Y_WEBGL,k),!0}dispose(){this.gl.deleteTexture(this.buffer),this.buffer=null}texture(){return this.buffer}valid(){return!!this.buffer}}var r0=Object.defineProperty,d0=Object.getOwnPropertySymbols,Ut=Object.prototype.hasOwnProperty,$0=Object.prototype.propertyIsEnumerable,Q0=(I,r,d)=>r in I?r0(I,r,{enumerable:!0,configurable:!0,writable:!0,value:d}):I[r]=d,Un=(I,r)=>{for(var d in r||(r={}))Ut.call(r,d)&&Q0(I,d,r[d]);if(d0)for(var d of d0(r))$0.call(r,d)&&Q0(I,d,r[d]);return I};class b0{constructor(r,d={width:1920,height:1080},g=["image"],y={},_=Rt,R=X0,k=!1){this.gl=r,this.size=d,this.inputs=g,this.uniforms=y,this.vertShader=null,this.fragShader=null,this.shaderProgram=null,this.vertBuffer=null,this.vertAttrs=null,this.uniformsLoc={},this.frameBuffer=null,_.includes("uniform vec2 wh;")&&!y.wh&&(y.wh="2f"),R.includes("uniform float flip;")&&!y.flip&&(y.flip="1f"),this.outputTexture=new T0(r,d,!1,k),this.compile(_,R),this.resize(d)}process(r,d={}){const{gl:g,outputTexture:y}=this;if(!g||!y||r.length!==this.inputs.length)return null;const _=y.texture();if(!_)return null;const R=this.save(g);return g.bindFramebuffer(g.FRAMEBUFFER,this.frameBuffer),g.framebufferTexture2D(g.FRAMEBUFFER,g.COLOR_ATTACHMENT0,g.TEXTURE_2D,_,0),d=Un({flip:[-1]},d),this.prepare(g,r,d),g.drawArrays(g.TRIANGLES,0,6),this.restore(g,R),_}render(r,d={}){const{gl:g,outputTexture:y}=this;if(!g||!y||r.length!==this.inputs.length)return;const _=this.save(g);g.bindFramebuffer(g.FRAMEBUFFER,null),d=Un({flip:[1]},d),this.prepare(g,r,d),g.drawArrays(g.TRIANGLES,0,6),this.restore(g,_)}output(){var r;return((r=this.outputTexture)==null?void 0:r.texture())||null}program(){return this.shaderProgram}resize(r){var d;const{gl:g}=this;this.size={width:r.width,height:r.height},(d=this.outputTexture)==null||d.resize(r);const y=g.getParameter(g.CURRENT_PROGRAM);g.useProgram(this.shaderProgram),this.uniformsLoc.wh&&g.uniform2f(this.uniformsLoc.wh,r.width,r.height),g.useProgram(y)}dispose(){var r;const{gl:d}=this;d.deleteBuffer(this.vertBuffer),this.vertBuffer=null,d.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,d.deleteShader(this.vertShader),this.vertShader=null,d.deleteShader(this.fragShader),this.fragShader=null,d.deleteProgram(this.shaderProgram),this.shaderProgram=null,(r=this.outputTexture)==null||r.dispose(),delete this.outputTexture}compile(r,d){const{gl:g}=this,y=this.save(g);if(this.vertBuffer=g.createBuffer(),this.vertAttrs=g.createVertexArray(),this.frameBuffer=g.createFramebuffer(),!this.vertBuffer||!this.frameBuffer||!this.vertAttrs){g.deleteBuffer(this.vertBuffer),this.vertBuffer=null,g.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,g.deleteVertexArray(this.vertAttrs),this.vertAttrs=null;return}if(this.vertShader=g.createShader(g.VERTEX_SHADER),this.fragShader=g.createShader(g.FRAGMENT_SHADER),this.shaderProgram=g.createProgram(),!this.vertShader||!this.fragShader||!this.shaderProgram){g.deleteBuffer(this.vertBuffer),this.vertBuffer=null,g.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,g.deleteShader(this.vertShader),this.vertShader=null,g.deleteShader(this.fragShader),this.fragShader=null,g.deleteProgram(this.shaderProgram),this.shaderProgram=null;return}g.shaderSource(this.vertShader,d),g.shaderSource(this.fragShader,r),g.compileShader(this.vertShader),g.compileShader(this.fragShader),g.attachShader(this.shaderProgram,this.vertShader),g.attachShader(this.shaderProgram,this.fragShader),g.linkProgram(this.shaderProgram),g.useProgram(this.shaderProgram),g.bindBuffer(g.ARRAY_BUFFER,this.vertBuffer),g.bufferData(g.ARRAY_BUFFER,new Float32Array([-1,-1,1,1,-1,1,-1,-1,1,-1,1,1]),g.STATIC_DRAW),g.bindVertexArray(this.vertAttrs);const _=g.getAttribLocation(this.shaderProgram,"pos");g.vertexAttribPointer(_,2,g.FLOAT,!1,0,0),g.enableVertexAttribArray(_),this.uniformsLoc={};for(let R in this.uniforms)this.uniformsLoc[R]=g.getUniformLocation(this.shaderProgram,R);for(let R=0;R<this.inputs.length;R++)g.uniform1i(g.getUniformLocation(this.shaderProgram,this.inputs[R]),R);this.restore(g,y)}prepare(r,d,g={}){const{size:{width:y,height:_}}=this;for(let R=0;R<d.length;R++)r.activeTexture(r.TEXTURE0+R),r.bindTexture(r.TEXTURE_2D,d[R]);r.useProgram(this.shaderProgram),r.bindVertexArray(this.vertAttrs);for(let R in g)switch(this.uniforms[R]){case"1f":this.uniformsLoc[R]&&g[R].length===1&&r.uniform1f(this.uniformsLoc[R],g[R][0]);break;case"2f":this.uniformsLoc[R]&&g[R].length===2&&r.uniform2f(this.uniformsLoc[R],g[R][0],g[R][1]);break;case"3f":this.uniformsLoc[R]&&g[R].length===3&&r.uniform3f(this.uniformsLoc[R],g[R][0],g[R][1],g[R][2]);break;case"4f":this.uniformsLoc[R]&&g[R].length===4&&r.uniform4f(this.uniformsLoc[R],g[R][0],g[R][1],g[R][2],g[R][3]);break}r.disable(r.CULL_FACE),r.colorMask(!0,!0,!0,!0),r.viewport(0,0,y,_),r.scissor(0,0,y,_)}save(r){return{program:r.getParameter(r.CURRENT_PROGRAM),arrayBuffer:r.getParameter(r.ARRAY_BUFFER_BINDING),framebuffer:r.getParameter(r.FRAMEBUFFER_BINDING),vertexArray:r.getParameter(r.VERTEX_ARRAY_BINDING),viewport:r.getParameter(r.VIEWPORT),scissor:r.getParameter(r.SCISSOR_BOX),colorMask:r.getParameter(r.COLOR_WRITEMASK),cullFace:r.getParameter(r.CULL_FACE),activeTexture:r.getParameter(r.ACTIVE_TEXTURE),textures:this.inputs.map((d,g)=>(r.activeTexture(r.TEXTURE0+g),r.getParameter(r.TEXTURE_BINDING_2D)))}}restore(r,d){r.useProgram(d.program),r.bindBuffer(r.ARRAY_BUFFER,d.arrayBuffer),r.bindFramebuffer(r.FRAMEBUFFER,d.framebuffer),r.bindVertexArray(d.vertexArray),r.viewport(d.viewport[0],d.viewport[1],d.viewport[2],d.viewport[3]),r.scissor(d.scissor[0],d.scissor[1],d.scissor[2],d.scissor[3]),r.colorMask(d.colorMask[0],d.colorMask[1],d.colorMask[2],d.colorMask[3]);for(let g=0;g<d.textures.length;g++)r.activeTexture(r.TEXTURE0+g),r.bindTexture(r.TEXTURE_2D,d.textures[g]);r.activeTexture(d.activeTexture),d.cullFace?r.enable(r.CULL_FACE):r.disable(r.CULL_FACE)}}const X0=`
    attribute vec2 pos;
    uniform float flip;
    varying vec2 xy;
    void main() {
        xy = (vec2(pos.x, -pos.y) + 1.0) * 0.5;
        gl_Position = vec4(pos.x, pos.y * flip, 0, 1.0);
    }
`,Rt=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D image;
    void main() {
        gl_FragColor = texture2D(image, xy);
    }
`;class Qt extends Gt{constructor(r){super(r),this.shaderCtx=null,this.current=null;const d=this.canvas.layers[0];this.shaderCtx=d.getContext("webgl2",{alpha:!0,preserveDrawingBuffer:!0})}async load(){if(this.loaded)return;const{shaderCtx:r,videoSize:d}=this;if(r)return this.shader=new b0(r,d),this.input=new T0(r,d),super.load()}unload(){var r,d;(r=this.input)==null||r.dispose(),delete this.input,(d=this.shader)==null||d.dispose(),delete this.shader,super.unload()}async update(r,d){if(!this.loaded)return;const{input:g}=this,y=g?.texture();if(!(!g||!y))return g?.update(d),this.current=y,super.update(r,d)}updateVideo(r){this.shader&&(this.shader.render([this.current]),super.updateVideo(r))}setupVideo(r,d){var g,y;super.setupVideo(r,d);const{width:_,height:R}=this.videoSize;this.canvas.layers[0].width=_,this.canvas.layers[0].height=R,(g=this.input)==null||g.resize({width:_,height:R}),(y=this.shader)==null||y.resize({width:_,height:R})}}class A0 extends Qt{dispose(){delete this.scene,super.dispose()}}class J0{constructor(){this.loaded=!1,this.ordinal=800}async load(r){this.loaded||(this.renderer=r,this.loaded=!0)}unload(){this.loaded&&(this.loaded=!1)}async update(r,d){this.loaded}dispose(){this.unload()}setupVideo(r){}setupCamera(r,d){}}var Pn=(I=>(I[I.PreProcess=100]="PreProcess",I[I.Process=200]="Process",I[I.PostProcess=300]="PostProcess",I[I.PreRender=700]="PreRender",I[I.Render=800]="Render",I[I.PostRender=900]="PostRender",I))(Pn||{});class dx extends null{constructor(){super(),this.ordinal=Pn.PreRender}async load(r){if(!(this.loaded||!(r instanceof Vt)||!r.videoCtx))return this.videoCtx=r.videoCtx,super.load(r)}unload(){this.loaded&&(delete this.videoCtx,super.unload())}}var Bn=Object.defineProperty,Wn=Object.getOwnPropertySymbols,gx=Object.prototype.hasOwnProperty,Jx=Object.prototype.propertyIsEnumerable,er=(I,r,d)=>r in I?Bn(I,r,{enumerable:!0,configurable:!0,writable:!0,value:d}):I[r]=d,Cr=(I,r)=>{for(var d in r||(r={}))gx.call(r,d)&&er(I,d,r[d]);if(Wn)for(var d of Wn(r))Jx.call(r,d)&&er(I,d,r[d]);return I};class Rr extends null{constructor(r,d,g,y){super(),this.inputs=r,this.uniforms=d,this.fragSrc=g,this.vertSrc=y,this.size={width:0,height:0},this.ordinal=Pn.PreRender}async load(r){if(!(this.loaded||!(r instanceof Qt)||!r.shaderCtx))return this.shader=new b0(r.shaderCtx,this.size,this.inputs,this.uniforms,this.fragSrc,this.vertSrc),super.load(r)}unload(){var r;this.loaded&&((r=this.shader)==null||r.dispose(),delete this.shader,super.unload())}async update(r,d){var g;const{renderer:y}=this;if(!this.loaded||!(y instanceof Qt)||!y.current)return;const _=await this.process(r,y.current)&&((g=this.shader)==null?void 0:g.output());_&&(y.current=_)}async process(r,d){var g;return(g=this.shader)==null||g.process([d]),!0}setupVideo(r){var d;this.size=Cr({},r),(d=this.shader)==null||d.resize(r)}}class xi extends J0{constructor(){super(),this.ordinal=Pn.Render}async load(r){if(!(this.loaded||!(r instanceof A0)||!r.scene))return this.scene=r.scene,super.load(r)}unload(){this.loaded&&(delete this.scene,super.unload())}}class Nr{constructor(r,d=!1,g="video",y){this.renderer=r,this.mirror=d,this.sizeMode=g,this.sizeMax=y}async snapshot(){return new Promise(r=>{this.renderer.once("render",()=>{const{renderer:d}=this,{layers:g}=d.canvas;let{width:y,height:_}=d.canvas.layers[0];this.sizeMode==="max"?(y=Math.max(...g.map(K=>K.width)),_=Math.max(...g.map(K=>K.height))):this.sizeMode==="min"&&(y=Math.min(...g.map(K=>K.width)),_=Math.min(...g.map(K=>K.height)));const R=document.createElement("canvas");R.id="engeenee.snapshot",R.hidden=!0,R.width=y,R.height=_;const k=R.getContext("2d",{alpha:!0});if(!k)return;this.mirror&&(k.translate(y,0),k.scale(-1,1)),g.forEach(K=>k.drawImage(K,0,0,y,_));const X=k.getImageData(0,0,y,_);R.remove(),r(X)})})}async snapshotLayers(){return new Promise(r=>{this.renderer.once("render",()=>{const d=document.createElement("canvas");d.id="engeenee.snapshot",d.hidden=!0;const g=d.getContext("2d",{alpha:!0});if(!g)return;const y=this.renderer.canvas.layers.map(_=>{const{width:R,height:k}=_;return d.width=R,d.height=k,g.resetTransform(),this.mirror&&(g.translate(R,0),g.scale(-1,1)),g.drawImage(_,0,0),g.getImageData(0,0,R,k)});d.remove(),r(y)})})}}class rr{constructor(r,d="video/webm",g=!1,y="video",_,R){this.renderer=r,this.type=d,this.mirror=g,this.sizeMode=y,this.sizeMax=_,this.bitRate=R,this.context=null,this.records=[],this.frame=()=>{var k;const{renderer:X,context:K,stream:Q}=this,{width:xe,height:ue}=this.canvas;!Q||!K||(X.canvas.layers.map(ge=>K.drawImage(ge,0,0,xe,ue)),(k=Q.getVideoTracks()[0])==null||k.requestFrame())},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:r,context:d,renderer:g}=this;if(!r||!d)return!1;const{layers:y}=g.canvas;let{width:_,height:R}=y[0];this.sizeMode==="max"?(_=Math.max(...y.map(X=>X.width)),R=Math.max(...y.map(X=>X.height))):this.sizeMode==="min"&&(_=Math.min(...y.map(X=>X.width)),R=Math.min(...y.map(X=>X.height)));const k=Math.max(_,R);if(this.sizeMax&&k>this.sizeMax){const X=this.sizeMax/k;_*=X,R*=X}return r.width=_,r.height=R,d.resetTransform(),this.mirror&&(d.translate(_,0),d.scale(-1,1)),g.on("render",this.frame),this.records=[],this.stream=r.captureStream(0),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=X=>this.records.push(X.data),this.recorder.start(),!0}async stop(){const{recorder:r}=this;if(!(!r||r.state!="recording"))return new Promise(d=>{r.onstop=()=>{var g;d(new Blob(this.records,{type:this.type})),this.records=[],(g=this.stream)==null||g.getVideoTracks().forEach(y=>y.stop()),this.renderer.removeListener("render",this.frame),delete this.stream,delete this.recorder},r.stop()})}dispose(){this.canvas.remove()}}class ja{constructor(r,d=0,g="video/webm",y){this.renderer=r,this.layer=d,this.type=g,this.bitRate=y,this.records=[]}start(){const{renderer:r}=this,d=r.canvas.layers[this.layer];return this.records=[],this.stream=d.captureStream(),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=g=>this.records.push(g.data),this.recorder.start(),!0}async stop(){const{recorder:r}=this;if(!(!r||r.state!="recording"))return new Promise(d=>{r.onstop=()=>{var g;d(new Blob(this.records,{type:this.type})),this.records=[],(g=this.stream)==null||g.getVideoTracks().forEach(y=>y.stop()),delete this.stream,delete this.recorder},r.stop()})}}class xn{constructor(r,d=!1,g="video",y){this.renderer=r,this.mirror=d,this.sizeMode=g,this.sizeMax=y,this.context=null,this.render=()=>{const{canvas:_,context:R}=this;!_||!R||this.renderer.canvas.layers.map(k=>R.drawImage(k,0,0,_.width,_.height))},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.mirror&&(this.canvas.style.transform="scaleX(-1)"),this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:r,context:d,renderer:g}=this;if(!r||!d)return!1;const{layers:y}=g.canvas;let{width:_,height:R}=y[0];this.sizeMode==="max"?(_=Math.max(...y.map(X=>X.width)),R=Math.max(...y.map(X=>X.height))):this.sizeMode==="min"&&(_=Math.min(...y.map(X=>X.width)),R=Math.min(...y.map(X=>X.height)));const k=Math.max(_,R);if(this.sizeMax&&k>this.sizeMax){const X=this.sizeMax/k;_*=X,R*=X}return r.width=_,r.height=R,d.resetTransform(),this.mirror&&(d.translate(_,0),d.scale(-1,1)),this.renderer.on("render",this.render),this.stream=r.captureStream(),!0}pause(){this.renderer.removeListener("render",this.render)}mediaStream(){return this.stream}}class io extends null{constructor(){super(...arguments),this.faceTracker=new Y,this.cameraAngleBase=10/180*Math.PI}async init(r,d,g){return await this.faceTracker.init(r.token,r.root,r.cache,r.highp),await this.faceTracker.prepare(),super.init(r,d,g)}reset(){this.faceTracker.reset(),super.reset()}dispose(){this.faceTracker.dispose()}async process(r,d){return{faces:(await this.faceTracker.process(r,d)).map(g=>{const y=g&&this.params.transform?this.faceTracker.align(g.keypoints):void 0,_=y&&this.params.metric?this.faceTracker.metricPoints():void 0,R=y&&this.params.backproj?this.faceTracker.backprojPoints():void 0;return{mesh:g,transform:y,metric:_,backproj:R}})}}setupVideo(r,d){super.setupVideo(r,d),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.faceTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.faceTracker.reset()}}class Po extends null{constructor(r,d=D){super(io,r,d)}}class Ka extends Me{constructor(){super(),this.poseTracker=new u.Xv,this.cameraAngleBase=15/180*Math.PI;const r=/iPhone|iPad|iPod/i.test(navigator.userAgent);this.optimalSize=r?512:1024}async init(r,d,g){return await this.poseTracker.init(r.token,r.root,r.cache,r.mask),await this.poseTracker.prepare(),super.init(r,d,g)}reset(){return this.poseTracker.reset(),super.reset()}dispose(){this.poseTracker.dispose()}async process(r,d){return{poses:(await this.poseTracker.process(r,d)).map(g=>({points:ba(y=>g.keypoints[uo[y]]),score:g.score,mask:g.mask,timestamp:d,debug:g.debug}))}}setupVideo(r,d){super.setupVideo(r,d),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.poseTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.poseTracker.reset()}}class Ji extends j{constructor(r,d=H){super(Ka,r,d)}}const W2=["nose","eyeInnerL","eyeL","eyeOutterL","eyeInnerR","eyeR","eyeOutterR","earL","earR","mouthL","mouthR","shoulderL","shoulderR","elbowL","elbowR","wristL","wristR","pinkyL","pinkyR","indexL","indexR","thumbL","thumbR","hipL","hipR","kneeL","kneeR","ankleL","ankleR","heelL","heelR","footIndexL","footIndexR"];function Vc(I,r){return Object.fromEntries(r.map(d=>[d,I(d)]))}const Ql=(I,r)=>Vc(I,r),ba=I=>Vc(I,W2),uo=ba(I=>W2.indexOf(I));class Wi extends null{constructor(){super(...arguments),this.handTracker=new x,this.cameraAngleBase=10/180*Math.PI}async init(r,d,g){return await this.handTracker.init(r.token,r.root,r.cache),await this.handTracker.prepare(),super.init(r,d,g)}reset(){this.handTracker.reset(),super.reset()}dispose(){this.handTracker.dispose()}async process(r,d){return{hands:(await this.handTracker.process(r,d)).map(g=>({points:g.keypoints,score:g.score,handedness:g.handedness,wrist:g.wrist}))}}setupVideo(r,d){super.setupVideo(r,d),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.handTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.handTracker.reset()}}class $a extends null{constructor(r,d=D){super(Wi,r,d)}}const Rs="161",C2={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},vd={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},Gu=0,R2=1,ul=2,Q2=3,Ns=0,Js=1,Pi=2,_a=3,Ta=0,vs=1,Ba=2,Aa=0,Bi=1,Ws=2,Nn=3,bs=4,_r=5,Ui=100,go=101,dl=102,Uc=103,ec=104,xc=200,rc=201,gl=202,vl=203,uc=204,dc=205,N2=206,bl=207,vo=208,Wo=209,Qo=210,bo=211,Xu=212,gc=213,Bo=214,ju=0,zo=1,Gc=2,Vo=3,vc=4,Ku=5,$u=6,Uo=7,bc=0,Go=1,_o=2,Ma=0,Ju=1,Xc=2,jc=3,Wu=4,Qu=5,eh=6,_c="attached",To="detached",_l=300,_s=301,e2=302,Qs=303,Ps=304,P2=306,Ri=1e3,Gi=1001,ea=1002,gi=1003,Tc=1004,k2=1004,x2=1005,Tl=1005,ui=1006,Xo=1007,za=1007,Us=1008,Va=1008,Ao=1009,Al=1010,Gs=1011,Ac=1012,r2=1013,jo=1014,Ts=1015,Xi=1016,eu=1017,Kc=1018,u2=1020,xh=1021,xa=1023,rh=1024,uh=1025,d2=1026,B2=1027,dh=1028,xu=1029,ru=1030,uu=1031,du=1033,$c=33776,Jc=33777,Ua=33778,z2=33779,Ml=35840,Cl=35841,ra=35842,g2=35843,et=36196,Je=37492,Nt=37496,_0=37808,Ue=37809,ze=37810,We=37811,_t=37812,jt=37813,e0=37814,u0=37815,Jt=37816,B0=37817,dn=37818,zn=37819,Jn=37820,Wx=37821,br=36492,Qr=36494,gr=36495,Qi=36283,es=36284,Xs=36285,ji=36286,gh=2200,bd=2201,_d=2202,Ja=2300,Ga=2301,Td=2302,Rl=2400,Mc=2401,Ad=2402,vh=2500,Ge=2501,Ve=0,gt=1,Kt=2,k0=3e3,z0=3001,K0=3200,C0=3201,Rn=0,rx=1,$n="",jn="srgb",vx="srgb-linear",$r="display-p3",Mi="display-p3-linear",ei="linear",dr="srgb",$i="rec709",gn="p3",Tx=0,zi=7680,us=7681,V2=7682,Gx=7683,js=34055,Cc=34056,Wc=5386,Wp=512,Qp=513,gu=514,em=515,Qf=516,Ca=517,v2=518,U2=519,VT=512,UT=513,GT=514,Rb=515,XT=516,jT=517,KT=518,$T=519,xm=35044,C6=35048,R6=35040,N6=35045,P6=35049,B6=35041,z6=35046,V6=35050,U6=35042,G6="100",Nb="300 es",Cy=1035,Nl=2e3,rm=2001;class Md{addEventListener(r,d){this._listeners===void 0&&(this._listeners={});const g=this._listeners;g[r]===void 0&&(g[r]=[]),g[r].indexOf(d)===-1&&g[r].push(d)}hasEventListener(r,d){if(this._listeners===void 0)return!1;const g=this._listeners;return g[r]!==void 0&&g[r].indexOf(d)!==-1}removeEventListener(r,d){if(this._listeners===void 0)return;const y=this._listeners[r];if(y!==void 0){const _=y.indexOf(d);_!==-1&&y.splice(_,1)}}dispatchEvent(r){if(this._listeners===void 0)return;const g=this._listeners[r.type];if(g!==void 0){r.target=this;const y=g.slice(0);for(let _=0,R=y.length;_<R;_++)y[_].call(this,r);r.target=null}}}const Wa=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Pb=1234567;const bh=Math.PI/180,Cd=180/Math.PI;function b2(){const I=Math.random()*4294967295|0,r=Math.random()*4294967295|0,d=Math.random()*4294967295|0,g=Math.random()*4294967295|0;return(Wa[I&255]+Wa[I>>8&255]+Wa[I>>16&255]+Wa[I>>24&255]+"-"+Wa[r&255]+Wa[r>>8&255]+"-"+Wa[r>>16&15|64]+Wa[r>>24&255]+"-"+Wa[d&63|128]+Wa[d>>8&255]+"-"+Wa[d>>16&255]+Wa[d>>24&255]+Wa[g&255]+Wa[g>>8&255]+Wa[g>>16&255]+Wa[g>>24&255]).toLowerCase()}function As(I,r,d){return Math.max(r,Math.min(d,I))}function Ry(I,r){return(I%r+r)%r}function JT(I,r,d,g,y){return g+(I-r)*(y-g)/(d-r)}function WT(I,r,d){return I!==r?(d-I)/(r-I):0}function ep(I,r,d){return(1-d)*I+d*r}function QT(I,r,d,g){return ep(I,r,1-Math.exp(-d*g))}function eE(I,r=1){return r-Math.abs(Ry(I,r*2)-r)}function xE(I,r,d){return I<=r?0:I>=d?1:(I=(I-r)/(d-r),I*I*(3-2*I))}function rE(I,r,d){return I<=r?0:I>=d?1:(I=(I-r)/(d-r),I*I*I*(I*(I*6-15)+10))}function uE(I,r){return I+Math.floor(Math.random()*(r-I+1))}function dE(I,r){return I+Math.random()*(r-I)}function gE(I){return I*(.5-Math.random())}function vE(I){I!==void 0&&(Pb=I);let r=Pb+=1831565813;return r=Math.imul(r^r>>>15,r|1),r^=r+Math.imul(r^r>>>7,r|61),((r^r>>>14)>>>0)/4294967296}function bE(I){return I*bh}function _E(I){return I*Cd}function Ny(I){return(I&I-1)===0&&I!==0}function TE(I){return Math.pow(2,Math.ceil(Math.log(I)/Math.LN2))}function um(I){return Math.pow(2,Math.floor(Math.log(I)/Math.LN2))}function AE(I,r,d,g,y){const _=Math.cos,R=Math.sin,k=_(d/2),X=R(d/2),K=_((r+g)/2),Q=R((r+g)/2),xe=_((r-g)/2),ue=R((r-g)/2),ge=_((g-r)/2),_e=R((g-r)/2);switch(y){case"XYX":I.set(k*Q,X*xe,X*ue,k*K);break;case"YZY":I.set(X*ue,k*Q,X*xe,k*K);break;case"ZXZ":I.set(X*xe,X*ue,k*Q,k*K);break;case"XZX":I.set(k*Q,X*_e,X*ge,k*K);break;case"YXY":I.set(X*ge,k*Q,X*_e,k*K);break;case"ZYZ":I.set(X*_e,X*ge,k*Q,k*K);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+y)}}function Mo(I,r){switch(r.constructor){case Float32Array:return I;case Uint32Array:return I/4294967295;case Uint16Array:return I/65535;case Uint8Array:return I/255;case Int32Array:return Math.max(I/2147483647,-1);case Int16Array:return Math.max(I/32767,-1);case Int8Array:return Math.max(I/127,-1);default:throw new Error("Invalid component type.")}}function Br(I,r){switch(r.constructor){case Float32Array:return I;case Uint32Array:return Math.round(I*4294967295);case Uint16Array:return Math.round(I*65535);case Uint8Array:return Math.round(I*255);case Int32Array:return Math.round(I*2147483647);case Int16Array:return Math.round(I*32767);case Int8Array:return Math.round(I*127);default:throw new Error("Invalid component type.")}}const ME={DEG2RAD:bh,RAD2DEG:Cd,generateUUID:b2,clamp:As,euclideanModulo:Ry,mapLinear:JT,inverseLerp:WT,lerp:ep,damp:QT,pingpong:eE,smoothstep:xE,smootherstep:rE,randInt:uE,randFloat:dE,randFloatSpread:gE,seededRandom:vE,degToRad:bE,radToDeg:_E,isPowerOfTwo:Ny,ceilPowerOfTwo:TE,floorPowerOfTwo:um,setQuaternionFromProperEuler:AE,normalize:Br,denormalize:Mo};class vn{constructor(r=0,d=0){vn.prototype.isVector2=!0,this.x=r,this.y=d}get width(){return this.x}set width(r){this.x=r}get height(){return this.y}set height(r){this.y=r}set(r,d){return this.x=r,this.y=d,this}setScalar(r){return this.x=r,this.y=r,this}setX(r){return this.x=r,this}setY(r){return this.y=r,this}setComponent(r,d){switch(r){case 0:this.x=d;break;case 1:this.y=d;break;default:throw new Error("index is out of range: "+r)}return this}getComponent(r){switch(r){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+r)}}clone(){return new this.constructor(this.x,this.y)}copy(r){return this.x=r.x,this.y=r.y,this}add(r){return this.x+=r.x,this.y+=r.y,this}addScalar(r){return this.x+=r,this.y+=r,this}addVectors(r,d){return this.x=r.x+d.x,this.y=r.y+d.y,this}addScaledVector(r,d){return this.x+=r.x*d,this.y+=r.y*d,this}sub(r){return this.x-=r.x,this.y-=r.y,this}subScalar(r){return this.x-=r,this.y-=r,this}subVectors(r,d){return this.x=r.x-d.x,this.y=r.y-d.y,this}multiply(r){return this.x*=r.x,this.y*=r.y,this}multiplyScalar(r){return this.x*=r,this.y*=r,this}divide(r){return this.x/=r.x,this.y/=r.y,this}divideScalar(r){return this.multiplyScalar(1/r)}applyMatrix3(r){const d=this.x,g=this.y,y=r.elements;return this.x=y[0]*d+y[3]*g+y[6],this.y=y[1]*d+y[4]*g+y[7],this}min(r){return this.x=Math.min(this.x,r.x),this.y=Math.min(this.y,r.y),this}max(r){return this.x=Math.max(this.x,r.x),this.y=Math.max(this.y,r.y),this}clamp(r,d){return this.x=Math.max(r.x,Math.min(d.x,this.x)),this.y=Math.max(r.y,Math.min(d.y,this.y)),this}clampScalar(r,d){return this.x=Math.max(r,Math.min(d,this.x)),this.y=Math.max(r,Math.min(d,this.y)),this}clampLength(r,d){const g=this.length();return this.divideScalar(g||1).multiplyScalar(Math.max(r,Math.min(d,g)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(r){return this.x*r.x+this.y*r.y}cross(r){return this.x*r.y-this.y*r.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(r){const d=Math.sqrt(this.lengthSq()*r.lengthSq());if(d===0)return Math.PI/2;const g=this.dot(r)/d;return Math.acos(As(g,-1,1))}distanceTo(r){return Math.sqrt(this.distanceToSquared(r))}distanceToSquared(r){const d=this.x-r.x,g=this.y-r.y;return d*d+g*g}manhattanDistanceTo(r){return Math.abs(this.x-r.x)+Math.abs(this.y-r.y)}setLength(r){return this.normalize().multiplyScalar(r)}lerp(r,d){return this.x+=(r.x-this.x)*d,this.y+=(r.y-this.y)*d,this}lerpVectors(r,d,g){return this.x=r.x+(d.x-r.x)*g,this.y=r.y+(d.y-r.y)*g,this}equals(r){return r.x===this.x&&r.y===this.y}fromArray(r,d=0){return this.x=r[d],this.y=r[d+1],this}toArray(r=[],d=0){return r[d]=this.x,r[d+1]=this.y,r}fromBufferAttribute(r,d){return this.x=r.getX(d),this.y=r.getY(d),this}rotateAround(r,d){const g=Math.cos(d),y=Math.sin(d),_=this.x-r.x,R=this.y-r.y;return this.x=_*g-R*y+r.x,this.y=_*y+R*g+r.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Xr{constructor(r,d,g,y,_,R,k,X,K){Xr.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],r!==void 0&&this.set(r,d,g,y,_,R,k,X,K)}set(r,d,g,y,_,R,k,X,K){const Q=this.elements;return Q[0]=r,Q[1]=y,Q[2]=k,Q[3]=d,Q[4]=_,Q[5]=X,Q[6]=g,Q[7]=R,Q[8]=K,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(r){const d=this.elements,g=r.elements;return d[0]=g[0],d[1]=g[1],d[2]=g[2],d[3]=g[3],d[4]=g[4],d[5]=g[5],d[6]=g[6],d[7]=g[7],d[8]=g[8],this}extractBasis(r,d,g){return r.setFromMatrix3Column(this,0),d.setFromMatrix3Column(this,1),g.setFromMatrix3Column(this,2),this}setFromMatrix4(r){const d=r.elements;return this.set(d[0],d[4],d[8],d[1],d[5],d[9],d[2],d[6],d[10]),this}multiply(r){return this.multiplyMatrices(this,r)}premultiply(r){return this.multiplyMatrices(r,this)}multiplyMatrices(r,d){const g=r.elements,y=d.elements,_=this.elements,R=g[0],k=g[3],X=g[6],K=g[1],Q=g[4],xe=g[7],ue=g[2],ge=g[5],_e=g[8],Re=y[0],be=y[3],ve=y[6],Xe=y[1],Be=y[4],Ke=y[7],bt=y[2],rt=y[5],xt=y[8];return _[0]=R*Re+k*Xe+X*bt,_[3]=R*be+k*Be+X*rt,_[6]=R*ve+k*Ke+X*xt,_[1]=K*Re+Q*Xe+xe*bt,_[4]=K*be+Q*Be+xe*rt,_[7]=K*ve+Q*Ke+xe*xt,_[2]=ue*Re+ge*Xe+_e*bt,_[5]=ue*be+ge*Be+_e*rt,_[8]=ue*ve+ge*Ke+_e*xt,this}multiplyScalar(r){const d=this.elements;return d[0]*=r,d[3]*=r,d[6]*=r,d[1]*=r,d[4]*=r,d[7]*=r,d[2]*=r,d[5]*=r,d[8]*=r,this}determinant(){const r=this.elements,d=r[0],g=r[1],y=r[2],_=r[3],R=r[4],k=r[5],X=r[6],K=r[7],Q=r[8];return d*R*Q-d*k*K-g*_*Q+g*k*X+y*_*K-y*R*X}invert(){const r=this.elements,d=r[0],g=r[1],y=r[2],_=r[3],R=r[4],k=r[5],X=r[6],K=r[7],Q=r[8],xe=Q*R-k*K,ue=k*X-Q*_,ge=K*_-R*X,_e=d*xe+g*ue+y*ge;if(_e===0)return this.set(0,0,0,0,0,0,0,0,0);const Re=1/_e;return r[0]=xe*Re,r[1]=(y*K-Q*g)*Re,r[2]=(k*g-y*R)*Re,r[3]=ue*Re,r[4]=(Q*d-y*X)*Re,r[5]=(y*_-k*d)*Re,r[6]=ge*Re,r[7]=(g*X-K*d)*Re,r[8]=(R*d-g*_)*Re,this}transpose(){let r;const d=this.elements;return r=d[1],d[1]=d[3],d[3]=r,r=d[2],d[2]=d[6],d[6]=r,r=d[5],d[5]=d[7],d[7]=r,this}getNormalMatrix(r){return this.setFromMatrix4(r).invert().transpose()}transposeIntoArray(r){const d=this.elements;return r[0]=d[0],r[1]=d[3],r[2]=d[6],r[3]=d[1],r[4]=d[4],r[5]=d[7],r[6]=d[2],r[7]=d[5],r[8]=d[8],this}setUvTransform(r,d,g,y,_,R,k){const X=Math.cos(_),K=Math.sin(_);return this.set(g*X,g*K,-g*(X*R+K*k)+R+r,-y*K,y*X,-y*(-K*R+X*k)+k+d,0,0,1),this}scale(r,d){return this.premultiply(Py.makeScale(r,d)),this}rotate(r){return this.premultiply(Py.makeRotation(-r)),this}translate(r,d){return this.premultiply(Py.makeTranslation(r,d)),this}makeTranslation(r,d){return r.isVector2?this.set(1,0,r.x,0,1,r.y,0,0,1):this.set(1,0,r,0,1,d,0,0,1),this}makeRotation(r){const d=Math.cos(r),g=Math.sin(r);return this.set(d,-g,0,g,d,0,0,0,1),this}makeScale(r,d){return this.set(r,0,0,0,d,0,0,0,1),this}equals(r){const d=this.elements,g=r.elements;for(let y=0;y<9;y++)if(d[y]!==g[y])return!1;return!0}fromArray(r,d=0){for(let g=0;g<9;g++)this.elements[g]=r[g+d];return this}toArray(r=[],d=0){const g=this.elements;return r[d]=g[0],r[d+1]=g[1],r[d+2]=g[2],r[d+3]=g[3],r[d+4]=g[4],r[d+5]=g[5],r[d+6]=g[6],r[d+7]=g[7],r[d+8]=g[8],r}clone(){return new this.constructor().fromArray(this.elements)}}const Py=new Xr;function Bb(I){for(let r=I.length-1;r>=0;--r)if(I[r]>=65535)return!0;return!1}const CE={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Rd(I,r){return new CE[I](r)}function xp(I){return document.createElementNS("http://www.w3.org/1999/xhtml",I)}function RE(){const I=xp("canvas");return I.style.display="block",I}const zb={};function _h(I){I in zb||(zb[I]=!0,console.warn(I))}const Vb=new Xr().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),Ub=new Xr().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),dm={[vx]:{transfer:ei,primaries:$i,toReference:I=>I,fromReference:I=>I},[jn]:{transfer:dr,primaries:$i,toReference:I=>I.convertSRGBToLinear(),fromReference:I=>I.convertLinearToSRGB()},[Mi]:{transfer:ei,primaries:gn,toReference:I=>I.applyMatrix3(Ub),fromReference:I=>I.applyMatrix3(Vb)},[$r]:{transfer:dr,primaries:gn,toReference:I=>I.convertSRGBToLinear().applyMatrix3(Ub),fromReference:I=>I.applyMatrix3(Vb).convertLinearToSRGB()}},NE=new Set([vx,Mi]),Ci={enabled:!0,_workingColorSpace:vx,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(I){if(!NE.has(I))throw new Error(`Unsupported working color space, "${I}".`);this._workingColorSpace=I},convert:function(I,r,d){if(this.enabled===!1||r===d||!r||!d)return I;const g=dm[r].toReference,y=dm[d].fromReference;return y(g(I))},fromWorkingColorSpace:function(I,r){return this.convert(I,this._workingColorSpace,r)},toWorkingColorSpace:function(I,r){return this.convert(I,r,this._workingColorSpace)},getPrimaries:function(I){return dm[I].primaries},getTransfer:function(I){return I===$n?ei:dm[I].transfer}};function Nd(I){return I<.04045?I*.0773993808:Math.pow(I*.9478672986+.0521327014,2.4)}function By(I){return I<.0031308?I*12.92:1.055*Math.pow(I,.41666)-.055}let Pd;class Gb{static getDataURL(r){if(/^data:/i.test(r.src)||typeof HTMLCanvasElement>"u")return r.src;let d;if(r instanceof HTMLCanvasElement)d=r;else{Pd===void 0&&(Pd=xp("canvas")),Pd.width=r.width,Pd.height=r.height;const g=Pd.getContext("2d");r instanceof ImageData?g.putImageData(r,0,0):g.drawImage(r,0,0,r.width,r.height),d=Pd}return d.width>2048||d.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",r),d.toDataURL("image/jpeg",.6)):d.toDataURL("image/png")}static sRGBToLinear(r){if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap){const d=xp("canvas");d.width=r.width,d.height=r.height;const g=d.getContext("2d");g.drawImage(r,0,0,r.width,r.height);const y=g.getImageData(0,0,r.width,r.height),_=y.data;for(let R=0;R<_.length;R++)_[R]=Nd(_[R]/255)*255;return g.putImageData(y,0,0),d}else if(r.data){const d=r.data.slice(0);for(let g=0;g<d.length;g++)d instanceof Uint8Array||d instanceof Uint8ClampedArray?d[g]=Math.floor(Nd(d[g]/255)*255):d[g]=Nd(d[g]);return{data:d,width:r.width,height:r.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),r}}let PE=0;class Bd{constructor(r=null){this.isSource=!0,Object.defineProperty(this,"id",{value:PE++}),this.uuid=b2(),this.data=r,this.dataReady=!0,this.version=0}set needsUpdate(r){r===!0&&this.version++}toJSON(r){const d=r===void 0||typeof r=="string";if(!d&&r.images[this.uuid]!==void 0)return r.images[this.uuid];const g={uuid:this.uuid,url:""},y=this.data;if(y!==null){let _;if(Array.isArray(y)){_=[];for(let R=0,k=y.length;R<k;R++)y[R].isDataTexture?_.push(zy(y[R].image)):_.push(zy(y[R]))}else _=zy(y);g.url=_}return d||(r.images[this.uuid]=g),g}}function zy(I){return typeof HTMLImageElement<"u"&&I instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&I instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&I instanceof ImageBitmap?Gb.getDataURL(I):I.data?{data:Array.from(I.data),width:I.width,height:I.height,type:I.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let BE=0;class Ks extends Md{constructor(r=Ks.DEFAULT_IMAGE,d=Ks.DEFAULT_MAPPING,g=Gi,y=Gi,_=ui,R=Us,k=xa,X=Ao,K=Ks.DEFAULT_ANISOTROPY,Q=$n){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:BE++}),this.uuid=b2(),this.name="",this.source=new Bd(r),this.mipmaps=[],this.mapping=d,this.channel=0,this.wrapS=g,this.wrapT=y,this.magFilter=_,this.minFilter=R,this.anisotropy=K,this.format=k,this.internalFormat=null,this.type=X,this.offset=new vn(0,0),this.repeat=new vn(1,1),this.center=new vn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Xr,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof Q=="string"?this.colorSpace=Q:(_h("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=Q===z0?jn:$n),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(r=null){this.source.data=r}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(r){return this.name=r.name,this.source=r.source,this.mipmaps=r.mipmaps.slice(0),this.mapping=r.mapping,this.channel=r.channel,this.wrapS=r.wrapS,this.wrapT=r.wrapT,this.magFilter=r.magFilter,this.minFilter=r.minFilter,this.anisotropy=r.anisotropy,this.format=r.format,this.internalFormat=r.internalFormat,this.type=r.type,this.offset.copy(r.offset),this.repeat.copy(r.repeat),this.center.copy(r.center),this.rotation=r.rotation,this.matrixAutoUpdate=r.matrixAutoUpdate,this.matrix.copy(r.matrix),this.generateMipmaps=r.generateMipmaps,this.premultiplyAlpha=r.premultiplyAlpha,this.flipY=r.flipY,this.unpackAlignment=r.unpackAlignment,this.colorSpace=r.colorSpace,this.userData=JSON.parse(JSON.stringify(r.userData)),this.needsUpdate=!0,this}toJSON(r){const d=r===void 0||typeof r=="string";if(!d&&r.textures[this.uuid]!==void 0)return r.textures[this.uuid];const g={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(r).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(g.userData=this.userData),d||(r.textures[this.uuid]=g),g}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(r){if(this.mapping!==_l)return r;if(r.applyMatrix3(this.matrix),r.x<0||r.x>1)switch(this.wrapS){case Ri:r.x=r.x-Math.floor(r.x);break;case Gi:r.x=r.x<0?0:1;break;case ea:Math.abs(Math.floor(r.x)%2)===1?r.x=Math.ceil(r.x)-r.x:r.x=r.x-Math.floor(r.x);break}if(r.y<0||r.y>1)switch(this.wrapT){case Ri:r.y=r.y-Math.floor(r.y);break;case Gi:r.y=r.y<0?0:1;break;case ea:Math.abs(Math.floor(r.y)%2)===1?r.y=Math.ceil(r.y)-r.y:r.y=r.y-Math.floor(r.y);break}return this.flipY&&(r.y=1-r.y),r}set needsUpdate(r){r===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return _h("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===jn?z0:k0}set encoding(r){_h("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=r===z0?jn:$n}}Ks.DEFAULT_IMAGE=null,Ks.DEFAULT_MAPPING=_l,Ks.DEFAULT_ANISOTROPY=1;class Vi{constructor(r=0,d=0,g=0,y=1){Vi.prototype.isVector4=!0,this.x=r,this.y=d,this.z=g,this.w=y}get width(){return this.z}set width(r){this.z=r}get height(){return this.w}set height(r){this.w=r}set(r,d,g,y){return this.x=r,this.y=d,this.z=g,this.w=y,this}setScalar(r){return this.x=r,this.y=r,this.z=r,this.w=r,this}setX(r){return this.x=r,this}setY(r){return this.y=r,this}setZ(r){return this.z=r,this}setW(r){return this.w=r,this}setComponent(r,d){switch(r){case 0:this.x=d;break;case 1:this.y=d;break;case 2:this.z=d;break;case 3:this.w=d;break;default:throw new Error("index is out of range: "+r)}return this}getComponent(r){switch(r){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+r)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(r){return this.x=r.x,this.y=r.y,this.z=r.z,this.w=r.w!==void 0?r.w:1,this}add(r){return this.x+=r.x,this.y+=r.y,this.z+=r.z,this.w+=r.w,this}addScalar(r){return this.x+=r,this.y+=r,this.z+=r,this.w+=r,this}addVectors(r,d){return this.x=r.x+d.x,this.y=r.y+d.y,this.z=r.z+d.z,this.w=r.w+d.w,this}addScaledVector(r,d){return this.x+=r.x*d,this.y+=r.y*d,this.z+=r.z*d,this.w+=r.w*d,this}sub(r){return this.x-=r.x,this.y-=r.y,this.z-=r.z,this.w-=r.w,this}subScalar(r){return this.x-=r,this.y-=r,this.z-=r,this.w-=r,this}subVectors(r,d){return this.x=r.x-d.x,this.y=r.y-d.y,this.z=r.z-d.z,this.w=r.w-d.w,this}multiply(r){return this.x*=r.x,this.y*=r.y,this.z*=r.z,this.w*=r.w,this}multiplyScalar(r){return this.x*=r,this.y*=r,this.z*=r,this.w*=r,this}applyMatrix4(r){const d=this.x,g=this.y,y=this.z,_=this.w,R=r.elements;return this.x=R[0]*d+R[4]*g+R[8]*y+R[12]*_,this.y=R[1]*d+R[5]*g+R[9]*y+R[13]*_,this.z=R[2]*d+R[6]*g+R[10]*y+R[14]*_,this.w=R[3]*d+R[7]*g+R[11]*y+R[15]*_,this}divideScalar(r){return this.multiplyScalar(1/r)}setAxisAngleFromQuaternion(r){this.w=2*Math.acos(r.w);const d=Math.sqrt(1-r.w*r.w);return d<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=r.x/d,this.y=r.y/d,this.z=r.z/d),this}setAxisAngleFromRotationMatrix(r){let d,g,y,_;const X=r.elements,K=X[0],Q=X[4],xe=X[8],ue=X[1],ge=X[5],_e=X[9],Re=X[2],be=X[6],ve=X[10];if(Math.abs(Q-ue)<.01&&Math.abs(xe-Re)<.01&&Math.abs(_e-be)<.01){if(Math.abs(Q+ue)<.1&&Math.abs(xe+Re)<.1&&Math.abs(_e+be)<.1&&Math.abs(K+ge+ve-3)<.1)return this.set(1,0,0,0),this;d=Math.PI;const Be=(K+1)/2,Ke=(ge+1)/2,bt=(ve+1)/2,rt=(Q+ue)/4,xt=(xe+Re)/4,Mt=(_e+be)/4;return Be>Ke&&Be>bt?Be<.01?(g=0,y=.707106781,_=.707106781):(g=Math.sqrt(Be),y=rt/g,_=xt/g):Ke>bt?Ke<.01?(g=.707106781,y=0,_=.707106781):(y=Math.sqrt(Ke),g=rt/y,_=Mt/y):bt<.01?(g=.707106781,y=.707106781,_=0):(_=Math.sqrt(bt),g=xt/_,y=Mt/_),this.set(g,y,_,d),this}let Xe=Math.sqrt((be-_e)*(be-_e)+(xe-Re)*(xe-Re)+(ue-Q)*(ue-Q));return Math.abs(Xe)<.001&&(Xe=1),this.x=(be-_e)/Xe,this.y=(xe-Re)/Xe,this.z=(ue-Q)/Xe,this.w=Math.acos((K+ge+ve-1)/2),this}min(r){return this.x=Math.min(this.x,r.x),this.y=Math.min(this.y,r.y),this.z=Math.min(this.z,r.z),this.w=Math.min(this.w,r.w),this}max(r){return this.x=Math.max(this.x,r.x),this.y=Math.max(this.y,r.y),this.z=Math.max(this.z,r.z),this.w=Math.max(this.w,r.w),this}clamp(r,d){return this.x=Math.max(r.x,Math.min(d.x,this.x)),this.y=Math.max(r.y,Math.min(d.y,this.y)),this.z=Math.max(r.z,Math.min(d.z,this.z)),this.w=Math.max(r.w,Math.min(d.w,this.w)),this}clampScalar(r,d){return this.x=Math.max(r,Math.min(d,this.x)),this.y=Math.max(r,Math.min(d,this.y)),this.z=Math.max(r,Math.min(d,this.z)),this.w=Math.max(r,Math.min(d,this.w)),this}clampLength(r,d){const g=this.length();return this.divideScalar(g||1).multiplyScalar(Math.max(r,Math.min(d,g)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(r){return this.x*r.x+this.y*r.y+this.z*r.z+this.w*r.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(r){return this.normalize().multiplyScalar(r)}lerp(r,d){return this.x+=(r.x-this.x)*d,this.y+=(r.y-this.y)*d,this.z+=(r.z-this.z)*d,this.w+=(r.w-this.w)*d,this}lerpVectors(r,d,g){return this.x=r.x+(d.x-r.x)*g,this.y=r.y+(d.y-r.y)*g,this.z=r.z+(d.z-r.z)*g,this.w=r.w+(d.w-r.w)*g,this}equals(r){return r.x===this.x&&r.y===this.y&&r.z===this.z&&r.w===this.w}fromArray(r,d=0){return this.x=r[d],this.y=r[d+1],this.z=r[d+2],this.w=r[d+3],this}toArray(r=[],d=0){return r[d]=this.x,r[d+1]=this.y,r[d+2]=this.z,r[d+3]=this.w,r}fromBufferAttribute(r,d){return this.x=r.getX(d),this.y=r.getY(d),this.z=r.getZ(d),this.w=r.getW(d),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class zE extends Md{constructor(r=1,d=1,g={}){super(),this.isRenderTarget=!0,this.width=r,this.height=d,this.depth=1,this.scissor=new Vi(0,0,r,d),this.scissorTest=!1,this.viewport=new Vi(0,0,r,d);const y={width:r,height:d,depth:1};g.encoding!==void 0&&(_h("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),g.colorSpace=g.encoding===z0?jn:$n),g=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:ui,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},g),this.texture=new Ks(y,g.mapping,g.wrapS,g.wrapT,g.magFilter,g.minFilter,g.format,g.type,g.anisotropy,g.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=g.generateMipmaps,this.texture.internalFormat=g.internalFormat,this.depthBuffer=g.depthBuffer,this.stencilBuffer=g.stencilBuffer,this.depthTexture=g.depthTexture,this.samples=g.samples}setSize(r,d,g=1){(this.width!==r||this.height!==d||this.depth!==g)&&(this.width=r,this.height=d,this.depth=g,this.texture.image.width=r,this.texture.image.height=d,this.texture.image.depth=g,this.dispose()),this.viewport.set(0,0,r,d),this.scissor.set(0,0,r,d)}clone(){return new this.constructor().copy(this)}copy(r){this.width=r.width,this.height=r.height,this.depth=r.depth,this.scissor.copy(r.scissor),this.scissorTest=r.scissorTest,this.viewport.copy(r.viewport),this.texture=r.texture.clone(),this.texture.isRenderTargetTexture=!0;const d=Object.assign({},r.texture.image);return this.texture.source=new Bd(d),this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,r.depthTexture!==null&&(this.depthTexture=r.depthTexture.clone()),this.samples=r.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Th extends zE{constructor(r=1,d=1,g={}){super(r,d,g),this.isWebGLRenderTarget=!0}}class Vy extends Ks{constructor(r=null,d=1,g=1,y=1){super(null),this.isDataArrayTexture=!0,this.image={data:r,width:d,height:g,depth:y},this.magFilter=gi,this.minFilter=gi,this.wrapR=Gi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class X6 extends null{constructor(r=1,d=1,g=1,y={}){super(r,d,y),this.isWebGLArrayRenderTarget=!0,this.depth=g,this.texture=new Vy(null,r,d,g),this.texture.isRenderTargetTexture=!0}}class Xb extends Ks{constructor(r=null,d=1,g=1,y=1){super(null),this.isData3DTexture=!0,this.image={data:r,width:d,height:g,depth:y},this.magFilter=gi,this.minFilter=gi,this.wrapR=Gi,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class j6 extends null{constructor(r=1,d=1,g=1,y={}){super(r,d,y),this.isWebGL3DRenderTarget=!0,this.depth=g,this.texture=new Xb(null,r,d,g),this.texture.isRenderTargetTexture=!0}}class K6 extends null{constructor(r=1,d=1,g=1,y={}){super(r,d,y),this.isWebGLMultipleRenderTargets=!0;const _=this.texture;this.texture=[];for(let R=0;R<g;R++)this.texture[R]=_.clone(),this.texture[R].isRenderTargetTexture=!0}setSize(r,d,g=1){if(this.width!==r||this.height!==d||this.depth!==g){this.width=r,this.height=d,this.depth=g;for(let y=0,_=this.texture.length;y<_;y++)this.texture[y].image.width=r,this.texture[y].image.height=d,this.texture[y].image.depth=g;this.dispose()}this.viewport.set(0,0,r,d),this.scissor.set(0,0,r,d)}copy(r){this.dispose(),this.width=r.width,this.height=r.height,this.depth=r.depth,this.scissor.copy(r.scissor),this.scissorTest=r.scissorTest,this.viewport.copy(r.viewport),this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,r.depthTexture!==null&&(this.depthTexture=r.depthTexture.clone()),this.texture.length=0;for(let d=0,g=r.texture.length;d<g;d++)this.texture[d]=r.texture[d].clone(),this.texture[d].isRenderTargetTexture=!0;return this}}class Xa{constructor(r=0,d=0,g=0,y=1){this.isQuaternion=!0,this._x=r,this._y=d,this._z=g,this._w=y}static slerpFlat(r,d,g,y,_,R,k){let X=g[y+0],K=g[y+1],Q=g[y+2],xe=g[y+3];const ue=_[R+0],ge=_[R+1],_e=_[R+2],Re=_[R+3];if(k===0){r[d+0]=X,r[d+1]=K,r[d+2]=Q,r[d+3]=xe;return}if(k===1){r[d+0]=ue,r[d+1]=ge,r[d+2]=_e,r[d+3]=Re;return}if(xe!==Re||X!==ue||K!==ge||Q!==_e){let be=1-k;const ve=X*ue+K*ge+Q*_e+xe*Re,Xe=ve>=0?1:-1,Be=1-ve*ve;if(Be>Number.EPSILON){const bt=Math.sqrt(Be),rt=Math.atan2(bt,ve*Xe);be=Math.sin(be*rt)/bt,k=Math.sin(k*rt)/bt}const Ke=k*Xe;if(X=X*be+ue*Ke,K=K*be+ge*Ke,Q=Q*be+_e*Ke,xe=xe*be+Re*Ke,be===1-k){const bt=1/Math.sqrt(X*X+K*K+Q*Q+xe*xe);X*=bt,K*=bt,Q*=bt,xe*=bt}}r[d]=X,r[d+1]=K,r[d+2]=Q,r[d+3]=xe}static multiplyQuaternionsFlat(r,d,g,y,_,R){const k=g[y],X=g[y+1],K=g[y+2],Q=g[y+3],xe=_[R],ue=_[R+1],ge=_[R+2],_e=_[R+3];return r[d]=k*_e+Q*xe+X*ge-K*ue,r[d+1]=X*_e+Q*ue+K*xe-k*ge,r[d+2]=K*_e+Q*ge+k*ue-X*xe,r[d+3]=Q*_e-k*xe-X*ue-K*ge,r}get x(){return this._x}set x(r){this._x=r,this._onChangeCallback()}get y(){return this._y}set y(r){this._y=r,this._onChangeCallback()}get z(){return this._z}set z(r){this._z=r,this._onChangeCallback()}get w(){return this._w}set w(r){this._w=r,this._onChangeCallback()}set(r,d,g,y){return this._x=r,this._y=d,this._z=g,this._w=y,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(r){return this._x=r.x,this._y=r.y,this._z=r.z,this._w=r.w,this._onChangeCallback(),this}setFromEuler(r,d=!0){const g=r._x,y=r._y,_=r._z,R=r._order,k=Math.cos,X=Math.sin,K=k(g/2),Q=k(y/2),xe=k(_/2),ue=X(g/2),ge=X(y/2),_e=X(_/2);switch(R){case"XYZ":this._x=ue*Q*xe+K*ge*_e,this._y=K*ge*xe-ue*Q*_e,this._z=K*Q*_e+ue*ge*xe,this._w=K*Q*xe-ue*ge*_e;break;case"YXZ":this._x=ue*Q*xe+K*ge*_e,this._y=K*ge*xe-ue*Q*_e,this._z=K*Q*_e-ue*ge*xe,this._w=K*Q*xe+ue*ge*_e;break;case"ZXY":this._x=ue*Q*xe-K*ge*_e,this._y=K*ge*xe+ue*Q*_e,this._z=K*Q*_e+ue*ge*xe,this._w=K*Q*xe-ue*ge*_e;break;case"ZYX":this._x=ue*Q*xe-K*ge*_e,this._y=K*ge*xe+ue*Q*_e,this._z=K*Q*_e-ue*ge*xe,this._w=K*Q*xe+ue*ge*_e;break;case"YZX":this._x=ue*Q*xe+K*ge*_e,this._y=K*ge*xe+ue*Q*_e,this._z=K*Q*_e-ue*ge*xe,this._w=K*Q*xe-ue*ge*_e;break;case"XZY":this._x=ue*Q*xe-K*ge*_e,this._y=K*ge*xe-ue*Q*_e,this._z=K*Q*_e+ue*ge*xe,this._w=K*Q*xe+ue*ge*_e;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+R)}return d===!0&&this._onChangeCallback(),this}setFromAxisAngle(r,d){const g=d/2,y=Math.sin(g);return this._x=r.x*y,this._y=r.y*y,this._z=r.z*y,this._w=Math.cos(g),this._onChangeCallback(),this}setFromRotationMatrix(r){const d=r.elements,g=d[0],y=d[4],_=d[8],R=d[1],k=d[5],X=d[9],K=d[2],Q=d[6],xe=d[10],ue=g+k+xe;if(ue>0){const ge=.5/Math.sqrt(ue+1);this._w=.25/ge,this._x=(Q-X)*ge,this._y=(_-K)*ge,this._z=(R-y)*ge}else if(g>k&&g>xe){const ge=2*Math.sqrt(1+g-k-xe);this._w=(Q-X)/ge,this._x=.25*ge,this._y=(y+R)/ge,this._z=(_+K)/ge}else if(k>xe){const ge=2*Math.sqrt(1+k-g-xe);this._w=(_-K)/ge,this._x=(y+R)/ge,this._y=.25*ge,this._z=(X+Q)/ge}else{const ge=2*Math.sqrt(1+xe-g-k);this._w=(R-y)/ge,this._x=(_+K)/ge,this._y=(X+Q)/ge,this._z=.25*ge}return this._onChangeCallback(),this}setFromUnitVectors(r,d){let g=r.dot(d)+1;return g<Number.EPSILON?(g=0,Math.abs(r.x)>Math.abs(r.z)?(this._x=-r.y,this._y=r.x,this._z=0,this._w=g):(this._x=0,this._y=-r.z,this._z=r.y,this._w=g)):(this._x=r.y*d.z-r.z*d.y,this._y=r.z*d.x-r.x*d.z,this._z=r.x*d.y-r.y*d.x,this._w=g),this.normalize()}angleTo(r){return 2*Math.acos(Math.abs(As(this.dot(r),-1,1)))}rotateTowards(r,d){const g=this.angleTo(r);if(g===0)return this;const y=Math.min(1,d/g);return this.slerp(r,y),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(r){return this._x*r._x+this._y*r._y+this._z*r._z+this._w*r._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let r=this.length();return r===0?(this._x=0,this._y=0,this._z=0,this._w=1):(r=1/r,this._x=this._x*r,this._y=this._y*r,this._z=this._z*r,this._w=this._w*r),this._onChangeCallback(),this}multiply(r){return this.multiplyQuaternions(this,r)}premultiply(r){return this.multiplyQuaternions(r,this)}multiplyQuaternions(r,d){const g=r._x,y=r._y,_=r._z,R=r._w,k=d._x,X=d._y,K=d._z,Q=d._w;return this._x=g*Q+R*k+y*K-_*X,this._y=y*Q+R*X+_*k-g*K,this._z=_*Q+R*K+g*X-y*k,this._w=R*Q-g*k-y*X-_*K,this._onChangeCallback(),this}slerp(r,d){if(d===0)return this;if(d===1)return this.copy(r);const g=this._x,y=this._y,_=this._z,R=this._w;let k=R*r._w+g*r._x+y*r._y+_*r._z;if(k<0?(this._w=-r._w,this._x=-r._x,this._y=-r._y,this._z=-r._z,k=-k):this.copy(r),k>=1)return this._w=R,this._x=g,this._y=y,this._z=_,this;const X=1-k*k;if(X<=Number.EPSILON){const ge=1-d;return this._w=ge*R+d*this._w,this._x=ge*g+d*this._x,this._y=ge*y+d*this._y,this._z=ge*_+d*this._z,this.normalize(),this}const K=Math.sqrt(X),Q=Math.atan2(K,k),xe=Math.sin((1-d)*Q)/K,ue=Math.sin(d*Q)/K;return this._w=R*xe+this._w*ue,this._x=g*xe+this._x*ue,this._y=y*xe+this._y*ue,this._z=_*xe+this._z*ue,this._onChangeCallback(),this}slerpQuaternions(r,d,g){return this.copy(r).slerp(d,g)}random(){const r=Math.random(),d=Math.sqrt(1-r),g=Math.sqrt(r),y=2*Math.PI*Math.random(),_=2*Math.PI*Math.random();return this.set(d*Math.cos(y),g*Math.sin(_),g*Math.cos(_),d*Math.sin(y))}equals(r){return r._x===this._x&&r._y===this._y&&r._z===this._z&&r._w===this._w}fromArray(r,d=0){return this._x=r[d],this._y=r[d+1],this._z=r[d+2],this._w=r[d+3],this._onChangeCallback(),this}toArray(r=[],d=0){return r[d]=this._x,r[d+1]=this._y,r[d+2]=this._z,r[d+3]=this._w,r}fromBufferAttribute(r,d){return this._x=r.getX(d),this._y=r.getY(d),this._z=r.getZ(d),this._w=r.getW(d),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(r){return this._onChangeCallback=r,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ut{constructor(r=0,d=0,g=0){ut.prototype.isVector3=!0,this.x=r,this.y=d,this.z=g}set(r,d,g){return g===void 0&&(g=this.z),this.x=r,this.y=d,this.z=g,this}setScalar(r){return this.x=r,this.y=r,this.z=r,this}setX(r){return this.x=r,this}setY(r){return this.y=r,this}setZ(r){return this.z=r,this}setComponent(r,d){switch(r){case 0:this.x=d;break;case 1:this.y=d;break;case 2:this.z=d;break;default:throw new Error("index is out of range: "+r)}return this}getComponent(r){switch(r){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+r)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(r){return this.x=r.x,this.y=r.y,this.z=r.z,this}add(r){return this.x+=r.x,this.y+=r.y,this.z+=r.z,this}addScalar(r){return this.x+=r,this.y+=r,this.z+=r,this}addVectors(r,d){return this.x=r.x+d.x,this.y=r.y+d.y,this.z=r.z+d.z,this}addScaledVector(r,d){return this.x+=r.x*d,this.y+=r.y*d,this.z+=r.z*d,this}sub(r){return this.x-=r.x,this.y-=r.y,this.z-=r.z,this}subScalar(r){return this.x-=r,this.y-=r,this.z-=r,this}subVectors(r,d){return this.x=r.x-d.x,this.y=r.y-d.y,this.z=r.z-d.z,this}multiply(r){return this.x*=r.x,this.y*=r.y,this.z*=r.z,this}multiplyScalar(r){return this.x*=r,this.y*=r,this.z*=r,this}multiplyVectors(r,d){return this.x=r.x*d.x,this.y=r.y*d.y,this.z=r.z*d.z,this}applyEuler(r){return this.applyQuaternion(jb.setFromEuler(r))}applyAxisAngle(r,d){return this.applyQuaternion(jb.setFromAxisAngle(r,d))}applyMatrix3(r){const d=this.x,g=this.y,y=this.z,_=r.elements;return this.x=_[0]*d+_[3]*g+_[6]*y,this.y=_[1]*d+_[4]*g+_[7]*y,this.z=_[2]*d+_[5]*g+_[8]*y,this}applyNormalMatrix(r){return this.applyMatrix3(r).normalize()}applyMatrix4(r){const d=this.x,g=this.y,y=this.z,_=r.elements,R=1/(_[3]*d+_[7]*g+_[11]*y+_[15]);return this.x=(_[0]*d+_[4]*g+_[8]*y+_[12])*R,this.y=(_[1]*d+_[5]*g+_[9]*y+_[13])*R,this.z=(_[2]*d+_[6]*g+_[10]*y+_[14])*R,this}applyQuaternion(r){const d=this.x,g=this.y,y=this.z,_=r.x,R=r.y,k=r.z,X=r.w,K=2*(R*y-k*g),Q=2*(k*d-_*y),xe=2*(_*g-R*d);return this.x=d+X*K+R*xe-k*Q,this.y=g+X*Q+k*K-_*xe,this.z=y+X*xe+_*Q-R*K,this}project(r){return this.applyMatrix4(r.matrixWorldInverse).applyMatrix4(r.projectionMatrix)}unproject(r){return this.applyMatrix4(r.projectionMatrixInverse).applyMatrix4(r.matrixWorld)}transformDirection(r){const d=this.x,g=this.y,y=this.z,_=r.elements;return this.x=_[0]*d+_[4]*g+_[8]*y,this.y=_[1]*d+_[5]*g+_[9]*y,this.z=_[2]*d+_[6]*g+_[10]*y,this.normalize()}divide(r){return this.x/=r.x,this.y/=r.y,this.z/=r.z,this}divideScalar(r){return this.multiplyScalar(1/r)}min(r){return this.x=Math.min(this.x,r.x),this.y=Math.min(this.y,r.y),this.z=Math.min(this.z,r.z),this}max(r){return this.x=Math.max(this.x,r.x),this.y=Math.max(this.y,r.y),this.z=Math.max(this.z,r.z),this}clamp(r,d){return this.x=Math.max(r.x,Math.min(d.x,this.x)),this.y=Math.max(r.y,Math.min(d.y,this.y)),this.z=Math.max(r.z,Math.min(d.z,this.z)),this}clampScalar(r,d){return this.x=Math.max(r,Math.min(d,this.x)),this.y=Math.max(r,Math.min(d,this.y)),this.z=Math.max(r,Math.min(d,this.z)),this}clampLength(r,d){const g=this.length();return this.divideScalar(g||1).multiplyScalar(Math.max(r,Math.min(d,g)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(r){return this.x*r.x+this.y*r.y+this.z*r.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(r){return this.normalize().multiplyScalar(r)}lerp(r,d){return this.x+=(r.x-this.x)*d,this.y+=(r.y-this.y)*d,this.z+=(r.z-this.z)*d,this}lerpVectors(r,d,g){return this.x=r.x+(d.x-r.x)*g,this.y=r.y+(d.y-r.y)*g,this.z=r.z+(d.z-r.z)*g,this}cross(r){return this.crossVectors(this,r)}crossVectors(r,d){const g=r.x,y=r.y,_=r.z,R=d.x,k=d.y,X=d.z;return this.x=y*X-_*k,this.y=_*R-g*X,this.z=g*k-y*R,this}projectOnVector(r){const d=r.lengthSq();if(d===0)return this.set(0,0,0);const g=r.dot(this)/d;return this.copy(r).multiplyScalar(g)}projectOnPlane(r){return Uy.copy(this).projectOnVector(r),this.sub(Uy)}reflect(r){return this.sub(Uy.copy(r).multiplyScalar(2*this.dot(r)))}angleTo(r){const d=Math.sqrt(this.lengthSq()*r.lengthSq());if(d===0)return Math.PI/2;const g=this.dot(r)/d;return Math.acos(As(g,-1,1))}distanceTo(r){return Math.sqrt(this.distanceToSquared(r))}distanceToSquared(r){const d=this.x-r.x,g=this.y-r.y,y=this.z-r.z;return d*d+g*g+y*y}manhattanDistanceTo(r){return Math.abs(this.x-r.x)+Math.abs(this.y-r.y)+Math.abs(this.z-r.z)}setFromSpherical(r){return this.setFromSphericalCoords(r.radius,r.phi,r.theta)}setFromSphericalCoords(r,d,g){const y=Math.sin(d)*r;return this.x=y*Math.sin(g),this.y=Math.cos(d)*r,this.z=y*Math.cos(g),this}setFromCylindrical(r){return this.setFromCylindricalCoords(r.radius,r.theta,r.y)}setFromCylindricalCoords(r,d,g){return this.x=r*Math.sin(d),this.y=g,this.z=r*Math.cos(d),this}setFromMatrixPosition(r){const d=r.elements;return this.x=d[12],this.y=d[13],this.z=d[14],this}setFromMatrixScale(r){const d=this.setFromMatrixColumn(r,0).length(),g=this.setFromMatrixColumn(r,1).length(),y=this.setFromMatrixColumn(r,2).length();return this.x=d,this.y=g,this.z=y,this}setFromMatrixColumn(r,d){return this.fromArray(r.elements,d*4)}setFromMatrix3Column(r,d){return this.fromArray(r.elements,d*3)}setFromEuler(r){return this.x=r._x,this.y=r._y,this.z=r._z,this}setFromColor(r){return this.x=r.r,this.y=r.g,this.z=r.b,this}equals(r){return r.x===this.x&&r.y===this.y&&r.z===this.z}fromArray(r,d=0){return this.x=r[d],this.y=r[d+1],this.z=r[d+2],this}toArray(r=[],d=0){return r[d]=this.x,r[d+1]=this.y,r[d+2]=this.z,r}fromBufferAttribute(r,d){return this.x=r.getX(d),this.y=r.getY(d),this.z=r.getZ(d),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const r=(Math.random()-.5)*2,d=Math.random()*Math.PI*2,g=Math.sqrt(1-r**2);return this.x=g*Math.cos(d),this.y=g*Math.sin(d),this.z=r,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Uy=new ut,jb=new Xa;class Co{constructor(r=new ut(1/0,1/0,1/0),d=new ut(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=r,this.max=d}set(r,d){return this.min.copy(r),this.max.copy(d),this}setFromArray(r){this.makeEmpty();for(let d=0,g=r.length;d<g;d+=3)this.expandByPoint(Rc.fromArray(r,d));return this}setFromBufferAttribute(r){this.makeEmpty();for(let d=0,g=r.count;d<g;d++)this.expandByPoint(Rc.fromBufferAttribute(r,d));return this}setFromPoints(r){this.makeEmpty();for(let d=0,g=r.length;d<g;d++)this.expandByPoint(r[d]);return this}setFromCenterAndSize(r,d){const g=Rc.copy(d).multiplyScalar(.5);return this.min.copy(r).sub(g),this.max.copy(r).add(g),this}setFromObject(r,d=!1){return this.makeEmpty(),this.expandByObject(r,d)}clone(){return new this.constructor().copy(this)}copy(r){return this.min.copy(r.min),this.max.copy(r.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(r){return this.isEmpty()?r.set(0,0,0):r.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(r){return this.isEmpty()?r.set(0,0,0):r.subVectors(this.max,this.min)}expandByPoint(r){return this.min.min(r),this.max.max(r),this}expandByVector(r){return this.min.sub(r),this.max.add(r),this}expandByScalar(r){return this.min.addScalar(-r),this.max.addScalar(r),this}expandByObject(r,d=!1){r.updateWorldMatrix(!1,!1);const g=r.geometry;if(g!==void 0){const _=g.getAttribute("position");if(d===!0&&_!==void 0&&r.isInstancedMesh!==!0)for(let R=0,k=_.count;R<k;R++)r.isMesh===!0?r.getVertexPosition(R,Rc):Rc.fromBufferAttribute(_,R),Rc.applyMatrix4(r.matrixWorld),this.expandByPoint(Rc);else r.boundingBox!==void 0?(r.boundingBox===null&&r.computeBoundingBox(),gm.copy(r.boundingBox)):(g.boundingBox===null&&g.computeBoundingBox(),gm.copy(g.boundingBox)),gm.applyMatrix4(r.matrixWorld),this.union(gm)}const y=r.children;for(let _=0,R=y.length;_<R;_++)this.expandByObject(y[_],d);return this}containsPoint(r){return!(r.x<this.min.x||r.x>this.max.x||r.y<this.min.y||r.y>this.max.y||r.z<this.min.z||r.z>this.max.z)}containsBox(r){return this.min.x<=r.min.x&&r.max.x<=this.max.x&&this.min.y<=r.min.y&&r.max.y<=this.max.y&&this.min.z<=r.min.z&&r.max.z<=this.max.z}getParameter(r,d){return d.set((r.x-this.min.x)/(this.max.x-this.min.x),(r.y-this.min.y)/(this.max.y-this.min.y),(r.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(r){return!(r.max.x<this.min.x||r.min.x>this.max.x||r.max.y<this.min.y||r.min.y>this.max.y||r.max.z<this.min.z||r.min.z>this.max.z)}intersectsSphere(r){return this.clampPoint(r.center,Rc),Rc.distanceToSquared(r.center)<=r.radius*r.radius}intersectsPlane(r){let d,g;return r.normal.x>0?(d=r.normal.x*this.min.x,g=r.normal.x*this.max.x):(d=r.normal.x*this.max.x,g=r.normal.x*this.min.x),r.normal.y>0?(d+=r.normal.y*this.min.y,g+=r.normal.y*this.max.y):(d+=r.normal.y*this.max.y,g+=r.normal.y*this.min.y),r.normal.z>0?(d+=r.normal.z*this.min.z,g+=r.normal.z*this.max.z):(d+=r.normal.z*this.max.z,g+=r.normal.z*this.min.z),d<=-r.constant&&g>=-r.constant}intersectsTriangle(r){if(this.isEmpty())return!1;this.getCenter(rp),vm.subVectors(this.max,rp),zd.subVectors(r.a,rp),Vd.subVectors(r.b,rp),Ud.subVectors(r.c,rp),vu.subVectors(Vd,zd),bu.subVectors(Ud,Vd),Ah.subVectors(zd,Ud);let d=[0,-vu.z,vu.y,0,-bu.z,bu.y,0,-Ah.z,Ah.y,vu.z,0,-vu.x,bu.z,0,-bu.x,Ah.z,0,-Ah.x,-vu.y,vu.x,0,-bu.y,bu.x,0,-Ah.y,Ah.x,0];return!Gy(d,zd,Vd,Ud,vm)||(d=[1,0,0,0,1,0,0,0,1],!Gy(d,zd,Vd,Ud,vm))?!1:(bm.crossVectors(vu,bu),d=[bm.x,bm.y,bm.z],Gy(d,zd,Vd,Ud,vm))}clampPoint(r,d){return d.copy(r).clamp(this.min,this.max)}distanceToPoint(r){return this.clampPoint(r,Rc).distanceTo(r)}getBoundingSphere(r){return this.isEmpty()?r.makeEmpty():(this.getCenter(r.center),r.radius=this.getSize(Rc).length()*.5),r}intersect(r){return this.min.max(r.min),this.max.min(r.max),this.isEmpty()&&this.makeEmpty(),this}union(r){return this.min.min(r.min),this.max.max(r.max),this}applyMatrix4(r){return this.isEmpty()?this:(Pl[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(r),Pl[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(r),Pl[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(r),Pl[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(r),Pl[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(r),Pl[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(r),Pl[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(r),Pl[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(r),this.setFromPoints(Pl),this)}translate(r){return this.min.add(r),this.max.add(r),this}equals(r){return r.min.equals(this.min)&&r.max.equals(this.max)}}const Pl=[new ut,new ut,new ut,new ut,new ut,new ut,new ut,new ut],Rc=new ut,gm=new Co,zd=new ut,Vd=new ut,Ud=new ut,vu=new ut,bu=new ut,Ah=new ut,rp=new ut,vm=new ut,bm=new ut,Mh=new ut;function Gy(I,r,d,g,y){for(let _=0,R=I.length-3;_<=R;_+=3){Mh.fromArray(I,_);const k=y.x*Math.abs(Mh.x)+y.y*Math.abs(Mh.y)+y.z*Math.abs(Mh.z),X=r.dot(Mh),K=d.dot(Mh),Q=g.dot(Mh);if(Math.max(-Math.max(X,K,Q),Math.min(X,K,Q))>k)return!1}return!0}const VE=new Co,op=new ut,Xy=new ut;class Qa{constructor(r=new ut,d=-1){this.isSphere=!0,this.center=r,this.radius=d}set(r,d){return this.center.copy(r),this.radius=d,this}setFromPoints(r,d){const g=this.center;d!==void 0?g.copy(d):VE.setFromPoints(r).getCenter(g);let y=0;for(let _=0,R=r.length;_<R;_++)y=Math.max(y,g.distanceToSquared(r[_]));return this.radius=Math.sqrt(y),this}copy(r){return this.center.copy(r.center),this.radius=r.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(r){return r.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(r){return r.distanceTo(this.center)-this.radius}intersectsSphere(r){const d=this.radius+r.radius;return r.center.distanceToSquared(this.center)<=d*d}intersectsBox(r){return r.intersectsSphere(this)}intersectsPlane(r){return Math.abs(r.distanceToPoint(this.center))<=this.radius}clampPoint(r,d){const g=this.center.distanceToSquared(r);return d.copy(r),g>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center)),d}getBoundingBox(r){return this.isEmpty()?(r.makeEmpty(),r):(r.set(this.center,this.center),r.expandByScalar(this.radius),r)}applyMatrix4(r){return this.center.applyMatrix4(r),this.radius=this.radius*r.getMaxScaleOnAxis(),this}translate(r){return this.center.add(r),this}expandByPoint(r){if(this.isEmpty())return this.center.copy(r),this.radius=0,this;op.subVectors(r,this.center);const d=op.lengthSq();if(d>this.radius*this.radius){const g=Math.sqrt(d),y=(g-this.radius)*.5;this.center.addScaledVector(op,y/g),this.radius+=y}return this}union(r){return r.isEmpty()?this:this.isEmpty()?(this.copy(r),this):(this.center.equals(r.center)===!0?this.radius=Math.max(this.radius,r.radius):(Xy.subVectors(r.center,this.center).setLength(r.radius),this.expandByPoint(op.copy(r.center).add(Xy)),this.expandByPoint(op.copy(r.center).sub(Xy))),this)}equals(r){return r.center.equals(this.center)&&r.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Bl=new ut,jy=new ut,_m=new ut,_u=new ut,Ky=new ut,Tm=new ut,$y=new ut;class up{constructor(r=new ut,d=new ut(0,0,-1)){this.origin=r,this.direction=d}set(r,d){return this.origin.copy(r),this.direction.copy(d),this}copy(r){return this.origin.copy(r.origin),this.direction.copy(r.direction),this}at(r,d){return d.copy(this.origin).addScaledVector(this.direction,r)}lookAt(r){return this.direction.copy(r).sub(this.origin).normalize(),this}recast(r){return this.origin.copy(this.at(r,Bl)),this}closestPointToPoint(r,d){d.subVectors(r,this.origin);const g=d.dot(this.direction);return g<0?d.copy(this.origin):d.copy(this.origin).addScaledVector(this.direction,g)}distanceToPoint(r){return Math.sqrt(this.distanceSqToPoint(r))}distanceSqToPoint(r){const d=Bl.subVectors(r,this.origin).dot(this.direction);return d<0?this.origin.distanceToSquared(r):(Bl.copy(this.origin).addScaledVector(this.direction,d),Bl.distanceToSquared(r))}distanceSqToSegment(r,d,g,y){jy.copy(r).add(d).multiplyScalar(.5),_m.copy(d).sub(r).normalize(),_u.copy(this.origin).sub(jy);const _=r.distanceTo(d)*.5,R=-this.direction.dot(_m),k=_u.dot(this.direction),X=-_u.dot(_m),K=_u.lengthSq(),Q=Math.abs(1-R*R);let xe,ue,ge,_e;if(Q>0)if(xe=R*X-k,ue=R*k-X,_e=_*Q,xe>=0)if(ue>=-_e)if(ue<=_e){const Re=1/Q;xe*=Re,ue*=Re,ge=xe*(xe+R*ue+2*k)+ue*(R*xe+ue+2*X)+K}else ue=_,xe=Math.max(0,-(R*ue+k)),ge=-xe*xe+ue*(ue+2*X)+K;else ue=-_,xe=Math.max(0,-(R*ue+k)),ge=-xe*xe+ue*(ue+2*X)+K;else ue<=-_e?(xe=Math.max(0,-(-R*_+k)),ue=xe>0?-_:Math.min(Math.max(-_,-X),_),ge=-xe*xe+ue*(ue+2*X)+K):ue<=_e?(xe=0,ue=Math.min(Math.max(-_,-X),_),ge=ue*(ue+2*X)+K):(xe=Math.max(0,-(R*_+k)),ue=xe>0?_:Math.min(Math.max(-_,-X),_),ge=-xe*xe+ue*(ue+2*X)+K);else ue=R>0?-_:_,xe=Math.max(0,-(R*ue+k)),ge=-xe*xe+ue*(ue+2*X)+K;return g&&g.copy(this.origin).addScaledVector(this.direction,xe),y&&y.copy(jy).addScaledVector(_m,ue),ge}intersectSphere(r,d){Bl.subVectors(r.center,this.origin);const g=Bl.dot(this.direction),y=Bl.dot(Bl)-g*g,_=r.radius*r.radius;if(y>_)return null;const R=Math.sqrt(_-y),k=g-R,X=g+R;return X<0?null:k<0?this.at(X,d):this.at(k,d)}intersectsSphere(r){return this.distanceSqToPoint(r.center)<=r.radius*r.radius}distanceToPlane(r){const d=r.normal.dot(this.direction);if(d===0)return r.distanceToPoint(this.origin)===0?0:null;const g=-(this.origin.dot(r.normal)+r.constant)/d;return g>=0?g:null}intersectPlane(r,d){const g=this.distanceToPlane(r);return g===null?null:this.at(g,d)}intersectsPlane(r){const d=r.distanceToPoint(this.origin);return d===0||r.normal.dot(this.direction)*d<0}intersectBox(r,d){let g,y,_,R,k,X;const K=1/this.direction.x,Q=1/this.direction.y,xe=1/this.direction.z,ue=this.origin;return K>=0?(g=(r.min.x-ue.x)*K,y=(r.max.x-ue.x)*K):(g=(r.max.x-ue.x)*K,y=(r.min.x-ue.x)*K),Q>=0?(_=(r.min.y-ue.y)*Q,R=(r.max.y-ue.y)*Q):(_=(r.max.y-ue.y)*Q,R=(r.min.y-ue.y)*Q),g>R||_>y||((_>g||isNaN(g))&&(g=_),(R<y||isNaN(y))&&(y=R),xe>=0?(k=(r.min.z-ue.z)*xe,X=(r.max.z-ue.z)*xe):(k=(r.max.z-ue.z)*xe,X=(r.min.z-ue.z)*xe),g>X||k>y)||((k>g||g!==g)&&(g=k),(X<y||y!==y)&&(y=X),y<0)?null:this.at(g>=0?g:y,d)}intersectsBox(r){return this.intersectBox(r,Bl)!==null}intersectTriangle(r,d,g,y,_){Ky.subVectors(d,r),Tm.subVectors(g,r),$y.crossVectors(Ky,Tm);let R=this.direction.dot($y),k;if(R>0){if(y)return null;k=1}else if(R<0)k=-1,R=-R;else return null;_u.subVectors(this.origin,r);const X=k*this.direction.dot(Tm.crossVectors(_u,Tm));if(X<0)return null;const K=k*this.direction.dot(Ky.cross(_u));if(K<0||X+K>R)return null;const Q=-k*_u.dot($y);return Q<0?null:this.at(Q/R,_)}applyMatrix4(r){return this.origin.applyMatrix4(r),this.direction.transformDirection(r),this}equals(r){return r.origin.equals(this.origin)&&r.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ur{constructor(r,d,g,y,_,R,k,X,K,Q,xe,ue,ge,_e,Re,be){ur.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],r!==void 0&&this.set(r,d,g,y,_,R,k,X,K,Q,xe,ue,ge,_e,Re,be)}set(r,d,g,y,_,R,k,X,K,Q,xe,ue,ge,_e,Re,be){const ve=this.elements;return ve[0]=r,ve[4]=d,ve[8]=g,ve[12]=y,ve[1]=_,ve[5]=R,ve[9]=k,ve[13]=X,ve[2]=K,ve[6]=Q,ve[10]=xe,ve[14]=ue,ve[3]=ge,ve[7]=_e,ve[11]=Re,ve[15]=be,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ur().fromArray(this.elements)}copy(r){const d=this.elements,g=r.elements;return d[0]=g[0],d[1]=g[1],d[2]=g[2],d[3]=g[3],d[4]=g[4],d[5]=g[5],d[6]=g[6],d[7]=g[7],d[8]=g[8],d[9]=g[9],d[10]=g[10],d[11]=g[11],d[12]=g[12],d[13]=g[13],d[14]=g[14],d[15]=g[15],this}copyPosition(r){const d=this.elements,g=r.elements;return d[12]=g[12],d[13]=g[13],d[14]=g[14],this}setFromMatrix3(r){const d=r.elements;return this.set(d[0],d[3],d[6],0,d[1],d[4],d[7],0,d[2],d[5],d[8],0,0,0,0,1),this}extractBasis(r,d,g){return r.setFromMatrixColumn(this,0),d.setFromMatrixColumn(this,1),g.setFromMatrixColumn(this,2),this}makeBasis(r,d,g){return this.set(r.x,d.x,g.x,0,r.y,d.y,g.y,0,r.z,d.z,g.z,0,0,0,0,1),this}extractRotation(r){const d=this.elements,g=r.elements,y=1/Gd.setFromMatrixColumn(r,0).length(),_=1/Gd.setFromMatrixColumn(r,1).length(),R=1/Gd.setFromMatrixColumn(r,2).length();return d[0]=g[0]*y,d[1]=g[1]*y,d[2]=g[2]*y,d[3]=0,d[4]=g[4]*_,d[5]=g[5]*_,d[6]=g[6]*_,d[7]=0,d[8]=g[8]*R,d[9]=g[9]*R,d[10]=g[10]*R,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,this}makeRotationFromEuler(r){const d=this.elements,g=r.x,y=r.y,_=r.z,R=Math.cos(g),k=Math.sin(g),X=Math.cos(y),K=Math.sin(y),Q=Math.cos(_),xe=Math.sin(_);if(r.order==="XYZ"){const ue=R*Q,ge=R*xe,_e=k*Q,Re=k*xe;d[0]=X*Q,d[4]=-X*xe,d[8]=K,d[1]=ge+_e*K,d[5]=ue-Re*K,d[9]=-k*X,d[2]=Re-ue*K,d[6]=_e+ge*K,d[10]=R*X}else if(r.order==="YXZ"){const ue=X*Q,ge=X*xe,_e=K*Q,Re=K*xe;d[0]=ue+Re*k,d[4]=_e*k-ge,d[8]=R*K,d[1]=R*xe,d[5]=R*Q,d[9]=-k,d[2]=ge*k-_e,d[6]=Re+ue*k,d[10]=R*X}else if(r.order==="ZXY"){const ue=X*Q,ge=X*xe,_e=K*Q,Re=K*xe;d[0]=ue-Re*k,d[4]=-R*xe,d[8]=_e+ge*k,d[1]=ge+_e*k,d[5]=R*Q,d[9]=Re-ue*k,d[2]=-R*K,d[6]=k,d[10]=R*X}else if(r.order==="ZYX"){const ue=R*Q,ge=R*xe,_e=k*Q,Re=k*xe;d[0]=X*Q,d[4]=_e*K-ge,d[8]=ue*K+Re,d[1]=X*xe,d[5]=Re*K+ue,d[9]=ge*K-_e,d[2]=-K,d[6]=k*X,d[10]=R*X}else if(r.order==="YZX"){const ue=R*X,ge=R*K,_e=k*X,Re=k*K;d[0]=X*Q,d[4]=Re-ue*xe,d[8]=_e*xe+ge,d[1]=xe,d[5]=R*Q,d[9]=-k*Q,d[2]=-K*Q,d[6]=ge*xe+_e,d[10]=ue-Re*xe}else if(r.order==="XZY"){const ue=R*X,ge=R*K,_e=k*X,Re=k*K;d[0]=X*Q,d[4]=-xe,d[8]=K*Q,d[1]=ue*xe+Re,d[5]=R*Q,d[9]=ge*xe-_e,d[2]=_e*xe-ge,d[6]=k*Q,d[10]=Re*xe+ue}return d[3]=0,d[7]=0,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,this}makeRotationFromQuaternion(r){return this.compose(UE,r,GE)}lookAt(r,d,g){const y=this.elements;return _2.subVectors(r,d),_2.lengthSq()===0&&(_2.z=1),_2.normalize(),Tu.crossVectors(g,_2),Tu.lengthSq()===0&&(Math.abs(g.z)===1?_2.x+=1e-4:_2.z+=1e-4,_2.normalize(),Tu.crossVectors(g,_2)),Tu.normalize(),Am.crossVectors(_2,Tu),y[0]=Tu.x,y[4]=Am.x,y[8]=_2.x,y[1]=Tu.y,y[5]=Am.y,y[9]=_2.y,y[2]=Tu.z,y[6]=Am.z,y[10]=_2.z,this}multiply(r){return this.multiplyMatrices(this,r)}premultiply(r){return this.multiplyMatrices(r,this)}multiplyMatrices(r,d){const g=r.elements,y=d.elements,_=this.elements,R=g[0],k=g[4],X=g[8],K=g[12],Q=g[1],xe=g[5],ue=g[9],ge=g[13],_e=g[2],Re=g[6],be=g[10],ve=g[14],Xe=g[3],Be=g[7],Ke=g[11],bt=g[15],rt=y[0],xt=y[4],Mt=y[8],$t=y[12],$e=y[1],vt=y[5],M0=y[9],V0=y[13],Pt=y[2],x0=y[6],Wt=y[10],an=y[14],W0=y[3],j0=y[7],un=y[11],bn=y[15];return _[0]=R*rt+k*$e+X*Pt+K*W0,_[4]=R*xt+k*vt+X*x0+K*j0,_[8]=R*Mt+k*M0+X*Wt+K*un,_[12]=R*$t+k*V0+X*an+K*bn,_[1]=Q*rt+xe*$e+ue*Pt+ge*W0,_[5]=Q*xt+xe*vt+ue*x0+ge*j0,_[9]=Q*Mt+xe*M0+ue*Wt+ge*un,_[13]=Q*$t+xe*V0+ue*an+ge*bn,_[2]=_e*rt+Re*$e+be*Pt+ve*W0,_[6]=_e*xt+Re*vt+be*x0+ve*j0,_[10]=_e*Mt+Re*M0+be*Wt+ve*un,_[14]=_e*$t+Re*V0+be*an+ve*bn,_[3]=Xe*rt+Be*$e+Ke*Pt+bt*W0,_[7]=Xe*xt+Be*vt+Ke*x0+bt*j0,_[11]=Xe*Mt+Be*M0+Ke*Wt+bt*un,_[15]=Xe*$t+Be*V0+Ke*an+bt*bn,this}multiplyScalar(r){const d=this.elements;return d[0]*=r,d[4]*=r,d[8]*=r,d[12]*=r,d[1]*=r,d[5]*=r,d[9]*=r,d[13]*=r,d[2]*=r,d[6]*=r,d[10]*=r,d[14]*=r,d[3]*=r,d[7]*=r,d[11]*=r,d[15]*=r,this}determinant(){const r=this.elements,d=r[0],g=r[4],y=r[8],_=r[12],R=r[1],k=r[5],X=r[9],K=r[13],Q=r[2],xe=r[6],ue=r[10],ge=r[14],_e=r[3],Re=r[7],be=r[11],ve=r[15];return _e*(+_*X*xe-y*K*xe-_*k*ue+g*K*ue+y*k*ge-g*X*ge)+Re*(+d*X*ge-d*K*ue+_*R*ue-y*R*ge+y*K*Q-_*X*Q)+be*(+d*K*xe-d*k*ge-_*R*xe+g*R*ge+_*k*Q-g*K*Q)+ve*(-y*k*Q-d*X*xe+d*k*ue+y*R*xe-g*R*ue+g*X*Q)}transpose(){const r=this.elements;let d;return d=r[1],r[1]=r[4],r[4]=d,d=r[2],r[2]=r[8],r[8]=d,d=r[6],r[6]=r[9],r[9]=d,d=r[3],r[3]=r[12],r[12]=d,d=r[7],r[7]=r[13],r[13]=d,d=r[11],r[11]=r[14],r[14]=d,this}setPosition(r,d,g){const y=this.elements;return r.isVector3?(y[12]=r.x,y[13]=r.y,y[14]=r.z):(y[12]=r,y[13]=d,y[14]=g),this}invert(){const r=this.elements,d=r[0],g=r[1],y=r[2],_=r[3],R=r[4],k=r[5],X=r[6],K=r[7],Q=r[8],xe=r[9],ue=r[10],ge=r[11],_e=r[12],Re=r[13],be=r[14],ve=r[15],Xe=xe*be*K-Re*ue*K+Re*X*ge-k*be*ge-xe*X*ve+k*ue*ve,Be=_e*ue*K-Q*be*K-_e*X*ge+R*be*ge+Q*X*ve-R*ue*ve,Ke=Q*Re*K-_e*xe*K+_e*k*ge-R*Re*ge-Q*k*ve+R*xe*ve,bt=_e*xe*X-Q*Re*X-_e*k*ue+R*Re*ue+Q*k*be-R*xe*be,rt=d*Xe+g*Be+y*Ke+_*bt;if(rt===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const xt=1/rt;return r[0]=Xe*xt,r[1]=(Re*ue*_-xe*be*_-Re*y*ge+g*be*ge+xe*y*ve-g*ue*ve)*xt,r[2]=(k*be*_-Re*X*_+Re*y*K-g*be*K-k*y*ve+g*X*ve)*xt,r[3]=(xe*X*_-k*ue*_-xe*y*K+g*ue*K+k*y*ge-g*X*ge)*xt,r[4]=Be*xt,r[5]=(Q*be*_-_e*ue*_+_e*y*ge-d*be*ge-Q*y*ve+d*ue*ve)*xt,r[6]=(_e*X*_-R*be*_-_e*y*K+d*be*K+R*y*ve-d*X*ve)*xt,r[7]=(R*ue*_-Q*X*_+Q*y*K-d*ue*K-R*y*ge+d*X*ge)*xt,r[8]=Ke*xt,r[9]=(_e*xe*_-Q*Re*_-_e*g*ge+d*Re*ge+Q*g*ve-d*xe*ve)*xt,r[10]=(R*Re*_-_e*k*_+_e*g*K-d*Re*K-R*g*ve+d*k*ve)*xt,r[11]=(Q*k*_-R*xe*_-Q*g*K+d*xe*K+R*g*ge-d*k*ge)*xt,r[12]=bt*xt,r[13]=(Q*Re*y-_e*xe*y+_e*g*ue-d*Re*ue-Q*g*be+d*xe*be)*xt,r[14]=(_e*k*y-R*Re*y-_e*g*X+d*Re*X+R*g*be-d*k*be)*xt,r[15]=(R*xe*y-Q*k*y+Q*g*X-d*xe*X-R*g*ue+d*k*ue)*xt,this}scale(r){const d=this.elements,g=r.x,y=r.y,_=r.z;return d[0]*=g,d[4]*=y,d[8]*=_,d[1]*=g,d[5]*=y,d[9]*=_,d[2]*=g,d[6]*=y,d[10]*=_,d[3]*=g,d[7]*=y,d[11]*=_,this}getMaxScaleOnAxis(){const r=this.elements,d=r[0]*r[0]+r[1]*r[1]+r[2]*r[2],g=r[4]*r[4]+r[5]*r[5]+r[6]*r[6],y=r[8]*r[8]+r[9]*r[9]+r[10]*r[10];return Math.sqrt(Math.max(d,g,y))}makeTranslation(r,d,g){return r.isVector3?this.set(1,0,0,r.x,0,1,0,r.y,0,0,1,r.z,0,0,0,1):this.set(1,0,0,r,0,1,0,d,0,0,1,g,0,0,0,1),this}makeRotationX(r){const d=Math.cos(r),g=Math.sin(r);return this.set(1,0,0,0,0,d,-g,0,0,g,d,0,0,0,0,1),this}makeRotationY(r){const d=Math.cos(r),g=Math.sin(r);return this.set(d,0,g,0,0,1,0,0,-g,0,d,0,0,0,0,1),this}makeRotationZ(r){const d=Math.cos(r),g=Math.sin(r);return this.set(d,-g,0,0,g,d,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(r,d){const g=Math.cos(d),y=Math.sin(d),_=1-g,R=r.x,k=r.y,X=r.z,K=_*R,Q=_*k;return this.set(K*R+g,K*k-y*X,K*X+y*k,0,K*k+y*X,Q*k+g,Q*X-y*R,0,K*X-y*k,Q*X+y*R,_*X*X+g,0,0,0,0,1),this}makeScale(r,d,g){return this.set(r,0,0,0,0,d,0,0,0,0,g,0,0,0,0,1),this}makeShear(r,d,g,y,_,R){return this.set(1,g,_,0,r,1,R,0,d,y,1,0,0,0,0,1),this}compose(r,d,g){const y=this.elements,_=d._x,R=d._y,k=d._z,X=d._w,K=_+_,Q=R+R,xe=k+k,ue=_*K,ge=_*Q,_e=_*xe,Re=R*Q,be=R*xe,ve=k*xe,Xe=X*K,Be=X*Q,Ke=X*xe,bt=g.x,rt=g.y,xt=g.z;return y[0]=(1-(Re+ve))*bt,y[1]=(ge+Ke)*bt,y[2]=(_e-Be)*bt,y[3]=0,y[4]=(ge-Ke)*rt,y[5]=(1-(ue+ve))*rt,y[6]=(be+Xe)*rt,y[7]=0,y[8]=(_e+Be)*xt,y[9]=(be-Xe)*xt,y[10]=(1-(ue+Re))*xt,y[11]=0,y[12]=r.x,y[13]=r.y,y[14]=r.z,y[15]=1,this}decompose(r,d,g){const y=this.elements;let _=Gd.set(y[0],y[1],y[2]).length();const R=Gd.set(y[4],y[5],y[6]).length(),k=Gd.set(y[8],y[9],y[10]).length();this.determinant()<0&&(_=-_),r.x=y[12],r.y=y[13],r.z=y[14],Nc.copy(this);const K=1/_,Q=1/R,xe=1/k;return Nc.elements[0]*=K,Nc.elements[1]*=K,Nc.elements[2]*=K,Nc.elements[4]*=Q,Nc.elements[5]*=Q,Nc.elements[6]*=Q,Nc.elements[8]*=xe,Nc.elements[9]*=xe,Nc.elements[10]*=xe,d.setFromRotationMatrix(Nc),g.x=_,g.y=R,g.z=k,this}makePerspective(r,d,g,y,_,R,k=Nl){const X=this.elements,K=2*_/(d-r),Q=2*_/(g-y),xe=(d+r)/(d-r),ue=(g+y)/(g-y);let ge,_e;if(k===Nl)ge=-(R+_)/(R-_),_e=-2*R*_/(R-_);else if(k===rm)ge=-R/(R-_),_e=-R*_/(R-_);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+k);return X[0]=K,X[4]=0,X[8]=xe,X[12]=0,X[1]=0,X[5]=Q,X[9]=ue,X[13]=0,X[2]=0,X[6]=0,X[10]=ge,X[14]=_e,X[3]=0,X[7]=0,X[11]=-1,X[15]=0,this}makeOrthographic(r,d,g,y,_,R,k=Nl){const X=this.elements,K=1/(d-r),Q=1/(g-y),xe=1/(R-_),ue=(d+r)*K,ge=(g+y)*Q;let _e,Re;if(k===Nl)_e=(R+_)*xe,Re=-2*xe;else if(k===rm)_e=_*xe,Re=-1*xe;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+k);return X[0]=2*K,X[4]=0,X[8]=0,X[12]=-ue,X[1]=0,X[5]=2*Q,X[9]=0,X[13]=-ge,X[2]=0,X[6]=0,X[10]=Re,X[14]=-_e,X[3]=0,X[7]=0,X[11]=0,X[15]=1,this}equals(r){const d=this.elements,g=r.elements;for(let y=0;y<16;y++)if(d[y]!==g[y])return!1;return!0}fromArray(r,d=0){for(let g=0;g<16;g++)this.elements[g]=r[g+d];return this}toArray(r=[],d=0){const g=this.elements;return r[d]=g[0],r[d+1]=g[1],r[d+2]=g[2],r[d+3]=g[3],r[d+4]=g[4],r[d+5]=g[5],r[d+6]=g[6],r[d+7]=g[7],r[d+8]=g[8],r[d+9]=g[9],r[d+10]=g[10],r[d+11]=g[11],r[d+12]=g[12],r[d+13]=g[13],r[d+14]=g[14],r[d+15]=g[15],r}}const Gd=new ut,Nc=new ur,UE=new ut(0,0,0),GE=new ut(1,1,1),Tu=new ut,Am=new ut,_2=new ut,Kb=new ur,$b=new Xa;class Mm{constructor(r=0,d=0,g=0,y=Mm.DEFAULT_ORDER){this.isEuler=!0,this._x=r,this._y=d,this._z=g,this._order=y}get x(){return this._x}set x(r){this._x=r,this._onChangeCallback()}get y(){return this._y}set y(r){this._y=r,this._onChangeCallback()}get z(){return this._z}set z(r){this._z=r,this._onChangeCallback()}get order(){return this._order}set order(r){this._order=r,this._onChangeCallback()}set(r,d,g,y=this._order){return this._x=r,this._y=d,this._z=g,this._order=y,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(r){return this._x=r._x,this._y=r._y,this._z=r._z,this._order=r._order,this._onChangeCallback(),this}setFromRotationMatrix(r,d=this._order,g=!0){const y=r.elements,_=y[0],R=y[4],k=y[8],X=y[1],K=y[5],Q=y[9],xe=y[2],ue=y[6],ge=y[10];switch(d){case"XYZ":this._y=Math.asin(As(k,-1,1)),Math.abs(k)<.9999999?(this._x=Math.atan2(-Q,ge),this._z=Math.atan2(-R,_)):(this._x=Math.atan2(ue,K),this._z=0);break;case"YXZ":this._x=Math.asin(-As(Q,-1,1)),Math.abs(Q)<.9999999?(this._y=Math.atan2(k,ge),this._z=Math.atan2(X,K)):(this._y=Math.atan2(-xe,_),this._z=0);break;case"ZXY":this._x=Math.asin(As(ue,-1,1)),Math.abs(ue)<.9999999?(this._y=Math.atan2(-xe,ge),this._z=Math.atan2(-R,K)):(this._y=0,this._z=Math.atan2(X,_));break;case"ZYX":this._y=Math.asin(-As(xe,-1,1)),Math.abs(xe)<.9999999?(this._x=Math.atan2(ue,ge),this._z=Math.atan2(X,_)):(this._x=0,this._z=Math.atan2(-R,K));break;case"YZX":this._z=Math.asin(As(X,-1,1)),Math.abs(X)<.9999999?(this._x=Math.atan2(-Q,K),this._y=Math.atan2(-xe,_)):(this._x=0,this._y=Math.atan2(k,ge));break;case"XZY":this._z=Math.asin(-As(R,-1,1)),Math.abs(R)<.9999999?(this._x=Math.atan2(ue,K),this._y=Math.atan2(k,_)):(this._x=Math.atan2(-Q,ge),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+d)}return this._order=d,g===!0&&this._onChangeCallback(),this}setFromQuaternion(r,d,g){return Kb.makeRotationFromQuaternion(r),this.setFromRotationMatrix(Kb,d,g)}setFromVector3(r,d=this._order){return this.set(r.x,r.y,r.z,d)}reorder(r){return $b.setFromEuler(this),this.setFromQuaternion($b,r)}equals(r){return r._x===this._x&&r._y===this._y&&r._z===this._z&&r._order===this._order}fromArray(r){return this._x=r[0],this._y=r[1],this._z=r[2],r[3]!==void 0&&(this._order=r[3]),this._onChangeCallback(),this}toArray(r=[],d=0){return r[d]=this._x,r[d+1]=this._y,r[d+2]=this._z,r[d+3]=this._order,r}_onChange(r){return this._onChangeCallback=r,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Mm.DEFAULT_ORDER="XYZ";class Jy{constructor(){this.mask=1}set(r){this.mask=(1<<r|0)>>>0}enable(r){this.mask|=1<<r|0}enableAll(){this.mask=-1}toggle(r){this.mask^=1<<r|0}disable(r){this.mask&=~(1<<r|0)}disableAll(){this.mask=0}test(r){return(this.mask&r.mask)!==0}isEnabled(r){return(this.mask&(1<<r|0))!==0}}let XE=0;const Jb=new ut,Xd=new Xa,zl=new ur,Cm=new ut,dp=new ut,jE=new ut,KE=new Xa,Wb=new ut(1,0,0),Qb=new ut(0,1,0),e_=new ut(0,0,1),$E={type:"added"},JE={type:"removed"};class xs extends Md{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:XE++}),this.uuid=b2(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=xs.DEFAULT_UP.clone();const r=new ut,d=new Mm,g=new Xa,y=new ut(1,1,1);function _(){g.setFromEuler(d,!1)}function R(){d.setFromQuaternion(g,void 0,!1)}d._onChange(_),g._onChange(R),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:r},rotation:{configurable:!0,enumerable:!0,value:d},quaternion:{configurable:!0,enumerable:!0,value:g},scale:{configurable:!0,enumerable:!0,value:y},modelViewMatrix:{value:new ur},normalMatrix:{value:new Xr}}),this.matrix=new ur,this.matrixWorld=new ur,this.matrixAutoUpdate=xs.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=xs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Jy,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(r){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(r),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(r){return this.quaternion.premultiply(r),this}setRotationFromAxisAngle(r,d){this.quaternion.setFromAxisAngle(r,d)}setRotationFromEuler(r){this.quaternion.setFromEuler(r,!0)}setRotationFromMatrix(r){this.quaternion.setFromRotationMatrix(r)}setRotationFromQuaternion(r){this.quaternion.copy(r)}rotateOnAxis(r,d){return Xd.setFromAxisAngle(r,d),this.quaternion.multiply(Xd),this}rotateOnWorldAxis(r,d){return Xd.setFromAxisAngle(r,d),this.quaternion.premultiply(Xd),this}rotateX(r){return this.rotateOnAxis(Wb,r)}rotateY(r){return this.rotateOnAxis(Qb,r)}rotateZ(r){return this.rotateOnAxis(e_,r)}translateOnAxis(r,d){return Jb.copy(r).applyQuaternion(this.quaternion),this.position.add(Jb.multiplyScalar(d)),this}translateX(r){return this.translateOnAxis(Wb,r)}translateY(r){return this.translateOnAxis(Qb,r)}translateZ(r){return this.translateOnAxis(e_,r)}localToWorld(r){return this.updateWorldMatrix(!0,!1),r.applyMatrix4(this.matrixWorld)}worldToLocal(r){return this.updateWorldMatrix(!0,!1),r.applyMatrix4(zl.copy(this.matrixWorld).invert())}lookAt(r,d,g){r.isVector3?Cm.copy(r):Cm.set(r,d,g);const y=this.parent;this.updateWorldMatrix(!0,!1),dp.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?zl.lookAt(dp,Cm,this.up):zl.lookAt(Cm,dp,this.up),this.quaternion.setFromRotationMatrix(zl),y&&(zl.extractRotation(y.matrixWorld),Xd.setFromRotationMatrix(zl),this.quaternion.premultiply(Xd.invert()))}add(r){if(arguments.length>1){for(let d=0;d<arguments.length;d++)this.add(arguments[d]);return this}return r===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",r),this):(r&&r.isObject3D?(r.parent!==null&&r.parent.remove(r),r.parent=this,this.children.push(r),r.dispatchEvent($E)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",r),this)}remove(r){if(arguments.length>1){for(let g=0;g<arguments.length;g++)this.remove(arguments[g]);return this}const d=this.children.indexOf(r);return d!==-1&&(r.parent=null,this.children.splice(d,1),r.dispatchEvent(JE)),this}removeFromParent(){const r=this.parent;return r!==null&&r.remove(this),this}clear(){return this.remove(...this.children)}attach(r){return this.updateWorldMatrix(!0,!1),zl.copy(this.matrixWorld).invert(),r.parent!==null&&(r.parent.updateWorldMatrix(!0,!1),zl.multiply(r.parent.matrixWorld)),r.applyMatrix4(zl),this.add(r),r.updateWorldMatrix(!1,!0),this}getObjectById(r){return this.getObjectByProperty("id",r)}getObjectByName(r){return this.getObjectByProperty("name",r)}getObjectByProperty(r,d){if(this[r]===d)return this;for(let g=0,y=this.children.length;g<y;g++){const R=this.children[g].getObjectByProperty(r,d);if(R!==void 0)return R}}getObjectsByProperty(r,d,g=[]){this[r]===d&&g.push(this);const y=this.children;for(let _=0,R=y.length;_<R;_++)y[_].getObjectsByProperty(r,d,g);return g}getWorldPosition(r){return this.updateWorldMatrix(!0,!1),r.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(r){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(dp,r,jE),r}getWorldScale(r){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(dp,KE,r),r}getWorldDirection(r){this.updateWorldMatrix(!0,!1);const d=this.matrixWorld.elements;return r.set(d[8],d[9],d[10]).normalize()}raycast(){}traverse(r){r(this);const d=this.children;for(let g=0,y=d.length;g<y;g++)d[g].traverse(r)}traverseVisible(r){if(this.visible===!1)return;r(this);const d=this.children;for(let g=0,y=d.length;g<y;g++)d[g].traverseVisible(r)}traverseAncestors(r){const d=this.parent;d!==null&&(r(d),d.traverseAncestors(r))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(r){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||r)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,r=!0);const d=this.children;for(let g=0,y=d.length;g<y;g++){const _=d[g];(_.matrixWorldAutoUpdate===!0||r===!0)&&_.updateMatrixWorld(r)}}updateWorldMatrix(r,d){const g=this.parent;if(r===!0&&g!==null&&g.matrixWorldAutoUpdate===!0&&g.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),d===!0){const y=this.children;for(let _=0,R=y.length;_<R;_++){const k=y[_];k.matrixWorldAutoUpdate===!0&&k.updateWorldMatrix(!1,!0)}}}toJSON(r){const d=r===void 0||typeof r=="string",g={};d&&(r={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},g.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const y={};y.uuid=this.uuid,y.type=this.type,this.name!==""&&(y.name=this.name),this.castShadow===!0&&(y.castShadow=!0),this.receiveShadow===!0&&(y.receiveShadow=!0),this.visible===!1&&(y.visible=!1),this.frustumCulled===!1&&(y.frustumCulled=!1),this.renderOrder!==0&&(y.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(y.userData=this.userData),y.layers=this.layers.mask,y.matrix=this.matrix.toArray(),y.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(y.matrixAutoUpdate=!1),this.isInstancedMesh&&(y.type="InstancedMesh",y.count=this.count,y.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(y.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(y.type="BatchedMesh",y.perObjectFrustumCulled=this.perObjectFrustumCulled,y.sortObjects=this.sortObjects,y.drawRanges=this._drawRanges,y.reservedRanges=this._reservedRanges,y.visibility=this._visibility,y.active=this._active,y.bounds=this._bounds.map(k=>({boxInitialized:k.boxInitialized,boxMin:k.box.min.toArray(),boxMax:k.box.max.toArray(),sphereInitialized:k.sphereInitialized,sphereRadius:k.sphere.radius,sphereCenter:k.sphere.center.toArray()})),y.maxGeometryCount=this._maxGeometryCount,y.maxVertexCount=this._maxVertexCount,y.maxIndexCount=this._maxIndexCount,y.geometryInitialized=this._geometryInitialized,y.geometryCount=this._geometryCount,y.matricesTexture=this._matricesTexture.toJSON(r),this.boundingSphere!==null&&(y.boundingSphere={center:y.boundingSphere.center.toArray(),radius:y.boundingSphere.radius}),this.boundingBox!==null&&(y.boundingBox={min:y.boundingBox.min.toArray(),max:y.boundingBox.max.toArray()}));function _(k,X){return k[X.uuid]===void 0&&(k[X.uuid]=X.toJSON(r)),X.uuid}if(this.isScene)this.background&&(this.background.isColor?y.background=this.background.toJSON():this.background.isTexture&&(y.background=this.background.toJSON(r).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(y.environment=this.environment.toJSON(r).uuid);else if(this.isMesh||this.isLine||this.isPoints){y.geometry=_(r.geometries,this.geometry);const k=this.geometry.parameters;if(k!==void 0&&k.shapes!==void 0){const X=k.shapes;if(Array.isArray(X))for(let K=0,Q=X.length;K<Q;K++){const xe=X[K];_(r.shapes,xe)}else _(r.shapes,X)}}if(this.isSkinnedMesh&&(y.bindMode=this.bindMode,y.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(_(r.skeletons,this.skeleton),y.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const k=[];for(let X=0,K=this.material.length;X<K;X++)k.push(_(r.materials,this.material[X]));y.material=k}else y.material=_(r.materials,this.material);if(this.children.length>0){y.children=[];for(let k=0;k<this.children.length;k++)y.children.push(this.children[k].toJSON(r).object)}if(this.animations.length>0){y.animations=[];for(let k=0;k<this.animations.length;k++){const X=this.animations[k];y.animations.push(_(r.animations,X))}}if(d){const k=R(r.geometries),X=R(r.materials),K=R(r.textures),Q=R(r.images),xe=R(r.shapes),ue=R(r.skeletons),ge=R(r.animations),_e=R(r.nodes);k.length>0&&(g.geometries=k),X.length>0&&(g.materials=X),K.length>0&&(g.textures=K),Q.length>0&&(g.images=Q),xe.length>0&&(g.shapes=xe),ue.length>0&&(g.skeletons=ue),ge.length>0&&(g.animations=ge),_e.length>0&&(g.nodes=_e)}return g.object=y,g;function R(k){const X=[];for(const K in k){const Q=k[K];delete Q.metadata,X.push(Q)}return X}}clone(r){return new this.constructor().copy(this,r)}copy(r,d=!0){if(this.name=r.name,this.up.copy(r.up),this.position.copy(r.position),this.rotation.order=r.rotation.order,this.quaternion.copy(r.quaternion),this.scale.copy(r.scale),this.matrix.copy(r.matrix),this.matrixWorld.copy(r.matrixWorld),this.matrixAutoUpdate=r.matrixAutoUpdate,this.matrixWorldAutoUpdate=r.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=r.matrixWorldNeedsUpdate,this.layers.mask=r.layers.mask,this.visible=r.visible,this.castShadow=r.castShadow,this.receiveShadow=r.receiveShadow,this.frustumCulled=r.frustumCulled,this.renderOrder=r.renderOrder,this.animations=r.animations.slice(),this.userData=JSON.parse(JSON.stringify(r.userData)),d===!0)for(let g=0;g<r.children.length;g++){const y=r.children[g];this.add(y.clone())}return this}}xs.DEFAULT_UP=new ut(0,1,0),xs.DEFAULT_MATRIX_AUTO_UPDATE=!0,xs.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Pc=new ut,Vl=new ut,Wy=new ut,Ul=new ut,jd=new ut,Kd=new ut,t_=new ut,Qy=new ut,e1=new ut,x1=new ut;class G2{constructor(r=new ut,d=new ut,g=new ut){this.a=r,this.b=d,this.c=g}static getNormal(r,d,g,y){y.subVectors(g,d),Pc.subVectors(r,d),y.cross(Pc);const _=y.lengthSq();return _>0?y.multiplyScalar(1/Math.sqrt(_)):y.set(0,0,0)}static getBarycoord(r,d,g,y,_){Pc.subVectors(y,d),Vl.subVectors(g,d),Wy.subVectors(r,d);const R=Pc.dot(Pc),k=Pc.dot(Vl),X=Pc.dot(Wy),K=Vl.dot(Vl),Q=Vl.dot(Wy),xe=R*K-k*k;if(xe===0)return _.set(0,0,0),null;const ue=1/xe,ge=(K*X-k*Q)*ue,_e=(R*Q-k*X)*ue;return _.set(1-ge-_e,_e,ge)}static containsPoint(r,d,g,y){return this.getBarycoord(r,d,g,y,Ul)===null?!1:Ul.x>=0&&Ul.y>=0&&Ul.x+Ul.y<=1}static getInterpolation(r,d,g,y,_,R,k,X){return this.getBarycoord(r,d,g,y,Ul)===null?(X.x=0,X.y=0,"z"in X&&(X.z=0),"w"in X&&(X.w=0),null):(X.setScalar(0),X.addScaledVector(_,Ul.x),X.addScaledVector(R,Ul.y),X.addScaledVector(k,Ul.z),X)}static isFrontFacing(r,d,g,y){return Pc.subVectors(g,d),Vl.subVectors(r,d),Pc.cross(Vl).dot(y)<0}set(r,d,g){return this.a.copy(r),this.b.copy(d),this.c.copy(g),this}setFromPointsAndIndices(r,d,g,y){return this.a.copy(r[d]),this.b.copy(r[g]),this.c.copy(r[y]),this}setFromAttributeAndIndices(r,d,g,y){return this.a.fromBufferAttribute(r,d),this.b.fromBufferAttribute(r,g),this.c.fromBufferAttribute(r,y),this}clone(){return new this.constructor().copy(this)}copy(r){return this.a.copy(r.a),this.b.copy(r.b),this.c.copy(r.c),this}getArea(){return Pc.subVectors(this.c,this.b),Vl.subVectors(this.a,this.b),Pc.cross(Vl).length()*.5}getMidpoint(r){return r.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(r){return G2.getNormal(this.a,this.b,this.c,r)}getPlane(r){return r.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(r,d){return G2.getBarycoord(r,this.a,this.b,this.c,d)}getInterpolation(r,d,g,y,_){return G2.getInterpolation(r,this.a,this.b,this.c,d,g,y,_)}containsPoint(r){return G2.containsPoint(r,this.a,this.b,this.c)}isFrontFacing(r){return G2.isFrontFacing(this.a,this.b,this.c,r)}intersectsBox(r){return r.intersectsTriangle(this)}closestPointToPoint(r,d){const g=this.a,y=this.b,_=this.c;let R,k;jd.subVectors(y,g),Kd.subVectors(_,g),Qy.subVectors(r,g);const X=jd.dot(Qy),K=Kd.dot(Qy);if(X<=0&&K<=0)return d.copy(g);e1.subVectors(r,y);const Q=jd.dot(e1),xe=Kd.dot(e1);if(Q>=0&&xe<=Q)return d.copy(y);const ue=X*xe-Q*K;if(ue<=0&&X>=0&&Q<=0)return R=X/(X-Q),d.copy(g).addScaledVector(jd,R);x1.subVectors(r,_);const ge=jd.dot(x1),_e=Kd.dot(x1);if(_e>=0&&ge<=_e)return d.copy(_);const Re=ge*K-X*_e;if(Re<=0&&K>=0&&_e<=0)return k=K/(K-_e),d.copy(g).addScaledVector(Kd,k);const be=Q*_e-ge*xe;if(be<=0&&xe-Q>=0&&ge-_e>=0)return t_.subVectors(_,y),k=(xe-Q)/(xe-Q+(ge-_e)),d.copy(y).addScaledVector(t_,k);const ve=1/(be+Re+ue);return R=Re*ve,k=ue*ve,d.copy(g).addScaledVector(jd,R).addScaledVector(Kd,k)}equals(r){return r.a.equals(this.a)&&r.b.equals(this.b)&&r.c.equals(this.c)}}const n_={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Au={h:0,s:0,l:0},Rm={h:0,s:0,l:0};function r1(I,r,d){return d<0&&(d+=1),d>1&&(d-=1),d<1/6?I+(r-I)*6*d:d<1/2?r:d<2/3?I+(r-I)*6*(2/3-d):I}class bx{constructor(r,d,g){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(r,d,g)}set(r,d,g){if(d===void 0&&g===void 0){const y=r;y&&y.isColor?this.copy(y):typeof y=="number"?this.setHex(y):typeof y=="string"&&this.setStyle(y)}else this.setRGB(r,d,g);return this}setScalar(r){return this.r=r,this.g=r,this.b=r,this}setHex(r,d=jn){return r=Math.floor(r),this.r=(r>>16&255)/255,this.g=(r>>8&255)/255,this.b=(r&255)/255,Ci.toWorkingColorSpace(this,d),this}setRGB(r,d,g,y=Ci.workingColorSpace){return this.r=r,this.g=d,this.b=g,Ci.toWorkingColorSpace(this,y),this}setHSL(r,d,g,y=Ci.workingColorSpace){if(r=Ry(r,1),d=As(d,0,1),g=As(g,0,1),d===0)this.r=this.g=this.b=g;else{const _=g<=.5?g*(1+d):g+d-g*d,R=2*g-_;this.r=r1(R,_,r+1/3),this.g=r1(R,_,r),this.b=r1(R,_,r-1/3)}return Ci.toWorkingColorSpace(this,y),this}setStyle(r,d=jn){function g(_){_!==void 0&&parseFloat(_)<1&&console.warn("THREE.Color: Alpha component of "+r+" will be ignored.")}let y;if(y=/^(\w+)\(([^\)]*)\)/.exec(r)){let _;const R=y[1],k=y[2];switch(R){case"rgb":case"rgba":if(_=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(k))return g(_[4]),this.setRGB(Math.min(255,parseInt(_[1],10))/255,Math.min(255,parseInt(_[2],10))/255,Math.min(255,parseInt(_[3],10))/255,d);if(_=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(k))return g(_[4]),this.setRGB(Math.min(100,parseInt(_[1],10))/100,Math.min(100,parseInt(_[2],10))/100,Math.min(100,parseInt(_[3],10))/100,d);break;case"hsl":case"hsla":if(_=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(k))return g(_[4]),this.setHSL(parseFloat(_[1])/360,parseFloat(_[2])/100,parseFloat(_[3])/100,d);break;default:console.warn("THREE.Color: Unknown color model "+r)}}else if(y=/^\#([A-Fa-f\d]+)$/.exec(r)){const _=y[1],R=_.length;if(R===3)return this.setRGB(parseInt(_.charAt(0),16)/15,parseInt(_.charAt(1),16)/15,parseInt(_.charAt(2),16)/15,d);if(R===6)return this.setHex(parseInt(_,16),d);console.warn("THREE.Color: Invalid hex color "+r)}else if(r&&r.length>0)return this.setColorName(r,d);return this}setColorName(r,d=jn){const g=n_[r.toLowerCase()];return g!==void 0?this.setHex(g,d):console.warn("THREE.Color: Unknown color "+r),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(r){return this.r=r.r,this.g=r.g,this.b=r.b,this}copySRGBToLinear(r){return this.r=Nd(r.r),this.g=Nd(r.g),this.b=Nd(r.b),this}copyLinearToSRGB(r){return this.r=By(r.r),this.g=By(r.g),this.b=By(r.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(r=jn){return Ci.fromWorkingColorSpace(eo.copy(this),r),Math.round(As(eo.r*255,0,255))*65536+Math.round(As(eo.g*255,0,255))*256+Math.round(As(eo.b*255,0,255))}getHexString(r=jn){return("000000"+this.getHex(r).toString(16)).slice(-6)}getHSL(r,d=Ci.workingColorSpace){Ci.fromWorkingColorSpace(eo.copy(this),d);const g=eo.r,y=eo.g,_=eo.b,R=Math.max(g,y,_),k=Math.min(g,y,_);let X,K;const Q=(k+R)/2;if(k===R)X=0,K=0;else{const xe=R-k;switch(K=Q<=.5?xe/(R+k):xe/(2-R-k),R){case g:X=(y-_)/xe+(y<_?6:0);break;case y:X=(_-g)/xe+2;break;case _:X=(g-y)/xe+4;break}X/=6}return r.h=X,r.s=K,r.l=Q,r}getRGB(r,d=Ci.workingColorSpace){return Ci.fromWorkingColorSpace(eo.copy(this),d),r.r=eo.r,r.g=eo.g,r.b=eo.b,r}getStyle(r=jn){Ci.fromWorkingColorSpace(eo.copy(this),r);const d=eo.r,g=eo.g,y=eo.b;return r!==jn?`color(${r} ${d.toFixed(3)} ${g.toFixed(3)} ${y.toFixed(3)})`:`rgb(${Math.round(d*255)},${Math.round(g*255)},${Math.round(y*255)})`}offsetHSL(r,d,g){return this.getHSL(Au),this.setHSL(Au.h+r,Au.s+d,Au.l+g)}add(r){return this.r+=r.r,this.g+=r.g,this.b+=r.b,this}addColors(r,d){return this.r=r.r+d.r,this.g=r.g+d.g,this.b=r.b+d.b,this}addScalar(r){return this.r+=r,this.g+=r,this.b+=r,this}sub(r){return this.r=Math.max(0,this.r-r.r),this.g=Math.max(0,this.g-r.g),this.b=Math.max(0,this.b-r.b),this}multiply(r){return this.r*=r.r,this.g*=r.g,this.b*=r.b,this}multiplyScalar(r){return this.r*=r,this.g*=r,this.b*=r,this}lerp(r,d){return this.r+=(r.r-this.r)*d,this.g+=(r.g-this.g)*d,this.b+=(r.b-this.b)*d,this}lerpColors(r,d,g){return this.r=r.r+(d.r-r.r)*g,this.g=r.g+(d.g-r.g)*g,this.b=r.b+(d.b-r.b)*g,this}lerpHSL(r,d){this.getHSL(Au),r.getHSL(Rm);const g=ep(Au.h,Rm.h,d),y=ep(Au.s,Rm.s,d),_=ep(Au.l,Rm.l,d);return this.setHSL(g,y,_),this}setFromVector3(r){return this.r=r.x,this.g=r.y,this.b=r.z,this}applyMatrix3(r){const d=this.r,g=this.g,y=this.b,_=r.elements;return this.r=_[0]*d+_[3]*g+_[6]*y,this.g=_[1]*d+_[4]*g+_[7]*y,this.b=_[2]*d+_[5]*g+_[8]*y,this}equals(r){return r.r===this.r&&r.g===this.g&&r.b===this.b}fromArray(r,d=0){return this.r=r[d],this.g=r[d+1],this.b=r[d+2],this}toArray(r=[],d=0){return r[d]=this.r,r[d+1]=this.g,r[d+2]=this.b,r}fromBufferAttribute(r,d){return this.r=r.getX(d),this.g=r.getY(d),this.b=r.getZ(d),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const eo=new bx;bx.NAMES=n_;let WE=0;class T2 extends Md{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:WE++}),this.uuid=b2(),this.name="",this.type="Material",this.blending=Bi,this.side=Ta,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=uc,this.blendDst=dc,this.blendEquation=Ui,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new bx(0,0,0),this.blendAlpha=0,this.depthFunc=Vo,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=U2,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=zi,this.stencilZFail=zi,this.stencilZPass=zi,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(r){this._alphaTest>0!=r>0&&this.version++,this._alphaTest=r}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(r){if(r!==void 0)for(const d in r){const g=r[d];if(g===void 0){console.warn(`THREE.Material: parameter '${d}' has value of undefined.`);continue}const y=this[d];if(y===void 0){console.warn(`THREE.Material: '${d}' is not a property of THREE.${this.type}.`);continue}y&&y.isColor?y.set(g):y&&y.isVector3&&g&&g.isVector3?y.copy(g):this[d]=g}}toJSON(r){const d=r===void 0||typeof r=="string";d&&(r={textures:{},images:{}});const g={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};g.uuid=this.uuid,g.type=this.type,this.name!==""&&(g.name=this.name),this.color&&this.color.isColor&&(g.color=this.color.getHex()),this.roughness!==void 0&&(g.roughness=this.roughness),this.metalness!==void 0&&(g.metalness=this.metalness),this.sheen!==void 0&&(g.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(g.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(g.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(g.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(g.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(g.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(g.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(g.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(g.shininess=this.shininess),this.clearcoat!==void 0&&(g.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(g.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(g.clearcoatMap=this.clearcoatMap.toJSON(r).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(g.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(r).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(g.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(r).uuid,g.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(g.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(g.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(g.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(g.iridescenceMap=this.iridescenceMap.toJSON(r).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(g.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(r).uuid),this.anisotropy!==void 0&&(g.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(g.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(g.anisotropyMap=this.anisotropyMap.toJSON(r).uuid),this.map&&this.map.isTexture&&(g.map=this.map.toJSON(r).uuid),this.matcap&&this.matcap.isTexture&&(g.matcap=this.matcap.toJSON(r).uuid),this.alphaMap&&this.alphaMap.isTexture&&(g.alphaMap=this.alphaMap.toJSON(r).uuid),this.lightMap&&this.lightMap.isTexture&&(g.lightMap=this.lightMap.toJSON(r).uuid,g.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(g.aoMap=this.aoMap.toJSON(r).uuid,g.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(g.bumpMap=this.bumpMap.toJSON(r).uuid,g.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(g.normalMap=this.normalMap.toJSON(r).uuid,g.normalMapType=this.normalMapType,g.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(g.displacementMap=this.displacementMap.toJSON(r).uuid,g.displacementScale=this.displacementScale,g.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(g.roughnessMap=this.roughnessMap.toJSON(r).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(g.metalnessMap=this.metalnessMap.toJSON(r).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(g.emissiveMap=this.emissiveMap.toJSON(r).uuid),this.specularMap&&this.specularMap.isTexture&&(g.specularMap=this.specularMap.toJSON(r).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(g.specularIntensityMap=this.specularIntensityMap.toJSON(r).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(g.specularColorMap=this.specularColorMap.toJSON(r).uuid),this.envMap&&this.envMap.isTexture&&(g.envMap=this.envMap.toJSON(r).uuid,this.combine!==void 0&&(g.combine=this.combine)),this.envMapIntensity!==void 0&&(g.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(g.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(g.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(g.gradientMap=this.gradientMap.toJSON(r).uuid),this.transmission!==void 0&&(g.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(g.transmissionMap=this.transmissionMap.toJSON(r).uuid),this.thickness!==void 0&&(g.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(g.thicknessMap=this.thicknessMap.toJSON(r).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(g.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(g.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(g.size=this.size),this.shadowSide!==null&&(g.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(g.sizeAttenuation=this.sizeAttenuation),this.blending!==Bi&&(g.blending=this.blending),this.side!==Ta&&(g.side=this.side),this.vertexColors===!0&&(g.vertexColors=!0),this.opacity<1&&(g.opacity=this.opacity),this.transparent===!0&&(g.transparent=!0),this.blendSrc!==uc&&(g.blendSrc=this.blendSrc),this.blendDst!==dc&&(g.blendDst=this.blendDst),this.blendEquation!==Ui&&(g.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(g.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(g.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(g.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(g.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(g.blendAlpha=this.blendAlpha),this.depthFunc!==Vo&&(g.depthFunc=this.depthFunc),this.depthTest===!1&&(g.depthTest=this.depthTest),this.depthWrite===!1&&(g.depthWrite=this.depthWrite),this.colorWrite===!1&&(g.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(g.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==U2&&(g.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(g.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(g.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==zi&&(g.stencilFail=this.stencilFail),this.stencilZFail!==zi&&(g.stencilZFail=this.stencilZFail),this.stencilZPass!==zi&&(g.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(g.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(g.rotation=this.rotation),this.polygonOffset===!0&&(g.polygonOffset=!0),this.polygonOffsetFactor!==0&&(g.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(g.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(g.linewidth=this.linewidth),this.dashSize!==void 0&&(g.dashSize=this.dashSize),this.gapSize!==void 0&&(g.gapSize=this.gapSize),this.scale!==void 0&&(g.scale=this.scale),this.dithering===!0&&(g.dithering=!0),this.alphaTest>0&&(g.alphaTest=this.alphaTest),this.alphaHash===!0&&(g.alphaHash=!0),this.alphaToCoverage===!0&&(g.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(g.premultipliedAlpha=!0),this.forceSinglePass===!0&&(g.forceSinglePass=!0),this.wireframe===!0&&(g.wireframe=!0),this.wireframeLinewidth>1&&(g.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(g.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(g.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(g.flatShading=!0),this.visible===!1&&(g.visible=!1),this.toneMapped===!1&&(g.toneMapped=!1),this.fog===!1&&(g.fog=!1),Object.keys(this.userData).length>0&&(g.userData=this.userData);function y(_){const R=[];for(const k in _){const X=_[k];delete X.metadata,R.push(X)}return R}if(d){const _=y(r.textures),R=y(r.images);_.length>0&&(g.textures=_),R.length>0&&(g.images=R)}return g}clone(){return new this.constructor().copy(this)}copy(r){this.name=r.name,this.blending=r.blending,this.side=r.side,this.vertexColors=r.vertexColors,this.opacity=r.opacity,this.transparent=r.transparent,this.blendSrc=r.blendSrc,this.blendDst=r.blendDst,this.blendEquation=r.blendEquation,this.blendSrcAlpha=r.blendSrcAlpha,this.blendDstAlpha=r.blendDstAlpha,this.blendEquationAlpha=r.blendEquationAlpha,this.blendColor.copy(r.blendColor),this.blendAlpha=r.blendAlpha,this.depthFunc=r.depthFunc,this.depthTest=r.depthTest,this.depthWrite=r.depthWrite,this.stencilWriteMask=r.stencilWriteMask,this.stencilFunc=r.stencilFunc,this.stencilRef=r.stencilRef,this.stencilFuncMask=r.stencilFuncMask,this.stencilFail=r.stencilFail,this.stencilZFail=r.stencilZFail,this.stencilZPass=r.stencilZPass,this.stencilWrite=r.stencilWrite;const d=r.clippingPlanes;let g=null;if(d!==null){const y=d.length;g=new Array(y);for(let _=0;_!==y;++_)g[_]=d[_].clone()}return this.clippingPlanes=g,this.clipIntersection=r.clipIntersection,this.clipShadows=r.clipShadows,this.shadowSide=r.shadowSide,this.colorWrite=r.colorWrite,this.precision=r.precision,this.polygonOffset=r.polygonOffset,this.polygonOffsetFactor=r.polygonOffsetFactor,this.polygonOffsetUnits=r.polygonOffsetUnits,this.dithering=r.dithering,this.alphaTest=r.alphaTest,this.alphaHash=r.alphaHash,this.alphaToCoverage=r.alphaToCoverage,this.premultipliedAlpha=r.premultipliedAlpha,this.forceSinglePass=r.forceSinglePass,this.visible=r.visible,this.toneMapped=r.toneMapped,this.userData=JSON.parse(JSON.stringify(r.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(r){r===!0&&this.version++}}class X2 extends T2{constructor(r){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new bx(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=bc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.map=r.map,this.lightMap=r.lightMap,this.lightMapIntensity=r.lightMapIntensity,this.aoMap=r.aoMap,this.aoMapIntensity=r.aoMapIntensity,this.specularMap=r.specularMap,this.alphaMap=r.alphaMap,this.envMap=r.envMap,this.combine=r.combine,this.reflectivity=r.reflectivity,this.refractionRatio=r.refractionRatio,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.wireframeLinecap=r.wireframeLinecap,this.wireframeLinejoin=r.wireframeLinejoin,this.fog=r.fog,this}}const Gl=QE();function QE(){const I=new ArrayBuffer(4),r=new Float32Array(I),d=new Uint32Array(I),g=new Uint32Array(512),y=new Uint32Array(512);for(let X=0;X<256;++X){const K=X-127;K<-27?(g[X]=0,g[X|256]=32768,y[X]=24,y[X|256]=24):K<-14?(g[X]=1024>>-K-14,g[X|256]=1024>>-K-14|32768,y[X]=-K-1,y[X|256]=-K-1):K<=15?(g[X]=K+15<<10,g[X|256]=K+15<<10|32768,y[X]=13,y[X|256]=13):K<128?(g[X]=31744,g[X|256]=64512,y[X]=24,y[X|256]=24):(g[X]=31744,g[X|256]=64512,y[X]=13,y[X|256]=13)}const _=new Uint32Array(2048),R=new Uint32Array(64),k=new Uint32Array(64);for(let X=1;X<1024;++X){let K=X<<13,Q=0;for(;!(K&8388608);)K<<=1,Q-=8388608;K&=-8388609,Q+=947912704,_[X]=K|Q}for(let X=1024;X<2048;++X)_[X]=939524096+(X-1024<<13);for(let X=1;X<31;++X)R[X]=X<<23;R[31]=1199570944,R[32]=2147483648;for(let X=33;X<63;++X)R[X]=2147483648+(X-32<<23);R[63]=3347054592;for(let X=1;X<64;++X)X!==32&&(k[X]=1024);return{floatView:r,uint32View:d,baseTable:g,shiftTable:y,mantissaTable:_,exponentTable:R,offsetTable:k}}function Ko(I){Math.abs(I)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),I=As(I,-65504,65504),Gl.floatView[0]=I;const r=Gl.uint32View[0],d=r>>23&511;return Gl.baseTable[d]+((r&8388607)>>Gl.shiftTable[d])}function gp(I){const r=I>>10;return Gl.uint32View[0]=Gl.mantissaTable[Gl.offsetTable[r]+(I&1023)]+Gl.exponentTable[r],Gl.floatView[0]}const Nm={toHalfFloat:Ko,fromHalfFloat:gp},$s=new ut,Pm=new vn;class rs{constructor(r,d,g=!1){if(Array.isArray(r))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=r,this.itemSize=d,this.count=r!==void 0?r.length/d:0,this.normalized=g,this.usage=xm,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=Ts,this.version=0}onUploadCallback(){}set needsUpdate(r){r===!0&&this.version++}get updateRange(){return _h("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(r){return this.usage=r,this}addUpdateRange(r,d){this.updateRanges.push({start:r,count:d})}clearUpdateRanges(){this.updateRanges.length=0}copy(r){return this.name=r.name,this.array=new r.array.constructor(r.array),this.itemSize=r.itemSize,this.count=r.count,this.normalized=r.normalized,this.usage=r.usage,this.gpuType=r.gpuType,this}copyAt(r,d,g){r*=this.itemSize,g*=d.itemSize;for(let y=0,_=this.itemSize;y<_;y++)this.array[r+y]=d.array[g+y];return this}copyArray(r){return this.array.set(r),this}applyMatrix3(r){if(this.itemSize===2)for(let d=0,g=this.count;d<g;d++)Pm.fromBufferAttribute(this,d),Pm.applyMatrix3(r),this.setXY(d,Pm.x,Pm.y);else if(this.itemSize===3)for(let d=0,g=this.count;d<g;d++)$s.fromBufferAttribute(this,d),$s.applyMatrix3(r),this.setXYZ(d,$s.x,$s.y,$s.z);return this}applyMatrix4(r){for(let d=0,g=this.count;d<g;d++)$s.fromBufferAttribute(this,d),$s.applyMatrix4(r),this.setXYZ(d,$s.x,$s.y,$s.z);return this}applyNormalMatrix(r){for(let d=0,g=this.count;d<g;d++)$s.fromBufferAttribute(this,d),$s.applyNormalMatrix(r),this.setXYZ(d,$s.x,$s.y,$s.z);return this}transformDirection(r){for(let d=0,g=this.count;d<g;d++)$s.fromBufferAttribute(this,d),$s.transformDirection(r),this.setXYZ(d,$s.x,$s.y,$s.z);return this}set(r,d=0){return this.array.set(r,d),this}getComponent(r,d){let g=this.array[r*this.itemSize+d];return this.normalized&&(g=Mo(g,this.array)),g}setComponent(r,d,g){return this.normalized&&(g=Br(g,this.array)),this.array[r*this.itemSize+d]=g,this}getX(r){let d=this.array[r*this.itemSize];return this.normalized&&(d=Mo(d,this.array)),d}setX(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize]=d,this}getY(r){let d=this.array[r*this.itemSize+1];return this.normalized&&(d=Mo(d,this.array)),d}setY(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize+1]=d,this}getZ(r){let d=this.array[r*this.itemSize+2];return this.normalized&&(d=Mo(d,this.array)),d}setZ(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize+2]=d,this}getW(r){let d=this.array[r*this.itemSize+3];return this.normalized&&(d=Mo(d,this.array)),d}setW(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize+3]=d,this}setXY(r,d,g){return r*=this.itemSize,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array)),this.array[r+0]=d,this.array[r+1]=g,this}setXYZ(r,d,g,y){return r*=this.itemSize,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array),y=Br(y,this.array)),this.array[r+0]=d,this.array[r+1]=g,this.array[r+2]=y,this}setXYZW(r,d,g,y,_){return r*=this.itemSize,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array),y=Br(y,this.array),_=Br(_,this.array)),this.array[r+0]=d,this.array[r+1]=g,this.array[r+2]=y,this.array[r+3]=_,this}onUpload(r){return this.onUploadCallback=r,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const r={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(r.name=this.name),this.usage!==xm&&(r.usage=this.usage),r}}class $6 extends null{constructor(r,d,g){super(new Int8Array(r),d,g)}}class J6 extends null{constructor(r,d,g){super(new Uint8Array(r),d,g)}}class W6 extends null{constructor(r,d,g){super(new Uint8ClampedArray(r),d,g)}}class Q6 extends null{constructor(r,d,g){super(new Int16Array(r),d,g)}}class x_ extends rs{constructor(r,d,g){super(new Uint16Array(r),d,g)}}class ek extends null{constructor(r,d,g){super(new Int32Array(r),d,g)}}class r_ extends rs{constructor(r,d,g){super(new Uint32Array(r),d,g)}}class xk extends null{constructor(r,d,g){super(new Uint16Array(r),d,g),this.isFloat16BufferAttribute=!0}getX(r){let d=gp(this.array[r*this.itemSize]);return this.normalized&&(d=Mo(d,this.array)),d}setX(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize]=Ko(d),this}getY(r){let d=gp(this.array[r*this.itemSize+1]);return this.normalized&&(d=Mo(d,this.array)),d}setY(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize+1]=Ko(d),this}getZ(r){let d=gp(this.array[r*this.itemSize+2]);return this.normalized&&(d=Mo(d,this.array)),d}setZ(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize+2]=Ko(d),this}getW(r){let d=gp(this.array[r*this.itemSize+3]);return this.normalized&&(d=Mo(d,this.array)),d}setW(r,d){return this.normalized&&(d=Br(d,this.array)),this.array[r*this.itemSize+3]=Ko(d),this}setXY(r,d,g){return r*=this.itemSize,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array)),this.array[r+0]=Ko(d),this.array[r+1]=Ko(g),this}setXYZ(r,d,g,y){return r*=this.itemSize,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array),y=Br(y,this.array)),this.array[r+0]=Ko(d),this.array[r+1]=Ko(g),this.array[r+2]=Ko(y),this}setXYZW(r,d,g,y,_){return r*=this.itemSize,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array),y=Br(y,this.array),_=Br(_,this.array)),this.array[r+0]=Ko(d),this.array[r+1]=Ko(g),this.array[r+2]=Ko(y),this.array[r+3]=Ko(_),this}}class Ux extends rs{constructor(r,d,g){super(new Float32Array(r),d,g)}}class rk extends null{constructor(r,d,g){super(new Float64Array(r),d,g)}}let eA=0;const j2=new ur,u1=new xs,$d=new ut,A2=new Co,vp=new Co,Ra=new ut;class Ur extends Md{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:eA++}),this.uuid=b2(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(r){return Array.isArray(r)?this.index=new(Bb(r)?r_:x_)(r,1):this.index=r,this}getAttribute(r){return this.attributes[r]}setAttribute(r,d){return this.attributes[r]=d,this}deleteAttribute(r){return delete this.attributes[r],this}hasAttribute(r){return this.attributes[r]!==void 0}addGroup(r,d,g=0){this.groups.push({start:r,count:d,materialIndex:g})}clearGroups(){this.groups=[]}setDrawRange(r,d){this.drawRange.start=r,this.drawRange.count=d}applyMatrix4(r){const d=this.attributes.position;d!==void 0&&(d.applyMatrix4(r),d.needsUpdate=!0);const g=this.attributes.normal;if(g!==void 0){const _=new Xr().getNormalMatrix(r);g.applyNormalMatrix(_),g.needsUpdate=!0}const y=this.attributes.tangent;return y!==void 0&&(y.transformDirection(r),y.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(r){return j2.makeRotationFromQuaternion(r),this.applyMatrix4(j2),this}rotateX(r){return j2.makeRotationX(r),this.applyMatrix4(j2),this}rotateY(r){return j2.makeRotationY(r),this.applyMatrix4(j2),this}rotateZ(r){return j2.makeRotationZ(r),this.applyMatrix4(j2),this}translate(r,d,g){return j2.makeTranslation(r,d,g),this.applyMatrix4(j2),this}scale(r,d,g){return j2.makeScale(r,d,g),this.applyMatrix4(j2),this}lookAt(r){return u1.lookAt(r),u1.updateMatrix(),this.applyMatrix4(u1.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter($d).negate(),this.translate($d.x,$d.y,$d.z),this}setFromPoints(r){const d=[];for(let g=0,y=r.length;g<y;g++){const _=r[g];d.push(_.x,_.y,_.z||0)}return this.setAttribute("position",new Ux(d,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Co);const r=this.attributes.position,d=this.morphAttributes.position;if(r&&r.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new ut(-1/0,-1/0,-1/0),new ut(1/0,1/0,1/0));return}if(r!==void 0){if(this.boundingBox.setFromBufferAttribute(r),d)for(let g=0,y=d.length;g<y;g++){const _=d[g];A2.setFromBufferAttribute(_),this.morphTargetsRelative?(Ra.addVectors(this.boundingBox.min,A2.min),this.boundingBox.expandByPoint(Ra),Ra.addVectors(this.boundingBox.max,A2.max),this.boundingBox.expandByPoint(Ra)):(this.boundingBox.expandByPoint(A2.min),this.boundingBox.expandByPoint(A2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Qa);const r=this.attributes.position,d=this.morphAttributes.position;if(r&&r.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new ut,1/0);return}if(r){const g=this.boundingSphere.center;if(A2.setFromBufferAttribute(r),d)for(let _=0,R=d.length;_<R;_++){const k=d[_];vp.setFromBufferAttribute(k),this.morphTargetsRelative?(Ra.addVectors(A2.min,vp.min),A2.expandByPoint(Ra),Ra.addVectors(A2.max,vp.max),A2.expandByPoint(Ra)):(A2.expandByPoint(vp.min),A2.expandByPoint(vp.max))}A2.getCenter(g);let y=0;for(let _=0,R=r.count;_<R;_++)Ra.fromBufferAttribute(r,_),y=Math.max(y,g.distanceToSquared(Ra));if(d)for(let _=0,R=d.length;_<R;_++){const k=d[_],X=this.morphTargetsRelative;for(let K=0,Q=k.count;K<Q;K++)Ra.fromBufferAttribute(k,K),X&&($d.fromBufferAttribute(r,K),Ra.add($d)),y=Math.max(y,g.distanceToSquared(Ra))}this.boundingSphere.radius=Math.sqrt(y),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const r=this.index,d=this.attributes;if(r===null||d.position===void 0||d.normal===void 0||d.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const g=r.array,y=d.position.array,_=d.normal.array,R=d.uv.array,k=y.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new rs(new Float32Array(4*k),4));const X=this.getAttribute("tangent").array,K=[],Q=[];for(let $e=0;$e<k;$e++)K[$e]=new ut,Q[$e]=new ut;const xe=new ut,ue=new ut,ge=new ut,_e=new vn,Re=new vn,be=new vn,ve=new ut,Xe=new ut;function Be($e,vt,M0){xe.fromArray(y,$e*3),ue.fromArray(y,vt*3),ge.fromArray(y,M0*3),_e.fromArray(R,$e*2),Re.fromArray(R,vt*2),be.fromArray(R,M0*2),ue.sub(xe),ge.sub(xe),Re.sub(_e),be.sub(_e);const V0=1/(Re.x*be.y-be.x*Re.y);isFinite(V0)&&(ve.copy(ue).multiplyScalar(be.y).addScaledVector(ge,-Re.y).multiplyScalar(V0),Xe.copy(ge).multiplyScalar(Re.x).addScaledVector(ue,-be.x).multiplyScalar(V0),K[$e].add(ve),K[vt].add(ve),K[M0].add(ve),Q[$e].add(Xe),Q[vt].add(Xe),Q[M0].add(Xe))}let Ke=this.groups;Ke.length===0&&(Ke=[{start:0,count:g.length}]);for(let $e=0,vt=Ke.length;$e<vt;++$e){const M0=Ke[$e],V0=M0.start,Pt=M0.count;for(let x0=V0,Wt=V0+Pt;x0<Wt;x0+=3)Be(g[x0+0],g[x0+1],g[x0+2])}const bt=new ut,rt=new ut,xt=new ut,Mt=new ut;function $t($e){xt.fromArray(_,$e*3),Mt.copy(xt);const vt=K[$e];bt.copy(vt),bt.sub(xt.multiplyScalar(xt.dot(vt))).normalize(),rt.crossVectors(Mt,vt);const V0=rt.dot(Q[$e])<0?-1:1;X[$e*4]=bt.x,X[$e*4+1]=bt.y,X[$e*4+2]=bt.z,X[$e*4+3]=V0}for(let $e=0,vt=Ke.length;$e<vt;++$e){const M0=Ke[$e],V0=M0.start,Pt=M0.count;for(let x0=V0,Wt=V0+Pt;x0<Wt;x0+=3)$t(g[x0+0]),$t(g[x0+1]),$t(g[x0+2])}}computeVertexNormals(){const r=this.index,d=this.getAttribute("position");if(d!==void 0){let g=this.getAttribute("normal");if(g===void 0)g=new rs(new Float32Array(d.count*3),3),this.setAttribute("normal",g);else for(let ue=0,ge=g.count;ue<ge;ue++)g.setXYZ(ue,0,0,0);const y=new ut,_=new ut,R=new ut,k=new ut,X=new ut,K=new ut,Q=new ut,xe=new ut;if(r)for(let ue=0,ge=r.count;ue<ge;ue+=3){const _e=r.getX(ue+0),Re=r.getX(ue+1),be=r.getX(ue+2);y.fromBufferAttribute(d,_e),_.fromBufferAttribute(d,Re),R.fromBufferAttribute(d,be),Q.subVectors(R,_),xe.subVectors(y,_),Q.cross(xe),k.fromBufferAttribute(g,_e),X.fromBufferAttribute(g,Re),K.fromBufferAttribute(g,be),k.add(Q),X.add(Q),K.add(Q),g.setXYZ(_e,k.x,k.y,k.z),g.setXYZ(Re,X.x,X.y,X.z),g.setXYZ(be,K.x,K.y,K.z)}else for(let ue=0,ge=d.count;ue<ge;ue+=3)y.fromBufferAttribute(d,ue+0),_.fromBufferAttribute(d,ue+1),R.fromBufferAttribute(d,ue+2),Q.subVectors(R,_),xe.subVectors(y,_),Q.cross(xe),g.setXYZ(ue+0,Q.x,Q.y,Q.z),g.setXYZ(ue+1,Q.x,Q.y,Q.z),g.setXYZ(ue+2,Q.x,Q.y,Q.z);this.normalizeNormals(),g.needsUpdate=!0}}normalizeNormals(){const r=this.attributes.normal;for(let d=0,g=r.count;d<g;d++)Ra.fromBufferAttribute(r,d),Ra.normalize(),r.setXYZ(d,Ra.x,Ra.y,Ra.z)}toNonIndexed(){function r(k,X){const K=k.array,Q=k.itemSize,xe=k.normalized,ue=new K.constructor(X.length*Q);let ge=0,_e=0;for(let Re=0,be=X.length;Re<be;Re++){k.isInterleavedBufferAttribute?ge=X[Re]*k.data.stride+k.offset:ge=X[Re]*Q;for(let ve=0;ve<Q;ve++)ue[_e++]=K[ge++]}return new rs(ue,Q,xe)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const d=new Ur,g=this.index.array,y=this.attributes;for(const k in y){const X=y[k],K=r(X,g);d.setAttribute(k,K)}const _=this.morphAttributes;for(const k in _){const X=[],K=_[k];for(let Q=0,xe=K.length;Q<xe;Q++){const ue=K[Q],ge=r(ue,g);X.push(ge)}d.morphAttributes[k]=X}d.morphTargetsRelative=this.morphTargetsRelative;const R=this.groups;for(let k=0,X=R.length;k<X;k++){const K=R[k];d.addGroup(K.start,K.count,K.materialIndex)}return d}toJSON(){const r={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),Object.keys(this.userData).length>0&&(r.userData=this.userData),this.parameters!==void 0){const X=this.parameters;for(const K in X)X[K]!==void 0&&(r[K]=X[K]);return r}r.data={attributes:{}};const d=this.index;d!==null&&(r.data.index={type:d.array.constructor.name,array:Array.prototype.slice.call(d.array)});const g=this.attributes;for(const X in g){const K=g[X];r.data.attributes[X]=K.toJSON(r.data)}const y={};let _=!1;for(const X in this.morphAttributes){const K=this.morphAttributes[X],Q=[];for(let xe=0,ue=K.length;xe<ue;xe++){const ge=K[xe];Q.push(ge.toJSON(r.data))}Q.length>0&&(y[X]=Q,_=!0)}_&&(r.data.morphAttributes=y,r.data.morphTargetsRelative=this.morphTargetsRelative);const R=this.groups;R.length>0&&(r.data.groups=JSON.parse(JSON.stringify(R)));const k=this.boundingSphere;return k!==null&&(r.data.boundingSphere={center:k.center.toArray(),radius:k.radius}),r}clone(){return new this.constructor().copy(this)}copy(r){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const d={};this.name=r.name;const g=r.index;g!==null&&this.setIndex(g.clone(d));const y=r.attributes;for(const K in y){const Q=y[K];this.setAttribute(K,Q.clone(d))}const _=r.morphAttributes;for(const K in _){const Q=[],xe=_[K];for(let ue=0,ge=xe.length;ue<ge;ue++)Q.push(xe[ue].clone(d));this.morphAttributes[K]=Q}this.morphTargetsRelative=r.morphTargetsRelative;const R=r.groups;for(let K=0,Q=R.length;K<Q;K++){const xe=R[K];this.addGroup(xe.start,xe.count,xe.materialIndex)}const k=r.boundingBox;k!==null&&(this.boundingBox=k.clone());const X=r.boundingSphere;return X!==null&&(this.boundingSphere=X.clone()),this.drawRange.start=r.drawRange.start,this.drawRange.count=r.drawRange.count,this.userData=r.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const i_=new ur,Ch=new up,Bm=new Qa,s_=new ut,Jd=new ut,Wd=new ut,Qd=new ut,d1=new ut,zm=new ut,Vm=new vn,Um=new vn,Gm=new vn,a_=new ut,o_=new ut,c_=new ut,Xm=new ut,jm=new ut;class Bs extends xs{constructor(r=new Ur,d=new X2){super(),this.isMesh=!0,this.type="Mesh",this.geometry=r,this.material=d,this.updateMorphTargets()}copy(r,d){return super.copy(r,d),r.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=r.morphTargetInfluences.slice()),r.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},r.morphTargetDictionary)),this.material=Array.isArray(r.material)?r.material.slice():r.material,this.geometry=r.geometry,this}updateMorphTargets(){const d=this.geometry.morphAttributes,g=Object.keys(d);if(g.length>0){const y=d[g[0]];if(y!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let _=0,R=y.length;_<R;_++){const k=y[_].name||String(_);this.morphTargetInfluences.push(0),this.morphTargetDictionary[k]=_}}}}getVertexPosition(r,d){const g=this.geometry,y=g.attributes.position,_=g.morphAttributes.position,R=g.morphTargetsRelative;d.fromBufferAttribute(y,r);const k=this.morphTargetInfluences;if(_&&k){zm.set(0,0,0);for(let X=0,K=_.length;X<K;X++){const Q=k[X],xe=_[X];Q!==0&&(d1.fromBufferAttribute(xe,r),R?zm.addScaledVector(d1,Q):zm.addScaledVector(d1.sub(d),Q))}d.add(zm)}return d}raycast(r,d){const g=this.geometry,y=this.material,_=this.matrixWorld;y!==void 0&&(g.boundingSphere===null&&g.computeBoundingSphere(),Bm.copy(g.boundingSphere),Bm.applyMatrix4(_),Ch.copy(r.ray).recast(r.near),!(Bm.containsPoint(Ch.origin)===!1&&(Ch.intersectSphere(Bm,s_)===null||Ch.origin.distanceToSquared(s_)>(r.far-r.near)**2))&&(i_.copy(_).invert(),Ch.copy(r.ray).applyMatrix4(i_),!(g.boundingBox!==null&&Ch.intersectsBox(g.boundingBox)===!1)&&this._computeIntersections(r,d,Ch)))}_computeIntersections(r,d,g){let y;const _=this.geometry,R=this.material,k=_.index,X=_.attributes.position,K=_.attributes.uv,Q=_.attributes.uv1,xe=_.attributes.normal,ue=_.groups,ge=_.drawRange;if(k!==null)if(Array.isArray(R))for(let _e=0,Re=ue.length;_e<Re;_e++){const be=ue[_e],ve=R[be.materialIndex],Xe=Math.max(be.start,ge.start),Be=Math.min(k.count,Math.min(be.start+be.count,ge.start+ge.count));for(let Ke=Xe,bt=Be;Ke<bt;Ke+=3){const rt=k.getX(Ke),xt=k.getX(Ke+1),Mt=k.getX(Ke+2);y=Km(this,ve,r,g,K,Q,xe,rt,xt,Mt),y&&(y.faceIndex=Math.floor(Ke/3),y.face.materialIndex=be.materialIndex,d.push(y))}}else{const _e=Math.max(0,ge.start),Re=Math.min(k.count,ge.start+ge.count);for(let be=_e,ve=Re;be<ve;be+=3){const Xe=k.getX(be),Be=k.getX(be+1),Ke=k.getX(be+2);y=Km(this,R,r,g,K,Q,xe,Xe,Be,Ke),y&&(y.faceIndex=Math.floor(be/3),d.push(y))}}else if(X!==void 0)if(Array.isArray(R))for(let _e=0,Re=ue.length;_e<Re;_e++){const be=ue[_e],ve=R[be.materialIndex],Xe=Math.max(be.start,ge.start),Be=Math.min(X.count,Math.min(be.start+be.count,ge.start+ge.count));for(let Ke=Xe,bt=Be;Ke<bt;Ke+=3){const rt=Ke,xt=Ke+1,Mt=Ke+2;y=Km(this,ve,r,g,K,Q,xe,rt,xt,Mt),y&&(y.faceIndex=Math.floor(Ke/3),y.face.materialIndex=be.materialIndex,d.push(y))}}else{const _e=Math.max(0,ge.start),Re=Math.min(X.count,ge.start+ge.count);for(let be=_e,ve=Re;be<ve;be+=3){const Xe=be,Be=be+1,Ke=be+2;y=Km(this,R,r,g,K,Q,xe,Xe,Be,Ke),y&&(y.faceIndex=Math.floor(be/3),d.push(y))}}}}function xA(I,r,d,g,y,_,R,k){let X;if(r.side===vs?X=g.intersectTriangle(R,_,y,!0,k):X=g.intersectTriangle(y,_,R,r.side===Ta,k),X===null)return null;jm.copy(k),jm.applyMatrix4(I.matrixWorld);const K=d.ray.origin.distanceTo(jm);return K<d.near||K>d.far?null:{distance:K,point:jm.clone(),object:I}}function Km(I,r,d,g,y,_,R,k,X,K){I.getVertexPosition(k,Jd),I.getVertexPosition(X,Wd),I.getVertexPosition(K,Qd);const Q=xA(I,r,d,g,Jd,Wd,Qd,Xm);if(Q){y&&(Vm.fromBufferAttribute(y,k),Um.fromBufferAttribute(y,X),Gm.fromBufferAttribute(y,K),Q.uv=G2.getInterpolation(Xm,Jd,Wd,Qd,Vm,Um,Gm,new vn)),_&&(Vm.fromBufferAttribute(_,k),Um.fromBufferAttribute(_,X),Gm.fromBufferAttribute(_,K),Q.uv1=G2.getInterpolation(Xm,Jd,Wd,Qd,Vm,Um,Gm,new vn),Q.uv2=Q.uv1),R&&(a_.fromBufferAttribute(R,k),o_.fromBufferAttribute(R,X),c_.fromBufferAttribute(R,K),Q.normal=G2.getInterpolation(Xm,Jd,Wd,Qd,a_,o_,c_,new ut),Q.normal.dot(g.direction)>0&&Q.normal.multiplyScalar(-1));const xe={a:k,b:X,c:K,normal:new ut,materialIndex:0};G2.getNormal(Jd,Wd,Qd,xe.normal),Q.face=xe}return Q}class ef extends Ur{constructor(r=1,d=1,g=1,y=1,_=1,R=1){super(),this.type="BoxGeometry",this.parameters={width:r,height:d,depth:g,widthSegments:y,heightSegments:_,depthSegments:R};const k=this;y=Math.floor(y),_=Math.floor(_),R=Math.floor(R);const X=[],K=[],Q=[],xe=[];let ue=0,ge=0;_e("z","y","x",-1,-1,g,d,r,R,_,0),_e("z","y","x",1,-1,g,d,-r,R,_,1),_e("x","z","y",1,1,r,g,d,y,R,2),_e("x","z","y",1,-1,r,g,-d,y,R,3),_e("x","y","z",1,-1,r,d,g,y,_,4),_e("x","y","z",-1,-1,r,d,-g,y,_,5),this.setIndex(X),this.setAttribute("position",new Ux(K,3)),this.setAttribute("normal",new Ux(Q,3)),this.setAttribute("uv",new Ux(xe,2));function _e(Re,be,ve,Xe,Be,Ke,bt,rt,xt,Mt,$t){const $e=Ke/xt,vt=bt/Mt,M0=Ke/2,V0=bt/2,Pt=rt/2,x0=xt+1,Wt=Mt+1;let an=0,W0=0;const j0=new ut;for(let un=0;un<Wt;un++){const bn=un*vt-V0;for(let ex=0;ex<x0;ex++){const Cx=ex*$e-M0;j0[Re]=Cx*Xe,j0[be]=bn*Be,j0[ve]=Pt,K.push(j0.x,j0.y,j0.z),j0[Re]=0,j0[be]=0,j0[ve]=rt>0?1:-1,Q.push(j0.x,j0.y,j0.z),xe.push(ex/xt),xe.push(1-un/Mt),an+=1}}for(let un=0;un<Mt;un++)for(let bn=0;bn<xt;bn++){const ex=ue+bn+x0*un,Cx=ue+bn+x0*(un+1),R0=ue+(bn+1)+x0*(un+1),_n=ue+(bn+1)+x0*un;X.push(ex,Cx,_n),X.push(Cx,R0,_n),W0+=6}k.addGroup(ge,W0,$t),ge+=W0,ue+=an}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new ef(r.width,r.height,r.depth,r.widthSegments,r.heightSegments,r.depthSegments)}}function xf(I){const r={};for(const d in I){r[d]={};for(const g in I[d]){const y=I[d][g];y&&(y.isColor||y.isMatrix3||y.isMatrix4||y.isVector2||y.isVector3||y.isVector4||y.isTexture||y.isQuaternion)?y.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),r[d][g]=null):r[d][g]=y.clone():Array.isArray(y)?r[d][g]=y.slice():r[d][g]=y}}return r}function Ro(I){const r={};for(let d=0;d<I.length;d++){const g=xf(I[d]);for(const y in g)r[y]=g[y]}return r}function rA(I){const r=[];for(let d=0;d<I.length;d++)r.push(I[d].clone());return r}function l_(I){return I.getRenderTarget()===null?I.outputColorSpace:Ci.workingColorSpace}const uA={clone:xf,merge:Ro};var dA=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,gA=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Xl extends T2{constructor(r){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=dA,this.fragmentShader=gA,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,r!==void 0&&this.setValues(r)}copy(r){return super.copy(r),this.fragmentShader=r.fragmentShader,this.vertexShader=r.vertexShader,this.uniforms=xf(r.uniforms),this.uniformsGroups=rA(r.uniformsGroups),this.defines=Object.assign({},r.defines),this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.fog=r.fog,this.lights=r.lights,this.clipping=r.clipping,this.extensions=Object.assign({},r.extensions),this.glslVersion=r.glslVersion,this}toJSON(r){const d=super.toJSON(r);d.glslVersion=this.glslVersion,d.uniforms={};for(const y in this.uniforms){const R=this.uniforms[y].value;R&&R.isTexture?d.uniforms[y]={type:"t",value:R.toJSON(r).uuid}:R&&R.isColor?d.uniforms[y]={type:"c",value:R.getHex()}:R&&R.isVector2?d.uniforms[y]={type:"v2",value:R.toArray()}:R&&R.isVector3?d.uniforms[y]={type:"v3",value:R.toArray()}:R&&R.isVector4?d.uniforms[y]={type:"v4",value:R.toArray()}:R&&R.isMatrix3?d.uniforms[y]={type:"m3",value:R.toArray()}:R&&R.isMatrix4?d.uniforms[y]={type:"m4",value:R.toArray()}:d.uniforms[y]={value:R}}Object.keys(this.defines).length>0&&(d.defines=this.defines),d.vertexShader=this.vertexShader,d.fragmentShader=this.fragmentShader,d.lights=this.lights,d.clipping=this.clipping;const g={};for(const y in this.extensions)this.extensions[y]===!0&&(g[y]=!0);return Object.keys(g).length>0&&(d.extensions=g),d}}class g1 extends xs{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ur,this.projectionMatrix=new ur,this.projectionMatrixInverse=new ur,this.coordinateSystem=Nl}copy(r,d){return super.copy(r,d),this.matrixWorldInverse.copy(r.matrixWorldInverse),this.projectionMatrix.copy(r.projectionMatrix),this.projectionMatrixInverse.copy(r.projectionMatrixInverse),this.coordinateSystem=r.coordinateSystem,this}getWorldDirection(r){return super.getWorldDirection(r).negate()}updateMatrixWorld(r){super.updateMatrixWorld(r),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(r,d){super.updateWorldMatrix(r,d),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Mu=new ut,u_=new vn,h_=new vn;class ua extends g1{constructor(r=50,d=1,g=.1,y=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=r,this.zoom=1,this.near=g,this.far=y,this.focus=10,this.aspect=d,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(r,d){return super.copy(r,d),this.fov=r.fov,this.zoom=r.zoom,this.near=r.near,this.far=r.far,this.focus=r.focus,this.aspect=r.aspect,this.view=r.view===null?null:Object.assign({},r.view),this.filmGauge=r.filmGauge,this.filmOffset=r.filmOffset,this}setFocalLength(r){const d=.5*this.getFilmHeight()/r;this.fov=Cd*2*Math.atan(d),this.updateProjectionMatrix()}getFocalLength(){const r=Math.tan(bh*.5*this.fov);return .5*this.getFilmHeight()/r}getEffectiveFOV(){return Cd*2*Math.atan(Math.tan(bh*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(r,d,g){Mu.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),d.set(Mu.x,Mu.y).multiplyScalar(-r/Mu.z),Mu.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),g.set(Mu.x,Mu.y).multiplyScalar(-r/Mu.z)}getViewSize(r,d){return this.getViewBounds(r,u_,h_),d.subVectors(h_,u_)}setViewOffset(r,d,g,y,_,R){this.aspect=r/d,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=r,this.view.fullHeight=d,this.view.offsetX=g,this.view.offsetY=y,this.view.width=_,this.view.height=R,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const r=this.near;let d=r*Math.tan(bh*.5*this.fov)/this.zoom,g=2*d,y=this.aspect*g,_=-.5*y;const R=this.view;if(this.view!==null&&this.view.enabled){const X=R.fullWidth,K=R.fullHeight;_+=R.offsetX*y/X,d-=R.offsetY*g/K,y*=R.width/X,g*=R.height/K}const k=this.filmOffset;k!==0&&(_+=r*k/this.getFilmWidth()),this.projectionMatrix.makePerspective(_,_+y,d,d-g,r,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(r){const d=super.toJSON(r);return d.object.fov=this.fov,d.object.zoom=this.zoom,d.object.near=this.near,d.object.far=this.far,d.object.focus=this.focus,d.object.aspect=this.aspect,this.view!==null&&(d.object.view=Object.assign({},this.view)),d.object.filmGauge=this.filmGauge,d.object.filmOffset=this.filmOffset,d}}const rf=-90,uf=1;class vA extends xs{constructor(r,d,g){super(),this.type="CubeCamera",this.renderTarget=g,this.coordinateSystem=null,this.activeMipmapLevel=0;const y=new ua(rf,uf,r,d);y.layers=this.layers,this.add(y);const _=new ua(rf,uf,r,d);_.layers=this.layers,this.add(_);const R=new ua(rf,uf,r,d);R.layers=this.layers,this.add(R);const k=new ua(rf,uf,r,d);k.layers=this.layers,this.add(k);const X=new ua(rf,uf,r,d);X.layers=this.layers,this.add(X);const K=new ua(rf,uf,r,d);K.layers=this.layers,this.add(K)}updateCoordinateSystem(){const r=this.coordinateSystem,d=this.children.concat(),[g,y,_,R,k,X]=d;for(const K of d)this.remove(K);if(r===Nl)g.up.set(0,1,0),g.lookAt(1,0,0),y.up.set(0,1,0),y.lookAt(-1,0,0),_.up.set(0,0,-1),_.lookAt(0,1,0),R.up.set(0,0,1),R.lookAt(0,-1,0),k.up.set(0,1,0),k.lookAt(0,0,1),X.up.set(0,1,0),X.lookAt(0,0,-1);else if(r===rm)g.up.set(0,-1,0),g.lookAt(-1,0,0),y.up.set(0,-1,0),y.lookAt(1,0,0),_.up.set(0,0,1),_.lookAt(0,1,0),R.up.set(0,0,-1),R.lookAt(0,-1,0),k.up.set(0,-1,0),k.lookAt(0,0,1),X.up.set(0,-1,0),X.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+r);for(const K of d)this.add(K),K.updateMatrixWorld()}update(r,d){this.parent===null&&this.updateMatrixWorld();const{renderTarget:g,activeMipmapLevel:y}=this;this.coordinateSystem!==r.coordinateSystem&&(this.coordinateSystem=r.coordinateSystem,this.updateCoordinateSystem());const[_,R,k,X,K,Q]=this.children,xe=r.getRenderTarget(),ue=r.getActiveCubeFace(),ge=r.getActiveMipmapLevel(),_e=r.xr.enabled;r.xr.enabled=!1;const Re=g.texture.generateMipmaps;g.texture.generateMipmaps=!1,r.setRenderTarget(g,0,y),r.render(d,_),r.setRenderTarget(g,1,y),r.render(d,R),r.setRenderTarget(g,2,y),r.render(d,k),r.setRenderTarget(g,3,y),r.render(d,X),r.setRenderTarget(g,4,y),r.render(d,K),g.texture.generateMipmaps=Re,r.setRenderTarget(g,5,y),r.render(d,Q),r.setRenderTarget(xe,ue,ge),r.xr.enabled=_e,g.texture.needsPMREMUpdate=!0}}class $m extends Ks{constructor(r,d,g,y,_,R,k,X,K,Q){r=r!==void 0?r:[],d=d!==void 0?d:_s,super(r,d,g,y,_,R,k,X,K,Q),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(r){this.image=r}}class bA extends Th{constructor(r=1,d={}){super(r,r,d),this.isWebGLCubeRenderTarget=!0;const g={width:r,height:r,depth:1},y=[g,g,g,g,g,g];d.encoding!==void 0&&(_h("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),d.colorSpace=d.encoding===z0?jn:$n),this.texture=new $m(y,d.mapping,d.wrapS,d.wrapT,d.magFilter,d.minFilter,d.format,d.type,d.anisotropy,d.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=d.generateMipmaps!==void 0?d.generateMipmaps:!1,this.texture.minFilter=d.minFilter!==void 0?d.minFilter:ui}fromEquirectangularTexture(r,d){this.texture.type=d.type,this.texture.colorSpace=d.colorSpace,this.texture.generateMipmaps=d.generateMipmaps,this.texture.minFilter=d.minFilter,this.texture.magFilter=d.magFilter;const g={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},y=new ef(5,5,5),_=new Xl({name:"CubemapFromEquirect",uniforms:xf(g.uniforms),vertexShader:g.vertexShader,fragmentShader:g.fragmentShader,side:vs,blending:Aa});_.uniforms.tEquirect.value=d;const R=new Bs(y,_),k=d.minFilter;return d.minFilter===Us&&(d.minFilter=ui),new vA(1,10,this).update(r,R),d.minFilter=k,R.geometry.dispose(),R.material.dispose(),this}clear(r,d,g,y){const _=r.getRenderTarget();for(let R=0;R<6;R++)r.setRenderTarget(this,R),r.clear(d,g,y);r.setRenderTarget(_)}}const v1=new ut,_A=new ut,TA=new Xr;class Rh{constructor(r=new ut(1,0,0),d=0){this.isPlane=!0,this.normal=r,this.constant=d}set(r,d){return this.normal.copy(r),this.constant=d,this}setComponents(r,d,g,y){return this.normal.set(r,d,g),this.constant=y,this}setFromNormalAndCoplanarPoint(r,d){return this.normal.copy(r),this.constant=-d.dot(this.normal),this}setFromCoplanarPoints(r,d,g){const y=v1.subVectors(g,d).cross(_A.subVectors(r,d)).normalize();return this.setFromNormalAndCoplanarPoint(y,r),this}copy(r){return this.normal.copy(r.normal),this.constant=r.constant,this}normalize(){const r=1/this.normal.length();return this.normal.multiplyScalar(r),this.constant*=r,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(r){return this.normal.dot(r)+this.constant}distanceToSphere(r){return this.distanceToPoint(r.center)-r.radius}projectPoint(r,d){return d.copy(r).addScaledVector(this.normal,-this.distanceToPoint(r))}intersectLine(r,d){const g=r.delta(v1),y=this.normal.dot(g);if(y===0)return this.distanceToPoint(r.start)===0?d.copy(r.start):null;const _=-(r.start.dot(this.normal)+this.constant)/y;return _<0||_>1?null:d.copy(r.start).addScaledVector(g,_)}intersectsLine(r){const d=this.distanceToPoint(r.start),g=this.distanceToPoint(r.end);return d<0&&g>0||g<0&&d>0}intersectsBox(r){return r.intersectsPlane(this)}intersectsSphere(r){return r.intersectsPlane(this)}coplanarPoint(r){return r.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(r,d){const g=d||TA.getNormalMatrix(r),y=this.coplanarPoint(v1).applyMatrix4(r),_=this.normal.applyMatrix3(g).normalize();return this.constant=-y.dot(_),this}translate(r){return this.constant-=r.dot(this.normal),this}equals(r){return r.normal.equals(this.normal)&&r.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Nh=new Qa,Jm=new ut;class Wm{constructor(r=new Rh,d=new Rh,g=new Rh,y=new Rh,_=new Rh,R=new Rh){this.planes=[r,d,g,y,_,R]}set(r,d,g,y,_,R){const k=this.planes;return k[0].copy(r),k[1].copy(d),k[2].copy(g),k[3].copy(y),k[4].copy(_),k[5].copy(R),this}copy(r){const d=this.planes;for(let g=0;g<6;g++)d[g].copy(r.planes[g]);return this}setFromProjectionMatrix(r,d=Nl){const g=this.planes,y=r.elements,_=y[0],R=y[1],k=y[2],X=y[3],K=y[4],Q=y[5],xe=y[6],ue=y[7],ge=y[8],_e=y[9],Re=y[10],be=y[11],ve=y[12],Xe=y[13],Be=y[14],Ke=y[15];if(g[0].setComponents(X-_,ue-K,be-ge,Ke-ve).normalize(),g[1].setComponents(X+_,ue+K,be+ge,Ke+ve).normalize(),g[2].setComponents(X+R,ue+Q,be+_e,Ke+Xe).normalize(),g[3].setComponents(X-R,ue-Q,be-_e,Ke-Xe).normalize(),g[4].setComponents(X-k,ue-xe,be-Re,Ke-Be).normalize(),d===Nl)g[5].setComponents(X+k,ue+xe,be+Re,Ke+Be).normalize();else if(d===rm)g[5].setComponents(k,xe,Re,Be).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+d);return this}intersectsObject(r){if(r.boundingSphere!==void 0)r.boundingSphere===null&&r.computeBoundingSphere(),Nh.copy(r.boundingSphere).applyMatrix4(r.matrixWorld);else{const d=r.geometry;d.boundingSphere===null&&d.computeBoundingSphere(),Nh.copy(d.boundingSphere).applyMatrix4(r.matrixWorld)}return this.intersectsSphere(Nh)}intersectsSprite(r){return Nh.center.set(0,0,0),Nh.radius=.7071067811865476,Nh.applyMatrix4(r.matrixWorld),this.intersectsSphere(Nh)}intersectsSphere(r){const d=this.planes,g=r.center,y=-r.radius;for(let _=0;_<6;_++)if(d[_].distanceToPoint(g)<y)return!1;return!0}intersectsBox(r){const d=this.planes;for(let g=0;g<6;g++){const y=d[g];if(Jm.x=y.normal.x>0?r.max.x:r.min.x,Jm.y=y.normal.y>0?r.max.y:r.min.y,Jm.z=y.normal.z>0?r.max.z:r.min.z,y.distanceToPoint(Jm)<0)return!1}return!0}containsPoint(r){const d=this.planes;for(let g=0;g<6;g++)if(d[g].distanceToPoint(r)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function d_(){let I=null,r=!1,d=null,g=null;function y(_,R){d(_,R),g=I.requestAnimationFrame(y)}return{start:function(){r!==!0&&d!==null&&(g=I.requestAnimationFrame(y),r=!0)},stop:function(){I.cancelAnimationFrame(g),r=!1},setAnimationLoop:function(_){d=_},setContext:function(_){I=_}}}function AA(I,r){const d=r.isWebGL2,g=new WeakMap;function y(K,Q){const xe=K.array,ue=K.usage,ge=xe.byteLength,_e=I.createBuffer();I.bindBuffer(Q,_e),I.bufferData(Q,xe,ue),K.onUploadCallback();let Re;if(xe instanceof Float32Array)Re=I.FLOAT;else if(xe instanceof Uint16Array)if(K.isFloat16BufferAttribute)if(d)Re=I.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else Re=I.UNSIGNED_SHORT;else if(xe instanceof Int16Array)Re=I.SHORT;else if(xe instanceof Uint32Array)Re=I.UNSIGNED_INT;else if(xe instanceof Int32Array)Re=I.INT;else if(xe instanceof Int8Array)Re=I.BYTE;else if(xe instanceof Uint8Array)Re=I.UNSIGNED_BYTE;else if(xe instanceof Uint8ClampedArray)Re=I.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+xe);return{buffer:_e,type:Re,bytesPerElement:xe.BYTES_PER_ELEMENT,version:K.version,size:ge}}function _(K,Q,xe){const ue=Q.array,ge=Q._updateRange,_e=Q.updateRanges;if(I.bindBuffer(xe,K),ge.count===-1&&_e.length===0&&I.bufferSubData(xe,0,ue),_e.length!==0){for(let Re=0,be=_e.length;Re<be;Re++){const ve=_e[Re];d?I.bufferSubData(xe,ve.start*ue.BYTES_PER_ELEMENT,ue,ve.start,ve.count):I.bufferSubData(xe,ve.start*ue.BYTES_PER_ELEMENT,ue.subarray(ve.start,ve.start+ve.count))}Q.clearUpdateRanges()}ge.count!==-1&&(d?I.bufferSubData(xe,ge.offset*ue.BYTES_PER_ELEMENT,ue,ge.offset,ge.count):I.bufferSubData(xe,ge.offset*ue.BYTES_PER_ELEMENT,ue.subarray(ge.offset,ge.offset+ge.count)),ge.count=-1),Q.onUploadCallback()}function R(K){return K.isInterleavedBufferAttribute&&(K=K.data),g.get(K)}function k(K){K.isInterleavedBufferAttribute&&(K=K.data);const Q=g.get(K);Q&&(I.deleteBuffer(Q.buffer),g.delete(K))}function X(K,Q){if(K.isGLBufferAttribute){const ue=g.get(K);(!ue||ue.version<K.version)&&g.set(K,{buffer:K.buffer,type:K.type,bytesPerElement:K.elementSize,version:K.version});return}K.isInterleavedBufferAttribute&&(K=K.data);const xe=g.get(K);if(xe===void 0)g.set(K,y(K,Q));else if(xe.version<K.version){if(xe.size!==K.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");_(xe.buffer,K,Q),xe.version=K.version}}return{get:R,remove:k,update:X}}class bp extends Ur{constructor(r=1,d=1,g=1,y=1){super(),this.type="PlaneGeometry",this.parameters={width:r,height:d,widthSegments:g,heightSegments:y};const _=r/2,R=d/2,k=Math.floor(g),X=Math.floor(y),K=k+1,Q=X+1,xe=r/k,ue=d/X,ge=[],_e=[],Re=[],be=[];for(let ve=0;ve<Q;ve++){const Xe=ve*ue-R;for(let Be=0;Be<K;Be++){const Ke=Be*xe-_;_e.push(Ke,-Xe,0),Re.push(0,0,1),be.push(Be/k),be.push(1-ve/X)}}for(let ve=0;ve<X;ve++)for(let Xe=0;Xe<k;Xe++){const Be=Xe+K*ve,Ke=Xe+K*(ve+1),bt=Xe+1+K*(ve+1),rt=Xe+1+K*ve;ge.push(Be,Ke,rt),ge.push(Ke,bt,rt)}this.setIndex(ge),this.setAttribute("position",new Ux(_e,3)),this.setAttribute("normal",new Ux(Re,3)),this.setAttribute("uv",new Ux(be,2))}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new bp(r.width,r.height,r.widthSegments,r.heightSegments)}}var MA=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,CA=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,RA=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,NA=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,PA=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,BA=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,zA=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,VA=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,UA=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,GA=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,XA=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,jA=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,KA=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,$A=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,JA=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,WA=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,QA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,e3=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,x3=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,r3=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,u3=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,d3=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,g3=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,v3=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,b3=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,_3=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,T3=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,A3=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,M3=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,C3=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,R3="gl_FragColor = linearToOutputTexel( gl_FragColor );",N3=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,P3=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,B3=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,z3=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,V3=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,U3=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,G3=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,X3=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,j3=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,K3=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,$3=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,J3=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,W3=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Q3=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,eM=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,xM=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,rM=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,uM=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,dM=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,gM=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,vM=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,bM=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,_M=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,TM=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,AM=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,MM=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,CM=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,RM=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,NM=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,PM=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,BM=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,zM=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,VM=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,UM=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,GM=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,XM=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,jM=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,KM=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,$M=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,JM=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,WM=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,QM=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,eC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,xC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,rC=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,uC=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,dC=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,gC=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,vC=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,bC=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,_C=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,TC=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,AC=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,MC=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,CC=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,RC=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,NC=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,PC=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,BC=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,zC=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,VC=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,UC=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,GC=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,XC=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,jC=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,KC=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,$C=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,JC=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,WC=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,QC=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,eI=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,xI=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,rI=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uI=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,dI=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,gI=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Gr={alphahash_fragment:MA,alphahash_pars_fragment:CA,alphamap_fragment:RA,alphamap_pars_fragment:NA,alphatest_fragment:PA,alphatest_pars_fragment:BA,aomap_fragment:zA,aomap_pars_fragment:VA,batching_pars_vertex:UA,batching_vertex:GA,begin_vertex:XA,beginnormal_vertex:jA,bsdfs:KA,iridescence_fragment:$A,bumpmap_pars_fragment:JA,clipping_planes_fragment:WA,clipping_planes_pars_fragment:QA,clipping_planes_pars_vertex:e3,clipping_planes_vertex:x3,color_fragment:r3,color_pars_fragment:u3,color_pars_vertex:d3,color_vertex:g3,common:v3,cube_uv_reflection_fragment:b3,defaultnormal_vertex:_3,displacementmap_pars_vertex:T3,displacementmap_vertex:A3,emissivemap_fragment:M3,emissivemap_pars_fragment:C3,colorspace_fragment:R3,colorspace_pars_fragment:N3,envmap_fragment:P3,envmap_common_pars_fragment:B3,envmap_pars_fragment:z3,envmap_pars_vertex:V3,envmap_physical_pars_fragment:rM,envmap_vertex:U3,fog_vertex:G3,fog_pars_vertex:X3,fog_fragment:j3,fog_pars_fragment:K3,gradientmap_pars_fragment:$3,lightmap_fragment:J3,lightmap_pars_fragment:W3,lights_lambert_fragment:Q3,lights_lambert_pars_fragment:eM,lights_pars_begin:xM,lights_toon_fragment:uM,lights_toon_pars_fragment:dM,lights_phong_fragment:gM,lights_phong_pars_fragment:vM,lights_physical_fragment:bM,lights_physical_pars_fragment:_M,lights_fragment_begin:TM,lights_fragment_maps:AM,lights_fragment_end:MM,logdepthbuf_fragment:CM,logdepthbuf_pars_fragment:RM,logdepthbuf_pars_vertex:NM,logdepthbuf_vertex:PM,map_fragment:BM,map_pars_fragment:zM,map_particle_fragment:VM,map_particle_pars_fragment:UM,metalnessmap_fragment:GM,metalnessmap_pars_fragment:XM,morphcolor_vertex:jM,morphnormal_vertex:KM,morphtarget_pars_vertex:$M,morphtarget_vertex:JM,normal_fragment_begin:WM,normal_fragment_maps:QM,normal_pars_fragment:eC,normal_pars_vertex:xC,normal_vertex:rC,normalmap_pars_fragment:uC,clearcoat_normal_fragment_begin:dC,clearcoat_normal_fragment_maps:gC,clearcoat_pars_fragment:vC,iridescence_pars_fragment:bC,opaque_fragment:_C,packing:TC,premultiplied_alpha_fragment:AC,project_vertex:MC,dithering_fragment:CC,dithering_pars_fragment:RC,roughnessmap_fragment:NC,roughnessmap_pars_fragment:PC,shadowmap_pars_fragment:BC,shadowmap_pars_vertex:zC,shadowmap_vertex:VC,shadowmask_pars_fragment:UC,skinbase_vertex:GC,skinning_pars_vertex:XC,skinning_vertex:jC,skinnormal_vertex:KC,specularmap_fragment:$C,specularmap_pars_fragment:JC,tonemapping_fragment:WC,tonemapping_pars_fragment:QC,transmission_fragment:eI,transmission_pars_fragment:xI,uv_pars_fragment:rI,uv_pars_vertex:uI,uv_vertex:dI,worldpos_vertex:gI,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,background_frag:`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,backgroundCube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,backgroundCube_frag:`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,cube_frag:`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,depth_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,meshbasic_vert:`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshnormal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,meshnormal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,shadow_vert:`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`},Qn={common:{diffuse:{value:new bx(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Xr},alphaMap:{value:null},alphaMapTransform:{value:new Xr},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Xr}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Xr}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Xr}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Xr},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Xr},normalScale:{value:new vn(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Xr},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Xr}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Xr}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Xr}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new bx(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new bx(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Xr},alphaTest:{value:0},uvTransform:{value:new Xr}},sprite:{diffuse:{value:new bx(16777215)},opacity:{value:1},center:{value:new vn(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Xr},alphaMap:{value:null},alphaMapTransform:{value:new Xr},alphaTest:{value:0}}},Qc={basic:{uniforms:Ro([Qn.common,Qn.specularmap,Qn.envmap,Qn.aomap,Qn.lightmap,Qn.fog]),vertexShader:Gr.meshbasic_vert,fragmentShader:Gr.meshbasic_frag},lambert:{uniforms:Ro([Qn.common,Qn.specularmap,Qn.envmap,Qn.aomap,Qn.lightmap,Qn.emissivemap,Qn.bumpmap,Qn.normalmap,Qn.displacementmap,Qn.fog,Qn.lights,{emissive:{value:new bx(0)}}]),vertexShader:Gr.meshlambert_vert,fragmentShader:Gr.meshlambert_frag},phong:{uniforms:Ro([Qn.common,Qn.specularmap,Qn.envmap,Qn.aomap,Qn.lightmap,Qn.emissivemap,Qn.bumpmap,Qn.normalmap,Qn.displacementmap,Qn.fog,Qn.lights,{emissive:{value:new bx(0)},specular:{value:new bx(1118481)},shininess:{value:30}}]),vertexShader:Gr.meshphong_vert,fragmentShader:Gr.meshphong_frag},standard:{uniforms:Ro([Qn.common,Qn.envmap,Qn.aomap,Qn.lightmap,Qn.emissivemap,Qn.bumpmap,Qn.normalmap,Qn.displacementmap,Qn.roughnessmap,Qn.metalnessmap,Qn.fog,Qn.lights,{emissive:{value:new bx(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Gr.meshphysical_vert,fragmentShader:Gr.meshphysical_frag},toon:{uniforms:Ro([Qn.common,Qn.aomap,Qn.lightmap,Qn.emissivemap,Qn.bumpmap,Qn.normalmap,Qn.displacementmap,Qn.gradientmap,Qn.fog,Qn.lights,{emissive:{value:new bx(0)}}]),vertexShader:Gr.meshtoon_vert,fragmentShader:Gr.meshtoon_frag},matcap:{uniforms:Ro([Qn.common,Qn.bumpmap,Qn.normalmap,Qn.displacementmap,Qn.fog,{matcap:{value:null}}]),vertexShader:Gr.meshmatcap_vert,fragmentShader:Gr.meshmatcap_frag},points:{uniforms:Ro([Qn.points,Qn.fog]),vertexShader:Gr.points_vert,fragmentShader:Gr.points_frag},dashed:{uniforms:Ro([Qn.common,Qn.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Gr.linedashed_vert,fragmentShader:Gr.linedashed_frag},depth:{uniforms:Ro([Qn.common,Qn.displacementmap]),vertexShader:Gr.depth_vert,fragmentShader:Gr.depth_frag},normal:{uniforms:Ro([Qn.common,Qn.bumpmap,Qn.normalmap,Qn.displacementmap,{opacity:{value:1}}]),vertexShader:Gr.meshnormal_vert,fragmentShader:Gr.meshnormal_frag},sprite:{uniforms:Ro([Qn.sprite,Qn.fog]),vertexShader:Gr.sprite_vert,fragmentShader:Gr.sprite_frag},background:{uniforms:{uvTransform:{value:new Xr},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Gr.background_vert,fragmentShader:Gr.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:Gr.backgroundCube_vert,fragmentShader:Gr.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Gr.cube_vert,fragmentShader:Gr.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Gr.equirect_vert,fragmentShader:Gr.equirect_frag},distanceRGBA:{uniforms:Ro([Qn.common,Qn.displacementmap,{referencePosition:{value:new ut},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Gr.distanceRGBA_vert,fragmentShader:Gr.distanceRGBA_frag},shadow:{uniforms:Ro([Qn.lights,Qn.fog,{color:{value:new bx(0)},opacity:{value:1}}]),vertexShader:Gr.shadow_vert,fragmentShader:Gr.shadow_frag}};Qc.physical={uniforms:Ro([Qc.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Xr},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Xr},clearcoatNormalScale:{value:new vn(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Xr},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Xr},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Xr},sheen:{value:0},sheenColor:{value:new bx(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Xr},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Xr},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Xr},transmissionSamplerSize:{value:new vn},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Xr},attenuationDistance:{value:0},attenuationColor:{value:new bx(0)},specularColor:{value:new bx(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Xr},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Xr},anisotropyVector:{value:new vn},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Xr}}]),vertexShader:Gr.meshphysical_vert,fragmentShader:Gr.meshphysical_frag};const Qm={r:0,b:0,g:0};function vI(I,r,d,g,y,_,R){const k=new bx(0);let X=_===!0?0:1,K,Q,xe=null,ue=0,ge=null;function _e(be,ve){let Xe=!1,Be=ve.isScene===!0?ve.background:null;Be&&Be.isTexture&&(Be=(ve.backgroundBlurriness>0?d:r).get(Be)),Be===null?Re(k,X):Be&&Be.isColor&&(Re(Be,1),Xe=!0);const Ke=I.xr.getEnvironmentBlendMode();Ke==="additive"?g.buffers.color.setClear(0,0,0,1,R):Ke==="alpha-blend"&&g.buffers.color.setClear(0,0,0,0,R),(I.autoClear||Xe)&&I.clear(I.autoClearColor,I.autoClearDepth,I.autoClearStencil),Be&&(Be.isCubeTexture||Be.mapping===P2)?(Q===void 0&&(Q=new Bs(new ef(1,1,1),new Xl({name:"BackgroundCubeMaterial",uniforms:xf(Qc.backgroundCube.uniforms),vertexShader:Qc.backgroundCube.vertexShader,fragmentShader:Qc.backgroundCube.fragmentShader,side:vs,depthTest:!1,depthWrite:!1,fog:!1})),Q.geometry.deleteAttribute("normal"),Q.geometry.deleteAttribute("uv"),Q.onBeforeRender=function(bt,rt,xt){this.matrixWorld.copyPosition(xt.matrixWorld)},Object.defineProperty(Q.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),y.update(Q)),Q.material.uniforms.envMap.value=Be,Q.material.uniforms.flipEnvMap.value=Be.isCubeTexture&&Be.isRenderTargetTexture===!1?-1:1,Q.material.uniforms.backgroundBlurriness.value=ve.backgroundBlurriness,Q.material.uniforms.backgroundIntensity.value=ve.backgroundIntensity,Q.material.toneMapped=Ci.getTransfer(Be.colorSpace)!==dr,(xe!==Be||ue!==Be.version||ge!==I.toneMapping)&&(Q.material.needsUpdate=!0,xe=Be,ue=Be.version,ge=I.toneMapping),Q.layers.enableAll(),be.unshift(Q,Q.geometry,Q.material,0,0,null)):Be&&Be.isTexture&&(K===void 0&&(K=new Bs(new bp(2,2),new Xl({name:"BackgroundMaterial",uniforms:xf(Qc.background.uniforms),vertexShader:Qc.background.vertexShader,fragmentShader:Qc.background.fragmentShader,side:Ta,depthTest:!1,depthWrite:!1,fog:!1})),K.geometry.deleteAttribute("normal"),Object.defineProperty(K.material,"map",{get:function(){return this.uniforms.t2D.value}}),y.update(K)),K.material.uniforms.t2D.value=Be,K.material.uniforms.backgroundIntensity.value=ve.backgroundIntensity,K.material.toneMapped=Ci.getTransfer(Be.colorSpace)!==dr,Be.matrixAutoUpdate===!0&&Be.updateMatrix(),K.material.uniforms.uvTransform.value.copy(Be.matrix),(xe!==Be||ue!==Be.version||ge!==I.toneMapping)&&(K.material.needsUpdate=!0,xe=Be,ue=Be.version,ge=I.toneMapping),K.layers.enableAll(),be.unshift(K,K.geometry,K.material,0,0,null))}function Re(be,ve){be.getRGB(Qm,l_(I)),g.buffers.color.setClear(Qm.r,Qm.g,Qm.b,ve,R)}return{getClearColor:function(){return k},setClearColor:function(be,ve=1){k.set(be),X=ve,Re(k,X)},getClearAlpha:function(){return X},setClearAlpha:function(be){X=be,Re(k,X)},render:_e}}function bI(I,r,d,g){const y=I.getParameter(I.MAX_VERTEX_ATTRIBS),_=g.isWebGL2?null:r.get("OES_vertex_array_object"),R=g.isWebGL2||_!==null,k={},X=be(null);let K=X,Q=!1;function xe(Pt,x0,Wt,an,W0){let j0=!1;if(R){const un=Re(an,Wt,x0);K!==un&&(K=un,ge(K.object)),j0=ve(Pt,an,Wt,W0),j0&&Xe(Pt,an,Wt,W0)}else{const un=x0.wireframe===!0;(K.geometry!==an.id||K.program!==Wt.id||K.wireframe!==un)&&(K.geometry=an.id,K.program=Wt.id,K.wireframe=un,j0=!0)}W0!==null&&d.update(W0,I.ELEMENT_ARRAY_BUFFER),(j0||Q)&&(Q=!1,Mt(Pt,x0,Wt,an),W0!==null&&I.bindBuffer(I.ELEMENT_ARRAY_BUFFER,d.get(W0).buffer))}function ue(){return g.isWebGL2?I.createVertexArray():_.createVertexArrayOES()}function ge(Pt){return g.isWebGL2?I.bindVertexArray(Pt):_.bindVertexArrayOES(Pt)}function _e(Pt){return g.isWebGL2?I.deleteVertexArray(Pt):_.deleteVertexArrayOES(Pt)}function Re(Pt,x0,Wt){const an=Wt.wireframe===!0;let W0=k[Pt.id];W0===void 0&&(W0={},k[Pt.id]=W0);let j0=W0[x0.id];j0===void 0&&(j0={},W0[x0.id]=j0);let un=j0[an];return un===void 0&&(un=be(ue()),j0[an]=un),un}function be(Pt){const x0=[],Wt=[],an=[];for(let W0=0;W0<y;W0++)x0[W0]=0,Wt[W0]=0,an[W0]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:x0,enabledAttributes:Wt,attributeDivisors:an,object:Pt,attributes:{},index:null}}function ve(Pt,x0,Wt,an){const W0=K.attributes,j0=x0.attributes;let un=0;const bn=Wt.getAttributes();for(const ex in bn)if(bn[ex].location>=0){const R0=W0[ex];let _n=j0[ex];if(_n===void 0&&(ex==="instanceMatrix"&&Pt.instanceMatrix&&(_n=Pt.instanceMatrix),ex==="instanceColor"&&Pt.instanceColor&&(_n=Pt.instanceColor)),R0===void 0||R0.attribute!==_n||_n&&R0.data!==_n.data)return!0;un++}return K.attributesNum!==un||K.index!==an}function Xe(Pt,x0,Wt,an){const W0={},j0=x0.attributes;let un=0;const bn=Wt.getAttributes();for(const ex in bn)if(bn[ex].location>=0){let R0=j0[ex];R0===void 0&&(ex==="instanceMatrix"&&Pt.instanceMatrix&&(R0=Pt.instanceMatrix),ex==="instanceColor"&&Pt.instanceColor&&(R0=Pt.instanceColor));const _n={};_n.attribute=R0,R0&&R0.data&&(_n.data=R0.data),W0[ex]=_n,un++}K.attributes=W0,K.attributesNum=un,K.index=an}function Be(){const Pt=K.newAttributes;for(let x0=0,Wt=Pt.length;x0<Wt;x0++)Pt[x0]=0}function Ke(Pt){bt(Pt,0)}function bt(Pt,x0){const Wt=K.newAttributes,an=K.enabledAttributes,W0=K.attributeDivisors;Wt[Pt]=1,an[Pt]===0&&(I.enableVertexAttribArray(Pt),an[Pt]=1),W0[Pt]!==x0&&((g.isWebGL2?I:r.get("ANGLE_instanced_arrays"))[g.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](Pt,x0),W0[Pt]=x0)}function rt(){const Pt=K.newAttributes,x0=K.enabledAttributes;for(let Wt=0,an=x0.length;Wt<an;Wt++)x0[Wt]!==Pt[Wt]&&(I.disableVertexAttribArray(Wt),x0[Wt]=0)}function xt(Pt,x0,Wt,an,W0,j0,un){un===!0?I.vertexAttribIPointer(Pt,x0,Wt,W0,j0):I.vertexAttribPointer(Pt,x0,Wt,an,W0,j0)}function Mt(Pt,x0,Wt,an){if(g.isWebGL2===!1&&(Pt.isInstancedMesh||an.isInstancedBufferGeometry)&&r.get("ANGLE_instanced_arrays")===null)return;Be();const W0=an.attributes,j0=Wt.getAttributes(),un=x0.defaultAttributeValues;for(const bn in j0){const ex=j0[bn];if(ex.location>=0){let Cx=W0[bn];if(Cx===void 0&&(bn==="instanceMatrix"&&Pt.instanceMatrix&&(Cx=Pt.instanceMatrix),bn==="instanceColor"&&Pt.instanceColor&&(Cx=Pt.instanceColor)),Cx!==void 0){const R0=Cx.normalized,_n=Cx.itemSize,ux=d.get(Cx);if(ux===void 0)continue;const Rx=ux.buffer,Bx=ux.type,Px=ux.bytesPerElement,xr=g.isWebGL2===!0&&(Bx===I.INT||Bx===I.UNSIGNED_INT||Cx.gpuType===r2);if(Cx.isInterleavedBufferAttribute){const Xx=Cx.data,zt=Xx.stride,Kn=Cx.offset;if(Xx.isInstancedInterleavedBuffer){for(let en=0;en<ex.locationSize;en++)bt(ex.location+en,Xx.meshPerAttribute);Pt.isInstancedMesh!==!0&&an._maxInstanceCount===void 0&&(an._maxInstanceCount=Xx.meshPerAttribute*Xx.count)}else for(let en=0;en<ex.locationSize;en++)Ke(ex.location+en);I.bindBuffer(I.ARRAY_BUFFER,Rx);for(let en=0;en<ex.locationSize;en++)xt(ex.location+en,_n/ex.locationSize,Bx,R0,zt*Px,(Kn+_n/ex.locationSize*en)*Px,xr)}else{if(Cx.isInstancedBufferAttribute){for(let Xx=0;Xx<ex.locationSize;Xx++)bt(ex.location+Xx,Cx.meshPerAttribute);Pt.isInstancedMesh!==!0&&an._maxInstanceCount===void 0&&(an._maxInstanceCount=Cx.meshPerAttribute*Cx.count)}else for(let Xx=0;Xx<ex.locationSize;Xx++)Ke(ex.location+Xx);I.bindBuffer(I.ARRAY_BUFFER,Rx);for(let Xx=0;Xx<ex.locationSize;Xx++)xt(ex.location+Xx,_n/ex.locationSize,Bx,R0,_n*Px,_n/ex.locationSize*Xx*Px,xr)}}else if(un!==void 0){const R0=un[bn];if(R0!==void 0)switch(R0.length){case 2:I.vertexAttrib2fv(ex.location,R0);break;case 3:I.vertexAttrib3fv(ex.location,R0);break;case 4:I.vertexAttrib4fv(ex.location,R0);break;default:I.vertexAttrib1fv(ex.location,R0)}}}}rt()}function $t(){M0();for(const Pt in k){const x0=k[Pt];for(const Wt in x0){const an=x0[Wt];for(const W0 in an)_e(an[W0].object),delete an[W0];delete x0[Wt]}delete k[Pt]}}function $e(Pt){if(k[Pt.id]===void 0)return;const x0=k[Pt.id];for(const Wt in x0){const an=x0[Wt];for(const W0 in an)_e(an[W0].object),delete an[W0];delete x0[Wt]}delete k[Pt.id]}function vt(Pt){for(const x0 in k){const Wt=k[x0];if(Wt[Pt.id]===void 0)continue;const an=Wt[Pt.id];for(const W0 in an)_e(an[W0].object),delete an[W0];delete Wt[Pt.id]}}function M0(){V0(),Q=!0,K!==X&&(K=X,ge(K.object))}function V0(){X.geometry=null,X.program=null,X.wireframe=!1}return{setup:xe,reset:M0,resetDefaultState:V0,dispose:$t,releaseStatesOfGeometry:$e,releaseStatesOfProgram:vt,initAttributes:Be,enableAttribute:Ke,disableUnusedAttributes:rt}}function _I(I,r,d,g){const y=g.isWebGL2;let _;function R(Q){_=Q}function k(Q,xe){I.drawArrays(_,Q,xe),d.update(xe,_,1)}function X(Q,xe,ue){if(ue===0)return;let ge,_e;if(y)ge=I,_e="drawArraysInstanced";else if(ge=r.get("ANGLE_instanced_arrays"),_e="drawArraysInstancedANGLE",ge===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}ge[_e](_,Q,xe,ue),d.update(xe,_,ue)}function K(Q,xe,ue){if(ue===0)return;const ge=r.get("WEBGL_multi_draw");if(ge===null)for(let _e=0;_e<ue;_e++)this.render(Q[_e],xe[_e]);else{ge.multiDrawArraysWEBGL(_,Q,0,xe,0,ue);let _e=0;for(let Re=0;Re<ue;Re++)_e+=xe[Re];d.update(_e,_,1)}}this.setMode=R,this.render=k,this.renderInstances=X,this.renderMultiDraw=K}function TI(I,r,d){let g;function y(){if(g!==void 0)return g;if(r.has("EXT_texture_filter_anisotropic")===!0){const xt=r.get("EXT_texture_filter_anisotropic");g=I.getParameter(xt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else g=0;return g}function _(xt){if(xt==="highp"){if(I.getShaderPrecisionFormat(I.VERTEX_SHADER,I.HIGH_FLOAT).precision>0&&I.getShaderPrecisionFormat(I.FRAGMENT_SHADER,I.HIGH_FLOAT).precision>0)return"highp";xt="mediump"}return xt==="mediump"&&I.getShaderPrecisionFormat(I.VERTEX_SHADER,I.MEDIUM_FLOAT).precision>0&&I.getShaderPrecisionFormat(I.FRAGMENT_SHADER,I.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const R=typeof WebGL2RenderingContext<"u"&&I.constructor.name==="WebGL2RenderingContext";let k=d.precision!==void 0?d.precision:"highp";const X=_(k);X!==k&&(console.warn("THREE.WebGLRenderer:",k,"not supported, using",X,"instead."),k=X);const K=R||r.has("WEBGL_draw_buffers"),Q=d.logarithmicDepthBuffer===!0,xe=I.getParameter(I.MAX_TEXTURE_IMAGE_UNITS),ue=I.getParameter(I.MAX_VERTEX_TEXTURE_IMAGE_UNITS),ge=I.getParameter(I.MAX_TEXTURE_SIZE),_e=I.getParameter(I.MAX_CUBE_MAP_TEXTURE_SIZE),Re=I.getParameter(I.MAX_VERTEX_ATTRIBS),be=I.getParameter(I.MAX_VERTEX_UNIFORM_VECTORS),ve=I.getParameter(I.MAX_VARYING_VECTORS),Xe=I.getParameter(I.MAX_FRAGMENT_UNIFORM_VECTORS),Be=ue>0,Ke=R||r.has("OES_texture_float"),bt=Be&&Ke,rt=R?I.getParameter(I.MAX_SAMPLES):0;return{isWebGL2:R,drawBuffers:K,getMaxAnisotropy:y,getMaxPrecision:_,precision:k,logarithmicDepthBuffer:Q,maxTextures:xe,maxVertexTextures:ue,maxTextureSize:ge,maxCubemapSize:_e,maxAttributes:Re,maxVertexUniforms:be,maxVaryings:ve,maxFragmentUniforms:Xe,vertexTextures:Be,floatFragmentTextures:Ke,floatVertexTextures:bt,maxSamples:rt}}function AI(I){const r=this;let d=null,g=0,y=!1,_=!1;const R=new Rh,k=new Xr,X={value:null,needsUpdate:!1};this.uniform=X,this.numPlanes=0,this.numIntersection=0,this.init=function(xe,ue){const ge=xe.length!==0||ue||g!==0||y;return y=ue,g=xe.length,ge},this.beginShadows=function(){_=!0,Q(null)},this.endShadows=function(){_=!1},this.setGlobalState=function(xe,ue){d=Q(xe,ue,0)},this.setState=function(xe,ue,ge){const _e=xe.clippingPlanes,Re=xe.clipIntersection,be=xe.clipShadows,ve=I.get(xe);if(!y||_e===null||_e.length===0||_&&!be)_?Q(null):K();else{const Xe=_?0:g,Be=Xe*4;let Ke=ve.clippingState||null;X.value=Ke,Ke=Q(_e,ue,Be,ge);for(let bt=0;bt!==Be;++bt)Ke[bt]=d[bt];ve.clippingState=Ke,this.numIntersection=Re?this.numPlanes:0,this.numPlanes+=Xe}};function K(){X.value!==d&&(X.value=d,X.needsUpdate=g>0),r.numPlanes=g,r.numIntersection=0}function Q(xe,ue,ge,_e){const Re=xe!==null?xe.length:0;let be=null;if(Re!==0){if(be=X.value,_e!==!0||be===null){const ve=ge+Re*4,Xe=ue.matrixWorldInverse;k.getNormalMatrix(Xe),(be===null||be.length<ve)&&(be=new Float32Array(ve));for(let Be=0,Ke=ge;Be!==Re;++Be,Ke+=4)R.copy(xe[Be]).applyMatrix4(Xe,k),R.normal.toArray(be,Ke),be[Ke+3]=R.constant}X.value=be,X.needsUpdate=!0}return r.numPlanes=Re,r.numIntersection=0,be}}function MI(I){let r=new WeakMap;function d(R,k){return k===Qs?R.mapping=_s:k===Ps&&(R.mapping=e2),R}function g(R){if(R&&R.isTexture){const k=R.mapping;if(k===Qs||k===Ps)if(r.has(R)){const X=r.get(R).texture;return d(X,R.mapping)}else{const X=R.image;if(X&&X.height>0){const K=new bA(X.height);return K.fromEquirectangularTexture(I,R),r.set(R,K),R.addEventListener("dispose",y),d(K.texture,R.mapping)}else return null}}return R}function y(R){const k=R.target;k.removeEventListener("dispose",y);const X=r.get(k);X!==void 0&&(r.delete(k),X.dispose())}function _(){r=new WeakMap}return{get:g,dispose:_}}class _p extends g1{constructor(r=-1,d=1,g=1,y=-1,_=.1,R=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=r,this.right=d,this.top=g,this.bottom=y,this.near=_,this.far=R,this.updateProjectionMatrix()}copy(r,d){return super.copy(r,d),this.left=r.left,this.right=r.right,this.top=r.top,this.bottom=r.bottom,this.near=r.near,this.far=r.far,this.zoom=r.zoom,this.view=r.view===null?null:Object.assign({},r.view),this}setViewOffset(r,d,g,y,_,R){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=r,this.view.fullHeight=d,this.view.offsetX=g,this.view.offsetY=y,this.view.width=_,this.view.height=R,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const r=(this.right-this.left)/(2*this.zoom),d=(this.top-this.bottom)/(2*this.zoom),g=(this.right+this.left)/2,y=(this.top+this.bottom)/2;let _=g-r,R=g+r,k=y+d,X=y-d;if(this.view!==null&&this.view.enabled){const K=(this.right-this.left)/this.view.fullWidth/this.zoom,Q=(this.top-this.bottom)/this.view.fullHeight/this.zoom;_+=K*this.view.offsetX,R=_+K*this.view.width,k-=Q*this.view.offsetY,X=k-Q*this.view.height}this.projectionMatrix.makeOrthographic(_,R,k,X,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(r){const d=super.toJSON(r);return d.object.zoom=this.zoom,d.object.left=this.left,d.object.right=this.right,d.object.top=this.top,d.object.bottom=this.bottom,d.object.near=this.near,d.object.far=this.far,this.view!==null&&(d.object.view=Object.assign({},this.view)),d}}const df=4,f_=[.125,.215,.35,.446,.526,.582],Ph=20,b1=new _p,p_=new bx;let _1=null,T1=0,A1=0;const Bh=(1+Math.sqrt(5))/2,gf=1/Bh,m_=[new ut(1,1,1),new ut(-1,1,1),new ut(1,1,-1),new ut(-1,1,-1),new ut(0,Bh,gf),new ut(0,Bh,-gf),new ut(gf,0,Bh),new ut(-gf,0,Bh),new ut(Bh,gf,0),new ut(-Bh,gf,0)];class g_{constructor(r){this._renderer=r,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(r,d=0,g=.1,y=100){_1=this._renderer.getRenderTarget(),T1=this._renderer.getActiveCubeFace(),A1=this._renderer.getActiveMipmapLevel(),this._setSize(256);const _=this._allocateTargets();return _.depthBuffer=!0,this._sceneToCubeUV(r,g,y,_),d>0&&this._blur(_,0,0,d),this._applyPMREM(_),this._cleanup(_),_}fromEquirectangular(r,d=null){return this._fromTexture(r,d)}fromCubemap(r,d=null){return this._fromTexture(r,d)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=b_(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=v_(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(r){this._lodMax=Math.floor(Math.log2(r)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let r=0;r<this._lodPlanes.length;r++)this._lodPlanes[r].dispose()}_cleanup(r){this._renderer.setRenderTarget(_1,T1,A1),r.scissorTest=!1,eg(r,0,0,r.width,r.height)}_fromTexture(r,d){r.mapping===_s||r.mapping===e2?this._setSize(r.image.length===0?16:r.image[0].width||r.image[0].image.width):this._setSize(r.image.width/4),_1=this._renderer.getRenderTarget(),T1=this._renderer.getActiveCubeFace(),A1=this._renderer.getActiveMipmapLevel();const g=d||this._allocateTargets();return this._textureToCubeUV(r,g),this._applyPMREM(g),this._cleanup(g),g}_allocateTargets(){const r=3*Math.max(this._cubeSize,112),d=4*this._cubeSize,g={magFilter:ui,minFilter:ui,generateMipmaps:!1,type:Xi,format:xa,colorSpace:vx,depthBuffer:!1},y=y_(r,d,g);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==r||this._pingPongRenderTarget.height!==d){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=y_(r,d,g);const{_lodMax:_}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=CI(_)),this._blurMaterial=RI(_,r,d)}return y}_compileMaterial(r){const d=new Bs(this._lodPlanes[0],r);this._renderer.compile(d,b1)}_sceneToCubeUV(r,d,g,y){const k=new ua(90,1,d,g),X=[1,-1,1,1,1,1],K=[1,1,1,-1,-1,-1],Q=this._renderer,xe=Q.autoClear,ue=Q.toneMapping;Q.getClearColor(p_),Q.toneMapping=Ma,Q.autoClear=!1;const ge=new X2({name:"PMREM.Background",side:vs,depthWrite:!1,depthTest:!1}),_e=new Bs(new ef,ge);let Re=!1;const be=r.background;be?be.isColor&&(ge.color.copy(be),r.background=null,Re=!0):(ge.color.copy(p_),Re=!0);for(let ve=0;ve<6;ve++){const Xe=ve%3;Xe===0?(k.up.set(0,X[ve],0),k.lookAt(K[ve],0,0)):Xe===1?(k.up.set(0,0,X[ve]),k.lookAt(0,K[ve],0)):(k.up.set(0,X[ve],0),k.lookAt(0,0,K[ve]));const Be=this._cubeSize;eg(y,Xe*Be,ve>2?Be:0,Be,Be),Q.setRenderTarget(y),Re&&Q.render(_e,k),Q.render(r,k)}_e.geometry.dispose(),_e.material.dispose(),Q.toneMapping=ue,Q.autoClear=xe,r.background=be}_textureToCubeUV(r,d){const g=this._renderer,y=r.mapping===_s||r.mapping===e2;y?(this._cubemapMaterial===null&&(this._cubemapMaterial=b_()),this._cubemapMaterial.uniforms.flipEnvMap.value=r.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=v_());const _=y?this._cubemapMaterial:this._equirectMaterial,R=new Bs(this._lodPlanes[0],_),k=_.uniforms;k.envMap.value=r;const X=this._cubeSize;eg(d,0,0,3*X,2*X),g.setRenderTarget(d),g.render(R,b1)}_applyPMREM(r){const d=this._renderer,g=d.autoClear;d.autoClear=!1;for(let y=1;y<this._lodPlanes.length;y++){const _=Math.sqrt(this._sigmas[y]*this._sigmas[y]-this._sigmas[y-1]*this._sigmas[y-1]),R=m_[(y-1)%m_.length];this._blur(r,y-1,y,_,R)}d.autoClear=g}_blur(r,d,g,y,_){const R=this._pingPongRenderTarget;this._halfBlur(r,R,d,g,y,"latitudinal",_),this._halfBlur(R,r,g,g,y,"longitudinal",_)}_halfBlur(r,d,g,y,_,R,k){const X=this._renderer,K=this._blurMaterial;R!=="latitudinal"&&R!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const Q=3,xe=new Bs(this._lodPlanes[y],K),ue=K.uniforms,ge=this._sizeLods[g]-1,_e=isFinite(_)?Math.PI/(2*ge):2*Math.PI/(2*Ph-1),Re=_/_e,be=isFinite(_)?1+Math.floor(Q*Re):Ph;be>Ph&&console.warn(`sigmaRadians, ${_}, is too large and will clip, as it requested ${be} samples when the maximum is set to ${Ph}`);const ve=[];let Xe=0;for(let xt=0;xt<Ph;++xt){const Mt=xt/Re,$t=Math.exp(-Mt*Mt/2);ve.push($t),xt===0?Xe+=$t:xt<be&&(Xe+=2*$t)}for(let xt=0;xt<ve.length;xt++)ve[xt]=ve[xt]/Xe;ue.envMap.value=r.texture,ue.samples.value=be,ue.weights.value=ve,ue.latitudinal.value=R==="latitudinal",k&&(ue.poleAxis.value=k);const{_lodMax:Be}=this;ue.dTheta.value=_e,ue.mipInt.value=Be-g;const Ke=this._sizeLods[y],bt=3*Ke*(y>Be-df?y-Be+df:0),rt=4*(this._cubeSize-Ke);eg(d,bt,rt,3*Ke,2*Ke),X.setRenderTarget(d),X.render(xe,b1)}}function CI(I){const r=[],d=[],g=[];let y=I;const _=I-df+1+f_.length;for(let R=0;R<_;R++){const k=Math.pow(2,y);d.push(k);let X=1/k;R>I-df?X=f_[R-I+df-1]:R===0&&(X=0),g.push(X);const K=1/(k-2),Q=-K,xe=1+K,ue=[Q,Q,xe,Q,xe,xe,Q,Q,xe,xe,Q,xe],ge=6,_e=6,Re=3,be=2,ve=1,Xe=new Float32Array(Re*_e*ge),Be=new Float32Array(be*_e*ge),Ke=new Float32Array(ve*_e*ge);for(let rt=0;rt<ge;rt++){const xt=rt%3*2/3-1,Mt=rt>2?0:-1,$t=[xt,Mt,0,xt+2/3,Mt,0,xt+2/3,Mt+1,0,xt,Mt,0,xt+2/3,Mt+1,0,xt,Mt+1,0];Xe.set($t,Re*_e*rt),Be.set(ue,be*_e*rt);const $e=[rt,rt,rt,rt,rt,rt];Ke.set($e,ve*_e*rt)}const bt=new Ur;bt.setAttribute("position",new rs(Xe,Re)),bt.setAttribute("uv",new rs(Be,be)),bt.setAttribute("faceIndex",new rs(Ke,ve)),r.push(bt),y>df&&y--}return{lodPlanes:r,sizeLods:d,sigmas:g}}function y_(I,r,d){const g=new Th(I,r,d);return g.texture.mapping=P2,g.texture.name="PMREM.cubeUv",g.scissorTest=!0,g}function eg(I,r,d,g,y){I.viewport.set(r,d,g,y),I.scissor.set(r,d,g,y)}function RI(I,r,d){const g=new Float32Array(Ph),y=new ut(0,1,0);return new Xl({name:"SphericalGaussianBlur",defines:{n:Ph,CUBEUV_TEXEL_WIDTH:1/r,CUBEUV_TEXEL_HEIGHT:1/d,CUBEUV_MAX_MIP:`${I}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:g},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:y}},vertexShader:M1(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Aa,depthTest:!1,depthWrite:!1})}function v_(){return new Xl({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:M1(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Aa,depthTest:!1,depthWrite:!1})}function b_(){return new Xl({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:M1(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Aa,depthTest:!1,depthWrite:!1})}function M1(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function NI(I){let r=new WeakMap,d=null;function g(k){if(k&&k.isTexture){const X=k.mapping,K=X===Qs||X===Ps,Q=X===_s||X===e2;if(K||Q)if(k.isRenderTargetTexture&&k.needsPMREMUpdate===!0){k.needsPMREMUpdate=!1;let xe=r.get(k);return d===null&&(d=new g_(I)),xe=K?d.fromEquirectangular(k,xe):d.fromCubemap(k,xe),r.set(k,xe),xe.texture}else{if(r.has(k))return r.get(k).texture;{const xe=k.image;if(K&&xe&&xe.height>0||Q&&xe&&y(xe)){d===null&&(d=new g_(I));const ue=K?d.fromEquirectangular(k):d.fromCubemap(k);return r.set(k,ue),k.addEventListener("dispose",_),ue.texture}else return null}}}return k}function y(k){let X=0;const K=6;for(let Q=0;Q<K;Q++)k[Q]!==void 0&&X++;return X===K}function _(k){const X=k.target;X.removeEventListener("dispose",_);const K=r.get(X);K!==void 0&&(r.delete(X),K.dispose())}function R(){r=new WeakMap,d!==null&&(d.dispose(),d=null)}return{get:g,dispose:R}}function PI(I){const r={};function d(g){if(r[g]!==void 0)return r[g];let y;switch(g){case"WEBGL_depth_texture":y=I.getExtension("WEBGL_depth_texture")||I.getExtension("MOZ_WEBGL_depth_texture")||I.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":y=I.getExtension("EXT_texture_filter_anisotropic")||I.getExtension("MOZ_EXT_texture_filter_anisotropic")||I.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":y=I.getExtension("WEBGL_compressed_texture_s3tc")||I.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||I.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":y=I.getExtension("WEBGL_compressed_texture_pvrtc")||I.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:y=I.getExtension(g)}return r[g]=y,y}return{has:function(g){return d(g)!==null},init:function(g){g.isWebGL2?(d("EXT_color_buffer_float"),d("WEBGL_clip_cull_distance")):(d("WEBGL_depth_texture"),d("OES_texture_float"),d("OES_texture_half_float"),d("OES_texture_half_float_linear"),d("OES_standard_derivatives"),d("OES_element_index_uint"),d("OES_vertex_array_object"),d("ANGLE_instanced_arrays")),d("OES_texture_float_linear"),d("EXT_color_buffer_half_float"),d("WEBGL_multisampled_render_to_texture")},get:function(g){const y=d(g);return y===null&&console.warn("THREE.WebGLRenderer: "+g+" extension not supported."),y}}}function BI(I,r,d,g){const y={},_=new WeakMap;function R(xe){const ue=xe.target;ue.index!==null&&r.remove(ue.index);for(const _e in ue.attributes)r.remove(ue.attributes[_e]);for(const _e in ue.morphAttributes){const Re=ue.morphAttributes[_e];for(let be=0,ve=Re.length;be<ve;be++)r.remove(Re[be])}ue.removeEventListener("dispose",R),delete y[ue.id];const ge=_.get(ue);ge&&(r.remove(ge),_.delete(ue)),g.releaseStatesOfGeometry(ue),ue.isInstancedBufferGeometry===!0&&delete ue._maxInstanceCount,d.memory.geometries--}function k(xe,ue){return y[ue.id]===!0||(ue.addEventListener("dispose",R),y[ue.id]=!0,d.memory.geometries++),ue}function X(xe){const ue=xe.attributes;for(const _e in ue)r.update(ue[_e],I.ARRAY_BUFFER);const ge=xe.morphAttributes;for(const _e in ge){const Re=ge[_e];for(let be=0,ve=Re.length;be<ve;be++)r.update(Re[be],I.ARRAY_BUFFER)}}function K(xe){const ue=[],ge=xe.index,_e=xe.attributes.position;let Re=0;if(ge!==null){const Xe=ge.array;Re=ge.version;for(let Be=0,Ke=Xe.length;Be<Ke;Be+=3){const bt=Xe[Be+0],rt=Xe[Be+1],xt=Xe[Be+2];ue.push(bt,rt,rt,xt,xt,bt)}}else if(_e!==void 0){const Xe=_e.array;Re=_e.version;for(let Be=0,Ke=Xe.length/3-1;Be<Ke;Be+=3){const bt=Be+0,rt=Be+1,xt=Be+2;ue.push(bt,rt,rt,xt,xt,bt)}}else return;const be=new(Bb(ue)?r_:x_)(ue,1);be.version=Re;const ve=_.get(xe);ve&&r.remove(ve),_.set(xe,be)}function Q(xe){const ue=_.get(xe);if(ue){const ge=xe.index;ge!==null&&ue.version<ge.version&&K(xe)}else K(xe);return _.get(xe)}return{get:k,update:X,getWireframeAttribute:Q}}function zI(I,r,d,g){const y=g.isWebGL2;let _;function R(ge){_=ge}let k,X;function K(ge){k=ge.type,X=ge.bytesPerElement}function Q(ge,_e){I.drawElements(_,_e,k,ge*X),d.update(_e,_,1)}function xe(ge,_e,Re){if(Re===0)return;let be,ve;if(y)be=I,ve="drawElementsInstanced";else if(be=r.get("ANGLE_instanced_arrays"),ve="drawElementsInstancedANGLE",be===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}be[ve](_,_e,k,ge*X,Re),d.update(_e,_,Re)}function ue(ge,_e,Re){if(Re===0)return;const be=r.get("WEBGL_multi_draw");if(be===null)for(let ve=0;ve<Re;ve++)this.render(ge[ve]/X,_e[ve]);else{be.multiDrawElementsWEBGL(_,_e,0,k,ge,0,Re);let ve=0;for(let Xe=0;Xe<Re;Xe++)ve+=_e[Xe];d.update(ve,_,1)}}this.setMode=R,this.setIndex=K,this.render=Q,this.renderInstances=xe,this.renderMultiDraw=ue}function VI(I){const r={geometries:0,textures:0},d={frame:0,calls:0,triangles:0,points:0,lines:0};function g(_,R,k){switch(d.calls++,R){case I.TRIANGLES:d.triangles+=k*(_/3);break;case I.LINES:d.lines+=k*(_/2);break;case I.LINE_STRIP:d.lines+=k*(_-1);break;case I.LINE_LOOP:d.lines+=k*_;break;case I.POINTS:d.points+=k*_;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",R);break}}function y(){d.calls=0,d.triangles=0,d.points=0,d.lines=0}return{memory:r,render:d,programs:null,autoReset:!0,reset:y,update:g}}function UI(I,r){return I[0]-r[0]}function GI(I,r){return Math.abs(r[1])-Math.abs(I[1])}function XI(I,r,d){const g={},y=new Float32Array(8),_=new WeakMap,R=new Vi,k=[];for(let K=0;K<8;K++)k[K]=[K,0];function X(K,Q,xe){const ue=K.morphTargetInfluences;if(r.isWebGL2===!0){const ge=Q.morphAttributes.position||Q.morphAttributes.normal||Q.morphAttributes.color,_e=ge!==void 0?ge.length:0;let Re=_.get(Q);if(Re===void 0||Re.count!==_e){let Pt=function(){M0.dispose(),_.delete(Q),Q.removeEventListener("dispose",Pt)};Re!==void 0&&Re.texture.dispose();const Xe=Q.morphAttributes.position!==void 0,Be=Q.morphAttributes.normal!==void 0,Ke=Q.morphAttributes.color!==void 0,bt=Q.morphAttributes.position||[],rt=Q.morphAttributes.normal||[],xt=Q.morphAttributes.color||[];let Mt=0;Xe===!0&&(Mt=1),Be===!0&&(Mt=2),Ke===!0&&(Mt=3);let $t=Q.attributes.position.count*Mt,$e=1;$t>r.maxTextureSize&&($e=Math.ceil($t/r.maxTextureSize),$t=r.maxTextureSize);const vt=new Float32Array($t*$e*4*_e),M0=new Vy(vt,$t,$e,_e);M0.type=Ts,M0.needsUpdate=!0;const V0=Mt*4;for(let x0=0;x0<_e;x0++){const Wt=bt[x0],an=rt[x0],W0=xt[x0],j0=$t*$e*4*x0;for(let un=0;un<Wt.count;un++){const bn=un*V0;Xe===!0&&(R.fromBufferAttribute(Wt,un),vt[j0+bn+0]=R.x,vt[j0+bn+1]=R.y,vt[j0+bn+2]=R.z,vt[j0+bn+3]=0),Be===!0&&(R.fromBufferAttribute(an,un),vt[j0+bn+4]=R.x,vt[j0+bn+5]=R.y,vt[j0+bn+6]=R.z,vt[j0+bn+7]=0),Ke===!0&&(R.fromBufferAttribute(W0,un),vt[j0+bn+8]=R.x,vt[j0+bn+9]=R.y,vt[j0+bn+10]=R.z,vt[j0+bn+11]=W0.itemSize===4?R.w:1)}}Re={count:_e,texture:M0,size:new vn($t,$e)},_.set(Q,Re),Q.addEventListener("dispose",Pt)}let be=0;for(let Xe=0;Xe<ue.length;Xe++)be+=ue[Xe];const ve=Q.morphTargetsRelative?1:1-be;xe.getUniforms().setValue(I,"morphTargetBaseInfluence",ve),xe.getUniforms().setValue(I,"morphTargetInfluences",ue),xe.getUniforms().setValue(I,"morphTargetsTexture",Re.texture,d),xe.getUniforms().setValue(I,"morphTargetsTextureSize",Re.size)}else{const ge=ue===void 0?0:ue.length;let _e=g[Q.id];if(_e===void 0||_e.length!==ge){_e=[];for(let Be=0;Be<ge;Be++)_e[Be]=[Be,0];g[Q.id]=_e}for(let Be=0;Be<ge;Be++){const Ke=_e[Be];Ke[0]=Be,Ke[1]=ue[Be]}_e.sort(GI);for(let Be=0;Be<8;Be++)Be<ge&&_e[Be][1]?(k[Be][0]=_e[Be][0],k[Be][1]=_e[Be][1]):(k[Be][0]=Number.MAX_SAFE_INTEGER,k[Be][1]=0);k.sort(UI);const Re=Q.morphAttributes.position,be=Q.morphAttributes.normal;let ve=0;for(let Be=0;Be<8;Be++){const Ke=k[Be],bt=Ke[0],rt=Ke[1];bt!==Number.MAX_SAFE_INTEGER&&rt?(Re&&Q.getAttribute("morphTarget"+Be)!==Re[bt]&&Q.setAttribute("morphTarget"+Be,Re[bt]),be&&Q.getAttribute("morphNormal"+Be)!==be[bt]&&Q.setAttribute("morphNormal"+Be,be[bt]),y[Be]=rt,ve+=rt):(Re&&Q.hasAttribute("morphTarget"+Be)===!0&&Q.deleteAttribute("morphTarget"+Be),be&&Q.hasAttribute("morphNormal"+Be)===!0&&Q.deleteAttribute("morphNormal"+Be),y[Be]=0)}const Xe=Q.morphTargetsRelative?1:1-ve;xe.getUniforms().setValue(I,"morphTargetBaseInfluence",Xe),xe.getUniforms().setValue(I,"morphTargetInfluences",y)}}return{update:X}}function jI(I,r,d,g){let y=new WeakMap;function _(X){const K=g.render.frame,Q=X.geometry,xe=r.get(X,Q);if(y.get(xe)!==K&&(r.update(xe),y.set(xe,K)),X.isInstancedMesh&&(X.hasEventListener("dispose",k)===!1&&X.addEventListener("dispose",k),y.get(X)!==K&&(d.update(X.instanceMatrix,I.ARRAY_BUFFER),X.instanceColor!==null&&d.update(X.instanceColor,I.ARRAY_BUFFER),y.set(X,K))),X.isSkinnedMesh){const ue=X.skeleton;y.get(ue)!==K&&(ue.update(),y.set(ue,K))}return xe}function R(){y=new WeakMap}function k(X){const K=X.target;K.removeEventListener("dispose",k),d.remove(K.instanceMatrix),K.instanceColor!==null&&d.remove(K.instanceColor)}return{update:_,dispose:R}}class __ extends Ks{constructor(r,d,g,y,_,R,k,X,K,Q){if(Q=Q!==void 0?Q:d2,Q!==d2&&Q!==B2)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");g===void 0&&Q===d2&&(g=jo),g===void 0&&Q===B2&&(g=u2),super(null,y,_,R,k,X,Q,g,K),this.isDepthTexture=!0,this.image={width:r,height:d},this.magFilter=k!==void 0?k:gi,this.minFilter=X!==void 0?X:gi,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(r){return super.copy(r),this.compareFunction=r.compareFunction,this}toJSON(r){const d=super.toJSON(r);return this.compareFunction!==null&&(d.compareFunction=this.compareFunction),d}}const w_=new Ks,S_=new __(1,1);S_.compareFunction=Rb;const T_=new Vy,E_=new Xb,A_=new $m,M_=[],C_=[],I_=new Float32Array(16),R_=new Float32Array(9),N_=new Float32Array(4);function vf(I,r,d){const g=I[0];if(g<=0||g>0)return I;const y=r*d;let _=M_[y];if(_===void 0&&(_=new Float32Array(y),M_[y]=_),r!==0){g.toArray(_,0);for(let R=1,k=0;R!==r;++R)k+=d,I[R].toArray(_,k)}return _}function da(I,r){if(I.length!==r.length)return!1;for(let d=0,g=I.length;d<g;d++)if(I[d]!==r[d])return!1;return!0}function ga(I,r){for(let d=0,g=r.length;d<g;d++)I[d]=r[d]}function xg(I,r){let d=C_[r];d===void 0&&(d=new Int32Array(r),C_[r]=d);for(let g=0;g!==r;++g)d[g]=I.allocateTextureUnit();return d}function KI(I,r){const d=this.cache;d[0]!==r&&(I.uniform1f(this.addr,r),d[0]=r)}function $I(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y)&&(I.uniform2f(this.addr,r.x,r.y),d[0]=r.x,d[1]=r.y);else{if(da(d,r))return;I.uniform2fv(this.addr,r),ga(d,r)}}function JI(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y||d[2]!==r.z)&&(I.uniform3f(this.addr,r.x,r.y,r.z),d[0]=r.x,d[1]=r.y,d[2]=r.z);else if(r.r!==void 0)(d[0]!==r.r||d[1]!==r.g||d[2]!==r.b)&&(I.uniform3f(this.addr,r.r,r.g,r.b),d[0]=r.r,d[1]=r.g,d[2]=r.b);else{if(da(d,r))return;I.uniform3fv(this.addr,r),ga(d,r)}}function WI(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y||d[2]!==r.z||d[3]!==r.w)&&(I.uniform4f(this.addr,r.x,r.y,r.z,r.w),d[0]=r.x,d[1]=r.y,d[2]=r.z,d[3]=r.w);else{if(da(d,r))return;I.uniform4fv(this.addr,r),ga(d,r)}}function QI(I,r){const d=this.cache,g=r.elements;if(g===void 0){if(da(d,r))return;I.uniformMatrix2fv(this.addr,!1,r),ga(d,r)}else{if(da(d,g))return;N_.set(g),I.uniformMatrix2fv(this.addr,!1,N_),ga(d,g)}}function eR(I,r){const d=this.cache,g=r.elements;if(g===void 0){if(da(d,r))return;I.uniformMatrix3fv(this.addr,!1,r),ga(d,r)}else{if(da(d,g))return;R_.set(g),I.uniformMatrix3fv(this.addr,!1,R_),ga(d,g)}}function xR(I,r){const d=this.cache,g=r.elements;if(g===void 0){if(da(d,r))return;I.uniformMatrix4fv(this.addr,!1,r),ga(d,r)}else{if(da(d,g))return;I_.set(g),I.uniformMatrix4fv(this.addr,!1,I_),ga(d,g)}}function rR(I,r){const d=this.cache;d[0]!==r&&(I.uniform1i(this.addr,r),d[0]=r)}function uR(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y)&&(I.uniform2i(this.addr,r.x,r.y),d[0]=r.x,d[1]=r.y);else{if(da(d,r))return;I.uniform2iv(this.addr,r),ga(d,r)}}function dR(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y||d[2]!==r.z)&&(I.uniform3i(this.addr,r.x,r.y,r.z),d[0]=r.x,d[1]=r.y,d[2]=r.z);else{if(da(d,r))return;I.uniform3iv(this.addr,r),ga(d,r)}}function gR(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y||d[2]!==r.z||d[3]!==r.w)&&(I.uniform4i(this.addr,r.x,r.y,r.z,r.w),d[0]=r.x,d[1]=r.y,d[2]=r.z,d[3]=r.w);else{if(da(d,r))return;I.uniform4iv(this.addr,r),ga(d,r)}}function vR(I,r){const d=this.cache;d[0]!==r&&(I.uniform1ui(this.addr,r),d[0]=r)}function bR(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y)&&(I.uniform2ui(this.addr,r.x,r.y),d[0]=r.x,d[1]=r.y);else{if(da(d,r))return;I.uniform2uiv(this.addr,r),ga(d,r)}}function _R(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y||d[2]!==r.z)&&(I.uniform3ui(this.addr,r.x,r.y,r.z),d[0]=r.x,d[1]=r.y,d[2]=r.z);else{if(da(d,r))return;I.uniform3uiv(this.addr,r),ga(d,r)}}function TR(I,r){const d=this.cache;if(r.x!==void 0)(d[0]!==r.x||d[1]!==r.y||d[2]!==r.z||d[3]!==r.w)&&(I.uniform4ui(this.addr,r.x,r.y,r.z,r.w),d[0]=r.x,d[1]=r.y,d[2]=r.z,d[3]=r.w);else{if(da(d,r))return;I.uniform4uiv(this.addr,r),ga(d,r)}}function AR(I,r,d){const g=this.cache,y=d.allocateTextureUnit();g[0]!==y&&(I.uniform1i(this.addr,y),g[0]=y);const _=this.type===I.SAMPLER_2D_SHADOW?S_:w_;d.setTexture2D(r||_,y)}function MR(I,r,d){const g=this.cache,y=d.allocateTextureUnit();g[0]!==y&&(I.uniform1i(this.addr,y),g[0]=y),d.setTexture3D(r||E_,y)}function CR(I,r,d){const g=this.cache,y=d.allocateTextureUnit();g[0]!==y&&(I.uniform1i(this.addr,y),g[0]=y),d.setTextureCube(r||A_,y)}function RR(I,r,d){const g=this.cache,y=d.allocateTextureUnit();g[0]!==y&&(I.uniform1i(this.addr,y),g[0]=y),d.setTexture2DArray(r||T_,y)}function NR(I){switch(I){case 5126:return KI;case 35664:return $I;case 35665:return JI;case 35666:return WI;case 35674:return QI;case 35675:return eR;case 35676:return xR;case 5124:case 35670:return rR;case 35667:case 35671:return uR;case 35668:case 35672:return dR;case 35669:case 35673:return gR;case 5125:return vR;case 36294:return bR;case 36295:return _R;case 36296:return TR;case 35678:case 36198:case 36298:case 36306:case 35682:return AR;case 35679:case 36299:case 36307:return MR;case 35680:case 36300:case 36308:case 36293:return CR;case 36289:case 36303:case 36311:case 36292:return RR}}function PR(I,r){I.uniform1fv(this.addr,r)}function BR(I,r){const d=vf(r,this.size,2);I.uniform2fv(this.addr,d)}function zR(I,r){const d=vf(r,this.size,3);I.uniform3fv(this.addr,d)}function VR(I,r){const d=vf(r,this.size,4);I.uniform4fv(this.addr,d)}function UR(I,r){const d=vf(r,this.size,4);I.uniformMatrix2fv(this.addr,!1,d)}function GR(I,r){const d=vf(r,this.size,9);I.uniformMatrix3fv(this.addr,!1,d)}function XR(I,r){const d=vf(r,this.size,16);I.uniformMatrix4fv(this.addr,!1,d)}function jR(I,r){I.uniform1iv(this.addr,r)}function KR(I,r){I.uniform2iv(this.addr,r)}function $R(I,r){I.uniform3iv(this.addr,r)}function JR(I,r){I.uniform4iv(this.addr,r)}function WR(I,r){I.uniform1uiv(this.addr,r)}function QR(I,r){I.uniform2uiv(this.addr,r)}function e4(I,r){I.uniform3uiv(this.addr,r)}function x4(I,r){I.uniform4uiv(this.addr,r)}function r4(I,r,d){const g=this.cache,y=r.length,_=xg(d,y);da(g,_)||(I.uniform1iv(this.addr,_),ga(g,_));for(let R=0;R!==y;++R)d.setTexture2D(r[R]||w_,_[R])}function u4(I,r,d){const g=this.cache,y=r.length,_=xg(d,y);da(g,_)||(I.uniform1iv(this.addr,_),ga(g,_));for(let R=0;R!==y;++R)d.setTexture3D(r[R]||E_,_[R])}function d4(I,r,d){const g=this.cache,y=r.length,_=xg(d,y);da(g,_)||(I.uniform1iv(this.addr,_),ga(g,_));for(let R=0;R!==y;++R)d.setTextureCube(r[R]||A_,_[R])}function g4(I,r,d){const g=this.cache,y=r.length,_=xg(d,y);da(g,_)||(I.uniform1iv(this.addr,_),ga(g,_));for(let R=0;R!==y;++R)d.setTexture2DArray(r[R]||T_,_[R])}function v4(I){switch(I){case 5126:return PR;case 35664:return BR;case 35665:return zR;case 35666:return VR;case 35674:return UR;case 35675:return GR;case 35676:return XR;case 5124:case 35670:return jR;case 35667:case 35671:return KR;case 35668:case 35672:return $R;case 35669:case 35673:return JR;case 5125:return WR;case 36294:return QR;case 36295:return e4;case 36296:return x4;case 35678:case 36198:case 36298:case 36306:case 35682:return r4;case 35679:case 36299:case 36307:return u4;case 35680:case 36300:case 36308:case 36293:return d4;case 36289:case 36303:case 36311:case 36292:return g4}}class b4{constructor(r,d,g){this.id=r,this.addr=g,this.cache=[],this.type=d.type,this.setValue=NR(d.type)}}class _4{constructor(r,d,g){this.id=r,this.addr=g,this.cache=[],this.type=d.type,this.size=d.size,this.setValue=v4(d.type)}}class T4{constructor(r){this.id=r,this.seq=[],this.map={}}setValue(r,d,g){const y=this.seq;for(let _=0,R=y.length;_!==R;++_){const k=y[_];k.setValue(r,d[k.id],g)}}}const C1=/(\w+)(\])?(\[|\.)?/g;function L_(I,r){I.seq.push(r),I.map[r.id]=r}function A4(I,r,d){const g=I.name,y=g.length;for(C1.lastIndex=0;;){const _=C1.exec(g),R=C1.lastIndex;let k=_[1];const X=_[2]==="]",K=_[3];if(X&&(k=k|0),K===void 0||K==="["&&R+2===y){L_(d,K===void 0?new b4(k,I,r):new _4(k,I,r));break}else{let xe=d.map[k];xe===void 0&&(xe=new T4(k),L_(d,xe)),d=xe}}}class rg{constructor(r,d){this.seq=[],this.map={};const g=r.getProgramParameter(d,r.ACTIVE_UNIFORMS);for(let y=0;y<g;++y){const _=r.getActiveUniform(d,y),R=r.getUniformLocation(d,_.name);A4(_,R,this)}}setValue(r,d,g,y){const _=this.map[d];_!==void 0&&_.setValue(r,g,y)}setOptional(r,d,g){const y=d[g];y!==void 0&&this.setValue(r,g,y)}static upload(r,d,g,y){for(let _=0,R=d.length;_!==R;++_){const k=d[_],X=g[k.id];X.needsUpdate!==!1&&k.setValue(r,X.value,y)}}static seqWithValue(r,d){const g=[];for(let y=0,_=r.length;y!==_;++y){const R=r[y];R.id in d&&g.push(R)}return g}}function P_(I,r,d){const g=I.createShader(r);return I.shaderSource(g,d),I.compileShader(g),g}const M4=37297;let C4=0;function R4(I,r){const d=I.split(`
`),g=[],y=Math.max(r-6,0),_=Math.min(r+6,d.length);for(let R=y;R<_;R++){const k=R+1;g.push(`${k===r?">":" "} ${k}: ${d[R]}`)}return g.join(`
`)}function N4(I){const r=Ci.getPrimaries(Ci.workingColorSpace),d=Ci.getPrimaries(I);let g;switch(r===d?g="":r===gn&&d===$i?g="LinearDisplayP3ToLinearSRGB":r===$i&&d===gn&&(g="LinearSRGBToLinearDisplayP3"),I){case vx:case Mi:return[g,"LinearTransferOETF"];case jn:case $r:return[g,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",I),[g,"LinearTransferOETF"]}}function O_(I,r,d){const g=I.getShaderParameter(r,I.COMPILE_STATUS),y=I.getShaderInfoLog(r).trim();if(g&&y==="")return"";const _=/ERROR: 0:(\d+)/.exec(y);if(_){const R=parseInt(_[1]);return d.toUpperCase()+`

`+y+`

`+R4(I.getShaderSource(r),R)}else return y}function P4(I,r){const d=N4(r);return`vec4 ${I}( vec4 value ) { return ${d[0]}( ${d[1]}( value ) ); }`}function B4(I,r){let d;switch(r){case Ju:d="Linear";break;case Xc:d="Reinhard";break;case jc:d="OptimizedCineon";break;case Wu:d="ACESFilmic";break;case eh:d="AgX";break;case Qu:d="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",r),d="Linear"}return"vec3 "+I+"( vec3 color ) { return "+d+"ToneMapping( color ); }"}function z4(I){return[I.extensionDerivatives||I.envMapCubeUVHeight||I.bumpMap||I.normalMapTangentSpace||I.clearcoatNormalMap||I.flatShading||I.alphaToCoverage||I.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(I.extensionFragDepth||I.logarithmicDepthBuffer)&&I.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",I.extensionDrawBuffers&&I.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(I.extensionShaderTextureLOD||I.envMap||I.transmission)&&I.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(bf).join(`
`)}function V4(I){return[I.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",I.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(bf).join(`
`)}function U4(I){const r=[];for(const d in I){const g=I[d];g!==!1&&r.push("#define "+d+" "+g)}return r.join(`
`)}function G4(I,r){const d={},g=I.getProgramParameter(r,I.ACTIVE_ATTRIBUTES);for(let y=0;y<g;y++){const _=I.getActiveAttrib(r,y),R=_.name;let k=1;_.type===I.FLOAT_MAT2&&(k=2),_.type===I.FLOAT_MAT3&&(k=3),_.type===I.FLOAT_MAT4&&(k=4),d[R]={type:_.type,location:I.getAttribLocation(r,R),locationSize:k}}return d}function bf(I){return I!==""}function D_(I,r){const d=r.numSpotLightShadows+r.numSpotLightMaps-r.numSpotLightShadowsWithMaps;return I.replace(/NUM_DIR_LIGHTS/g,r.numDirLights).replace(/NUM_SPOT_LIGHTS/g,r.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,r.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,d).replace(/NUM_RECT_AREA_LIGHTS/g,r.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,r.numPointLights).replace(/NUM_HEMI_LIGHTS/g,r.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,r.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,r.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,r.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,r.numPointLightShadows)}function k_(I,r){return I.replace(/NUM_CLIPPING_PLANES/g,r.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,r.numClippingPlanes-r.numClipIntersection)}const X4=/^[ \t]*#include +<([\w\d./]+)>/gm;function R1(I){return I.replace(X4,K4)}const j4=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function K4(I,r){let d=Gr[r];if(d===void 0){const g=j4.get(r);if(g!==void 0)d=Gr[g],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',r,g);else throw new Error("Can not resolve #include <"+r+">")}return R1(d)}const $4=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function F_(I){return I.replace($4,J4)}function J4(I,r,d,g){let y="";for(let _=parseInt(r);_<parseInt(d);_++)y+=g.replace(/\[\s*i\s*\]/g,"[ "+_+" ]").replace(/UNROLLED_LOOP_INDEX/g,_);return y}function B_(I){let r=`precision ${I.precision} float;
	precision ${I.precision} int;
	precision ${I.precision} sampler2D;
	precision ${I.precision} samplerCube;
	`;return I.isWebGL2&&(r+=`precision ${I.precision} sampler3D;
		precision ${I.precision} sampler2DArray;
		precision ${I.precision} sampler2DShadow;
		precision ${I.precision} samplerCubeShadow;
		precision ${I.precision} sampler2DArrayShadow;
		precision ${I.precision} isampler2D;
		precision ${I.precision} isampler3D;
		precision ${I.precision} isamplerCube;
		precision ${I.precision} isampler2DArray;
		precision ${I.precision} usampler2D;
		precision ${I.precision} usampler3D;
		precision ${I.precision} usamplerCube;
		precision ${I.precision} usampler2DArray;
		`),I.precision==="highp"?r+=`
#define HIGH_PRECISION`:I.precision==="mediump"?r+=`
#define MEDIUM_PRECISION`:I.precision==="lowp"&&(r+=`
#define LOW_PRECISION`),r}function W4(I){let r="SHADOWMAP_TYPE_BASIC";return I.shadowMapType===Js?r="SHADOWMAP_TYPE_PCF":I.shadowMapType===Pi?r="SHADOWMAP_TYPE_PCF_SOFT":I.shadowMapType===_a&&(r="SHADOWMAP_TYPE_VSM"),r}function Q4(I){let r="ENVMAP_TYPE_CUBE";if(I.envMap)switch(I.envMapMode){case _s:case e2:r="ENVMAP_TYPE_CUBE";break;case P2:r="ENVMAP_TYPE_CUBE_UV";break}return r}function eN(I){let r="ENVMAP_MODE_REFLECTION";if(I.envMap)switch(I.envMapMode){case e2:r="ENVMAP_MODE_REFRACTION";break}return r}function xN(I){let r="ENVMAP_BLENDING_NONE";if(I.envMap)switch(I.combine){case bc:r="ENVMAP_BLENDING_MULTIPLY";break;case Go:r="ENVMAP_BLENDING_MIX";break;case _o:r="ENVMAP_BLENDING_ADD";break}return r}function rN(I){const r=I.envMapCubeUVHeight;if(r===null)return null;const d=Math.log2(r)-2,g=1/r;return{texelWidth:1/(3*Math.max(Math.pow(2,d),7*16)),texelHeight:g,maxMip:d}}function uN(I,r,d,g){const y=I.getContext(),_=d.defines;let R=d.vertexShader,k=d.fragmentShader;const X=W4(d),K=Q4(d),Q=eN(d),xe=xN(d),ue=rN(d),ge=d.isWebGL2?"":z4(d),_e=V4(d),Re=U4(_),be=y.createProgram();let ve,Xe,Be=d.glslVersion?"#version "+d.glslVersion+`
`:"";d.isRawShaderMaterial?(ve=["#define SHADER_TYPE "+d.shaderType,"#define SHADER_NAME "+d.shaderName,Re].filter(bf).join(`
`),ve.length>0&&(ve+=`
`),Xe=[ge,"#define SHADER_TYPE "+d.shaderType,"#define SHADER_NAME "+d.shaderName,Re].filter(bf).join(`
`),Xe.length>0&&(Xe+=`
`)):(ve=[B_(d),"#define SHADER_TYPE "+d.shaderType,"#define SHADER_NAME "+d.shaderName,Re,d.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",d.batching?"#define USE_BATCHING":"",d.instancing?"#define USE_INSTANCING":"",d.instancingColor?"#define USE_INSTANCING_COLOR":"",d.useFog&&d.fog?"#define USE_FOG":"",d.useFog&&d.fogExp2?"#define FOG_EXP2":"",d.map?"#define USE_MAP":"",d.envMap?"#define USE_ENVMAP":"",d.envMap?"#define "+Q:"",d.lightMap?"#define USE_LIGHTMAP":"",d.aoMap?"#define USE_AOMAP":"",d.bumpMap?"#define USE_BUMPMAP":"",d.normalMap?"#define USE_NORMALMAP":"",d.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",d.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",d.displacementMap?"#define USE_DISPLACEMENTMAP":"",d.emissiveMap?"#define USE_EMISSIVEMAP":"",d.anisotropy?"#define USE_ANISOTROPY":"",d.anisotropyMap?"#define USE_ANISOTROPYMAP":"",d.clearcoatMap?"#define USE_CLEARCOATMAP":"",d.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",d.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",d.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",d.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",d.specularMap?"#define USE_SPECULARMAP":"",d.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",d.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",d.roughnessMap?"#define USE_ROUGHNESSMAP":"",d.metalnessMap?"#define USE_METALNESSMAP":"",d.alphaMap?"#define USE_ALPHAMAP":"",d.alphaHash?"#define USE_ALPHAHASH":"",d.transmission?"#define USE_TRANSMISSION":"",d.transmissionMap?"#define USE_TRANSMISSIONMAP":"",d.thicknessMap?"#define USE_THICKNESSMAP":"",d.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",d.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",d.mapUv?"#define MAP_UV "+d.mapUv:"",d.alphaMapUv?"#define ALPHAMAP_UV "+d.alphaMapUv:"",d.lightMapUv?"#define LIGHTMAP_UV "+d.lightMapUv:"",d.aoMapUv?"#define AOMAP_UV "+d.aoMapUv:"",d.emissiveMapUv?"#define EMISSIVEMAP_UV "+d.emissiveMapUv:"",d.bumpMapUv?"#define BUMPMAP_UV "+d.bumpMapUv:"",d.normalMapUv?"#define NORMALMAP_UV "+d.normalMapUv:"",d.displacementMapUv?"#define DISPLACEMENTMAP_UV "+d.displacementMapUv:"",d.metalnessMapUv?"#define METALNESSMAP_UV "+d.metalnessMapUv:"",d.roughnessMapUv?"#define ROUGHNESSMAP_UV "+d.roughnessMapUv:"",d.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+d.anisotropyMapUv:"",d.clearcoatMapUv?"#define CLEARCOATMAP_UV "+d.clearcoatMapUv:"",d.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+d.clearcoatNormalMapUv:"",d.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+d.clearcoatRoughnessMapUv:"",d.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+d.iridescenceMapUv:"",d.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+d.iridescenceThicknessMapUv:"",d.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+d.sheenColorMapUv:"",d.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+d.sheenRoughnessMapUv:"",d.specularMapUv?"#define SPECULARMAP_UV "+d.specularMapUv:"",d.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+d.specularColorMapUv:"",d.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+d.specularIntensityMapUv:"",d.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+d.transmissionMapUv:"",d.thicknessMapUv?"#define THICKNESSMAP_UV "+d.thicknessMapUv:"",d.vertexTangents&&d.flatShading===!1?"#define USE_TANGENT":"",d.vertexColors?"#define USE_COLOR":"",d.vertexAlphas?"#define USE_COLOR_ALPHA":"",d.vertexUv1s?"#define USE_UV1":"",d.vertexUv2s?"#define USE_UV2":"",d.vertexUv3s?"#define USE_UV3":"",d.pointsUvs?"#define USE_POINTS_UV":"",d.flatShading?"#define FLAT_SHADED":"",d.skinning?"#define USE_SKINNING":"",d.morphTargets?"#define USE_MORPHTARGETS":"",d.morphNormals&&d.flatShading===!1?"#define USE_MORPHNORMALS":"",d.morphColors&&d.isWebGL2?"#define USE_MORPHCOLORS":"",d.morphTargetsCount>0&&d.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",d.morphTargetsCount>0&&d.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+d.morphTextureStride:"",d.morphTargetsCount>0&&d.isWebGL2?"#define MORPHTARGETS_COUNT "+d.morphTargetsCount:"",d.doubleSided?"#define DOUBLE_SIDED":"",d.flipSided?"#define FLIP_SIDED":"",d.shadowMapEnabled?"#define USE_SHADOWMAP":"",d.shadowMapEnabled?"#define "+X:"",d.sizeAttenuation?"#define USE_SIZEATTENUATION":"",d.numLightProbes>0?"#define USE_LIGHT_PROBES":"",d.useLegacyLights?"#define LEGACY_LIGHTS":"",d.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",d.logarithmicDepthBuffer&&d.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(bf).join(`
`),Xe=[ge,B_(d),"#define SHADER_TYPE "+d.shaderType,"#define SHADER_NAME "+d.shaderName,Re,d.useFog&&d.fog?"#define USE_FOG":"",d.useFog&&d.fogExp2?"#define FOG_EXP2":"",d.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",d.map?"#define USE_MAP":"",d.matcap?"#define USE_MATCAP":"",d.envMap?"#define USE_ENVMAP":"",d.envMap?"#define "+K:"",d.envMap?"#define "+Q:"",d.envMap?"#define "+xe:"",ue?"#define CUBEUV_TEXEL_WIDTH "+ue.texelWidth:"",ue?"#define CUBEUV_TEXEL_HEIGHT "+ue.texelHeight:"",ue?"#define CUBEUV_MAX_MIP "+ue.maxMip+".0":"",d.lightMap?"#define USE_LIGHTMAP":"",d.aoMap?"#define USE_AOMAP":"",d.bumpMap?"#define USE_BUMPMAP":"",d.normalMap?"#define USE_NORMALMAP":"",d.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",d.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",d.emissiveMap?"#define USE_EMISSIVEMAP":"",d.anisotropy?"#define USE_ANISOTROPY":"",d.anisotropyMap?"#define USE_ANISOTROPYMAP":"",d.clearcoat?"#define USE_CLEARCOAT":"",d.clearcoatMap?"#define USE_CLEARCOATMAP":"",d.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",d.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",d.iridescence?"#define USE_IRIDESCENCE":"",d.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",d.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",d.specularMap?"#define USE_SPECULARMAP":"",d.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",d.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",d.roughnessMap?"#define USE_ROUGHNESSMAP":"",d.metalnessMap?"#define USE_METALNESSMAP":"",d.alphaMap?"#define USE_ALPHAMAP":"",d.alphaTest?"#define USE_ALPHATEST":"",d.alphaHash?"#define USE_ALPHAHASH":"",d.sheen?"#define USE_SHEEN":"",d.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",d.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",d.transmission?"#define USE_TRANSMISSION":"",d.transmissionMap?"#define USE_TRANSMISSIONMAP":"",d.thicknessMap?"#define USE_THICKNESSMAP":"",d.vertexTangents&&d.flatShading===!1?"#define USE_TANGENT":"",d.vertexColors||d.instancingColor?"#define USE_COLOR":"",d.vertexAlphas?"#define USE_COLOR_ALPHA":"",d.vertexUv1s?"#define USE_UV1":"",d.vertexUv2s?"#define USE_UV2":"",d.vertexUv3s?"#define USE_UV3":"",d.pointsUvs?"#define USE_POINTS_UV":"",d.gradientMap?"#define USE_GRADIENTMAP":"",d.flatShading?"#define FLAT_SHADED":"",d.doubleSided?"#define DOUBLE_SIDED":"",d.flipSided?"#define FLIP_SIDED":"",d.shadowMapEnabled?"#define USE_SHADOWMAP":"",d.shadowMapEnabled?"#define "+X:"",d.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",d.numLightProbes>0?"#define USE_LIGHT_PROBES":"",d.useLegacyLights?"#define LEGACY_LIGHTS":"",d.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",d.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",d.logarithmicDepthBuffer&&d.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",d.toneMapping!==Ma?"#define TONE_MAPPING":"",d.toneMapping!==Ma?Gr.tonemapping_pars_fragment:"",d.toneMapping!==Ma?B4("toneMapping",d.toneMapping):"",d.dithering?"#define DITHERING":"",d.opaque?"#define OPAQUE":"",Gr.colorspace_pars_fragment,P4("linearToOutputTexel",d.outputColorSpace),d.useDepthPacking?"#define DEPTH_PACKING "+d.depthPacking:"",`
`].filter(bf).join(`
`)),R=R1(R),R=D_(R,d),R=k_(R,d),k=R1(k),k=D_(k,d),k=k_(k,d),R=F_(R),k=F_(k),d.isWebGL2&&d.isRawShaderMaterial!==!0&&(Be=`#version 300 es
`,ve=[_e,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+ve,Xe=["precision mediump sampler2DArray;","#define varying in",d.glslVersion===Nb?"":"layout(location = 0) out highp vec4 pc_fragColor;",d.glslVersion===Nb?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+Xe);const Ke=Be+ve+R,bt=Be+Xe+k,rt=P_(y,y.VERTEX_SHADER,Ke),xt=P_(y,y.FRAGMENT_SHADER,bt);y.attachShader(be,rt),y.attachShader(be,xt),d.index0AttributeName!==void 0?y.bindAttribLocation(be,0,d.index0AttributeName):d.morphTargets===!0&&y.bindAttribLocation(be,0,"position"),y.linkProgram(be);function Mt(M0){if(I.debug.checkShaderErrors){const V0=y.getProgramInfoLog(be).trim(),Pt=y.getShaderInfoLog(rt).trim(),x0=y.getShaderInfoLog(xt).trim();let Wt=!0,an=!0;if(y.getProgramParameter(be,y.LINK_STATUS)===!1)if(Wt=!1,typeof I.debug.onShaderError=="function")I.debug.onShaderError(y,be,rt,xt);else{const W0=O_(y,rt,"vertex"),j0=O_(y,xt,"fragment");console.error("THREE.WebGLProgram: Shader Error "+y.getError()+" - VALIDATE_STATUS "+y.getProgramParameter(be,y.VALIDATE_STATUS)+`

Material Name: `+M0.name+`
Material Type: `+M0.type+`

Program Info Log: `+V0+`
`+W0+`
`+j0)}else V0!==""?console.warn("THREE.WebGLProgram: Program Info Log:",V0):(Pt===""||x0==="")&&(an=!1);an&&(M0.diagnostics={runnable:Wt,programLog:V0,vertexShader:{log:Pt,prefix:ve},fragmentShader:{log:x0,prefix:Xe}})}y.deleteShader(rt),y.deleteShader(xt),$t=new rg(y,be),$e=G4(y,be)}let $t;this.getUniforms=function(){return $t===void 0&&Mt(this),$t};let $e;this.getAttributes=function(){return $e===void 0&&Mt(this),$e};let vt=d.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return vt===!1&&(vt=y.getProgramParameter(be,M4)),vt},this.destroy=function(){g.releaseStatesOfProgram(this),y.deleteProgram(be),this.program=void 0},this.type=d.shaderType,this.name=d.shaderName,this.id=C4++,this.cacheKey=r,this.usedTimes=1,this.program=be,this.vertexShader=rt,this.fragmentShader=xt,this}let dN=0;class gN{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(r){const d=r.vertexShader,g=r.fragmentShader,y=this._getShaderStage(d),_=this._getShaderStage(g),R=this._getShaderCacheForMaterial(r);return R.has(y)===!1&&(R.add(y),y.usedTimes++),R.has(_)===!1&&(R.add(_),_.usedTimes++),this}remove(r){const d=this.materialCache.get(r);for(const g of d)g.usedTimes--,g.usedTimes===0&&this.shaderCache.delete(g.code);return this.materialCache.delete(r),this}getVertexShaderID(r){return this._getShaderStage(r.vertexShader).id}getFragmentShaderID(r){return this._getShaderStage(r.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(r){const d=this.materialCache;let g=d.get(r);return g===void 0&&(g=new Set,d.set(r,g)),g}_getShaderStage(r){const d=this.shaderCache;let g=d.get(r);return g===void 0&&(g=new vN(r),d.set(r,g)),g}}class vN{constructor(r){this.id=dN++,this.code=r,this.usedTimes=0}}function bN(I,r,d,g,y,_,R){const k=new Jy,X=new gN,K=new Set,Q=[],xe=y.isWebGL2,ue=y.logarithmicDepthBuffer,ge=y.vertexTextures;let _e=y.precision;const Re={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function be($e){return K.add($e),$e===0?"uv":`uv${$e}`}function ve($e,vt,M0,V0,Pt){const x0=V0.fog,Wt=Pt.geometry,an=$e.isMeshStandardMaterial?V0.environment:null,W0=($e.isMeshStandardMaterial?d:r).get($e.envMap||an),j0=W0&&W0.mapping===P2?W0.image.height:null,un=Re[$e.type];$e.precision!==null&&(_e=y.getMaxPrecision($e.precision),_e!==$e.precision&&console.warn("THREE.WebGLProgram.getParameters:",$e.precision,"not supported, using",_e,"instead."));const bn=Wt.morphAttributes.position||Wt.morphAttributes.normal||Wt.morphAttributes.color,ex=bn!==void 0?bn.length:0;let Cx=0;Wt.morphAttributes.position!==void 0&&(Cx=1),Wt.morphAttributes.normal!==void 0&&(Cx=2),Wt.morphAttributes.color!==void 0&&(Cx=3);let R0,_n,ux,Rx;if(un){const Ni=Qc[un];R0=Ni.vertexShader,_n=Ni.fragmentShader}else R0=$e.vertexShader,_n=$e.fragmentShader,X.update($e),ux=X.getVertexShaderID($e),Rx=X.getFragmentShaderID($e);const Bx=I.getRenderTarget(),Px=Pt.isInstancedMesh===!0,xr=Pt.isBatchedMesh===!0,Xx=!!$e.map,zt=!!$e.matcap,Kn=!!W0,en=!!$e.aoMap,Vn=!!$e.lightMap,rn=!!$e.bumpMap,jx=!!$e.normalMap,_x=!!$e.displacementMap,Tt=!!$e.emissiveMap,tt=!!$e.metalnessMap,g0=!!$e.roughnessMap,Cn=$e.anisotropy>0,Tn=$e.clearcoat>0,An=$e.iridescence>0,zx=$e.sheen>0,xx=$e.transmission>0,Ax=Cn&&!!$e.anisotropyMap,sr=Tn&&!!$e.clearcoatMap,Pr=Tn&&!!$e.clearcoatNormalMap,Mn=Tn&&!!$e.clearcoatRoughnessMap,di=An&&!!$e.iridescenceMap,jr=An&&!!$e.iridescenceThicknessMap,Tr=zx&&!!$e.sheenColorMap,Kx=zx&&!!$e.sheenRoughnessMap,Nx=!!$e.specularMap,Mr=!!$e.specularColorMap,_i=!!$e.specularIntensityMap,Ki=xx&&!!$e.transmissionMap,Jr=xx&&!!$e.thicknessMap,Ti=!!$e.gradientMap,Bt=!!$e.alphaMap,Gn=$e.alphaTest>0,Xn=!!$e.alphaHash,Vx=!!$e.extensions;let Qx=Ma;$e.toneMapped&&(Bx===null||Bx.isXRRenderTarget===!0)&&(Qx=I.toneMapping);const bi={isWebGL2:xe,shaderID:un,shaderType:$e.type,shaderName:$e.name,vertexShader:R0,fragmentShader:_n,defines:$e.defines,customVertexShaderID:ux,customFragmentShaderID:Rx,isRawShaderMaterial:$e.isRawShaderMaterial===!0,glslVersion:$e.glslVersion,precision:_e,batching:xr,instancing:Px,instancingColor:Px&&Pt.instanceColor!==null,supportsVertexTextures:ge,outputColorSpace:Bx===null?I.outputColorSpace:Bx.isXRRenderTarget===!0?Bx.texture.colorSpace:vx,alphaToCoverage:!!$e.alphaToCoverage,map:Xx,matcap:zt,envMap:Kn,envMapMode:Kn&&W0.mapping,envMapCubeUVHeight:j0,aoMap:en,lightMap:Vn,bumpMap:rn,normalMap:jx,displacementMap:ge&&_x,emissiveMap:Tt,normalMapObjectSpace:jx&&$e.normalMapType===rx,normalMapTangentSpace:jx&&$e.normalMapType===Rn,metalnessMap:tt,roughnessMap:g0,anisotropy:Cn,anisotropyMap:Ax,clearcoat:Tn,clearcoatMap:sr,clearcoatNormalMap:Pr,clearcoatRoughnessMap:Mn,iridescence:An,iridescenceMap:di,iridescenceThicknessMap:jr,sheen:zx,sheenColorMap:Tr,sheenRoughnessMap:Kx,specularMap:Nx,specularColorMap:Mr,specularIntensityMap:_i,transmission:xx,transmissionMap:Ki,thicknessMap:Jr,gradientMap:Ti,opaque:$e.transparent===!1&&$e.blending===Bi&&$e.alphaToCoverage===!1,alphaMap:Bt,alphaTest:Gn,alphaHash:Xn,combine:$e.combine,mapUv:Xx&&be($e.map.channel),aoMapUv:en&&be($e.aoMap.channel),lightMapUv:Vn&&be($e.lightMap.channel),bumpMapUv:rn&&be($e.bumpMap.channel),normalMapUv:jx&&be($e.normalMap.channel),displacementMapUv:_x&&be($e.displacementMap.channel),emissiveMapUv:Tt&&be($e.emissiveMap.channel),metalnessMapUv:tt&&be($e.metalnessMap.channel),roughnessMapUv:g0&&be($e.roughnessMap.channel),anisotropyMapUv:Ax&&be($e.anisotropyMap.channel),clearcoatMapUv:sr&&be($e.clearcoatMap.channel),clearcoatNormalMapUv:Pr&&be($e.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Mn&&be($e.clearcoatRoughnessMap.channel),iridescenceMapUv:di&&be($e.iridescenceMap.channel),iridescenceThicknessMapUv:jr&&be($e.iridescenceThicknessMap.channel),sheenColorMapUv:Tr&&be($e.sheenColorMap.channel),sheenRoughnessMapUv:Kx&&be($e.sheenRoughnessMap.channel),specularMapUv:Nx&&be($e.specularMap.channel),specularColorMapUv:Mr&&be($e.specularColorMap.channel),specularIntensityMapUv:_i&&be($e.specularIntensityMap.channel),transmissionMapUv:Ki&&be($e.transmissionMap.channel),thicknessMapUv:Jr&&be($e.thicknessMap.channel),alphaMapUv:Bt&&be($e.alphaMap.channel),vertexTangents:!!Wt.attributes.tangent&&(jx||Cn),vertexColors:$e.vertexColors,vertexAlphas:$e.vertexColors===!0&&!!Wt.attributes.color&&Wt.attributes.color.itemSize===4,pointsUvs:Pt.isPoints===!0&&!!Wt.attributes.uv&&(Xx||Bt),fog:!!x0,useFog:$e.fog===!0,fogExp2:!!x0&&x0.isFogExp2,flatShading:$e.flatShading===!0,sizeAttenuation:$e.sizeAttenuation===!0,logarithmicDepthBuffer:ue,skinning:Pt.isSkinnedMesh===!0,morphTargets:Wt.morphAttributes.position!==void 0,morphNormals:Wt.morphAttributes.normal!==void 0,morphColors:Wt.morphAttributes.color!==void 0,morphTargetsCount:ex,morphTextureStride:Cx,numDirLights:vt.directional.length,numPointLights:vt.point.length,numSpotLights:vt.spot.length,numSpotLightMaps:vt.spotLightMap.length,numRectAreaLights:vt.rectArea.length,numHemiLights:vt.hemi.length,numDirLightShadows:vt.directionalShadowMap.length,numPointLightShadows:vt.pointShadowMap.length,numSpotLightShadows:vt.spotShadowMap.length,numSpotLightShadowsWithMaps:vt.numSpotLightShadowsWithMaps,numLightProbes:vt.numLightProbes,numClippingPlanes:R.numPlanes,numClipIntersection:R.numIntersection,dithering:$e.dithering,shadowMapEnabled:I.shadowMap.enabled&&M0.length>0,shadowMapType:I.shadowMap.type,toneMapping:Qx,useLegacyLights:I._useLegacyLights,decodeVideoTexture:Xx&&$e.map.isVideoTexture===!0&&Ci.getTransfer($e.map.colorSpace)===dr,premultipliedAlpha:$e.premultipliedAlpha,doubleSided:$e.side===Ba,flipSided:$e.side===vs,useDepthPacking:$e.depthPacking>=0,depthPacking:$e.depthPacking||0,index0AttributeName:$e.index0AttributeName,extensionDerivatives:Vx&&$e.extensions.derivatives===!0,extensionFragDepth:Vx&&$e.extensions.fragDepth===!0,extensionDrawBuffers:Vx&&$e.extensions.drawBuffers===!0,extensionShaderTextureLOD:Vx&&$e.extensions.shaderTextureLOD===!0,extensionClipCullDistance:Vx&&$e.extensions.clipCullDistance===!0&&g.has("WEBGL_clip_cull_distance"),extensionMultiDraw:Vx&&$e.extensions.multiDraw===!0&&g.has("WEBGL_multi_draw"),rendererExtensionFragDepth:xe||g.has("EXT_frag_depth"),rendererExtensionDrawBuffers:xe||g.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:xe||g.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:g.has("KHR_parallel_shader_compile"),customProgramCacheKey:$e.customProgramCacheKey()};return bi.vertexUv1s=K.has(1),bi.vertexUv2s=K.has(2),bi.vertexUv3s=K.has(3),K.clear(),bi}function Xe($e){const vt=[];if($e.shaderID?vt.push($e.shaderID):(vt.push($e.customVertexShaderID),vt.push($e.customFragmentShaderID)),$e.defines!==void 0)for(const M0 in $e.defines)vt.push(M0),vt.push($e.defines[M0]);return $e.isRawShaderMaterial===!1&&(Be(vt,$e),Ke(vt,$e),vt.push(I.outputColorSpace)),vt.push($e.customProgramCacheKey),vt.join()}function Be($e,vt){$e.push(vt.precision),$e.push(vt.outputColorSpace),$e.push(vt.envMapMode),$e.push(vt.envMapCubeUVHeight),$e.push(vt.mapUv),$e.push(vt.alphaMapUv),$e.push(vt.lightMapUv),$e.push(vt.aoMapUv),$e.push(vt.bumpMapUv),$e.push(vt.normalMapUv),$e.push(vt.displacementMapUv),$e.push(vt.emissiveMapUv),$e.push(vt.metalnessMapUv),$e.push(vt.roughnessMapUv),$e.push(vt.anisotropyMapUv),$e.push(vt.clearcoatMapUv),$e.push(vt.clearcoatNormalMapUv),$e.push(vt.clearcoatRoughnessMapUv),$e.push(vt.iridescenceMapUv),$e.push(vt.iridescenceThicknessMapUv),$e.push(vt.sheenColorMapUv),$e.push(vt.sheenRoughnessMapUv),$e.push(vt.specularMapUv),$e.push(vt.specularColorMapUv),$e.push(vt.specularIntensityMapUv),$e.push(vt.transmissionMapUv),$e.push(vt.thicknessMapUv),$e.push(vt.combine),$e.push(vt.fogExp2),$e.push(vt.sizeAttenuation),$e.push(vt.morphTargetsCount),$e.push(vt.morphAttributeCount),$e.push(vt.numDirLights),$e.push(vt.numPointLights),$e.push(vt.numSpotLights),$e.push(vt.numSpotLightMaps),$e.push(vt.numHemiLights),$e.push(vt.numRectAreaLights),$e.push(vt.numDirLightShadows),$e.push(vt.numPointLightShadows),$e.push(vt.numSpotLightShadows),$e.push(vt.numSpotLightShadowsWithMaps),$e.push(vt.numLightProbes),$e.push(vt.shadowMapType),$e.push(vt.toneMapping),$e.push(vt.numClippingPlanes),$e.push(vt.numClipIntersection),$e.push(vt.depthPacking)}function Ke($e,vt){k.disableAll(),vt.isWebGL2&&k.enable(0),vt.supportsVertexTextures&&k.enable(1),vt.instancing&&k.enable(2),vt.instancingColor&&k.enable(3),vt.matcap&&k.enable(4),vt.envMap&&k.enable(5),vt.normalMapObjectSpace&&k.enable(6),vt.normalMapTangentSpace&&k.enable(7),vt.clearcoat&&k.enable(8),vt.iridescence&&k.enable(9),vt.alphaTest&&k.enable(10),vt.vertexColors&&k.enable(11),vt.vertexAlphas&&k.enable(12),vt.vertexUv1s&&k.enable(13),vt.vertexUv2s&&k.enable(14),vt.vertexUv3s&&k.enable(15),vt.vertexTangents&&k.enable(16),vt.anisotropy&&k.enable(17),vt.alphaHash&&k.enable(18),vt.batching&&k.enable(19),$e.push(k.mask),k.disableAll(),vt.fog&&k.enable(0),vt.useFog&&k.enable(1),vt.flatShading&&k.enable(2),vt.logarithmicDepthBuffer&&k.enable(3),vt.skinning&&k.enable(4),vt.morphTargets&&k.enable(5),vt.morphNormals&&k.enable(6),vt.morphColors&&k.enable(7),vt.premultipliedAlpha&&k.enable(8),vt.shadowMapEnabled&&k.enable(9),vt.useLegacyLights&&k.enable(10),vt.doubleSided&&k.enable(11),vt.flipSided&&k.enable(12),vt.useDepthPacking&&k.enable(13),vt.dithering&&k.enable(14),vt.transmission&&k.enable(15),vt.sheen&&k.enable(16),vt.opaque&&k.enable(17),vt.pointsUvs&&k.enable(18),vt.decodeVideoTexture&&k.enable(19),vt.alphaToCoverage&&k.enable(20),$e.push(k.mask)}function bt($e){const vt=Re[$e.type];let M0;if(vt){const V0=Qc[vt];M0=uA.clone(V0.uniforms)}else M0=$e.uniforms;return M0}function rt($e,vt){let M0;for(let V0=0,Pt=Q.length;V0<Pt;V0++){const x0=Q[V0];if(x0.cacheKey===vt){M0=x0,++M0.usedTimes;break}}return M0===void 0&&(M0=new uN(I,vt,$e,_),Q.push(M0)),M0}function xt($e){if(--$e.usedTimes===0){const vt=Q.indexOf($e);Q[vt]=Q[Q.length-1],Q.pop(),$e.destroy()}}function Mt($e){X.remove($e)}function $t(){X.dispose()}return{getParameters:ve,getProgramCacheKey:Xe,getUniforms:bt,acquireProgram:rt,releaseProgram:xt,releaseShaderCache:Mt,programs:Q,dispose:$t}}function _N(){let I=new WeakMap;function r(_){let R=I.get(_);return R===void 0&&(R={},I.set(_,R)),R}function d(_){I.delete(_)}function g(_,R,k){I.get(_)[R]=k}function y(){I=new WeakMap}return{get:r,remove:d,update:g,dispose:y}}function TN(I,r){return I.groupOrder!==r.groupOrder?I.groupOrder-r.groupOrder:I.renderOrder!==r.renderOrder?I.renderOrder-r.renderOrder:I.material.id!==r.material.id?I.material.id-r.material.id:I.z!==r.z?I.z-r.z:I.id-r.id}function z_(I,r){return I.groupOrder!==r.groupOrder?I.groupOrder-r.groupOrder:I.renderOrder!==r.renderOrder?I.renderOrder-r.renderOrder:I.z!==r.z?r.z-I.z:I.id-r.id}function H_(){const I=[];let r=0;const d=[],g=[],y=[];function _(){r=0,d.length=0,g.length=0,y.length=0}function R(xe,ue,ge,_e,Re,be){let ve=I[r];return ve===void 0?(ve={id:xe.id,object:xe,geometry:ue,material:ge,groupOrder:_e,renderOrder:xe.renderOrder,z:Re,group:be},I[r]=ve):(ve.id=xe.id,ve.object=xe,ve.geometry=ue,ve.material=ge,ve.groupOrder=_e,ve.renderOrder=xe.renderOrder,ve.z=Re,ve.group=be),r++,ve}function k(xe,ue,ge,_e,Re,be){const ve=R(xe,ue,ge,_e,Re,be);ge.transmission>0?g.push(ve):ge.transparent===!0?y.push(ve):d.push(ve)}function X(xe,ue,ge,_e,Re,be){const ve=R(xe,ue,ge,_e,Re,be);ge.transmission>0?g.unshift(ve):ge.transparent===!0?y.unshift(ve):d.unshift(ve)}function K(xe,ue){d.length>1&&d.sort(xe||TN),g.length>1&&g.sort(ue||z_),y.length>1&&y.sort(ue||z_)}function Q(){for(let xe=r,ue=I.length;xe<ue;xe++){const ge=I[xe];if(ge.id===null)break;ge.id=null,ge.object=null,ge.geometry=null,ge.material=null,ge.group=null}}return{opaque:d,transmissive:g,transparent:y,init:_,push:k,unshift:X,finish:Q,sort:K}}function AN(){let I=new WeakMap;function r(g,y){const _=I.get(g);let R;return _===void 0?(R=new H_,I.set(g,[R])):y>=_.length?(R=new H_,_.push(R)):R=_[y],R}function d(){I=new WeakMap}return{get:r,dispose:d}}function MN(){const I={};return{get:function(r){if(I[r.id]!==void 0)return I[r.id];let d;switch(r.type){case"DirectionalLight":d={direction:new ut,color:new bx};break;case"SpotLight":d={position:new ut,direction:new ut,color:new bx,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":d={position:new ut,color:new bx,distance:0,decay:0};break;case"HemisphereLight":d={direction:new ut,skyColor:new bx,groundColor:new bx};break;case"RectAreaLight":d={color:new bx,position:new ut,halfWidth:new ut,halfHeight:new ut};break}return I[r.id]=d,d}}}function CN(){const I={};return{get:function(r){if(I[r.id]!==void 0)return I[r.id];let d;switch(r.type){case"DirectionalLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new vn};break;case"SpotLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new vn};break;case"PointLight":d={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new vn,shadowCameraNear:1,shadowCameraFar:1e3};break}return I[r.id]=d,d}}}let RN=0;function NN(I,r){return(r.castShadow?2:0)-(I.castShadow?2:0)+(r.map?1:0)-(I.map?1:0)}function PN(I,r){const d=new MN,g=CN(),y={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let Q=0;Q<9;Q++)y.probe.push(new ut);const _=new ut,R=new ur,k=new ur;function X(Q,xe){let ue=0,ge=0,_e=0;for(let M0=0;M0<9;M0++)y.probe[M0].set(0,0,0);let Re=0,be=0,ve=0,Xe=0,Be=0,Ke=0,bt=0,rt=0,xt=0,Mt=0,$t=0;Q.sort(NN);const $e=xe===!0?Math.PI:1;for(let M0=0,V0=Q.length;M0<V0;M0++){const Pt=Q[M0],x0=Pt.color,Wt=Pt.intensity,an=Pt.distance,W0=Pt.shadow&&Pt.shadow.map?Pt.shadow.map.texture:null;if(Pt.isAmbientLight)ue+=x0.r*Wt*$e,ge+=x0.g*Wt*$e,_e+=x0.b*Wt*$e;else if(Pt.isLightProbe){for(let j0=0;j0<9;j0++)y.probe[j0].addScaledVector(Pt.sh.coefficients[j0],Wt);$t++}else if(Pt.isDirectionalLight){const j0=d.get(Pt);if(j0.color.copy(Pt.color).multiplyScalar(Pt.intensity*$e),Pt.castShadow){const un=Pt.shadow,bn=g.get(Pt);bn.shadowBias=un.bias,bn.shadowNormalBias=un.normalBias,bn.shadowRadius=un.radius,bn.shadowMapSize=un.mapSize,y.directionalShadow[Re]=bn,y.directionalShadowMap[Re]=W0,y.directionalShadowMatrix[Re]=Pt.shadow.matrix,Ke++}y.directional[Re]=j0,Re++}else if(Pt.isSpotLight){const j0=d.get(Pt);j0.position.setFromMatrixPosition(Pt.matrixWorld),j0.color.copy(x0).multiplyScalar(Wt*$e),j0.distance=an,j0.coneCos=Math.cos(Pt.angle),j0.penumbraCos=Math.cos(Pt.angle*(1-Pt.penumbra)),j0.decay=Pt.decay,y.spot[ve]=j0;const un=Pt.shadow;if(Pt.map&&(y.spotLightMap[xt]=Pt.map,xt++,un.updateMatrices(Pt),Pt.castShadow&&Mt++),y.spotLightMatrix[ve]=un.matrix,Pt.castShadow){const bn=g.get(Pt);bn.shadowBias=un.bias,bn.shadowNormalBias=un.normalBias,bn.shadowRadius=un.radius,bn.shadowMapSize=un.mapSize,y.spotShadow[ve]=bn,y.spotShadowMap[ve]=W0,rt++}ve++}else if(Pt.isRectAreaLight){const j0=d.get(Pt);j0.color.copy(x0).multiplyScalar(Wt),j0.halfWidth.set(Pt.width*.5,0,0),j0.halfHeight.set(0,Pt.height*.5,0),y.rectArea[Xe]=j0,Xe++}else if(Pt.isPointLight){const j0=d.get(Pt);if(j0.color.copy(Pt.color).multiplyScalar(Pt.intensity*$e),j0.distance=Pt.distance,j0.decay=Pt.decay,Pt.castShadow){const un=Pt.shadow,bn=g.get(Pt);bn.shadowBias=un.bias,bn.shadowNormalBias=un.normalBias,bn.shadowRadius=un.radius,bn.shadowMapSize=un.mapSize,bn.shadowCameraNear=un.camera.near,bn.shadowCameraFar=un.camera.far,y.pointShadow[be]=bn,y.pointShadowMap[be]=W0,y.pointShadowMatrix[be]=Pt.shadow.matrix,bt++}y.point[be]=j0,be++}else if(Pt.isHemisphereLight){const j0=d.get(Pt);j0.skyColor.copy(Pt.color).multiplyScalar(Wt*$e),j0.groundColor.copy(Pt.groundColor).multiplyScalar(Wt*$e),y.hemi[Be]=j0,Be++}}Xe>0&&(r.isWebGL2?I.has("OES_texture_float_linear")===!0?(y.rectAreaLTC1=Qn.LTC_FLOAT_1,y.rectAreaLTC2=Qn.LTC_FLOAT_2):(y.rectAreaLTC1=Qn.LTC_HALF_1,y.rectAreaLTC2=Qn.LTC_HALF_2):I.has("OES_texture_float_linear")===!0?(y.rectAreaLTC1=Qn.LTC_FLOAT_1,y.rectAreaLTC2=Qn.LTC_FLOAT_2):I.has("OES_texture_half_float_linear")===!0?(y.rectAreaLTC1=Qn.LTC_HALF_1,y.rectAreaLTC2=Qn.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),y.ambient[0]=ue,y.ambient[1]=ge,y.ambient[2]=_e;const vt=y.hash;(vt.directionalLength!==Re||vt.pointLength!==be||vt.spotLength!==ve||vt.rectAreaLength!==Xe||vt.hemiLength!==Be||vt.numDirectionalShadows!==Ke||vt.numPointShadows!==bt||vt.numSpotShadows!==rt||vt.numSpotMaps!==xt||vt.numLightProbes!==$t)&&(y.directional.length=Re,y.spot.length=ve,y.rectArea.length=Xe,y.point.length=be,y.hemi.length=Be,y.directionalShadow.length=Ke,y.directionalShadowMap.length=Ke,y.pointShadow.length=bt,y.pointShadowMap.length=bt,y.spotShadow.length=rt,y.spotShadowMap.length=rt,y.directionalShadowMatrix.length=Ke,y.pointShadowMatrix.length=bt,y.spotLightMatrix.length=rt+xt-Mt,y.spotLightMap.length=xt,y.numSpotLightShadowsWithMaps=Mt,y.numLightProbes=$t,vt.directionalLength=Re,vt.pointLength=be,vt.spotLength=ve,vt.rectAreaLength=Xe,vt.hemiLength=Be,vt.numDirectionalShadows=Ke,vt.numPointShadows=bt,vt.numSpotShadows=rt,vt.numSpotMaps=xt,vt.numLightProbes=$t,y.version=RN++)}function K(Q,xe){let ue=0,ge=0,_e=0,Re=0,be=0;const ve=xe.matrixWorldInverse;for(let Xe=0,Be=Q.length;Xe<Be;Xe++){const Ke=Q[Xe];if(Ke.isDirectionalLight){const bt=y.directional[ue];bt.direction.setFromMatrixPosition(Ke.matrixWorld),_.setFromMatrixPosition(Ke.target.matrixWorld),bt.direction.sub(_),bt.direction.transformDirection(ve),ue++}else if(Ke.isSpotLight){const bt=y.spot[_e];bt.position.setFromMatrixPosition(Ke.matrixWorld),bt.position.applyMatrix4(ve),bt.direction.setFromMatrixPosition(Ke.matrixWorld),_.setFromMatrixPosition(Ke.target.matrixWorld),bt.direction.sub(_),bt.direction.transformDirection(ve),_e++}else if(Ke.isRectAreaLight){const bt=y.rectArea[Re];bt.position.setFromMatrixPosition(Ke.matrixWorld),bt.position.applyMatrix4(ve),k.identity(),R.copy(Ke.matrixWorld),R.premultiply(ve),k.extractRotation(R),bt.halfWidth.set(Ke.width*.5,0,0),bt.halfHeight.set(0,Ke.height*.5,0),bt.halfWidth.applyMatrix4(k),bt.halfHeight.applyMatrix4(k),Re++}else if(Ke.isPointLight){const bt=y.point[ge];bt.position.setFromMatrixPosition(Ke.matrixWorld),bt.position.applyMatrix4(ve),ge++}else if(Ke.isHemisphereLight){const bt=y.hemi[be];bt.direction.setFromMatrixPosition(Ke.matrixWorld),bt.direction.transformDirection(ve),be++}}}return{setup:X,setupView:K,state:y}}function V_(I,r){const d=new PN(I,r),g=[],y=[];function _(){g.length=0,y.length=0}function R(xe){g.push(xe)}function k(xe){y.push(xe)}function X(xe){d.setup(g,xe)}function K(xe){d.setupView(g,xe)}return{init:_,state:{lightsArray:g,shadowsArray:y,lights:d},setupLights:X,setupLightsView:K,pushLight:R,pushShadow:k}}function BN(I,r){let d=new WeakMap;function g(_,R=0){const k=d.get(_);let X;return k===void 0?(X=new V_(I,r),d.set(_,[X])):R>=k.length?(X=new V_(I,r),k.push(X)):X=k[R],X}function y(){d=new WeakMap}return{get:g,dispose:y}}class U_ extends T2{constructor(r){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=K0,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(r)}copy(r){return super.copy(r),this.depthPacking=r.depthPacking,this.map=r.map,this.alphaMap=r.alphaMap,this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this}}class G_ extends T2{constructor(r){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(r)}copy(r){return super.copy(r),this.map=r.map,this.alphaMap=r.alphaMap,this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this}}const zN=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,VN=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function UN(I,r,d){let g=new Wm;const y=new vn,_=new vn,R=new Vi,k=new U_({depthPacking:C0}),X=new G_,K={},Q=d.maxTextureSize,xe={[Ta]:vs,[vs]:Ta,[Ba]:Ba},ue=new Xl({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new vn},radius:{value:4}},vertexShader:zN,fragmentShader:VN}),ge=ue.clone();ge.defines.HORIZONTAL_PASS=1;const _e=new Ur;_e.setAttribute("position",new rs(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const Re=new Bs(_e,ue),be=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Js;let ve=this.type;this.render=function(rt,xt,Mt){if(be.enabled===!1||be.autoUpdate===!1&&be.needsUpdate===!1||rt.length===0)return;const $t=I.getRenderTarget(),$e=I.getActiveCubeFace(),vt=I.getActiveMipmapLevel(),M0=I.state;M0.setBlending(Aa),M0.buffers.color.setClear(1,1,1,1),M0.buffers.depth.setTest(!0),M0.setScissorTest(!1);const V0=ve!==_a&&this.type===_a,Pt=ve===_a&&this.type!==_a;for(let x0=0,Wt=rt.length;x0<Wt;x0++){const an=rt[x0],W0=an.shadow;if(W0===void 0){console.warn("THREE.WebGLShadowMap:",an,"has no shadow.");continue}if(W0.autoUpdate===!1&&W0.needsUpdate===!1)continue;y.copy(W0.mapSize);const j0=W0.getFrameExtents();if(y.multiply(j0),_.copy(W0.mapSize),(y.x>Q||y.y>Q)&&(y.x>Q&&(_.x=Math.floor(Q/j0.x),y.x=_.x*j0.x,W0.mapSize.x=_.x),y.y>Q&&(_.y=Math.floor(Q/j0.y),y.y=_.y*j0.y,W0.mapSize.y=_.y)),W0.map===null||V0===!0||Pt===!0){const bn=this.type!==_a?{minFilter:gi,magFilter:gi}:{};W0.map!==null&&W0.map.dispose(),W0.map=new Th(y.x,y.y,bn),W0.map.texture.name=an.name+".shadowMap",W0.camera.updateProjectionMatrix()}I.setRenderTarget(W0.map),I.clear();const un=W0.getViewportCount();for(let bn=0;bn<un;bn++){const ex=W0.getViewport(bn);R.set(_.x*ex.x,_.y*ex.y,_.x*ex.z,_.y*ex.w),M0.viewport(R),W0.updateMatrices(an,bn),g=W0.getFrustum(),Ke(xt,Mt,W0.camera,an,this.type)}W0.isPointLightShadow!==!0&&this.type===_a&&Xe(W0,Mt),W0.needsUpdate=!1}ve=this.type,be.needsUpdate=!1,I.setRenderTarget($t,$e,vt)};function Xe(rt,xt){const Mt=r.update(Re);ue.defines.VSM_SAMPLES!==rt.blurSamples&&(ue.defines.VSM_SAMPLES=rt.blurSamples,ge.defines.VSM_SAMPLES=rt.blurSamples,ue.needsUpdate=!0,ge.needsUpdate=!0),rt.mapPass===null&&(rt.mapPass=new Th(y.x,y.y)),ue.uniforms.shadow_pass.value=rt.map.texture,ue.uniforms.resolution.value=rt.mapSize,ue.uniforms.radius.value=rt.radius,I.setRenderTarget(rt.mapPass),I.clear(),I.renderBufferDirect(xt,null,Mt,ue,Re,null),ge.uniforms.shadow_pass.value=rt.mapPass.texture,ge.uniforms.resolution.value=rt.mapSize,ge.uniforms.radius.value=rt.radius,I.setRenderTarget(rt.map),I.clear(),I.renderBufferDirect(xt,null,Mt,ge,Re,null)}function Be(rt,xt,Mt,$t){let $e=null;const vt=Mt.isPointLight===!0?rt.customDistanceMaterial:rt.customDepthMaterial;if(vt!==void 0)$e=vt;else if($e=Mt.isPointLight===!0?X:k,I.localClippingEnabled&&xt.clipShadows===!0&&Array.isArray(xt.clippingPlanes)&&xt.clippingPlanes.length!==0||xt.displacementMap&&xt.displacementScale!==0||xt.alphaMap&&xt.alphaTest>0||xt.map&&xt.alphaTest>0){const M0=$e.uuid,V0=xt.uuid;let Pt=K[M0];Pt===void 0&&(Pt={},K[M0]=Pt);let x0=Pt[V0];x0===void 0&&(x0=$e.clone(),Pt[V0]=x0,xt.addEventListener("dispose",bt)),$e=x0}if($e.visible=xt.visible,$e.wireframe=xt.wireframe,$t===_a?$e.side=xt.shadowSide!==null?xt.shadowSide:xt.side:$e.side=xt.shadowSide!==null?xt.shadowSide:xe[xt.side],$e.alphaMap=xt.alphaMap,$e.alphaTest=xt.alphaTest,$e.map=xt.map,$e.clipShadows=xt.clipShadows,$e.clippingPlanes=xt.clippingPlanes,$e.clipIntersection=xt.clipIntersection,$e.displacementMap=xt.displacementMap,$e.displacementScale=xt.displacementScale,$e.displacementBias=xt.displacementBias,$e.wireframeLinewidth=xt.wireframeLinewidth,$e.linewidth=xt.linewidth,Mt.isPointLight===!0&&$e.isMeshDistanceMaterial===!0){const M0=I.properties.get($e);M0.light=Mt}return $e}function Ke(rt,xt,Mt,$t,$e){if(rt.visible===!1)return;if(rt.layers.test(xt.layers)&&(rt.isMesh||rt.isLine||rt.isPoints)&&(rt.castShadow||rt.receiveShadow&&$e===_a)&&(!rt.frustumCulled||g.intersectsObject(rt))){rt.modelViewMatrix.multiplyMatrices(Mt.matrixWorldInverse,rt.matrixWorld);const V0=r.update(rt),Pt=rt.material;if(Array.isArray(Pt)){const x0=V0.groups;for(let Wt=0,an=x0.length;Wt<an;Wt++){const W0=x0[Wt],j0=Pt[W0.materialIndex];if(j0&&j0.visible){const un=Be(rt,j0,$t,$e);rt.onBeforeShadow(I,rt,xt,Mt,V0,un,W0),I.renderBufferDirect(Mt,null,V0,un,rt,W0),rt.onAfterShadow(I,rt,xt,Mt,V0,un,W0)}}}else if(Pt.visible){const x0=Be(rt,Pt,$t,$e);rt.onBeforeShadow(I,rt,xt,Mt,V0,x0,null),I.renderBufferDirect(Mt,null,V0,x0,rt,null),rt.onAfterShadow(I,rt,xt,Mt,V0,x0,null)}}const M0=rt.children;for(let V0=0,Pt=M0.length;V0<Pt;V0++)Ke(M0[V0],xt,Mt,$t,$e)}function bt(rt){rt.target.removeEventListener("dispose",bt);for(const Mt in K){const $t=K[Mt],$e=rt.target.uuid;$e in $t&&($t[$e].dispose(),delete $t[$e])}}}function GN(I,r,d){const g=d.isWebGL2;function y(){let Bt=!1;const Gn=new Vi;let Xn=null;const Vx=new Vi(0,0,0,0);return{setMask:function(Qx){Xn!==Qx&&!Bt&&(I.colorMask(Qx,Qx,Qx,Qx),Xn=Qx)},setLocked:function(Qx){Bt=Qx},setClear:function(Qx,bi,Ni,va,Jo){Jo===!0&&(Qx*=va,bi*=va,Ni*=va),Gn.set(Qx,bi,Ni,va),Vx.equals(Gn)===!1&&(I.clearColor(Qx,bi,Ni,va),Vx.copy(Gn))},reset:function(){Bt=!1,Xn=null,Vx.set(-1,0,0,0)}}}function _(){let Bt=!1,Gn=null,Xn=null,Vx=null;return{setTest:function(Qx){Qx?Px(I.DEPTH_TEST):xr(I.DEPTH_TEST)},setMask:function(Qx){Gn!==Qx&&!Bt&&(I.depthMask(Qx),Gn=Qx)},setFunc:function(Qx){if(Xn!==Qx){switch(Qx){case ju:I.depthFunc(I.NEVER);break;case zo:I.depthFunc(I.ALWAYS);break;case Gc:I.depthFunc(I.LESS);break;case Vo:I.depthFunc(I.LEQUAL);break;case vc:I.depthFunc(I.EQUAL);break;case Ku:I.depthFunc(I.GEQUAL);break;case $u:I.depthFunc(I.GREATER);break;case Uo:I.depthFunc(I.NOTEQUAL);break;default:I.depthFunc(I.LEQUAL)}Xn=Qx}},setLocked:function(Qx){Bt=Qx},setClear:function(Qx){Vx!==Qx&&(I.clearDepth(Qx),Vx=Qx)},reset:function(){Bt=!1,Gn=null,Xn=null,Vx=null}}}function R(){let Bt=!1,Gn=null,Xn=null,Vx=null,Qx=null,bi=null,Ni=null,va=null,Jo=null;return{setTest:function(Ai){Bt||(Ai?Px(I.STENCIL_TEST):xr(I.STENCIL_TEST))},setMask:function(Ai){Gn!==Ai&&!Bt&&(I.stencilMask(Ai),Gn=Ai)},setFunc:function(Ai,Na,$2){(Xn!==Ai||Vx!==Na||Qx!==$2)&&(I.stencilFunc(Ai,Na,$2),Xn=Ai,Vx=Na,Qx=$2)},setOp:function(Ai,Na,$2){(bi!==Ai||Ni!==Na||va!==$2)&&(I.stencilOp(Ai,Na,$2),bi=Ai,Ni=Na,va=$2)},setLocked:function(Ai){Bt=Ai},setClear:function(Ai){Jo!==Ai&&(I.clearStencil(Ai),Jo=Ai)},reset:function(){Bt=!1,Gn=null,Xn=null,Vx=null,Qx=null,bi=null,Ni=null,va=null,Jo=null}}}const k=new y,X=new _,K=new R,Q=new WeakMap,xe=new WeakMap;let ue={},ge={},_e=new WeakMap,Re=[],be=null,ve=!1,Xe=null,Be=null,Ke=null,bt=null,rt=null,xt=null,Mt=null,$t=new bx(0,0,0),$e=0,vt=!1,M0=null,V0=null,Pt=null,x0=null,Wt=null;const an=I.getParameter(I.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let W0=!1,j0=0;const un=I.getParameter(I.VERSION);un.indexOf("WebGL")!==-1?(j0=parseFloat(/^WebGL (\d)/.exec(un)[1]),W0=j0>=1):un.indexOf("OpenGL ES")!==-1&&(j0=parseFloat(/^OpenGL ES (\d)/.exec(un)[1]),W0=j0>=2);let bn=null,ex={};const Cx=I.getParameter(I.SCISSOR_BOX),R0=I.getParameter(I.VIEWPORT),_n=new Vi().fromArray(Cx),ux=new Vi().fromArray(R0);function Rx(Bt,Gn,Xn,Vx){const Qx=new Uint8Array(4),bi=I.createTexture();I.bindTexture(Bt,bi),I.texParameteri(Bt,I.TEXTURE_MIN_FILTER,I.NEAREST),I.texParameteri(Bt,I.TEXTURE_MAG_FILTER,I.NEAREST);for(let Ni=0;Ni<Xn;Ni++)g&&(Bt===I.TEXTURE_3D||Bt===I.TEXTURE_2D_ARRAY)?I.texImage3D(Gn,0,I.RGBA,1,1,Vx,0,I.RGBA,I.UNSIGNED_BYTE,Qx):I.texImage2D(Gn+Ni,0,I.RGBA,1,1,0,I.RGBA,I.UNSIGNED_BYTE,Qx);return bi}const Bx={};Bx[I.TEXTURE_2D]=Rx(I.TEXTURE_2D,I.TEXTURE_2D,1),Bx[I.TEXTURE_CUBE_MAP]=Rx(I.TEXTURE_CUBE_MAP,I.TEXTURE_CUBE_MAP_POSITIVE_X,6),g&&(Bx[I.TEXTURE_2D_ARRAY]=Rx(I.TEXTURE_2D_ARRAY,I.TEXTURE_2D_ARRAY,1,1),Bx[I.TEXTURE_3D]=Rx(I.TEXTURE_3D,I.TEXTURE_3D,1,1)),k.setClear(0,0,0,1),X.setClear(1),K.setClear(0),Px(I.DEPTH_TEST),X.setFunc(Vo),_x(!1),Tt(R2),Px(I.CULL_FACE),rn(Aa);function Px(Bt){ue[Bt]!==!0&&(I.enable(Bt),ue[Bt]=!0)}function xr(Bt){ue[Bt]!==!1&&(I.disable(Bt),ue[Bt]=!1)}function Xx(Bt,Gn){return ge[Bt]!==Gn?(I.bindFramebuffer(Bt,Gn),ge[Bt]=Gn,g&&(Bt===I.DRAW_FRAMEBUFFER&&(ge[I.FRAMEBUFFER]=Gn),Bt===I.FRAMEBUFFER&&(ge[I.DRAW_FRAMEBUFFER]=Gn)),!0):!1}function zt(Bt,Gn){let Xn=Re,Vx=!1;if(Bt)if(Xn=_e.get(Gn),Xn===void 0&&(Xn=[],_e.set(Gn,Xn)),Bt.isWebGLMultipleRenderTargets){const Qx=Bt.texture;if(Xn.length!==Qx.length||Xn[0]!==I.COLOR_ATTACHMENT0){for(let bi=0,Ni=Qx.length;bi<Ni;bi++)Xn[bi]=I.COLOR_ATTACHMENT0+bi;Xn.length=Qx.length,Vx=!0}}else Xn[0]!==I.COLOR_ATTACHMENT0&&(Xn[0]=I.COLOR_ATTACHMENT0,Vx=!0);else Xn[0]!==I.BACK&&(Xn[0]=I.BACK,Vx=!0);Vx&&(d.isWebGL2?I.drawBuffers(Xn):r.get("WEBGL_draw_buffers").drawBuffersWEBGL(Xn))}function Kn(Bt){return be!==Bt?(I.useProgram(Bt),be=Bt,!0):!1}const en={[Ui]:I.FUNC_ADD,[go]:I.FUNC_SUBTRACT,[dl]:I.FUNC_REVERSE_SUBTRACT};if(g)en[Uc]=I.MIN,en[ec]=I.MAX;else{const Bt=r.get("EXT_blend_minmax");Bt!==null&&(en[Uc]=Bt.MIN_EXT,en[ec]=Bt.MAX_EXT)}const Vn={[xc]:I.ZERO,[rc]:I.ONE,[gl]:I.SRC_COLOR,[uc]:I.SRC_ALPHA,[Qo]:I.SRC_ALPHA_SATURATE,[vo]:I.DST_COLOR,[N2]:I.DST_ALPHA,[vl]:I.ONE_MINUS_SRC_COLOR,[dc]:I.ONE_MINUS_SRC_ALPHA,[Wo]:I.ONE_MINUS_DST_COLOR,[bl]:I.ONE_MINUS_DST_ALPHA,[bo]:I.CONSTANT_COLOR,[Xu]:I.ONE_MINUS_CONSTANT_COLOR,[gc]:I.CONSTANT_ALPHA,[Bo]:I.ONE_MINUS_CONSTANT_ALPHA};function rn(Bt,Gn,Xn,Vx,Qx,bi,Ni,va,Jo,Ai){if(Bt===Aa){ve===!0&&(xr(I.BLEND),ve=!1);return}if(ve===!1&&(Px(I.BLEND),ve=!0),Bt!==_r){if(Bt!==Xe||Ai!==vt){if((Be!==Ui||rt!==Ui)&&(I.blendEquation(I.FUNC_ADD),Be=Ui,rt=Ui),Ai)switch(Bt){case Bi:I.blendFuncSeparate(I.ONE,I.ONE_MINUS_SRC_ALPHA,I.ONE,I.ONE_MINUS_SRC_ALPHA);break;case Ws:I.blendFunc(I.ONE,I.ONE);break;case Nn:I.blendFuncSeparate(I.ZERO,I.ONE_MINUS_SRC_COLOR,I.ZERO,I.ONE);break;case bs:I.blendFuncSeparate(I.ZERO,I.SRC_COLOR,I.ZERO,I.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",Bt);break}else switch(Bt){case Bi:I.blendFuncSeparate(I.SRC_ALPHA,I.ONE_MINUS_SRC_ALPHA,I.ONE,I.ONE_MINUS_SRC_ALPHA);break;case Ws:I.blendFunc(I.SRC_ALPHA,I.ONE);break;case Nn:I.blendFuncSeparate(I.ZERO,I.ONE_MINUS_SRC_COLOR,I.ZERO,I.ONE);break;case bs:I.blendFunc(I.ZERO,I.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",Bt);break}Ke=null,bt=null,xt=null,Mt=null,$t.set(0,0,0),$e=0,Xe=Bt,vt=Ai}return}Qx=Qx||Gn,bi=bi||Xn,Ni=Ni||Vx,(Gn!==Be||Qx!==rt)&&(I.blendEquationSeparate(en[Gn],en[Qx]),Be=Gn,rt=Qx),(Xn!==Ke||Vx!==bt||bi!==xt||Ni!==Mt)&&(I.blendFuncSeparate(Vn[Xn],Vn[Vx],Vn[bi],Vn[Ni]),Ke=Xn,bt=Vx,xt=bi,Mt=Ni),(va.equals($t)===!1||Jo!==$e)&&(I.blendColor(va.r,va.g,va.b,Jo),$t.copy(va),$e=Jo),Xe=Bt,vt=!1}function jx(Bt,Gn){Bt.side===Ba?xr(I.CULL_FACE):Px(I.CULL_FACE);let Xn=Bt.side===vs;Gn&&(Xn=!Xn),_x(Xn),Bt.blending===Bi&&Bt.transparent===!1?rn(Aa):rn(Bt.blending,Bt.blendEquation,Bt.blendSrc,Bt.blendDst,Bt.blendEquationAlpha,Bt.blendSrcAlpha,Bt.blendDstAlpha,Bt.blendColor,Bt.blendAlpha,Bt.premultipliedAlpha),X.setFunc(Bt.depthFunc),X.setTest(Bt.depthTest),X.setMask(Bt.depthWrite),k.setMask(Bt.colorWrite);const Vx=Bt.stencilWrite;K.setTest(Vx),Vx&&(K.setMask(Bt.stencilWriteMask),K.setFunc(Bt.stencilFunc,Bt.stencilRef,Bt.stencilFuncMask),K.setOp(Bt.stencilFail,Bt.stencilZFail,Bt.stencilZPass)),g0(Bt.polygonOffset,Bt.polygonOffsetFactor,Bt.polygonOffsetUnits),Bt.alphaToCoverage===!0?Px(I.SAMPLE_ALPHA_TO_COVERAGE):xr(I.SAMPLE_ALPHA_TO_COVERAGE)}function _x(Bt){M0!==Bt&&(Bt?I.frontFace(I.CW):I.frontFace(I.CCW),M0=Bt)}function Tt(Bt){Bt!==Gu?(Px(I.CULL_FACE),Bt!==V0&&(Bt===R2?I.cullFace(I.BACK):Bt===ul?I.cullFace(I.FRONT):I.cullFace(I.FRONT_AND_BACK))):xr(I.CULL_FACE),V0=Bt}function tt(Bt){Bt!==Pt&&(W0&&I.lineWidth(Bt),Pt=Bt)}function g0(Bt,Gn,Xn){Bt?(Px(I.POLYGON_OFFSET_FILL),(x0!==Gn||Wt!==Xn)&&(I.polygonOffset(Gn,Xn),x0=Gn,Wt=Xn)):xr(I.POLYGON_OFFSET_FILL)}function Cn(Bt){Bt?Px(I.SCISSOR_TEST):xr(I.SCISSOR_TEST)}function Tn(Bt){Bt===void 0&&(Bt=I.TEXTURE0+an-1),bn!==Bt&&(I.activeTexture(Bt),bn=Bt)}function An(Bt,Gn,Xn){Xn===void 0&&(bn===null?Xn=I.TEXTURE0+an-1:Xn=bn);let Vx=ex[Xn];Vx===void 0&&(Vx={type:void 0,texture:void 0},ex[Xn]=Vx),(Vx.type!==Bt||Vx.texture!==Gn)&&(bn!==Xn&&(I.activeTexture(Xn),bn=Xn),I.bindTexture(Bt,Gn||Bx[Bt]),Vx.type=Bt,Vx.texture=Gn)}function zx(){const Bt=ex[bn];Bt!==void 0&&Bt.type!==void 0&&(I.bindTexture(Bt.type,null),Bt.type=void 0,Bt.texture=void 0)}function xx(){try{I.compressedTexImage2D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Ax(){try{I.compressedTexImage3D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function sr(){try{I.texSubImage2D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Pr(){try{I.texSubImage3D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Mn(){try{I.compressedTexSubImage2D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function di(){try{I.compressedTexSubImage3D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function jr(){try{I.texStorage2D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Tr(){try{I.texStorage3D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Kx(){try{I.texImage2D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Nx(){try{I.texImage3D.apply(I,arguments)}catch(Bt){console.error("THREE.WebGLState:",Bt)}}function Mr(Bt){_n.equals(Bt)===!1&&(I.scissor(Bt.x,Bt.y,Bt.z,Bt.w),_n.copy(Bt))}function _i(Bt){ux.equals(Bt)===!1&&(I.viewport(Bt.x,Bt.y,Bt.z,Bt.w),ux.copy(Bt))}function Ki(Bt,Gn){let Xn=xe.get(Gn);Xn===void 0&&(Xn=new WeakMap,xe.set(Gn,Xn));let Vx=Xn.get(Bt);Vx===void 0&&(Vx=I.getUniformBlockIndex(Gn,Bt.name),Xn.set(Bt,Vx))}function Jr(Bt,Gn){const Vx=xe.get(Gn).get(Bt);Q.get(Gn)!==Vx&&(I.uniformBlockBinding(Gn,Vx,Bt.__bindingPointIndex),Q.set(Gn,Vx))}function Ti(){I.disable(I.BLEND),I.disable(I.CULL_FACE),I.disable(I.DEPTH_TEST),I.disable(I.POLYGON_OFFSET_FILL),I.disable(I.SCISSOR_TEST),I.disable(I.STENCIL_TEST),I.disable(I.SAMPLE_ALPHA_TO_COVERAGE),I.blendEquation(I.FUNC_ADD),I.blendFunc(I.ONE,I.ZERO),I.blendFuncSeparate(I.ONE,I.ZERO,I.ONE,I.ZERO),I.blendColor(0,0,0,0),I.colorMask(!0,!0,!0,!0),I.clearColor(0,0,0,0),I.depthMask(!0),I.depthFunc(I.LESS),I.clearDepth(1),I.stencilMask(4294967295),I.stencilFunc(I.ALWAYS,0,4294967295),I.stencilOp(I.KEEP,I.KEEP,I.KEEP),I.clearStencil(0),I.cullFace(I.BACK),I.frontFace(I.CCW),I.polygonOffset(0,0),I.activeTexture(I.TEXTURE0),I.bindFramebuffer(I.FRAMEBUFFER,null),g===!0&&(I.bindFramebuffer(I.DRAW_FRAMEBUFFER,null),I.bindFramebuffer(I.READ_FRAMEBUFFER,null)),I.useProgram(null),I.lineWidth(1),I.scissor(0,0,I.canvas.width,I.canvas.height),I.viewport(0,0,I.canvas.width,I.canvas.height),ue={},bn=null,ex={},ge={},_e=new WeakMap,Re=[],be=null,ve=!1,Xe=null,Be=null,Ke=null,bt=null,rt=null,xt=null,Mt=null,$t=new bx(0,0,0),$e=0,vt=!1,M0=null,V0=null,Pt=null,x0=null,Wt=null,_n.set(0,0,I.canvas.width,I.canvas.height),ux.set(0,0,I.canvas.width,I.canvas.height),k.reset(),X.reset(),K.reset()}return{buffers:{color:k,depth:X,stencil:K},enable:Px,disable:xr,bindFramebuffer:Xx,drawBuffers:zt,useProgram:Kn,setBlending:rn,setMaterial:jx,setFlipSided:_x,setCullFace:Tt,setLineWidth:tt,setPolygonOffset:g0,setScissorTest:Cn,activeTexture:Tn,bindTexture:An,unbindTexture:zx,compressedTexImage2D:xx,compressedTexImage3D:Ax,texImage2D:Kx,texImage3D:Nx,updateUBOMapping:Ki,uniformBlockBinding:Jr,texStorage2D:jr,texStorage3D:Tr,texSubImage2D:sr,texSubImage3D:Pr,compressedTexSubImage2D:Mn,compressedTexSubImage3D:di,scissor:Mr,viewport:_i,reset:Ti}}function XN(I,r,d,g,y,_,R){const k=y.isWebGL2,X=r.has("WEBGL_multisampled_render_to_texture")?r.get("WEBGL_multisampled_render_to_texture"):null,K=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),Q=new WeakMap;let xe;const ue=new WeakMap;let ge=!1;try{ge=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function _e(Tt,tt){return ge?new OffscreenCanvas(Tt,tt):xp("canvas")}function Re(Tt,tt,g0,Cn){let Tn=1;if((Tt.width>Cn||Tt.height>Cn)&&(Tn=Cn/Math.max(Tt.width,Tt.height)),Tn<1||tt===!0)if(typeof HTMLImageElement<"u"&&Tt instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Tt instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Tt instanceof ImageBitmap){const An=tt?um:Math.floor,zx=An(Tn*Tt.width),xx=An(Tn*Tt.height);xe===void 0&&(xe=_e(zx,xx));const Ax=g0?_e(zx,xx):xe;return Ax.width=zx,Ax.height=xx,Ax.getContext("2d").drawImage(Tt,0,0,zx,xx),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Tt.width+"x"+Tt.height+") to ("+zx+"x"+xx+")."),Ax}else return"data"in Tt&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Tt.width+"x"+Tt.height+")."),Tt;return Tt}function be(Tt){return Ny(Tt.width)&&Ny(Tt.height)}function ve(Tt){return k?!1:Tt.wrapS!==Gi||Tt.wrapT!==Gi||Tt.minFilter!==gi&&Tt.minFilter!==ui}function Xe(Tt,tt){return Tt.generateMipmaps&&tt&&Tt.minFilter!==gi&&Tt.minFilter!==ui}function Be(Tt){I.generateMipmap(Tt)}function Ke(Tt,tt,g0,Cn,Tn=!1){if(k===!1)return tt;if(Tt!==null){if(I[Tt]!==void 0)return I[Tt];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Tt+"'")}let An=tt;if(tt===I.RED&&(g0===I.FLOAT&&(An=I.R32F),g0===I.HALF_FLOAT&&(An=I.R16F),g0===I.UNSIGNED_BYTE&&(An=I.R8)),tt===I.RED_INTEGER&&(g0===I.UNSIGNED_BYTE&&(An=I.R8UI),g0===I.UNSIGNED_SHORT&&(An=I.R16UI),g0===I.UNSIGNED_INT&&(An=I.R32UI),g0===I.BYTE&&(An=I.R8I),g0===I.SHORT&&(An=I.R16I),g0===I.INT&&(An=I.R32I)),tt===I.RG&&(g0===I.FLOAT&&(An=I.RG32F),g0===I.HALF_FLOAT&&(An=I.RG16F),g0===I.UNSIGNED_BYTE&&(An=I.RG8)),tt===I.RGBA){const zx=Tn?ei:Ci.getTransfer(Cn);g0===I.FLOAT&&(An=I.RGBA32F),g0===I.HALF_FLOAT&&(An=I.RGBA16F),g0===I.UNSIGNED_BYTE&&(An=zx===dr?I.SRGB8_ALPHA8:I.RGBA8),g0===I.UNSIGNED_SHORT_4_4_4_4&&(An=I.RGBA4),g0===I.UNSIGNED_SHORT_5_5_5_1&&(An=I.RGB5_A1)}return(An===I.R16F||An===I.R32F||An===I.RG16F||An===I.RG32F||An===I.RGBA16F||An===I.RGBA32F)&&r.get("EXT_color_buffer_float"),An}function bt(Tt,tt,g0){return Xe(Tt,g0)===!0||Tt.isFramebufferTexture&&Tt.minFilter!==gi&&Tt.minFilter!==ui?Math.log2(Math.max(tt.width,tt.height))+1:Tt.mipmaps!==void 0&&Tt.mipmaps.length>0?Tt.mipmaps.length:Tt.isCompressedTexture&&Array.isArray(Tt.image)?tt.mipmaps.length:1}function rt(Tt){return Tt===gi||Tt===Tc||Tt===x2?I.NEAREST:I.LINEAR}function xt(Tt){const tt=Tt.target;tt.removeEventListener("dispose",xt),$t(tt),tt.isVideoTexture&&Q.delete(tt)}function Mt(Tt){const tt=Tt.target;tt.removeEventListener("dispose",Mt),vt(tt)}function $t(Tt){const tt=g.get(Tt);if(tt.__webglInit===void 0)return;const g0=Tt.source,Cn=ue.get(g0);if(Cn){const Tn=Cn[tt.__cacheKey];Tn.usedTimes--,Tn.usedTimes===0&&$e(Tt),Object.keys(Cn).length===0&&ue.delete(g0)}g.remove(Tt)}function $e(Tt){const tt=g.get(Tt);I.deleteTexture(tt.__webglTexture);const g0=Tt.source,Cn=ue.get(g0);delete Cn[tt.__cacheKey],R.memory.textures--}function vt(Tt){const tt=Tt.texture,g0=g.get(Tt),Cn=g.get(tt);if(Cn.__webglTexture!==void 0&&(I.deleteTexture(Cn.__webglTexture),R.memory.textures--),Tt.depthTexture&&Tt.depthTexture.dispose(),Tt.isWebGLCubeRenderTarget)for(let Tn=0;Tn<6;Tn++){if(Array.isArray(g0.__webglFramebuffer[Tn]))for(let An=0;An<g0.__webglFramebuffer[Tn].length;An++)I.deleteFramebuffer(g0.__webglFramebuffer[Tn][An]);else I.deleteFramebuffer(g0.__webglFramebuffer[Tn]);g0.__webglDepthbuffer&&I.deleteRenderbuffer(g0.__webglDepthbuffer[Tn])}else{if(Array.isArray(g0.__webglFramebuffer))for(let Tn=0;Tn<g0.__webglFramebuffer.length;Tn++)I.deleteFramebuffer(g0.__webglFramebuffer[Tn]);else I.deleteFramebuffer(g0.__webglFramebuffer);if(g0.__webglDepthbuffer&&I.deleteRenderbuffer(g0.__webglDepthbuffer),g0.__webglMultisampledFramebuffer&&I.deleteFramebuffer(g0.__webglMultisampledFramebuffer),g0.__webglColorRenderbuffer)for(let Tn=0;Tn<g0.__webglColorRenderbuffer.length;Tn++)g0.__webglColorRenderbuffer[Tn]&&I.deleteRenderbuffer(g0.__webglColorRenderbuffer[Tn]);g0.__webglDepthRenderbuffer&&I.deleteRenderbuffer(g0.__webglDepthRenderbuffer)}if(Tt.isWebGLMultipleRenderTargets)for(let Tn=0,An=tt.length;Tn<An;Tn++){const zx=g.get(tt[Tn]);zx.__webglTexture&&(I.deleteTexture(zx.__webglTexture),R.memory.textures--),g.remove(tt[Tn])}g.remove(tt),g.remove(Tt)}let M0=0;function V0(){M0=0}function Pt(){const Tt=M0;return Tt>=y.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+Tt+" texture units while this GPU supports only "+y.maxTextures),M0+=1,Tt}function x0(Tt){const tt=[];return tt.push(Tt.wrapS),tt.push(Tt.wrapT),tt.push(Tt.wrapR||0),tt.push(Tt.magFilter),tt.push(Tt.minFilter),tt.push(Tt.anisotropy),tt.push(Tt.internalFormat),tt.push(Tt.format),tt.push(Tt.type),tt.push(Tt.generateMipmaps),tt.push(Tt.premultiplyAlpha),tt.push(Tt.flipY),tt.push(Tt.unpackAlignment),tt.push(Tt.colorSpace),tt.join()}function Wt(Tt,tt){const g0=g.get(Tt);if(Tt.isVideoTexture&&jx(Tt),Tt.isRenderTargetTexture===!1&&Tt.version>0&&g0.__version!==Tt.version){const Cn=Tt.image;if(Cn===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Cn.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{_n(g0,Tt,tt);return}}d.bindTexture(I.TEXTURE_2D,g0.__webglTexture,I.TEXTURE0+tt)}function an(Tt,tt){const g0=g.get(Tt);if(Tt.version>0&&g0.__version!==Tt.version){_n(g0,Tt,tt);return}d.bindTexture(I.TEXTURE_2D_ARRAY,g0.__webglTexture,I.TEXTURE0+tt)}function W0(Tt,tt){const g0=g.get(Tt);if(Tt.version>0&&g0.__version!==Tt.version){_n(g0,Tt,tt);return}d.bindTexture(I.TEXTURE_3D,g0.__webglTexture,I.TEXTURE0+tt)}function j0(Tt,tt){const g0=g.get(Tt);if(Tt.version>0&&g0.__version!==Tt.version){ux(g0,Tt,tt);return}d.bindTexture(I.TEXTURE_CUBE_MAP,g0.__webglTexture,I.TEXTURE0+tt)}const un={[Ri]:I.REPEAT,[Gi]:I.CLAMP_TO_EDGE,[ea]:I.MIRRORED_REPEAT},bn={[gi]:I.NEAREST,[Tc]:I.NEAREST_MIPMAP_NEAREST,[x2]:I.NEAREST_MIPMAP_LINEAR,[ui]:I.LINEAR,[Xo]:I.LINEAR_MIPMAP_NEAREST,[Us]:I.LINEAR_MIPMAP_LINEAR},ex={[VT]:I.NEVER,[$T]:I.ALWAYS,[UT]:I.LESS,[Rb]:I.LEQUAL,[GT]:I.EQUAL,[KT]:I.GEQUAL,[XT]:I.GREATER,[jT]:I.NOTEQUAL};function Cx(Tt,tt,g0){if(tt.type===Ts&&r.has("OES_texture_float_linear")===!1&&(tt.magFilter===ui||tt.magFilter===Xo||tt.magFilter===x2||tt.magFilter===Us||tt.minFilter===ui||tt.minFilter===Xo||tt.minFilter===x2||tt.minFilter===Us)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),g0?(I.texParameteri(Tt,I.TEXTURE_WRAP_S,un[tt.wrapS]),I.texParameteri(Tt,I.TEXTURE_WRAP_T,un[tt.wrapT]),(Tt===I.TEXTURE_3D||Tt===I.TEXTURE_2D_ARRAY)&&I.texParameteri(Tt,I.TEXTURE_WRAP_R,un[tt.wrapR]),I.texParameteri(Tt,I.TEXTURE_MAG_FILTER,bn[tt.magFilter]),I.texParameteri(Tt,I.TEXTURE_MIN_FILTER,bn[tt.minFilter])):(I.texParameteri(Tt,I.TEXTURE_WRAP_S,I.CLAMP_TO_EDGE),I.texParameteri(Tt,I.TEXTURE_WRAP_T,I.CLAMP_TO_EDGE),(Tt===I.TEXTURE_3D||Tt===I.TEXTURE_2D_ARRAY)&&I.texParameteri(Tt,I.TEXTURE_WRAP_R,I.CLAMP_TO_EDGE),(tt.wrapS!==Gi||tt.wrapT!==Gi)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),I.texParameteri(Tt,I.TEXTURE_MAG_FILTER,rt(tt.magFilter)),I.texParameteri(Tt,I.TEXTURE_MIN_FILTER,rt(tt.minFilter)),tt.minFilter!==gi&&tt.minFilter!==ui&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),tt.compareFunction&&(I.texParameteri(Tt,I.TEXTURE_COMPARE_MODE,I.COMPARE_REF_TO_TEXTURE),I.texParameteri(Tt,I.TEXTURE_COMPARE_FUNC,ex[tt.compareFunction])),r.has("EXT_texture_filter_anisotropic")===!0){const Cn=r.get("EXT_texture_filter_anisotropic");if(tt.magFilter===gi||tt.minFilter!==x2&&tt.minFilter!==Us||tt.type===Ts&&r.has("OES_texture_float_linear")===!1||k===!1&&tt.type===Xi&&r.has("OES_texture_half_float_linear")===!1)return;(tt.anisotropy>1||g.get(tt).__currentAnisotropy)&&(I.texParameterf(Tt,Cn.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(tt.anisotropy,y.getMaxAnisotropy())),g.get(tt).__currentAnisotropy=tt.anisotropy)}}function R0(Tt,tt){let g0=!1;Tt.__webglInit===void 0&&(Tt.__webglInit=!0,tt.addEventListener("dispose",xt));const Cn=tt.source;let Tn=ue.get(Cn);Tn===void 0&&(Tn={},ue.set(Cn,Tn));const An=x0(tt);if(An!==Tt.__cacheKey){Tn[An]===void 0&&(Tn[An]={texture:I.createTexture(),usedTimes:0},R.memory.textures++,g0=!0),Tn[An].usedTimes++;const zx=Tn[Tt.__cacheKey];zx!==void 0&&(Tn[Tt.__cacheKey].usedTimes--,zx.usedTimes===0&&$e(tt)),Tt.__cacheKey=An,Tt.__webglTexture=Tn[An].texture}return g0}function _n(Tt,tt,g0){let Cn=I.TEXTURE_2D;(tt.isDataArrayTexture||tt.isCompressedArrayTexture)&&(Cn=I.TEXTURE_2D_ARRAY),tt.isData3DTexture&&(Cn=I.TEXTURE_3D);const Tn=R0(Tt,tt),An=tt.source;d.bindTexture(Cn,Tt.__webglTexture,I.TEXTURE0+g0);const zx=g.get(An);if(An.version!==zx.__version||Tn===!0){d.activeTexture(I.TEXTURE0+g0);const xx=Ci.getPrimaries(Ci.workingColorSpace),Ax=tt.colorSpace===$n?null:Ci.getPrimaries(tt.colorSpace),sr=tt.colorSpace===$n||xx===Ax?I.NONE:I.BROWSER_DEFAULT_WEBGL;I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL,tt.flipY),I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL,tt.premultiplyAlpha),I.pixelStorei(I.UNPACK_ALIGNMENT,tt.unpackAlignment),I.pixelStorei(I.UNPACK_COLORSPACE_CONVERSION_WEBGL,sr);const Pr=ve(tt)&&be(tt.image)===!1;let Mn=Re(tt.image,Pr,!1,y.maxTextureSize);Mn=_x(tt,Mn);const di=be(Mn)||k,jr=_.convert(tt.format,tt.colorSpace);let Tr=_.convert(tt.type),Kx=Ke(tt.internalFormat,jr,Tr,tt.colorSpace,tt.isVideoTexture);Cx(Cn,tt,di);let Nx;const Mr=tt.mipmaps,_i=k&&tt.isVideoTexture!==!0&&Kx!==et,Ki=zx.__version===void 0||Tn===!0,Jr=An.dataReady,Ti=bt(tt,Mn,di);if(tt.isDepthTexture)Kx=I.DEPTH_COMPONENT,k?tt.type===Ts?Kx=I.DEPTH_COMPONENT32F:tt.type===jo?Kx=I.DEPTH_COMPONENT24:tt.type===u2?Kx=I.DEPTH24_STENCIL8:Kx=I.DEPTH_COMPONENT16:tt.type===Ts&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),tt.format===d2&&Kx===I.DEPTH_COMPONENT&&tt.type!==Ac&&tt.type!==jo&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),tt.type=jo,Tr=_.convert(tt.type)),tt.format===B2&&Kx===I.DEPTH_COMPONENT&&(Kx=I.DEPTH_STENCIL,tt.type!==u2&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),tt.type=u2,Tr=_.convert(tt.type))),Ki&&(_i?d.texStorage2D(I.TEXTURE_2D,1,Kx,Mn.width,Mn.height):d.texImage2D(I.TEXTURE_2D,0,Kx,Mn.width,Mn.height,0,jr,Tr,null));else if(tt.isDataTexture)if(Mr.length>0&&di){_i&&Ki&&d.texStorage2D(I.TEXTURE_2D,Ti,Kx,Mr[0].width,Mr[0].height);for(let Bt=0,Gn=Mr.length;Bt<Gn;Bt++)Nx=Mr[Bt],_i?Jr&&d.texSubImage2D(I.TEXTURE_2D,Bt,0,0,Nx.width,Nx.height,jr,Tr,Nx.data):d.texImage2D(I.TEXTURE_2D,Bt,Kx,Nx.width,Nx.height,0,jr,Tr,Nx.data);tt.generateMipmaps=!1}else _i?(Ki&&d.texStorage2D(I.TEXTURE_2D,Ti,Kx,Mn.width,Mn.height),Jr&&d.texSubImage2D(I.TEXTURE_2D,0,0,0,Mn.width,Mn.height,jr,Tr,Mn.data)):d.texImage2D(I.TEXTURE_2D,0,Kx,Mn.width,Mn.height,0,jr,Tr,Mn.data);else if(tt.isCompressedTexture)if(tt.isCompressedArrayTexture){_i&&Ki&&d.texStorage3D(I.TEXTURE_2D_ARRAY,Ti,Kx,Mr[0].width,Mr[0].height,Mn.depth);for(let Bt=0,Gn=Mr.length;Bt<Gn;Bt++)Nx=Mr[Bt],tt.format!==xa?jr!==null?_i?Jr&&d.compressedTexSubImage3D(I.TEXTURE_2D_ARRAY,Bt,0,0,0,Nx.width,Nx.height,Mn.depth,jr,Nx.data,0,0):d.compressedTexImage3D(I.TEXTURE_2D_ARRAY,Bt,Kx,Nx.width,Nx.height,Mn.depth,0,Nx.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_i?Jr&&d.texSubImage3D(I.TEXTURE_2D_ARRAY,Bt,0,0,0,Nx.width,Nx.height,Mn.depth,jr,Tr,Nx.data):d.texImage3D(I.TEXTURE_2D_ARRAY,Bt,Kx,Nx.width,Nx.height,Mn.depth,0,jr,Tr,Nx.data)}else{_i&&Ki&&d.texStorage2D(I.TEXTURE_2D,Ti,Kx,Mr[0].width,Mr[0].height);for(let Bt=0,Gn=Mr.length;Bt<Gn;Bt++)Nx=Mr[Bt],tt.format!==xa?jr!==null?_i?Jr&&d.compressedTexSubImage2D(I.TEXTURE_2D,Bt,0,0,Nx.width,Nx.height,jr,Nx.data):d.compressedTexImage2D(I.TEXTURE_2D,Bt,Kx,Nx.width,Nx.height,0,Nx.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_i?Jr&&d.texSubImage2D(I.TEXTURE_2D,Bt,0,0,Nx.width,Nx.height,jr,Tr,Nx.data):d.texImage2D(I.TEXTURE_2D,Bt,Kx,Nx.width,Nx.height,0,jr,Tr,Nx.data)}else if(tt.isDataArrayTexture)_i?(Ki&&d.texStorage3D(I.TEXTURE_2D_ARRAY,Ti,Kx,Mn.width,Mn.height,Mn.depth),Jr&&d.texSubImage3D(I.TEXTURE_2D_ARRAY,0,0,0,0,Mn.width,Mn.height,Mn.depth,jr,Tr,Mn.data)):d.texImage3D(I.TEXTURE_2D_ARRAY,0,Kx,Mn.width,Mn.height,Mn.depth,0,jr,Tr,Mn.data);else if(tt.isData3DTexture)_i?(Ki&&d.texStorage3D(I.TEXTURE_3D,Ti,Kx,Mn.width,Mn.height,Mn.depth),Jr&&d.texSubImage3D(I.TEXTURE_3D,0,0,0,0,Mn.width,Mn.height,Mn.depth,jr,Tr,Mn.data)):d.texImage3D(I.TEXTURE_3D,0,Kx,Mn.width,Mn.height,Mn.depth,0,jr,Tr,Mn.data);else if(tt.isFramebufferTexture){if(Ki)if(_i)d.texStorage2D(I.TEXTURE_2D,Ti,Kx,Mn.width,Mn.height);else{let Bt=Mn.width,Gn=Mn.height;for(let Xn=0;Xn<Ti;Xn++)d.texImage2D(I.TEXTURE_2D,Xn,Kx,Bt,Gn,0,jr,Tr,null),Bt>>=1,Gn>>=1}}else if(Mr.length>0&&di){_i&&Ki&&d.texStorage2D(I.TEXTURE_2D,Ti,Kx,Mr[0].width,Mr[0].height);for(let Bt=0,Gn=Mr.length;Bt<Gn;Bt++)Nx=Mr[Bt],_i?Jr&&d.texSubImage2D(I.TEXTURE_2D,Bt,0,0,jr,Tr,Nx):d.texImage2D(I.TEXTURE_2D,Bt,Kx,jr,Tr,Nx);tt.generateMipmaps=!1}else _i?(Ki&&d.texStorage2D(I.TEXTURE_2D,Ti,Kx,Mn.width,Mn.height),Jr&&d.texSubImage2D(I.TEXTURE_2D,0,0,0,jr,Tr,Mn)):d.texImage2D(I.TEXTURE_2D,0,Kx,jr,Tr,Mn);Xe(tt,di)&&Be(Cn),zx.__version=An.version,tt.onUpdate&&tt.onUpdate(tt)}Tt.__version=tt.version}function ux(Tt,tt,g0){if(tt.image.length!==6)return;const Cn=R0(Tt,tt),Tn=tt.source;d.bindTexture(I.TEXTURE_CUBE_MAP,Tt.__webglTexture,I.TEXTURE0+g0);const An=g.get(Tn);if(Tn.version!==An.__version||Cn===!0){d.activeTexture(I.TEXTURE0+g0);const zx=Ci.getPrimaries(Ci.workingColorSpace),xx=tt.colorSpace===$n?null:Ci.getPrimaries(tt.colorSpace),Ax=tt.colorSpace===$n||zx===xx?I.NONE:I.BROWSER_DEFAULT_WEBGL;I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL,tt.flipY),I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL,tt.premultiplyAlpha),I.pixelStorei(I.UNPACK_ALIGNMENT,tt.unpackAlignment),I.pixelStorei(I.UNPACK_COLORSPACE_CONVERSION_WEBGL,Ax);const sr=tt.isCompressedTexture||tt.image[0].isCompressedTexture,Pr=tt.image[0]&&tt.image[0].isDataTexture,Mn=[];for(let Bt=0;Bt<6;Bt++)!sr&&!Pr?Mn[Bt]=Re(tt.image[Bt],!1,!0,y.maxCubemapSize):Mn[Bt]=Pr?tt.image[Bt].image:tt.image[Bt],Mn[Bt]=_x(tt,Mn[Bt]);const di=Mn[0],jr=be(di)||k,Tr=_.convert(tt.format,tt.colorSpace),Kx=_.convert(tt.type),Nx=Ke(tt.internalFormat,Tr,Kx,tt.colorSpace),Mr=k&&tt.isVideoTexture!==!0,_i=An.__version===void 0||Cn===!0,Ki=Tn.dataReady;let Jr=bt(tt,di,jr);Cx(I.TEXTURE_CUBE_MAP,tt,jr);let Ti;if(sr){Mr&&_i&&d.texStorage2D(I.TEXTURE_CUBE_MAP,Jr,Nx,di.width,di.height);for(let Bt=0;Bt<6;Bt++){Ti=Mn[Bt].mipmaps;for(let Gn=0;Gn<Ti.length;Gn++){const Xn=Ti[Gn];tt.format!==xa?Tr!==null?Mr?Ki&&d.compressedTexSubImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn,0,0,Xn.width,Xn.height,Tr,Xn.data):d.compressedTexImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn,Nx,Xn.width,Xn.height,0,Xn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Mr?Ki&&d.texSubImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn,0,0,Xn.width,Xn.height,Tr,Kx,Xn.data):d.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn,Nx,Xn.width,Xn.height,0,Tr,Kx,Xn.data)}}}else{Ti=tt.mipmaps,Mr&&_i&&(Ti.length>0&&Jr++,d.texStorage2D(I.TEXTURE_CUBE_MAP,Jr,Nx,Mn[0].width,Mn[0].height));for(let Bt=0;Bt<6;Bt++)if(Pr){Mr?Ki&&d.texSubImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,0,0,0,Mn[Bt].width,Mn[Bt].height,Tr,Kx,Mn[Bt].data):d.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,0,Nx,Mn[Bt].width,Mn[Bt].height,0,Tr,Kx,Mn[Bt].data);for(let Gn=0;Gn<Ti.length;Gn++){const Vx=Ti[Gn].image[Bt].image;Mr?Ki&&d.texSubImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn+1,0,0,Vx.width,Vx.height,Tr,Kx,Vx.data):d.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn+1,Nx,Vx.width,Vx.height,0,Tr,Kx,Vx.data)}}else{Mr?Ki&&d.texSubImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,0,0,0,Tr,Kx,Mn[Bt]):d.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,0,Nx,Tr,Kx,Mn[Bt]);for(let Gn=0;Gn<Ti.length;Gn++){const Xn=Ti[Gn];Mr?Ki&&d.texSubImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn+1,0,0,Tr,Kx,Xn.image[Bt]):d.texImage2D(I.TEXTURE_CUBE_MAP_POSITIVE_X+Bt,Gn+1,Nx,Tr,Kx,Xn.image[Bt])}}}Xe(tt,jr)&&Be(I.TEXTURE_CUBE_MAP),An.__version=Tn.version,tt.onUpdate&&tt.onUpdate(tt)}Tt.__version=tt.version}function Rx(Tt,tt,g0,Cn,Tn,An){const zx=_.convert(g0.format,g0.colorSpace),xx=_.convert(g0.type),Ax=Ke(g0.internalFormat,zx,xx,g0.colorSpace);if(!g.get(tt).__hasExternalTextures){const Pr=Math.max(1,tt.width>>An),Mn=Math.max(1,tt.height>>An);Tn===I.TEXTURE_3D||Tn===I.TEXTURE_2D_ARRAY?d.texImage3D(Tn,An,Ax,Pr,Mn,tt.depth,0,zx,xx,null):d.texImage2D(Tn,An,Ax,Pr,Mn,0,zx,xx,null)}d.bindFramebuffer(I.FRAMEBUFFER,Tt),rn(tt)?X.framebufferTexture2DMultisampleEXT(I.FRAMEBUFFER,Cn,Tn,g.get(g0).__webglTexture,0,Vn(tt)):(Tn===I.TEXTURE_2D||Tn>=I.TEXTURE_CUBE_MAP_POSITIVE_X&&Tn<=I.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&I.framebufferTexture2D(I.FRAMEBUFFER,Cn,Tn,g.get(g0).__webglTexture,An),d.bindFramebuffer(I.FRAMEBUFFER,null)}function Bx(Tt,tt,g0){if(I.bindRenderbuffer(I.RENDERBUFFER,Tt),tt.depthBuffer&&!tt.stencilBuffer){let Cn=k===!0?I.DEPTH_COMPONENT24:I.DEPTH_COMPONENT16;if(g0||rn(tt)){const Tn=tt.depthTexture;Tn&&Tn.isDepthTexture&&(Tn.type===Ts?Cn=I.DEPTH_COMPONENT32F:Tn.type===jo&&(Cn=I.DEPTH_COMPONENT24));const An=Vn(tt);rn(tt)?X.renderbufferStorageMultisampleEXT(I.RENDERBUFFER,An,Cn,tt.width,tt.height):I.renderbufferStorageMultisample(I.RENDERBUFFER,An,Cn,tt.width,tt.height)}else I.renderbufferStorage(I.RENDERBUFFER,Cn,tt.width,tt.height);I.framebufferRenderbuffer(I.FRAMEBUFFER,I.DEPTH_ATTACHMENT,I.RENDERBUFFER,Tt)}else if(tt.depthBuffer&&tt.stencilBuffer){const Cn=Vn(tt);g0&&rn(tt)===!1?I.renderbufferStorageMultisample(I.RENDERBUFFER,Cn,I.DEPTH24_STENCIL8,tt.width,tt.height):rn(tt)?X.renderbufferStorageMultisampleEXT(I.RENDERBUFFER,Cn,I.DEPTH24_STENCIL8,tt.width,tt.height):I.renderbufferStorage(I.RENDERBUFFER,I.DEPTH_STENCIL,tt.width,tt.height),I.framebufferRenderbuffer(I.FRAMEBUFFER,I.DEPTH_STENCIL_ATTACHMENT,I.RENDERBUFFER,Tt)}else{const Cn=tt.isWebGLMultipleRenderTargets===!0?tt.texture:[tt.texture];for(let Tn=0;Tn<Cn.length;Tn++){const An=Cn[Tn],zx=_.convert(An.format,An.colorSpace),xx=_.convert(An.type),Ax=Ke(An.internalFormat,zx,xx,An.colorSpace),sr=Vn(tt);g0&&rn(tt)===!1?I.renderbufferStorageMultisample(I.RENDERBUFFER,sr,Ax,tt.width,tt.height):rn(tt)?X.renderbufferStorageMultisampleEXT(I.RENDERBUFFER,sr,Ax,tt.width,tt.height):I.renderbufferStorage(I.RENDERBUFFER,Ax,tt.width,tt.height)}}I.bindRenderbuffer(I.RENDERBUFFER,null)}function Px(Tt,tt){if(tt&&tt.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(d.bindFramebuffer(I.FRAMEBUFFER,Tt),!(tt.depthTexture&&tt.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!g.get(tt.depthTexture).__webglTexture||tt.depthTexture.image.width!==tt.width||tt.depthTexture.image.height!==tt.height)&&(tt.depthTexture.image.width=tt.width,tt.depthTexture.image.height=tt.height,tt.depthTexture.needsUpdate=!0),Wt(tt.depthTexture,0);const Cn=g.get(tt.depthTexture).__webglTexture,Tn=Vn(tt);if(tt.depthTexture.format===d2)rn(tt)?X.framebufferTexture2DMultisampleEXT(I.FRAMEBUFFER,I.DEPTH_ATTACHMENT,I.TEXTURE_2D,Cn,0,Tn):I.framebufferTexture2D(I.FRAMEBUFFER,I.DEPTH_ATTACHMENT,I.TEXTURE_2D,Cn,0);else if(tt.depthTexture.format===B2)rn(tt)?X.framebufferTexture2DMultisampleEXT(I.FRAMEBUFFER,I.DEPTH_STENCIL_ATTACHMENT,I.TEXTURE_2D,Cn,0,Tn):I.framebufferTexture2D(I.FRAMEBUFFER,I.DEPTH_STENCIL_ATTACHMENT,I.TEXTURE_2D,Cn,0);else throw new Error("Unknown depthTexture format")}function xr(Tt){const tt=g.get(Tt),g0=Tt.isWebGLCubeRenderTarget===!0;if(Tt.depthTexture&&!tt.__autoAllocateDepthBuffer){if(g0)throw new Error("target.depthTexture not supported in Cube render targets");Px(tt.__webglFramebuffer,Tt)}else if(g0){tt.__webglDepthbuffer=[];for(let Cn=0;Cn<6;Cn++)d.bindFramebuffer(I.FRAMEBUFFER,tt.__webglFramebuffer[Cn]),tt.__webglDepthbuffer[Cn]=I.createRenderbuffer(),Bx(tt.__webglDepthbuffer[Cn],Tt,!1)}else d.bindFramebuffer(I.FRAMEBUFFER,tt.__webglFramebuffer),tt.__webglDepthbuffer=I.createRenderbuffer(),Bx(tt.__webglDepthbuffer,Tt,!1);d.bindFramebuffer(I.FRAMEBUFFER,null)}function Xx(Tt,tt,g0){const Cn=g.get(Tt);tt!==void 0&&Rx(Cn.__webglFramebuffer,Tt,Tt.texture,I.COLOR_ATTACHMENT0,I.TEXTURE_2D,0),g0!==void 0&&xr(Tt)}function zt(Tt){const tt=Tt.texture,g0=g.get(Tt),Cn=g.get(tt);Tt.addEventListener("dispose",Mt),Tt.isWebGLMultipleRenderTargets!==!0&&(Cn.__webglTexture===void 0&&(Cn.__webglTexture=I.createTexture()),Cn.__version=tt.version,R.memory.textures++);const Tn=Tt.isWebGLCubeRenderTarget===!0,An=Tt.isWebGLMultipleRenderTargets===!0,zx=be(Tt)||k;if(Tn){g0.__webglFramebuffer=[];for(let xx=0;xx<6;xx++)if(k&&tt.mipmaps&&tt.mipmaps.length>0){g0.__webglFramebuffer[xx]=[];for(let Ax=0;Ax<tt.mipmaps.length;Ax++)g0.__webglFramebuffer[xx][Ax]=I.createFramebuffer()}else g0.__webglFramebuffer[xx]=I.createFramebuffer()}else{if(k&&tt.mipmaps&&tt.mipmaps.length>0){g0.__webglFramebuffer=[];for(let xx=0;xx<tt.mipmaps.length;xx++)g0.__webglFramebuffer[xx]=I.createFramebuffer()}else g0.__webglFramebuffer=I.createFramebuffer();if(An)if(y.drawBuffers){const xx=Tt.texture;for(let Ax=0,sr=xx.length;Ax<sr;Ax++){const Pr=g.get(xx[Ax]);Pr.__webglTexture===void 0&&(Pr.__webglTexture=I.createTexture(),R.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(k&&Tt.samples>0&&rn(Tt)===!1){const xx=An?tt:[tt];g0.__webglMultisampledFramebuffer=I.createFramebuffer(),g0.__webglColorRenderbuffer=[],d.bindFramebuffer(I.FRAMEBUFFER,g0.__webglMultisampledFramebuffer);for(let Ax=0;Ax<xx.length;Ax++){const sr=xx[Ax];g0.__webglColorRenderbuffer[Ax]=I.createRenderbuffer(),I.bindRenderbuffer(I.RENDERBUFFER,g0.__webglColorRenderbuffer[Ax]);const Pr=_.convert(sr.format,sr.colorSpace),Mn=_.convert(sr.type),di=Ke(sr.internalFormat,Pr,Mn,sr.colorSpace,Tt.isXRRenderTarget===!0),jr=Vn(Tt);I.renderbufferStorageMultisample(I.RENDERBUFFER,jr,di,Tt.width,Tt.height),I.framebufferRenderbuffer(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0+Ax,I.RENDERBUFFER,g0.__webglColorRenderbuffer[Ax])}I.bindRenderbuffer(I.RENDERBUFFER,null),Tt.depthBuffer&&(g0.__webglDepthRenderbuffer=I.createRenderbuffer(),Bx(g0.__webglDepthRenderbuffer,Tt,!0)),d.bindFramebuffer(I.FRAMEBUFFER,null)}}if(Tn){d.bindTexture(I.TEXTURE_CUBE_MAP,Cn.__webglTexture),Cx(I.TEXTURE_CUBE_MAP,tt,zx);for(let xx=0;xx<6;xx++)if(k&&tt.mipmaps&&tt.mipmaps.length>0)for(let Ax=0;Ax<tt.mipmaps.length;Ax++)Rx(g0.__webglFramebuffer[xx][Ax],Tt,tt,I.COLOR_ATTACHMENT0,I.TEXTURE_CUBE_MAP_POSITIVE_X+xx,Ax);else Rx(g0.__webglFramebuffer[xx],Tt,tt,I.COLOR_ATTACHMENT0,I.TEXTURE_CUBE_MAP_POSITIVE_X+xx,0);Xe(tt,zx)&&Be(I.TEXTURE_CUBE_MAP),d.unbindTexture()}else if(An){const xx=Tt.texture;for(let Ax=0,sr=xx.length;Ax<sr;Ax++){const Pr=xx[Ax],Mn=g.get(Pr);d.bindTexture(I.TEXTURE_2D,Mn.__webglTexture),Cx(I.TEXTURE_2D,Pr,zx),Rx(g0.__webglFramebuffer,Tt,Pr,I.COLOR_ATTACHMENT0+Ax,I.TEXTURE_2D,0),Xe(Pr,zx)&&Be(I.TEXTURE_2D)}d.unbindTexture()}else{let xx=I.TEXTURE_2D;if((Tt.isWebGL3DRenderTarget||Tt.isWebGLArrayRenderTarget)&&(k?xx=Tt.isWebGL3DRenderTarget?I.TEXTURE_3D:I.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),d.bindTexture(xx,Cn.__webglTexture),Cx(xx,tt,zx),k&&tt.mipmaps&&tt.mipmaps.length>0)for(let Ax=0;Ax<tt.mipmaps.length;Ax++)Rx(g0.__webglFramebuffer[Ax],Tt,tt,I.COLOR_ATTACHMENT0,xx,Ax);else Rx(g0.__webglFramebuffer,Tt,tt,I.COLOR_ATTACHMENT0,xx,0);Xe(tt,zx)&&Be(xx),d.unbindTexture()}Tt.depthBuffer&&xr(Tt)}function Kn(Tt){const tt=be(Tt)||k,g0=Tt.isWebGLMultipleRenderTargets===!0?Tt.texture:[Tt.texture];for(let Cn=0,Tn=g0.length;Cn<Tn;Cn++){const An=g0[Cn];if(Xe(An,tt)){const zx=Tt.isWebGLCubeRenderTarget?I.TEXTURE_CUBE_MAP:I.TEXTURE_2D,xx=g.get(An).__webglTexture;d.bindTexture(zx,xx),Be(zx),d.unbindTexture()}}}function en(Tt){if(k&&Tt.samples>0&&rn(Tt)===!1){const tt=Tt.isWebGLMultipleRenderTargets?Tt.texture:[Tt.texture],g0=Tt.width,Cn=Tt.height;let Tn=I.COLOR_BUFFER_BIT;const An=[],zx=Tt.stencilBuffer?I.DEPTH_STENCIL_ATTACHMENT:I.DEPTH_ATTACHMENT,xx=g.get(Tt),Ax=Tt.isWebGLMultipleRenderTargets===!0;if(Ax)for(let sr=0;sr<tt.length;sr++)d.bindFramebuffer(I.FRAMEBUFFER,xx.__webglMultisampledFramebuffer),I.framebufferRenderbuffer(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0+sr,I.RENDERBUFFER,null),d.bindFramebuffer(I.FRAMEBUFFER,xx.__webglFramebuffer),I.framebufferTexture2D(I.DRAW_FRAMEBUFFER,I.COLOR_ATTACHMENT0+sr,I.TEXTURE_2D,null,0);d.bindFramebuffer(I.READ_FRAMEBUFFER,xx.__webglMultisampledFramebuffer),d.bindFramebuffer(I.DRAW_FRAMEBUFFER,xx.__webglFramebuffer);for(let sr=0;sr<tt.length;sr++){An.push(I.COLOR_ATTACHMENT0+sr),Tt.depthBuffer&&An.push(zx);const Pr=xx.__ignoreDepthValues!==void 0?xx.__ignoreDepthValues:!1;if(Pr===!1&&(Tt.depthBuffer&&(Tn|=I.DEPTH_BUFFER_BIT),Tt.stencilBuffer&&(Tn|=I.STENCIL_BUFFER_BIT)),Ax&&I.framebufferRenderbuffer(I.READ_FRAMEBUFFER,I.COLOR_ATTACHMENT0,I.RENDERBUFFER,xx.__webglColorRenderbuffer[sr]),Pr===!0&&(I.invalidateFramebuffer(I.READ_FRAMEBUFFER,[zx]),I.invalidateFramebuffer(I.DRAW_FRAMEBUFFER,[zx])),Ax){const Mn=g.get(tt[sr]).__webglTexture;I.framebufferTexture2D(I.DRAW_FRAMEBUFFER,I.COLOR_ATTACHMENT0,I.TEXTURE_2D,Mn,0)}I.blitFramebuffer(0,0,g0,Cn,0,0,g0,Cn,Tn,I.NEAREST),K&&I.invalidateFramebuffer(I.READ_FRAMEBUFFER,An)}if(d.bindFramebuffer(I.READ_FRAMEBUFFER,null),d.bindFramebuffer(I.DRAW_FRAMEBUFFER,null),Ax)for(let sr=0;sr<tt.length;sr++){d.bindFramebuffer(I.FRAMEBUFFER,xx.__webglMultisampledFramebuffer),I.framebufferRenderbuffer(I.FRAMEBUFFER,I.COLOR_ATTACHMENT0+sr,I.RENDERBUFFER,xx.__webglColorRenderbuffer[sr]);const Pr=g.get(tt[sr]).__webglTexture;d.bindFramebuffer(I.FRAMEBUFFER,xx.__webglFramebuffer),I.framebufferTexture2D(I.DRAW_FRAMEBUFFER,I.COLOR_ATTACHMENT0+sr,I.TEXTURE_2D,Pr,0)}d.bindFramebuffer(I.DRAW_FRAMEBUFFER,xx.__webglMultisampledFramebuffer)}}function Vn(Tt){return Math.min(y.maxSamples,Tt.samples)}function rn(Tt){const tt=g.get(Tt);return k&&Tt.samples>0&&r.has("WEBGL_multisampled_render_to_texture")===!0&&tt.__useRenderToTexture!==!1}function jx(Tt){const tt=R.render.frame;Q.get(Tt)!==tt&&(Q.set(Tt,tt),Tt.update())}function _x(Tt,tt){const g0=Tt.colorSpace,Cn=Tt.format,Tn=Tt.type;return Tt.isCompressedTexture===!0||Tt.isVideoTexture===!0||Tt.format===Cy||g0!==vx&&g0!==$n&&(Ci.getTransfer(g0)===dr?k===!1?r.has("EXT_sRGB")===!0&&Cn===xa?(Tt.format=Cy,Tt.minFilter=ui,Tt.generateMipmaps=!1):tt=Gb.sRGBToLinear(tt):(Cn!==xa||Tn!==Ao)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",g0)),tt}this.allocateTextureUnit=Pt,this.resetTextureUnits=V0,this.setTexture2D=Wt,this.setTexture2DArray=an,this.setTexture3D=W0,this.setTextureCube=j0,this.rebindTextures=Xx,this.setupRenderTarget=zt,this.updateRenderTargetMipmap=Kn,this.updateMultisampleRenderTarget=en,this.setupDepthRenderbuffer=xr,this.setupFrameBufferTexture=Rx,this.useMultisampledRTT=rn}function jN(I,r,d){const g=d.isWebGL2;function y(_,R=$n){let k;const X=Ci.getTransfer(R);if(_===Ao)return I.UNSIGNED_BYTE;if(_===eu)return I.UNSIGNED_SHORT_4_4_4_4;if(_===Kc)return I.UNSIGNED_SHORT_5_5_5_1;if(_===Al)return I.BYTE;if(_===Gs)return I.SHORT;if(_===Ac)return I.UNSIGNED_SHORT;if(_===r2)return I.INT;if(_===jo)return I.UNSIGNED_INT;if(_===Ts)return I.FLOAT;if(_===Xi)return g?I.HALF_FLOAT:(k=r.get("OES_texture_half_float"),k!==null?k.HALF_FLOAT_OES:null);if(_===xh)return I.ALPHA;if(_===xa)return I.RGBA;if(_===rh)return I.LUMINANCE;if(_===uh)return I.LUMINANCE_ALPHA;if(_===d2)return I.DEPTH_COMPONENT;if(_===B2)return I.DEPTH_STENCIL;if(_===Cy)return k=r.get("EXT_sRGB"),k!==null?k.SRGB_ALPHA_EXT:null;if(_===dh)return I.RED;if(_===xu)return I.RED_INTEGER;if(_===ru)return I.RG;if(_===uu)return I.RG_INTEGER;if(_===du)return I.RGBA_INTEGER;if(_===$c||_===Jc||_===Ua||_===z2)if(X===dr)if(k=r.get("WEBGL_compressed_texture_s3tc_srgb"),k!==null){if(_===$c)return k.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(_===Jc)return k.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(_===Ua)return k.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(_===z2)return k.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(k=r.get("WEBGL_compressed_texture_s3tc"),k!==null){if(_===$c)return k.COMPRESSED_RGB_S3TC_DXT1_EXT;if(_===Jc)return k.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(_===Ua)return k.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(_===z2)return k.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(_===Ml||_===Cl||_===ra||_===g2)if(k=r.get("WEBGL_compressed_texture_pvrtc"),k!==null){if(_===Ml)return k.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(_===Cl)return k.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(_===ra)return k.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(_===g2)return k.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(_===et)return k=r.get("WEBGL_compressed_texture_etc1"),k!==null?k.COMPRESSED_RGB_ETC1_WEBGL:null;if(_===Je||_===Nt)if(k=r.get("WEBGL_compressed_texture_etc"),k!==null){if(_===Je)return X===dr?k.COMPRESSED_SRGB8_ETC2:k.COMPRESSED_RGB8_ETC2;if(_===Nt)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:k.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(_===_0||_===Ue||_===ze||_===We||_===_t||_===jt||_===e0||_===u0||_===Jt||_===B0||_===dn||_===zn||_===Jn||_===Wx)if(k=r.get("WEBGL_compressed_texture_astc"),k!==null){if(_===_0)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:k.COMPRESSED_RGBA_ASTC_4x4_KHR;if(_===Ue)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:k.COMPRESSED_RGBA_ASTC_5x4_KHR;if(_===ze)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:k.COMPRESSED_RGBA_ASTC_5x5_KHR;if(_===We)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:k.COMPRESSED_RGBA_ASTC_6x5_KHR;if(_===_t)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:k.COMPRESSED_RGBA_ASTC_6x6_KHR;if(_===jt)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:k.COMPRESSED_RGBA_ASTC_8x5_KHR;if(_===e0)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:k.COMPRESSED_RGBA_ASTC_8x6_KHR;if(_===u0)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:k.COMPRESSED_RGBA_ASTC_8x8_KHR;if(_===Jt)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:k.COMPRESSED_RGBA_ASTC_10x5_KHR;if(_===B0)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:k.COMPRESSED_RGBA_ASTC_10x6_KHR;if(_===dn)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:k.COMPRESSED_RGBA_ASTC_10x8_KHR;if(_===zn)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:k.COMPRESSED_RGBA_ASTC_10x10_KHR;if(_===Jn)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:k.COMPRESSED_RGBA_ASTC_12x10_KHR;if(_===Wx)return X===dr?k.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:k.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(_===br||_===Qr||_===gr)if(k=r.get("EXT_texture_compression_bptc"),k!==null){if(_===br)return X===dr?k.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:k.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(_===Qr)return k.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(_===gr)return k.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(_===Qi||_===es||_===Xs||_===ji)if(k=r.get("EXT_texture_compression_rgtc"),k!==null){if(_===br)return k.COMPRESSED_RED_RGTC1_EXT;if(_===es)return k.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(_===Xs)return k.COMPRESSED_RED_GREEN_RGTC2_EXT;if(_===ji)return k.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return _===u2?g?I.UNSIGNED_INT_24_8:(k=r.get("WEBGL_depth_texture"),k!==null?k.UNSIGNED_INT_24_8_WEBGL:null):I[_]!==void 0?I[_]:null}return{convert:y}}class KN extends ua{constructor(r=[]){super(),this.isArrayCamera=!0,this.cameras=r}}class jl extends xs{constructor(){super(),this.isGroup=!0,this.type="Group"}}const $N={type:"move"};class N1{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new jl,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new jl,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new ut,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new ut),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new jl,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new ut,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new ut),this._grip}dispatchEvent(r){return this._targetRay!==null&&this._targetRay.dispatchEvent(r),this._grip!==null&&this._grip.dispatchEvent(r),this._hand!==null&&this._hand.dispatchEvent(r),this}connect(r){if(r&&r.hand){const d=this._hand;if(d)for(const g of r.hand.values())this._getHandJoint(d,g)}return this.dispatchEvent({type:"connected",data:r}),this}disconnect(r){return this.dispatchEvent({type:"disconnected",data:r}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(r,d,g){let y=null,_=null,R=null;const k=this._targetRay,X=this._grip,K=this._hand;if(r&&d.session.visibilityState!=="visible-blurred"){if(K&&r.hand){R=!0;for(const Re of r.hand.values()){const be=d.getJointPose(Re,g),ve=this._getHandJoint(K,Re);be!==null&&(ve.matrix.fromArray(be.transform.matrix),ve.matrix.decompose(ve.position,ve.rotation,ve.scale),ve.matrixWorldNeedsUpdate=!0,ve.jointRadius=be.radius),ve.visible=be!==null}const Q=K.joints["index-finger-tip"],xe=K.joints["thumb-tip"],ue=Q.position.distanceTo(xe.position),ge=.02,_e=.005;K.inputState.pinching&&ue>ge+_e?(K.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:r.handedness,target:this})):!K.inputState.pinching&&ue<=ge-_e&&(K.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:r.handedness,target:this}))}else X!==null&&r.gripSpace&&(_=d.getPose(r.gripSpace,g),_!==null&&(X.matrix.fromArray(_.transform.matrix),X.matrix.decompose(X.position,X.rotation,X.scale),X.matrixWorldNeedsUpdate=!0,_.linearVelocity?(X.hasLinearVelocity=!0,X.linearVelocity.copy(_.linearVelocity)):X.hasLinearVelocity=!1,_.angularVelocity?(X.hasAngularVelocity=!0,X.angularVelocity.copy(_.angularVelocity)):X.hasAngularVelocity=!1));k!==null&&(y=d.getPose(r.targetRaySpace,g),y===null&&_!==null&&(y=_),y!==null&&(k.matrix.fromArray(y.transform.matrix),k.matrix.decompose(k.position,k.rotation,k.scale),k.matrixWorldNeedsUpdate=!0,y.linearVelocity?(k.hasLinearVelocity=!0,k.linearVelocity.copy(y.linearVelocity)):k.hasLinearVelocity=!1,y.angularVelocity?(k.hasAngularVelocity=!0,k.angularVelocity.copy(y.angularVelocity)):k.hasAngularVelocity=!1,this.dispatchEvent($N)))}return k!==null&&(k.visible=y!==null),X!==null&&(X.visible=_!==null),K!==null&&(K.visible=R!==null),this}_getHandJoint(r,d){if(r.joints[d.jointName]===void 0){const g=new jl;g.matrixAutoUpdate=!1,g.visible=!1,r.joints[d.jointName]=g,r.add(g)}return r.joints[d.jointName]}}const JN=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,WN=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class QN{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(r,d,g){if(this.texture===null){const y=new Ks,_=r.properties.get(y);_.__webglTexture=d.texture,(d.depthNear!=g.depthNear||d.depthFar!=g.depthFar)&&(this.depthNear=d.depthNear,this.depthFar=d.depthFar),this.texture=y}}render(r,d){if(this.texture!==null){if(this.mesh===null){const g=d.cameras[0].viewport,y=new Xl({extensions:{fragDepth:!0},vertexShader:JN,fragmentShader:WN,uniforms:{depthColor:{value:this.texture},depthWidth:{value:g.z},depthHeight:{value:g.w}}});this.mesh=new Bs(new bp(20,20),y)}r.render(this.mesh,d)}}reset(){this.texture=null,this.mesh=null}}class eL extends Md{constructor(r,d){super();const g=this;let y=null,_=1,R=null,k="local-floor",X=1,K=null,Q=null,xe=null,ue=null,ge=null,_e=null;const Re=new QN,be=d.getContextAttributes();let ve=null,Xe=null;const Be=[],Ke=[],bt=new vn;let rt=null;const xt=new ua;xt.layers.enable(1),xt.viewport=new Vi;const Mt=new ua;Mt.layers.enable(2),Mt.viewport=new Vi;const $t=[xt,Mt],$e=new KN;$e.layers.enable(1),$e.layers.enable(2);let vt=null,M0=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(R0){let _n=Be[R0];return _n===void 0&&(_n=new N1,Be[R0]=_n),_n.getTargetRaySpace()},this.getControllerGrip=function(R0){let _n=Be[R0];return _n===void 0&&(_n=new N1,Be[R0]=_n),_n.getGripSpace()},this.getHand=function(R0){let _n=Be[R0];return _n===void 0&&(_n=new N1,Be[R0]=_n),_n.getHandSpace()};function V0(R0){const _n=Ke.indexOf(R0.inputSource);if(_n===-1)return;const ux=Be[_n];ux!==void 0&&(ux.update(R0.inputSource,R0.frame,K||R),ux.dispatchEvent({type:R0.type,data:R0.inputSource}))}function Pt(){y.removeEventListener("select",V0),y.removeEventListener("selectstart",V0),y.removeEventListener("selectend",V0),y.removeEventListener("squeeze",V0),y.removeEventListener("squeezestart",V0),y.removeEventListener("squeezeend",V0),y.removeEventListener("end",Pt),y.removeEventListener("inputsourceschange",x0);for(let R0=0;R0<Be.length;R0++){const _n=Ke[R0];_n!==null&&(Ke[R0]=null,Be[R0].disconnect(_n))}vt=null,M0=null,Re.reset(),r.setRenderTarget(ve),ge=null,ue=null,xe=null,y=null,Xe=null,Cx.stop(),g.isPresenting=!1,r.setPixelRatio(rt),r.setSize(bt.width,bt.height,!1),g.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(R0){_=R0,g.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(R0){k=R0,g.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return K||R},this.setReferenceSpace=function(R0){K=R0},this.getBaseLayer=function(){return ue!==null?ue:ge},this.getBinding=function(){return xe},this.getFrame=function(){return _e},this.getSession=function(){return y},this.setSession=async function(R0){if(y=R0,y!==null){if(ve=r.getRenderTarget(),y.addEventListener("select",V0),y.addEventListener("selectstart",V0),y.addEventListener("selectend",V0),y.addEventListener("squeeze",V0),y.addEventListener("squeezestart",V0),y.addEventListener("squeezeend",V0),y.addEventListener("end",Pt),y.addEventListener("inputsourceschange",x0),be.xrCompatible!==!0&&await d.makeXRCompatible(),rt=r.getPixelRatio(),r.getSize(bt),y.renderState.layers===void 0||r.capabilities.isWebGL2===!1){const _n={antialias:y.renderState.layers===void 0?be.antialias:!0,alpha:!0,depth:be.depth,stencil:be.stencil,framebufferScaleFactor:_};ge=new XRWebGLLayer(y,d,_n),y.updateRenderState({baseLayer:ge}),r.setPixelRatio(1),r.setSize(ge.framebufferWidth,ge.framebufferHeight,!1),Xe=new Th(ge.framebufferWidth,ge.framebufferHeight,{format:xa,type:Ao,colorSpace:r.outputColorSpace,stencilBuffer:be.stencil})}else{let _n=null,ux=null,Rx=null;be.depth&&(Rx=be.stencil?d.DEPTH24_STENCIL8:d.DEPTH_COMPONENT24,_n=be.stencil?B2:d2,ux=be.stencil?u2:jo);const Bx={colorFormat:d.RGBA8,depthFormat:Rx,scaleFactor:_};xe=new XRWebGLBinding(y,d),ue=xe.createProjectionLayer(Bx),y.updateRenderState({layers:[ue]}),r.setPixelRatio(1),r.setSize(ue.textureWidth,ue.textureHeight,!1),Xe=new Th(ue.textureWidth,ue.textureHeight,{format:xa,type:Ao,depthTexture:new __(ue.textureWidth,ue.textureHeight,ux,void 0,void 0,void 0,void 0,void 0,void 0,_n),stencilBuffer:be.stencil,colorSpace:r.outputColorSpace,samples:be.antialias?4:0});const Px=r.properties.get(Xe);Px.__ignoreDepthValues=ue.ignoreDepthValues}Xe.isXRRenderTarget=!0,this.setFoveation(X),K=null,R=await y.requestReferenceSpace(k),Cx.setContext(y),Cx.start(),g.isPresenting=!0,g.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(y!==null)return y.environmentBlendMode};function x0(R0){for(let _n=0;_n<R0.removed.length;_n++){const ux=R0.removed[_n],Rx=Ke.indexOf(ux);Rx>=0&&(Ke[Rx]=null,Be[Rx].disconnect(ux))}for(let _n=0;_n<R0.added.length;_n++){const ux=R0.added[_n];let Rx=Ke.indexOf(ux);if(Rx===-1){for(let Px=0;Px<Be.length;Px++)if(Px>=Ke.length){Ke.push(ux),Rx=Px;break}else if(Ke[Px]===null){Ke[Px]=ux,Rx=Px;break}if(Rx===-1)break}const Bx=Be[Rx];Bx&&Bx.connect(ux)}}const Wt=new ut,an=new ut;function W0(R0,_n,ux){Wt.setFromMatrixPosition(_n.matrixWorld),an.setFromMatrixPosition(ux.matrixWorld);const Rx=Wt.distanceTo(an),Bx=_n.projectionMatrix.elements,Px=ux.projectionMatrix.elements,xr=Bx[14]/(Bx[10]-1),Xx=Bx[14]/(Bx[10]+1),zt=(Bx[9]+1)/Bx[5],Kn=(Bx[9]-1)/Bx[5],en=(Bx[8]-1)/Bx[0],Vn=(Px[8]+1)/Px[0],rn=xr*en,jx=xr*Vn,_x=Rx/(-en+Vn),Tt=_x*-en;_n.matrixWorld.decompose(R0.position,R0.quaternion,R0.scale),R0.translateX(Tt),R0.translateZ(_x),R0.matrixWorld.compose(R0.position,R0.quaternion,R0.scale),R0.matrixWorldInverse.copy(R0.matrixWorld).invert();const tt=xr+_x,g0=Xx+_x,Cn=rn-Tt,Tn=jx+(Rx-Tt),An=zt*Xx/g0*tt,zx=Kn*Xx/g0*tt;R0.projectionMatrix.makePerspective(Cn,Tn,An,zx,tt,g0),R0.projectionMatrixInverse.copy(R0.projectionMatrix).invert()}function j0(R0,_n){_n===null?R0.matrixWorld.copy(R0.matrix):R0.matrixWorld.multiplyMatrices(_n.matrixWorld,R0.matrix),R0.matrixWorldInverse.copy(R0.matrixWorld).invert()}this.updateCamera=function(R0){if(y===null)return;Re.texture!==null&&(R0.near=Re.depthNear,R0.far=Re.depthFar),$e.near=Mt.near=xt.near=R0.near,$e.far=Mt.far=xt.far=R0.far,(vt!==$e.near||M0!==$e.far)&&(y.updateRenderState({depthNear:$e.near,depthFar:$e.far}),vt=$e.near,M0=$e.far,xt.near=vt,xt.far=M0,Mt.near=vt,Mt.far=M0,xt.updateProjectionMatrix(),Mt.updateProjectionMatrix(),R0.updateProjectionMatrix());const _n=R0.parent,ux=$e.cameras;j0($e,_n);for(let Rx=0;Rx<ux.length;Rx++)j0(ux[Rx],_n);ux.length===2?W0($e,xt,Mt):$e.projectionMatrix.copy(xt.projectionMatrix),un(R0,$e,_n)};function un(R0,_n,ux){ux===null?R0.matrix.copy(_n.matrixWorld):(R0.matrix.copy(ux.matrixWorld),R0.matrix.invert(),R0.matrix.multiply(_n.matrixWorld)),R0.matrix.decompose(R0.position,R0.quaternion,R0.scale),R0.updateMatrixWorld(!0),R0.projectionMatrix.copy(_n.projectionMatrix),R0.projectionMatrixInverse.copy(_n.projectionMatrixInverse),R0.isPerspectiveCamera&&(R0.fov=Cd*2*Math.atan(1/R0.projectionMatrix.elements[5]),R0.zoom=1)}this.getCamera=function(){return $e},this.getFoveation=function(){if(!(ue===null&&ge===null))return X},this.setFoveation=function(R0){X=R0,ue!==null&&(ue.fixedFoveation=R0),ge!==null&&ge.fixedFoveation!==void 0&&(ge.fixedFoveation=R0)},this.hasDepthSensing=function(){return Re.texture!==null};let bn=null;function ex(R0,_n){if(Q=_n.getViewerPose(K||R),_e=_n,Q!==null){const ux=Q.views;ge!==null&&(r.setRenderTargetFramebuffer(Xe,ge.framebuffer),r.setRenderTarget(Xe));let Rx=!1;ux.length!==$e.cameras.length&&($e.cameras.length=0,Rx=!0);for(let Px=0;Px<ux.length;Px++){const xr=ux[Px];let Xx=null;if(ge!==null)Xx=ge.getViewport(xr);else{const Kn=xe.getViewSubImage(ue,xr);Xx=Kn.viewport,Px===0&&(r.setRenderTargetTextures(Xe,Kn.colorTexture,ue.ignoreDepthValues?void 0:Kn.depthStencilTexture),r.setRenderTarget(Xe))}let zt=$t[Px];zt===void 0&&(zt=new ua,zt.layers.enable(Px),zt.viewport=new Vi,$t[Px]=zt),zt.matrix.fromArray(xr.transform.matrix),zt.matrix.decompose(zt.position,zt.quaternion,zt.scale),zt.projectionMatrix.fromArray(xr.projectionMatrix),zt.projectionMatrixInverse.copy(zt.projectionMatrix).invert(),zt.viewport.set(Xx.x,Xx.y,Xx.width,Xx.height),Px===0&&($e.matrix.copy(zt.matrix),$e.matrix.decompose($e.position,$e.quaternion,$e.scale)),Rx===!0&&$e.cameras.push(zt)}const Bx=y.enabledFeatures;if(Bx&&Bx.includes("depth-sensing")){const Px=xe.getDepthInformation(ux[0]);Px&&Px.isValid&&Px.texture&&Re.init(r,Px,y.renderState)}}for(let ux=0;ux<Be.length;ux++){const Rx=Ke[ux],Bx=Be[ux];Rx!==null&&Bx!==void 0&&Bx.update(Rx,_n,K||R)}Re.render(r,$e),bn&&bn(R0,_n),_n.detectedPlanes&&g.dispatchEvent({type:"planesdetected",data:_n}),_e=null}const Cx=new d_;Cx.setAnimationLoop(ex),this.setAnimationLoop=function(R0){bn=R0},this.dispose=function(){}}}function xL(I,r){function d(be,ve){be.matrixAutoUpdate===!0&&be.updateMatrix(),ve.value.copy(be.matrix)}function g(be,ve){ve.color.getRGB(be.fogColor.value,l_(I)),ve.isFog?(be.fogNear.value=ve.near,be.fogFar.value=ve.far):ve.isFogExp2&&(be.fogDensity.value=ve.density)}function y(be,ve,Xe,Be,Ke){ve.isMeshBasicMaterial||ve.isMeshLambertMaterial?_(be,ve):ve.isMeshToonMaterial?(_(be,ve),xe(be,ve)):ve.isMeshPhongMaterial?(_(be,ve),Q(be,ve)):ve.isMeshStandardMaterial?(_(be,ve),ue(be,ve),ve.isMeshPhysicalMaterial&&ge(be,ve,Ke)):ve.isMeshMatcapMaterial?(_(be,ve),_e(be,ve)):ve.isMeshDepthMaterial?_(be,ve):ve.isMeshDistanceMaterial?(_(be,ve),Re(be,ve)):ve.isMeshNormalMaterial?_(be,ve):ve.isLineBasicMaterial?(R(be,ve),ve.isLineDashedMaterial&&k(be,ve)):ve.isPointsMaterial?X(be,ve,Xe,Be):ve.isSpriteMaterial?K(be,ve):ve.isShadowMaterial?(be.color.value.copy(ve.color),be.opacity.value=ve.opacity):ve.isShaderMaterial&&(ve.uniformsNeedUpdate=!1)}function _(be,ve){be.opacity.value=ve.opacity,ve.color&&be.diffuse.value.copy(ve.color),ve.emissive&&be.emissive.value.copy(ve.emissive).multiplyScalar(ve.emissiveIntensity),ve.map&&(be.map.value=ve.map,d(ve.map,be.mapTransform)),ve.alphaMap&&(be.alphaMap.value=ve.alphaMap,d(ve.alphaMap,be.alphaMapTransform)),ve.bumpMap&&(be.bumpMap.value=ve.bumpMap,d(ve.bumpMap,be.bumpMapTransform),be.bumpScale.value=ve.bumpScale,ve.side===vs&&(be.bumpScale.value*=-1)),ve.normalMap&&(be.normalMap.value=ve.normalMap,d(ve.normalMap,be.normalMapTransform),be.normalScale.value.copy(ve.normalScale),ve.side===vs&&be.normalScale.value.negate()),ve.displacementMap&&(be.displacementMap.value=ve.displacementMap,d(ve.displacementMap,be.displacementMapTransform),be.displacementScale.value=ve.displacementScale,be.displacementBias.value=ve.displacementBias),ve.emissiveMap&&(be.emissiveMap.value=ve.emissiveMap,d(ve.emissiveMap,be.emissiveMapTransform)),ve.specularMap&&(be.specularMap.value=ve.specularMap,d(ve.specularMap,be.specularMapTransform)),ve.alphaTest>0&&(be.alphaTest.value=ve.alphaTest);const Xe=r.get(ve).envMap;if(Xe&&(be.envMap.value=Xe,be.flipEnvMap.value=Xe.isCubeTexture&&Xe.isRenderTargetTexture===!1?-1:1,be.reflectivity.value=ve.reflectivity,be.ior.value=ve.ior,be.refractionRatio.value=ve.refractionRatio),ve.lightMap){be.lightMap.value=ve.lightMap;const Be=I._useLegacyLights===!0?Math.PI:1;be.lightMapIntensity.value=ve.lightMapIntensity*Be,d(ve.lightMap,be.lightMapTransform)}ve.aoMap&&(be.aoMap.value=ve.aoMap,be.aoMapIntensity.value=ve.aoMapIntensity,d(ve.aoMap,be.aoMapTransform))}function R(be,ve){be.diffuse.value.copy(ve.color),be.opacity.value=ve.opacity,ve.map&&(be.map.value=ve.map,d(ve.map,be.mapTransform))}function k(be,ve){be.dashSize.value=ve.dashSize,be.totalSize.value=ve.dashSize+ve.gapSize,be.scale.value=ve.scale}function X(be,ve,Xe,Be){be.diffuse.value.copy(ve.color),be.opacity.value=ve.opacity,be.size.value=ve.size*Xe,be.scale.value=Be*.5,ve.map&&(be.map.value=ve.map,d(ve.map,be.uvTransform)),ve.alphaMap&&(be.alphaMap.value=ve.alphaMap,d(ve.alphaMap,be.alphaMapTransform)),ve.alphaTest>0&&(be.alphaTest.value=ve.alphaTest)}function K(be,ve){be.diffuse.value.copy(ve.color),be.opacity.value=ve.opacity,be.rotation.value=ve.rotation,ve.map&&(be.map.value=ve.map,d(ve.map,be.mapTransform)),ve.alphaMap&&(be.alphaMap.value=ve.alphaMap,d(ve.alphaMap,be.alphaMapTransform)),ve.alphaTest>0&&(be.alphaTest.value=ve.alphaTest)}function Q(be,ve){be.specular.value.copy(ve.specular),be.shininess.value=Math.max(ve.shininess,1e-4)}function xe(be,ve){ve.gradientMap&&(be.gradientMap.value=ve.gradientMap)}function ue(be,ve){be.metalness.value=ve.metalness,ve.metalnessMap&&(be.metalnessMap.value=ve.metalnessMap,d(ve.metalnessMap,be.metalnessMapTransform)),be.roughness.value=ve.roughness,ve.roughnessMap&&(be.roughnessMap.value=ve.roughnessMap,d(ve.roughnessMap,be.roughnessMapTransform)),r.get(ve).envMap&&(be.envMapIntensity.value=ve.envMapIntensity)}function ge(be,ve,Xe){be.ior.value=ve.ior,ve.sheen>0&&(be.sheenColor.value.copy(ve.sheenColor).multiplyScalar(ve.sheen),be.sheenRoughness.value=ve.sheenRoughness,ve.sheenColorMap&&(be.sheenColorMap.value=ve.sheenColorMap,d(ve.sheenColorMap,be.sheenColorMapTransform)),ve.sheenRoughnessMap&&(be.sheenRoughnessMap.value=ve.sheenRoughnessMap,d(ve.sheenRoughnessMap,be.sheenRoughnessMapTransform))),ve.clearcoat>0&&(be.clearcoat.value=ve.clearcoat,be.clearcoatRoughness.value=ve.clearcoatRoughness,ve.clearcoatMap&&(be.clearcoatMap.value=ve.clearcoatMap,d(ve.clearcoatMap,be.clearcoatMapTransform)),ve.clearcoatRoughnessMap&&(be.clearcoatRoughnessMap.value=ve.clearcoatRoughnessMap,d(ve.clearcoatRoughnessMap,be.clearcoatRoughnessMapTransform)),ve.clearcoatNormalMap&&(be.clearcoatNormalMap.value=ve.clearcoatNormalMap,d(ve.clearcoatNormalMap,be.clearcoatNormalMapTransform),be.clearcoatNormalScale.value.copy(ve.clearcoatNormalScale),ve.side===vs&&be.clearcoatNormalScale.value.negate())),ve.iridescence>0&&(be.iridescence.value=ve.iridescence,be.iridescenceIOR.value=ve.iridescenceIOR,be.iridescenceThicknessMinimum.value=ve.iridescenceThicknessRange[0],be.iridescenceThicknessMaximum.value=ve.iridescenceThicknessRange[1],ve.iridescenceMap&&(be.iridescenceMap.value=ve.iridescenceMap,d(ve.iridescenceMap,be.iridescenceMapTransform)),ve.iridescenceThicknessMap&&(be.iridescenceThicknessMap.value=ve.iridescenceThicknessMap,d(ve.iridescenceThicknessMap,be.iridescenceThicknessMapTransform))),ve.transmission>0&&(be.transmission.value=ve.transmission,be.transmissionSamplerMap.value=Xe.texture,be.transmissionSamplerSize.value.set(Xe.width,Xe.height),ve.transmissionMap&&(be.transmissionMap.value=ve.transmissionMap,d(ve.transmissionMap,be.transmissionMapTransform)),be.thickness.value=ve.thickness,ve.thicknessMap&&(be.thicknessMap.value=ve.thicknessMap,d(ve.thicknessMap,be.thicknessMapTransform)),be.attenuationDistance.value=ve.attenuationDistance,be.attenuationColor.value.copy(ve.attenuationColor)),ve.anisotropy>0&&(be.anisotropyVector.value.set(ve.anisotropy*Math.cos(ve.anisotropyRotation),ve.anisotropy*Math.sin(ve.anisotropyRotation)),ve.anisotropyMap&&(be.anisotropyMap.value=ve.anisotropyMap,d(ve.anisotropyMap,be.anisotropyMapTransform))),be.specularIntensity.value=ve.specularIntensity,be.specularColor.value.copy(ve.specularColor),ve.specularColorMap&&(be.specularColorMap.value=ve.specularColorMap,d(ve.specularColorMap,be.specularColorMapTransform)),ve.specularIntensityMap&&(be.specularIntensityMap.value=ve.specularIntensityMap,d(ve.specularIntensityMap,be.specularIntensityMapTransform))}function _e(be,ve){ve.matcap&&(be.matcap.value=ve.matcap)}function Re(be,ve){const Xe=r.get(ve).light;be.referencePosition.value.setFromMatrixPosition(Xe.matrixWorld),be.nearDistance.value=Xe.shadow.camera.near,be.farDistance.value=Xe.shadow.camera.far}return{refreshFogUniforms:g,refreshMaterialUniforms:y}}function rL(I,r,d,g){let y={},_={},R=[];const k=d.isWebGL2?I.getParameter(I.MAX_UNIFORM_BUFFER_BINDINGS):0;function X(Xe,Be){const Ke=Be.program;g.uniformBlockBinding(Xe,Ke)}function K(Xe,Be){let Ke=y[Xe.id];Ke===void 0&&(_e(Xe),Ke=Q(Xe),y[Xe.id]=Ke,Xe.addEventListener("dispose",be));const bt=Be.program;g.updateUBOMapping(Xe,bt);const rt=r.render.frame;_[Xe.id]!==rt&&(ue(Xe),_[Xe.id]=rt)}function Q(Xe){const Be=xe();Xe.__bindingPointIndex=Be;const Ke=I.createBuffer(),bt=Xe.__size,rt=Xe.usage;return I.bindBuffer(I.UNIFORM_BUFFER,Ke),I.bufferData(I.UNIFORM_BUFFER,bt,rt),I.bindBuffer(I.UNIFORM_BUFFER,null),I.bindBufferBase(I.UNIFORM_BUFFER,Be,Ke),Ke}function xe(){for(let Xe=0;Xe<k;Xe++)if(R.indexOf(Xe)===-1)return R.push(Xe),Xe;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function ue(Xe){const Be=y[Xe.id],Ke=Xe.uniforms,bt=Xe.__cache;I.bindBuffer(I.UNIFORM_BUFFER,Be);for(let rt=0,xt=Ke.length;rt<xt;rt++){const Mt=Array.isArray(Ke[rt])?Ke[rt]:[Ke[rt]];for(let $t=0,$e=Mt.length;$t<$e;$t++){const vt=Mt[$t];if(ge(vt,rt,$t,bt)===!0){const M0=vt.__offset,V0=Array.isArray(vt.value)?vt.value:[vt.value];let Pt=0;for(let x0=0;x0<V0.length;x0++){const Wt=V0[x0],an=Re(Wt);typeof Wt=="number"||typeof Wt=="boolean"?(vt.__data[0]=Wt,I.bufferSubData(I.UNIFORM_BUFFER,M0+Pt,vt.__data)):Wt.isMatrix3?(vt.__data[0]=Wt.elements[0],vt.__data[1]=Wt.elements[1],vt.__data[2]=Wt.elements[2],vt.__data[3]=0,vt.__data[4]=Wt.elements[3],vt.__data[5]=Wt.elements[4],vt.__data[6]=Wt.elements[5],vt.__data[7]=0,vt.__data[8]=Wt.elements[6],vt.__data[9]=Wt.elements[7],vt.__data[10]=Wt.elements[8],vt.__data[11]=0):(Wt.toArray(vt.__data,Pt),Pt+=an.storage/Float32Array.BYTES_PER_ELEMENT)}I.bufferSubData(I.UNIFORM_BUFFER,M0,vt.__data)}}}I.bindBuffer(I.UNIFORM_BUFFER,null)}function ge(Xe,Be,Ke,bt){const rt=Xe.value,xt=Be+"_"+Ke;if(bt[xt]===void 0)return typeof rt=="number"||typeof rt=="boolean"?bt[xt]=rt:bt[xt]=rt.clone(),!0;{const Mt=bt[xt];if(typeof rt=="number"||typeof rt=="boolean"){if(Mt!==rt)return bt[xt]=rt,!0}else if(Mt.equals(rt)===!1)return Mt.copy(rt),!0}return!1}function _e(Xe){const Be=Xe.uniforms;let Ke=0;const bt=16;for(let xt=0,Mt=Be.length;xt<Mt;xt++){const $t=Array.isArray(Be[xt])?Be[xt]:[Be[xt]];for(let $e=0,vt=$t.length;$e<vt;$e++){const M0=$t[$e],V0=Array.isArray(M0.value)?M0.value:[M0.value];for(let Pt=0,x0=V0.length;Pt<x0;Pt++){const Wt=V0[Pt],an=Re(Wt),W0=Ke%bt;W0!==0&&bt-W0<an.boundary&&(Ke+=bt-W0),M0.__data=new Float32Array(an.storage/Float32Array.BYTES_PER_ELEMENT),M0.__offset=Ke,Ke+=an.storage}}}const rt=Ke%bt;return rt>0&&(Ke+=bt-rt),Xe.__size=Ke,Xe.__cache={},this}function Re(Xe){const Be={boundary:0,storage:0};return typeof Xe=="number"||typeof Xe=="boolean"?(Be.boundary=4,Be.storage=4):Xe.isVector2?(Be.boundary=8,Be.storage=8):Xe.isVector3||Xe.isColor?(Be.boundary=16,Be.storage=12):Xe.isVector4?(Be.boundary=16,Be.storage=16):Xe.isMatrix3?(Be.boundary=48,Be.storage=48):Xe.isMatrix4?(Be.boundary=64,Be.storage=64):Xe.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",Xe),Be}function be(Xe){const Be=Xe.target;Be.removeEventListener("dispose",be);const Ke=R.indexOf(Be.__bindingPointIndex);R.splice(Ke,1),I.deleteBuffer(y[Be.id]),delete y[Be.id],delete _[Be.id]}function ve(){for(const Xe in y)I.deleteBuffer(y[Xe]);R=[],y={},_={}}return{bind:X,update:K,dispose:ve}}class q_{constructor(r={}){const{canvas:d=RE(),context:g=null,depth:y=!0,stencil:_=!0,alpha:R=!1,antialias:k=!1,premultipliedAlpha:X=!0,preserveDrawingBuffer:K=!1,powerPreference:Q="default",failIfMajorPerformanceCaveat:xe=!1}=r;this.isWebGLRenderer=!0;let ue;g!==null?ue=g.getContextAttributes().alpha:ue=R;const ge=new Uint32Array(4),_e=new Int32Array(4);let Re=null,be=null;const ve=[],Xe=[];this.domElement=d,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=jn,this._useLegacyLights=!1,this.toneMapping=Ma,this.toneMappingExposure=1;const Be=this;let Ke=!1,bt=0,rt=0,xt=null,Mt=-1,$t=null;const $e=new Vi,vt=new Vi;let M0=null;const V0=new bx(0);let Pt=0,x0=d.width,Wt=d.height,an=1,W0=null,j0=null;const un=new Vi(0,0,x0,Wt),bn=new Vi(0,0,x0,Wt);let ex=!1;const Cx=new Wm;let R0=!1,_n=!1,ux=null;const Rx=new ur,Bx=new vn,Px=new ut,xr={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Xx(){return xt===null?an:1}let zt=g;function Kn(At,v0){for(let P0=0;P0<At.length;P0++){const G0=At[P0],N0=d.getContext(G0,v0);if(N0!==null)return N0}return null}try{const At={alpha:!0,depth:y,stencil:_,antialias:k,premultipliedAlpha:X,preserveDrawingBuffer:K,powerPreference:Q,failIfMajorPerformanceCaveat:xe};if("setAttribute"in d&&d.setAttribute("data-engine",`three.js r${Rs}`),d.addEventListener("webglcontextlost",Ti,!1),d.addEventListener("webglcontextrestored",Bt,!1),d.addEventListener("webglcontextcreationerror",Gn,!1),zt===null){const v0=["webgl2","webgl","experimental-webgl"];if(Be.isWebGL1Renderer===!0&&v0.shift(),zt=Kn(v0,At),zt===null)throw Kn(v0)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&zt instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),zt.getShaderPrecisionFormat===void 0&&(zt.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(At){throw console.error("THREE.WebGLRenderer: "+At.message),At}let en,Vn,rn,jx,_x,Tt,tt,g0,Cn,Tn,An,zx,xx,Ax,sr,Pr,Mn,di,jr,Tr,Kx,Nx,Mr,_i;function Ki(){en=new PI(zt),Vn=new TI(zt,en,r),en.init(Vn),Nx=new jN(zt,en,Vn),rn=new GN(zt,en,Vn),jx=new VI(zt),_x=new _N,Tt=new XN(zt,en,rn,_x,Vn,Nx,jx),tt=new MI(Be),g0=new NI(Be),Cn=new AA(zt,Vn),Mr=new bI(zt,en,Cn,Vn),Tn=new BI(zt,Cn,jx,Mr),An=new jI(zt,Tn,Cn,jx),jr=new XI(zt,Vn,Tt),Pr=new AI(_x),zx=new bN(Be,tt,g0,en,Vn,Mr,Pr),xx=new xL(Be,_x),Ax=new AN,sr=new BN(en,Vn),di=new vI(Be,tt,g0,rn,An,ue,X),Mn=new UN(Be,An,Vn),_i=new rL(zt,jx,Vn,rn),Tr=new _I(zt,en,jx,Vn),Kx=new zI(zt,en,jx,Vn),jx.programs=zx.programs,Be.capabilities=Vn,Be.extensions=en,Be.properties=_x,Be.renderLists=Ax,Be.shadowMap=Mn,Be.state=rn,Be.info=jx}Ki();const Jr=new eL(Be,zt);this.xr=Jr,this.getContext=function(){return zt},this.getContextAttributes=function(){return zt.getContextAttributes()},this.forceContextLoss=function(){const At=en.get("WEBGL_lose_context");At&&At.loseContext()},this.forceContextRestore=function(){const At=en.get("WEBGL_lose_context");At&&At.restoreContext()},this.getPixelRatio=function(){return an},this.setPixelRatio=function(At){At!==void 0&&(an=At,this.setSize(x0,Wt,!1))},this.getSize=function(At){return At.set(x0,Wt)},this.setSize=function(At,v0,P0=!0){if(Jr.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}x0=At,Wt=v0,d.width=Math.floor(At*an),d.height=Math.floor(v0*an),P0===!0&&(d.style.width=At+"px",d.style.height=v0+"px"),this.setViewport(0,0,At,v0)},this.getDrawingBufferSize=function(At){return At.set(x0*an,Wt*an).floor()},this.setDrawingBufferSize=function(At,v0,P0){x0=At,Wt=v0,an=P0,d.width=Math.floor(At*P0),d.height=Math.floor(v0*P0),this.setViewport(0,0,At,v0)},this.getCurrentViewport=function(At){return At.copy($e)},this.getViewport=function(At){return At.copy(un)},this.setViewport=function(At,v0,P0,G0){At.isVector4?un.set(At.x,At.y,At.z,At.w):un.set(At,v0,P0,G0),rn.viewport($e.copy(un).multiplyScalar(an).floor())},this.getScissor=function(At){return At.copy(bn)},this.setScissor=function(At,v0,P0,G0){At.isVector4?bn.set(At.x,At.y,At.z,At.w):bn.set(At,v0,P0,G0),rn.scissor(vt.copy(bn).multiplyScalar(an).floor())},this.getScissorTest=function(){return ex},this.setScissorTest=function(At){rn.setScissorTest(ex=At)},this.setOpaqueSort=function(At){W0=At},this.setTransparentSort=function(At){j0=At},this.getClearColor=function(At){return At.copy(di.getClearColor())},this.setClearColor=function(){di.setClearColor.apply(di,arguments)},this.getClearAlpha=function(){return di.getClearAlpha()},this.setClearAlpha=function(){di.setClearAlpha.apply(di,arguments)},this.clear=function(At=!0,v0=!0,P0=!0){let G0=0;if(At){let N0=!1;if(xt!==null){const Mx=xt.texture.format;N0=Mx===du||Mx===uu||Mx===xu}if(N0){const Mx=xt.texture.type,$x=Mx===Ao||Mx===jo||Mx===Ac||Mx===u2||Mx===eu||Mx===Kc,vr=di.getClearColor(),Ar=di.getClearAlpha(),Kr=vr.r,zr=vr.g,Vr=vr.b;$x?(ge[0]=Kr,ge[1]=zr,ge[2]=Vr,ge[3]=Ar,zt.clearBufferuiv(zt.COLOR,0,ge)):(_e[0]=Kr,_e[1]=zr,_e[2]=Vr,_e[3]=Ar,zt.clearBufferiv(zt.COLOR,0,_e))}else G0|=zt.COLOR_BUFFER_BIT}v0&&(G0|=zt.DEPTH_BUFFER_BIT),P0&&(G0|=zt.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),zt.clear(G0)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){d.removeEventListener("webglcontextlost",Ti,!1),d.removeEventListener("webglcontextrestored",Bt,!1),d.removeEventListener("webglcontextcreationerror",Gn,!1),Ax.dispose(),sr.dispose(),_x.dispose(),tt.dispose(),g0.dispose(),An.dispose(),Mr.dispose(),_i.dispose(),zx.dispose(),Jr.dispose(),Jr.removeEventListener("sessionstart",Jo),Jr.removeEventListener("sessionend",Ai),ux&&(ux.dispose(),ux=null),Na.stop()};function Ti(At){At.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),Ke=!0}function Bt(){console.log("THREE.WebGLRenderer: Context Restored."),Ke=!1;const At=jx.autoReset,v0=Mn.enabled,P0=Mn.autoUpdate,G0=Mn.needsUpdate,N0=Mn.type;Ki(),jx.autoReset=At,Mn.enabled=v0,Mn.autoUpdate=P0,Mn.needsUpdate=G0,Mn.type=N0}function Gn(At){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",At.statusMessage)}function Xn(At){const v0=At.target;v0.removeEventListener("dispose",Xn),Vx(v0)}function Vx(At){Qx(At),_x.remove(At)}function Qx(At){const v0=_x.get(At).programs;v0!==void 0&&(v0.forEach(function(P0){zx.releaseProgram(P0)}),At.isShaderMaterial&&zx.releaseShaderCache(At))}this.renderBufferDirect=function(At,v0,P0,G0,N0,Mx){v0===null&&(v0=xr);const $x=N0.isMesh&&N0.matrixWorld.determinant()<0,vr=_6(At,v0,P0,G0,N0);rn.setMaterial(G0,$x);let Ar=P0.index,Kr=1;if(G0.wireframe===!0){if(Ar=Tn.getWireframeAttribute(P0),Ar===void 0)return;Kr=2}const zr=P0.drawRange,Vr=P0.attributes.position;let Vs=zr.start*Kr,M2=(zr.start+zr.count)*Kr;Mx!==null&&(Vs=Math.max(Vs,Mx.start*Kr),M2=Math.min(M2,(Mx.start+Mx.count)*Kr)),Ar!==null?(Vs=Math.max(Vs,0),M2=Math.min(M2,Ar.count)):Vr!=null&&(Vs=Math.max(Vs,0),M2=Math.min(M2,Vr.count));const Pa=M2-Vs;if(Pa<0||Pa===1/0)return;Mr.setup(N0,G0,vr,P0,Ar);let Wl,gs=Tr;if(Ar!==null&&(Wl=Cn.get(Ar),gs=Kx,gs.setIndex(Wl)),N0.isMesh)G0.wireframe===!0?(rn.setLineWidth(G0.wireframeLinewidth*Xx()),gs.setMode(zt.LINES)):gs.setMode(zt.TRIANGLES);else if(N0.isLine){let Wr=G0.linewidth;Wr===void 0&&(Wr=1),rn.setLineWidth(Wr*Xx()),N0.isLineSegments?gs.setMode(zt.LINES):N0.isLineLoop?gs.setMode(zt.LINE_LOOP):gs.setMode(zt.LINE_STRIP)}else N0.isPoints?gs.setMode(zt.POINTS):N0.isSprite&&gs.setMode(zt.TRIANGLES);if(N0.isBatchedMesh)gs.renderMultiDraw(N0._multiDrawStarts,N0._multiDrawCounts,N0._multiDrawCount);else if(N0.isInstancedMesh)gs.renderInstances(Vs,Pa,N0.count);else if(P0.isInstancedBufferGeometry){const Wr=P0._maxInstanceCount!==void 0?P0._maxInstanceCount:1/0,Tb=Math.min(P0.instanceCount,Wr);gs.renderInstances(Vs,Pa,Tb)}else gs.render(Vs,Pa)};function bi(At,v0,P0){At.transparent===!0&&At.side===Ba&&At.forceSinglePass===!1?(At.side=vs,At.needsUpdate=!0,My(At,v0,P0),At.side=Ta,At.needsUpdate=!0,My(At,v0,P0),At.side=Ba):My(At,v0,P0)}this.compile=function(At,v0,P0=null){P0===null&&(P0=At),be=sr.get(P0),be.init(),Xe.push(be),P0.traverseVisible(function(N0){N0.isLight&&N0.layers.test(v0.layers)&&(be.pushLight(N0),N0.castShadow&&be.pushShadow(N0))}),At!==P0&&At.traverseVisible(function(N0){N0.isLight&&N0.layers.test(v0.layers)&&(be.pushLight(N0),N0.castShadow&&be.pushShadow(N0))}),be.setupLights(Be._useLegacyLights);const G0=new Set;return At.traverse(function(N0){const Mx=N0.material;if(Mx)if(Array.isArray(Mx))for(let $x=0;$x<Mx.length;$x++){const vr=Mx[$x];bi(vr,P0,N0),G0.add(vr)}else bi(Mx,P0,N0),G0.add(Mx)}),Xe.pop(),be=null,G0},this.compileAsync=function(At,v0,P0=null){const G0=this.compile(At,v0,P0);return new Promise(N0=>{function Mx(){if(G0.forEach(function($x){_x.get($x).currentProgram.isReady()&&G0.delete($x)}),G0.size===0){N0(At);return}setTimeout(Mx,10)}en.get("KHR_parallel_shader_compile")!==null?Mx():setTimeout(Mx,10)})};let Ni=null;function va(At){Ni&&Ni(At)}function Jo(){Na.stop()}function Ai(){Na.start()}const Na=new d_;Na.setAnimationLoop(va),typeof self<"u"&&Na.setContext(self),this.setAnimationLoop=function(At){Ni=At,Jr.setAnimationLoop(At),At===null?Na.stop():Na.start()},Jr.addEventListener("sessionstart",Jo),Jr.addEventListener("sessionend",Ai),this.render=function(At,v0){if(v0!==void 0&&v0.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(Ke===!0)return;At.matrixWorldAutoUpdate===!0&&At.updateMatrixWorld(),v0.parent===null&&v0.matrixWorldAutoUpdate===!0&&v0.updateMatrixWorld(),Jr.enabled===!0&&Jr.isPresenting===!0&&(Jr.cameraAutoUpdate===!0&&Jr.updateCamera(v0),v0=Jr.getCamera()),At.isScene===!0&&At.onBeforeRender(Be,At,v0,xt),be=sr.get(At,Xe.length),be.init(),Xe.push(be),Rx.multiplyMatrices(v0.projectionMatrix,v0.matrixWorldInverse),Cx.setFromProjectionMatrix(Rx),_n=this.localClippingEnabled,R0=Pr.init(this.clippingPlanes,_n),Re=Ax.get(At,ve.length),Re.init(),ve.push(Re),$2(At,v0,0,Be.sortObjects),Re.finish(),Be.sortObjects===!0&&Re.sort(W0,j0),this.info.render.frame++,R0===!0&&Pr.beginShadows();const P0=be.state.shadowsArray;if(Mn.render(P0,At,v0),R0===!0&&Pr.endShadows(),this.info.autoReset===!0&&this.info.reset(),(Jr.enabled===!1||Jr.isPresenting===!1||Jr.hasDepthSensing()===!1)&&di.render(Re,At),be.setupLights(Be._useLegacyLights),v0.isArrayCamera){const G0=v0.cameras;for(let N0=0,Mx=G0.length;N0<Mx;N0++){const $x=G0[N0];Ay(Re,At,$x,$x.viewport)}}else Ay(Re,At,v0);xt!==null&&(Tt.updateMultisampleRenderTarget(xt),Tt.updateRenderTargetMipmap(xt)),At.isScene===!0&&At.onAfterRender(Be,At,v0),Mr.resetDefaultState(),Mt=-1,$t=null,Xe.pop(),Xe.length>0?be=Xe[Xe.length-1]:be=null,ve.pop(),ve.length>0?Re=ve[ve.length-1]:Re=null};function $2(At,v0,P0,G0){if(At.visible===!1)return;if(At.layers.test(v0.layers)){if(At.isGroup)P0=At.renderOrder;else if(At.isLOD)At.autoUpdate===!0&&At.update(v0);else if(At.isLight)be.pushLight(At),At.castShadow&&be.pushShadow(At);else if(At.isSprite){if(!At.frustumCulled||Cx.intersectsSprite(At)){G0&&Px.setFromMatrixPosition(At.matrixWorld).applyMatrix4(Rx);const $x=An.update(At),vr=At.material;vr.visible&&Re.push(At,$x,vr,P0,Px.z,null)}}else if((At.isMesh||At.isLine||At.isPoints)&&(!At.frustumCulled||Cx.intersectsObject(At))){const $x=An.update(At),vr=At.material;if(G0&&(At.boundingSphere!==void 0?(At.boundingSphere===null&&At.computeBoundingSphere(),Px.copy(At.boundingSphere.center)):($x.boundingSphere===null&&$x.computeBoundingSphere(),Px.copy($x.boundingSphere.center)),Px.applyMatrix4(At.matrixWorld).applyMatrix4(Rx)),Array.isArray(vr)){const Ar=$x.groups;for(let Kr=0,zr=Ar.length;Kr<zr;Kr++){const Vr=Ar[Kr],Vs=vr[Vr.materialIndex];Vs&&Vs.visible&&Re.push(At,$x,Vs,P0,Px.z,Vr)}}else vr.visible&&Re.push(At,$x,vr,P0,Px.z,null)}}const Mx=At.children;for(let $x=0,vr=Mx.length;$x<vr;$x++)$2(Mx[$x],v0,P0,G0)}function Ay(At,v0,P0,G0){const N0=At.opaque,Mx=At.transmissive,$x=At.transparent;be.setupLightsView(P0),R0===!0&&Pr.setGlobalState(Be.clippingPlanes,P0),Mx.length>0&&Uu(N0,Mx,v0,P0),G0&&rn.viewport($e.copy(G0)),N0.length>0&&zc(N0,v0,P0),Mx.length>0&&zc(Mx,v0,P0),$x.length>0&&zc($x,v0,P0),rn.buffers.depth.setTest(!0),rn.buffers.depth.setMask(!0),rn.buffers.color.setMask(!0),rn.setPolygonOffset(!1)}function Uu(At,v0,P0,G0){if((P0.isScene===!0?P0.overrideMaterial:null)!==null)return;const Mx=Vn.isWebGL2;ux===null&&(ux=new Th(1,1,{generateMipmaps:!0,type:en.has("EXT_color_buffer_half_float")?Xi:Ao,minFilter:Us,samples:Mx?4:0})),Be.getDrawingBufferSize(Bx),Mx?ux.setSize(Bx.x,Bx.y):ux.setSize(um(Bx.x),um(Bx.y));const $x=Be.getRenderTarget();Be.setRenderTarget(ux),Be.getClearColor(V0),Pt=Be.getClearAlpha(),Pt<1&&Be.setClearColor(16777215,.5),Be.clear();const vr=Be.toneMapping;Be.toneMapping=Ma,zc(At,P0,G0),Tt.updateMultisampleRenderTarget(ux),Tt.updateRenderTargetMipmap(ux);let Ar=!1;for(let Kr=0,zr=v0.length;Kr<zr;Kr++){const Vr=v0[Kr],Vs=Vr.object,M2=Vr.geometry,Pa=Vr.material,Wl=Vr.group;if(Pa.side===Ba&&Vs.layers.test(G0.layers)){const gs=Pa.side;Pa.side=vs,Pa.needsUpdate=!0,Wf(Vs,P0,G0,M2,Pa,Wl),Pa.side=gs,Pa.needsUpdate=!0,Ar=!0}}Ar===!0&&(Tt.updateMultisampleRenderTarget(ux),Tt.updateRenderTargetMipmap(ux)),Be.setRenderTarget($x),Be.setClearColor(V0,Pt),Be.toneMapping=vr}function zc(At,v0,P0){const G0=v0.isScene===!0?v0.overrideMaterial:null;for(let N0=0,Mx=At.length;N0<Mx;N0++){const $x=At[N0],vr=$x.object,Ar=$x.geometry,Kr=G0===null?$x.material:G0,zr=$x.group;vr.layers.test(P0.layers)&&Wf(vr,v0,P0,Ar,Kr,zr)}}function Wf(At,v0,P0,G0,N0,Mx){At.onBeforeRender(Be,v0,P0,G0,N0,Mx),At.modelViewMatrix.multiplyMatrices(P0.matrixWorldInverse,At.matrixWorld),At.normalMatrix.getNormalMatrix(At.modelViewMatrix),N0.onBeforeRender(Be,v0,P0,G0,At,Mx),N0.transparent===!0&&N0.side===Ba&&N0.forceSinglePass===!1?(N0.side=vs,N0.needsUpdate=!0,Be.renderBufferDirect(P0,v0,G0,N0,At,Mx),N0.side=Ta,N0.needsUpdate=!0,Be.renderBufferDirect(P0,v0,G0,N0,At,Mx),N0.side=Ba):Be.renderBufferDirect(P0,v0,G0,N0,At,Mx),At.onAfterRender(Be,v0,P0,G0,N0,Mx)}function My(At,v0,P0){v0.isScene!==!0&&(v0=xr);const G0=_x.get(At),N0=be.state.lights,Mx=be.state.shadowsArray,$x=N0.state.version,vr=zx.getParameters(At,N0.state,Mx,v0,P0),Ar=zx.getProgramCacheKey(vr);let Kr=G0.programs;G0.environment=At.isMeshStandardMaterial?v0.environment:null,G0.fog=v0.fog,G0.envMap=(At.isMeshStandardMaterial?g0:tt).get(At.envMap||G0.environment),Kr===void 0&&(At.addEventListener("dispose",Xn),Kr=new Map,G0.programs=Kr);let zr=Kr.get(Ar);if(zr!==void 0){if(G0.currentProgram===zr&&G0.lightsStateVersion===$x)return PT(At,vr),zr}else vr.uniforms=zx.getUniforms(At),At.onBuild(P0,vr,Be),At.onBeforeCompile(vr,Be),zr=zx.acquireProgram(vr,Ar),Kr.set(Ar,zr),G0.uniforms=vr.uniforms;const Vr=G0.uniforms;return(!At.isShaderMaterial&&!At.isRawShaderMaterial||At.clipping===!0)&&(Vr.clippingPlanes=Pr.uniform),PT(At,vr),G0.needsLights=A6(At),G0.lightsStateVersion=$x,G0.needsLights&&(Vr.ambientLightColor.value=N0.state.ambient,Vr.lightProbe.value=N0.state.probe,Vr.directionalLights.value=N0.state.directional,Vr.directionalLightShadows.value=N0.state.directionalShadow,Vr.spotLights.value=N0.state.spot,Vr.spotLightShadows.value=N0.state.spotShadow,Vr.rectAreaLights.value=N0.state.rectArea,Vr.ltc_1.value=N0.state.rectAreaLTC1,Vr.ltc_2.value=N0.state.rectAreaLTC2,Vr.pointLights.value=N0.state.point,Vr.pointLightShadows.value=N0.state.pointShadow,Vr.hemisphereLights.value=N0.state.hemi,Vr.directionalShadowMap.value=N0.state.directionalShadowMap,Vr.directionalShadowMatrix.value=N0.state.directionalShadowMatrix,Vr.spotShadowMap.value=N0.state.spotShadowMap,Vr.spotLightMatrix.value=N0.state.spotLightMatrix,Vr.spotLightMap.value=N0.state.spotLightMap,Vr.pointShadowMap.value=N0.state.pointShadowMap,Vr.pointShadowMatrix.value=N0.state.pointShadowMatrix),G0.currentProgram=zr,G0.uniformsList=null,zr}function NT(At){if(At.uniformsList===null){const v0=At.currentProgram.getUniforms();At.uniformsList=rg.seqWithValue(v0.seq,At.uniforms)}return At.uniformsList}function PT(At,v0){const P0=_x.get(At);P0.outputColorSpace=v0.outputColorSpace,P0.batching=v0.batching,P0.instancing=v0.instancing,P0.instancingColor=v0.instancingColor,P0.skinning=v0.skinning,P0.morphTargets=v0.morphTargets,P0.morphNormals=v0.morphNormals,P0.morphColors=v0.morphColors,P0.morphTargetsCount=v0.morphTargetsCount,P0.numClippingPlanes=v0.numClippingPlanes,P0.numIntersection=v0.numClipIntersection,P0.vertexAlphas=v0.vertexAlphas,P0.vertexTangents=v0.vertexTangents,P0.toneMapping=v0.toneMapping}function _6(At,v0,P0,G0,N0){v0.isScene!==!0&&(v0=xr),Tt.resetTextureUnits();const Mx=v0.fog,$x=G0.isMeshStandardMaterial?v0.environment:null,vr=xt===null?Be.outputColorSpace:xt.isXRRenderTarget===!0?xt.texture.colorSpace:vx,Ar=(G0.isMeshStandardMaterial?g0:tt).get(G0.envMap||$x),Kr=G0.vertexColors===!0&&!!P0.attributes.color&&P0.attributes.color.itemSize===4,zr=!!P0.attributes.tangent&&(!!G0.normalMap||G0.anisotropy>0),Vr=!!P0.morphAttributes.position,Vs=!!P0.morphAttributes.normal,M2=!!P0.morphAttributes.color;let Pa=Ma;G0.toneMapped&&(xt===null||xt.isXRRenderTarget===!0)&&(Pa=Be.toneMapping);const Wl=P0.morphAttributes.position||P0.morphAttributes.normal||P0.morphAttributes.color,gs=Wl!==void 0?Wl.length:0,Wr=_x.get(G0),Tb=be.state.lights;if(R0===!0&&(_n===!0||At!==$t)){const J2=At===$t&&G0.id===Mt;Pr.setState(G0,At,J2)}let Cs=!1;G0.version===Wr.__version?(Wr.needsLights&&Wr.lightsStateVersion!==Tb.state.version||Wr.outputColorSpace!==vr||N0.isBatchedMesh&&Wr.batching===!1||!N0.isBatchedMesh&&Wr.batching===!0||N0.isInstancedMesh&&Wr.instancing===!1||!N0.isInstancedMesh&&Wr.instancing===!0||N0.isSkinnedMesh&&Wr.skinning===!1||!N0.isSkinnedMesh&&Wr.skinning===!0||N0.isInstancedMesh&&Wr.instancingColor===!0&&N0.instanceColor===null||N0.isInstancedMesh&&Wr.instancingColor===!1&&N0.instanceColor!==null||Wr.envMap!==Ar||G0.fog===!0&&Wr.fog!==Mx||Wr.numClippingPlanes!==void 0&&(Wr.numClippingPlanes!==Pr.numPlanes||Wr.numIntersection!==Pr.numIntersection)||Wr.vertexAlphas!==Kr||Wr.vertexTangents!==zr||Wr.morphTargets!==Vr||Wr.morphNormals!==Vs||Wr.morphColors!==M2||Wr.toneMapping!==Pa||Vn.isWebGL2===!0&&Wr.morphTargetsCount!==gs)&&(Cs=!0):(Cs=!0,Wr.__version=G0.version);let dd=Wr.currentProgram;Cs===!0&&(dd=My(G0,v0,N0));let BT=!1,Jp=!1,Ab=!1;const ro=dd.getUniforms(),gd=Wr.uniforms;if(rn.useProgram(dd.program)&&(BT=!0,Jp=!0,Ab=!0),G0.id!==Mt&&(Mt=G0.id,Jp=!0),BT||$t!==At){ro.setValue(zt,"projectionMatrix",At.projectionMatrix),ro.setValue(zt,"viewMatrix",At.matrixWorldInverse);const J2=ro.map.cameraPosition;J2!==void 0&&J2.setValue(zt,Px.setFromMatrixPosition(At.matrixWorld)),Vn.logarithmicDepthBuffer&&ro.setValue(zt,"logDepthBufFC",2/(Math.log(At.far+1)/Math.LN2)),(G0.isMeshPhongMaterial||G0.isMeshToonMaterial||G0.isMeshLambertMaterial||G0.isMeshBasicMaterial||G0.isMeshStandardMaterial||G0.isShaderMaterial)&&ro.setValue(zt,"isOrthographic",At.isOrthographicCamera===!0),$t!==At&&($t=At,Jp=!0,Ab=!0)}if(N0.isSkinnedMesh){ro.setOptional(zt,N0,"bindMatrix"),ro.setOptional(zt,N0,"bindMatrixInverse");const J2=N0.skeleton;J2&&(Vn.floatVertexTextures?(J2.boneTexture===null&&J2.computeBoneTexture(),ro.setValue(zt,"boneTexture",J2.boneTexture,Tt)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}N0.isBatchedMesh&&(ro.setOptional(zt,N0,"batchingTexture"),ro.setValue(zt,"batchingTexture",N0._matricesTexture,Tt));const Mb=P0.morphAttributes;if((Mb.position!==void 0||Mb.normal!==void 0||Mb.color!==void 0&&Vn.isWebGL2===!0)&&jr.update(N0,P0,dd),(Jp||Wr.receiveShadow!==N0.receiveShadow)&&(Wr.receiveShadow=N0.receiveShadow,ro.setValue(zt,"receiveShadow",N0.receiveShadow)),G0.isMeshGouraudMaterial&&G0.envMap!==null&&(gd.envMap.value=Ar,gd.flipEnvMap.value=Ar.isCubeTexture&&Ar.isRenderTargetTexture===!1?-1:1),Jp&&(ro.setValue(zt,"toneMappingExposure",Be.toneMappingExposure),Wr.needsLights&&T6(gd,Ab),Mx&&G0.fog===!0&&xx.refreshFogUniforms(gd,Mx),xx.refreshMaterialUniforms(gd,G0,an,Wt,ux),rg.upload(zt,NT(Wr),gd,Tt)),G0.isShaderMaterial&&G0.uniformsNeedUpdate===!0&&(rg.upload(zt,NT(Wr),gd,Tt),G0.uniformsNeedUpdate=!1),G0.isSpriteMaterial&&ro.setValue(zt,"center",N0.center),ro.setValue(zt,"modelViewMatrix",N0.modelViewMatrix),ro.setValue(zt,"normalMatrix",N0.normalMatrix),ro.setValue(zt,"modelMatrix",N0.matrixWorld),G0.isShaderMaterial||G0.isRawShaderMaterial){const J2=G0.uniformsGroups;for(let Cb=0,M6=J2.length;Cb<M6;Cb++)if(Vn.isWebGL2){const zT=J2[Cb];_i.update(zT,dd),_i.bind(zT,dd)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return dd}function T6(At,v0){At.ambientLightColor.needsUpdate=v0,At.lightProbe.needsUpdate=v0,At.directionalLights.needsUpdate=v0,At.directionalLightShadows.needsUpdate=v0,At.pointLights.needsUpdate=v0,At.pointLightShadows.needsUpdate=v0,At.spotLights.needsUpdate=v0,At.spotLightShadows.needsUpdate=v0,At.rectAreaLights.needsUpdate=v0,At.hemisphereLights.needsUpdate=v0}function A6(At){return At.isMeshLambertMaterial||At.isMeshToonMaterial||At.isMeshPhongMaterial||At.isMeshStandardMaterial||At.isShadowMaterial||At.isShaderMaterial&&At.lights===!0}this.getActiveCubeFace=function(){return bt},this.getActiveMipmapLevel=function(){return rt},this.getRenderTarget=function(){return xt},this.setRenderTargetTextures=function(At,v0,P0){_x.get(At.texture).__webglTexture=v0,_x.get(At.depthTexture).__webglTexture=P0;const G0=_x.get(At);G0.__hasExternalTextures=!0,G0.__hasExternalTextures&&(G0.__autoAllocateDepthBuffer=P0===void 0,G0.__autoAllocateDepthBuffer||en.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),G0.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(At,v0){const P0=_x.get(At);P0.__webglFramebuffer=v0,P0.__useDefaultFramebuffer=v0===void 0},this.setRenderTarget=function(At,v0=0,P0=0){xt=At,bt=v0,rt=P0;let G0=!0,N0=null,Mx=!1,$x=!1;if(At){const Ar=_x.get(At);Ar.__useDefaultFramebuffer!==void 0?(rn.bindFramebuffer(zt.FRAMEBUFFER,null),G0=!1):Ar.__webglFramebuffer===void 0?Tt.setupRenderTarget(At):Ar.__hasExternalTextures&&Tt.rebindTextures(At,_x.get(At.texture).__webglTexture,_x.get(At.depthTexture).__webglTexture);const Kr=At.texture;(Kr.isData3DTexture||Kr.isDataArrayTexture||Kr.isCompressedArrayTexture)&&($x=!0);const zr=_x.get(At).__webglFramebuffer;At.isWebGLCubeRenderTarget?(Array.isArray(zr[v0])?N0=zr[v0][P0]:N0=zr[v0],Mx=!0):Vn.isWebGL2&&At.samples>0&&Tt.useMultisampledRTT(At)===!1?N0=_x.get(At).__webglMultisampledFramebuffer:Array.isArray(zr)?N0=zr[P0]:N0=zr,$e.copy(At.viewport),vt.copy(At.scissor),M0=At.scissorTest}else $e.copy(un).multiplyScalar(an).floor(),vt.copy(bn).multiplyScalar(an).floor(),M0=ex;if(rn.bindFramebuffer(zt.FRAMEBUFFER,N0)&&Vn.drawBuffers&&G0&&rn.drawBuffers(At,N0),rn.viewport($e),rn.scissor(vt),rn.setScissorTest(M0),Mx){const Ar=_x.get(At.texture);zt.framebufferTexture2D(zt.FRAMEBUFFER,zt.COLOR_ATTACHMENT0,zt.TEXTURE_CUBE_MAP_POSITIVE_X+v0,Ar.__webglTexture,P0)}else if($x){const Ar=_x.get(At.texture),Kr=v0||0;zt.framebufferTextureLayer(zt.FRAMEBUFFER,zt.COLOR_ATTACHMENT0,Ar.__webglTexture,P0||0,Kr)}Mt=-1},this.readRenderTargetPixels=function(At,v0,P0,G0,N0,Mx,$x){if(!(At&&At.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let vr=_x.get(At).__webglFramebuffer;if(At.isWebGLCubeRenderTarget&&$x!==void 0&&(vr=vr[$x]),vr){rn.bindFramebuffer(zt.FRAMEBUFFER,vr);try{const Ar=At.texture,Kr=Ar.format,zr=Ar.type;if(Kr!==xa&&Nx.convert(Kr)!==zt.getParameter(zt.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Vr=zr===Xi&&(en.has("EXT_color_buffer_half_float")||Vn.isWebGL2&&en.has("EXT_color_buffer_float"));if(zr!==Ao&&Nx.convert(zr)!==zt.getParameter(zt.IMPLEMENTATION_COLOR_READ_TYPE)&&!(zr===Ts&&(Vn.isWebGL2||en.has("OES_texture_float")||en.has("WEBGL_color_buffer_float")))&&!Vr){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}v0>=0&&v0<=At.width-G0&&P0>=0&&P0<=At.height-N0&&zt.readPixels(v0,P0,G0,N0,Nx.convert(Kr),Nx.convert(zr),Mx)}finally{const Ar=xt!==null?_x.get(xt).__webglFramebuffer:null;rn.bindFramebuffer(zt.FRAMEBUFFER,Ar)}}},this.copyFramebufferToTexture=function(At,v0,P0=0){const G0=Math.pow(2,-P0),N0=Math.floor(v0.image.width*G0),Mx=Math.floor(v0.image.height*G0);Tt.setTexture2D(v0,0),zt.copyTexSubImage2D(zt.TEXTURE_2D,P0,0,0,At.x,At.y,N0,Mx),rn.unbindTexture()},this.copyTextureToTexture=function(At,v0,P0,G0=0){const N0=v0.image.width,Mx=v0.image.height,$x=Nx.convert(P0.format),vr=Nx.convert(P0.type);Tt.setTexture2D(P0,0),zt.pixelStorei(zt.UNPACK_FLIP_Y_WEBGL,P0.flipY),zt.pixelStorei(zt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,P0.premultiplyAlpha),zt.pixelStorei(zt.UNPACK_ALIGNMENT,P0.unpackAlignment),v0.isDataTexture?zt.texSubImage2D(zt.TEXTURE_2D,G0,At.x,At.y,N0,Mx,$x,vr,v0.image.data):v0.isCompressedTexture?zt.compressedTexSubImage2D(zt.TEXTURE_2D,G0,At.x,At.y,v0.mipmaps[0].width,v0.mipmaps[0].height,$x,v0.mipmaps[0].data):zt.texSubImage2D(zt.TEXTURE_2D,G0,At.x,At.y,$x,vr,v0.image),G0===0&&P0.generateMipmaps&&zt.generateMipmap(zt.TEXTURE_2D),rn.unbindTexture()},this.copyTextureToTexture3D=function(At,v0,P0,G0,N0=0){if(Be.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Mx=At.max.x-At.min.x+1,$x=At.max.y-At.min.y+1,vr=At.max.z-At.min.z+1,Ar=Nx.convert(G0.format),Kr=Nx.convert(G0.type);let zr;if(G0.isData3DTexture)Tt.setTexture3D(G0,0),zr=zt.TEXTURE_3D;else if(G0.isDataArrayTexture||G0.isCompressedArrayTexture)Tt.setTexture2DArray(G0,0),zr=zt.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}zt.pixelStorei(zt.UNPACK_FLIP_Y_WEBGL,G0.flipY),zt.pixelStorei(zt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,G0.premultiplyAlpha),zt.pixelStorei(zt.UNPACK_ALIGNMENT,G0.unpackAlignment);const Vr=zt.getParameter(zt.UNPACK_ROW_LENGTH),Vs=zt.getParameter(zt.UNPACK_IMAGE_HEIGHT),M2=zt.getParameter(zt.UNPACK_SKIP_PIXELS),Pa=zt.getParameter(zt.UNPACK_SKIP_ROWS),Wl=zt.getParameter(zt.UNPACK_SKIP_IMAGES),gs=P0.isCompressedTexture?P0.mipmaps[N0]:P0.image;zt.pixelStorei(zt.UNPACK_ROW_LENGTH,gs.width),zt.pixelStorei(zt.UNPACK_IMAGE_HEIGHT,gs.height),zt.pixelStorei(zt.UNPACK_SKIP_PIXELS,At.min.x),zt.pixelStorei(zt.UNPACK_SKIP_ROWS,At.min.y),zt.pixelStorei(zt.UNPACK_SKIP_IMAGES,At.min.z),P0.isDataTexture||P0.isData3DTexture?zt.texSubImage3D(zr,N0,v0.x,v0.y,v0.z,Mx,$x,vr,Ar,Kr,gs.data):P0.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),zt.compressedTexSubImage3D(zr,N0,v0.x,v0.y,v0.z,Mx,$x,vr,Ar,gs.data)):zt.texSubImage3D(zr,N0,v0.x,v0.y,v0.z,Mx,$x,vr,Ar,Kr,gs),zt.pixelStorei(zt.UNPACK_ROW_LENGTH,Vr),zt.pixelStorei(zt.UNPACK_IMAGE_HEIGHT,Vs),zt.pixelStorei(zt.UNPACK_SKIP_PIXELS,M2),zt.pixelStorei(zt.UNPACK_SKIP_ROWS,Pa),zt.pixelStorei(zt.UNPACK_SKIP_IMAGES,Wl),N0===0&&G0.generateMipmaps&&zt.generateMipmap(zr),rn.unbindTexture()},this.initTexture=function(At){At.isCubeTexture?Tt.setTextureCube(At,0):At.isData3DTexture?Tt.setTexture3D(At,0):At.isDataArrayTexture||At.isCompressedArrayTexture?Tt.setTexture2DArray(At,0):Tt.setTexture2D(At,0),rn.unbindTexture()},this.resetState=function(){bt=0,rt=0,xt=null,rn.reset(),Mr.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Nl}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(r){this._outputColorSpace=r;const d=this.getContext();d.drawingBufferColorSpace=r===$r?"display-p3":"srgb",d.unpackColorSpace=Ci.workingColorSpace===Mi?"display-p3":"srgb"}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===jn?z0:k0}set outputEncoding(r){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=r===z0?jn:vx}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(r){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=r}}class uL extends q_{}uL.prototype.isWebGL1Renderer=!0;class P1{constructor(r,d=25e-5){this.isFogExp2=!0,this.name="",this.color=new bx(r),this.density=d}clone(){return new P1(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class k1{constructor(r,d=1,g=1e3){this.isFog=!0,this.name="",this.color=new bx(r),this.near=d,this.far=g}clone(){return new k1(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Y_ extends xs{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(r,d){return super.copy(r,d),r.background!==null&&(this.background=r.background.clone()),r.environment!==null&&(this.environment=r.environment.clone()),r.fog!==null&&(this.fog=r.fog.clone()),this.backgroundBlurriness=r.backgroundBlurriness,this.backgroundIntensity=r.backgroundIntensity,r.overrideMaterial!==null&&(this.overrideMaterial=r.overrideMaterial.clone()),this.matrixAutoUpdate=r.matrixAutoUpdate,this}toJSON(r){const d=super.toJSON(r);return this.fog!==null&&(d.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(d.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(d.object.backgroundIntensity=this.backgroundIntensity),d}}class B1{constructor(r,d){this.isInterleavedBuffer=!0,this.array=r,this.stride=d,this.count=r!==void 0?r.length/d:0,this.usage=xm,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=b2()}onUploadCallback(){}set needsUpdate(r){r===!0&&this.version++}get updateRange(){return _h("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(r){return this.usage=r,this}addUpdateRange(r,d){this.updateRanges.push({start:r,count:d})}clearUpdateRanges(){this.updateRanges.length=0}copy(r){return this.array=new r.array.constructor(r.array),this.count=r.count,this.stride=r.stride,this.usage=r.usage,this}copyAt(r,d,g){r*=this.stride,g*=d.stride;for(let y=0,_=this.stride;y<_;y++)this.array[r+y]=d.array[g+y];return this}set(r,d=0){return this.array.set(r,d),this}clone(r){r.arrayBuffers===void 0&&(r.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=b2()),r.arrayBuffers[this.array.buffer._uuid]===void 0&&(r.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const d=new this.array.constructor(r.arrayBuffers[this.array.buffer._uuid]),g=new this.constructor(d,this.stride);return g.setUsage(this.usage),g}onUpload(r){return this.onUploadCallback=r,this}toJSON(r){return r.arrayBuffers===void 0&&(r.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=b2()),r.arrayBuffers[this.array.buffer._uuid]===void 0&&(r.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const No=new ut;class zh{constructor(r,d,g,y=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=r,this.itemSize=d,this.offset=g,this.normalized=y}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(r){this.data.needsUpdate=r}applyMatrix4(r){for(let d=0,g=this.data.count;d<g;d++)No.fromBufferAttribute(this,d),No.applyMatrix4(r),this.setXYZ(d,No.x,No.y,No.z);return this}applyNormalMatrix(r){for(let d=0,g=this.count;d<g;d++)No.fromBufferAttribute(this,d),No.applyNormalMatrix(r),this.setXYZ(d,No.x,No.y,No.z);return this}transformDirection(r){for(let d=0,g=this.count;d<g;d++)No.fromBufferAttribute(this,d),No.transformDirection(r),this.setXYZ(d,No.x,No.y,No.z);return this}getComponent(r,d){let g=this.array[r*this.data.stride+this.offset+d];return this.normalized&&(g=Mo(g,this.array)),g}setComponent(r,d,g){return this.normalized&&(g=Br(g,this.array)),this.data.array[r*this.data.stride+this.offset+d]=g,this}setX(r,d){return this.normalized&&(d=Br(d,this.array)),this.data.array[r*this.data.stride+this.offset]=d,this}setY(r,d){return this.normalized&&(d=Br(d,this.array)),this.data.array[r*this.data.stride+this.offset+1]=d,this}setZ(r,d){return this.normalized&&(d=Br(d,this.array)),this.data.array[r*this.data.stride+this.offset+2]=d,this}setW(r,d){return this.normalized&&(d=Br(d,this.array)),this.data.array[r*this.data.stride+this.offset+3]=d,this}getX(r){let d=this.data.array[r*this.data.stride+this.offset];return this.normalized&&(d=Mo(d,this.array)),d}getY(r){let d=this.data.array[r*this.data.stride+this.offset+1];return this.normalized&&(d=Mo(d,this.array)),d}getZ(r){let d=this.data.array[r*this.data.stride+this.offset+2];return this.normalized&&(d=Mo(d,this.array)),d}getW(r){let d=this.data.array[r*this.data.stride+this.offset+3];return this.normalized&&(d=Mo(d,this.array)),d}setXY(r,d,g){return r=r*this.data.stride+this.offset,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array)),this.data.array[r+0]=d,this.data.array[r+1]=g,this}setXYZ(r,d,g,y){return r=r*this.data.stride+this.offset,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array),y=Br(y,this.array)),this.data.array[r+0]=d,this.data.array[r+1]=g,this.data.array[r+2]=y,this}setXYZW(r,d,g,y,_){return r=r*this.data.stride+this.offset,this.normalized&&(d=Br(d,this.array),g=Br(g,this.array),y=Br(y,this.array),_=Br(_,this.array)),this.data.array[r+0]=d,this.data.array[r+1]=g,this.data.array[r+2]=y,this.data.array[r+3]=_,this}clone(r){if(r===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const d=[];for(let g=0;g<this.count;g++){const y=g*this.data.stride+this.offset;for(let _=0;_<this.itemSize;_++)d.push(this.data.array[y+_])}return new rs(new this.array.constructor(d),this.itemSize,this.normalized)}else return r.interleavedBuffers===void 0&&(r.interleavedBuffers={}),r.interleavedBuffers[this.data.uuid]===void 0&&(r.interleavedBuffers[this.data.uuid]=this.data.clone(r)),new zh(r.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(r){if(r===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const d=[];for(let g=0;g<this.count;g++){const y=g*this.data.stride+this.offset;for(let _=0;_<this.itemSize;_++)d.push(this.data.array[y+_])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:d,normalized:this.normalized}}else return r.interleavedBuffers===void 0&&(r.interleavedBuffers={}),r.interleavedBuffers[this.data.uuid]===void 0&&(r.interleavedBuffers[this.data.uuid]=this.data.toJSON(r)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class X_ extends null{constructor(r){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new bx(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.map=r.map,this.alphaMap=r.alphaMap,this.rotation=r.rotation,this.sizeAttenuation=r.sizeAttenuation,this.fog=r.fog,this}}let _f;const Tp=new ut,Tf=new ut,Af=new ut,Mf=new vn,Ap=new vn,j_=new ur,ug=new ut,Mp=new ut,dg=new ut,Z_=new vn,z1=new vn,K_=new vn;class dL extends null{constructor(r=new X_){if(super(),this.isSprite=!0,this.type="Sprite",_f===void 0){_f=new Ur;const d=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),g=new B1(d,5);_f.setIndex([0,1,2,0,2,3]),_f.setAttribute("position",new zh(g,3,0,!1)),_f.setAttribute("uv",new zh(g,2,3,!1))}this.geometry=_f,this.material=r,this.center=new vn(.5,.5)}raycast(r,d){r.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Tf.setFromMatrixScale(this.matrixWorld),j_.copy(r.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(r.camera.matrixWorldInverse,this.matrixWorld),Af.setFromMatrixPosition(this.modelViewMatrix),r.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Tf.multiplyScalar(-Af.z);const g=this.material.rotation;let y,_;g!==0&&(_=Math.cos(g),y=Math.sin(g));const R=this.center;gg(ug.set(-.5,-.5,0),Af,R,Tf,y,_),gg(Mp.set(.5,-.5,0),Af,R,Tf,y,_),gg(dg.set(.5,.5,0),Af,R,Tf,y,_),Z_.set(0,0),z1.set(1,0),K_.set(1,1);let k=r.ray.intersectTriangle(ug,Mp,dg,!1,Tp);if(k===null&&(gg(Mp.set(-.5,.5,0),Af,R,Tf,y,_),z1.set(0,1),k=r.ray.intersectTriangle(ug,dg,Mp,!1,Tp),k===null))return;const X=r.ray.origin.distanceTo(Tp);X<r.near||X>r.far||d.push({distance:X,point:Tp.clone(),uv:G2.getInterpolation(Tp,ug,Mp,dg,Z_,z1,K_,new vn),face:null,object:this})}copy(r,d){return super.copy(r,d),r.center!==void 0&&this.center.copy(r.center),this.material=r.material,this}}function gg(I,r,d,g,y,_){Mf.subVectors(I,d).addScalar(.5).multiply(g),y!==void 0?(Ap.x=_*Mf.x-y*Mf.y,Ap.y=y*Mf.x+_*Mf.y):Ap.copy(Mf),I.copy(r),I.x+=Ap.x,I.y+=Ap.y,I.applyMatrix4(j_)}const vg=new ut,$_=new ut;class gL extends null{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(r){super.copy(r,!1);const d=r.levels;for(let g=0,y=d.length;g<y;g++){const _=d[g];this.addLevel(_.object.clone(),_.distance,_.hysteresis)}return this.autoUpdate=r.autoUpdate,this}addLevel(r,d=0,g=0){d=Math.abs(d);const y=this.levels;let _;for(_=0;_<y.length&&!(d<y[_].distance);_++);return y.splice(_,0,{distance:d,hysteresis:g,object:r}),this.add(r),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(r){const d=this.levels;if(d.length>0){let g,y;for(g=1,y=d.length;g<y;g++){let _=d[g].distance;if(d[g].object.visible&&(_-=_*d[g].hysteresis),r<_)break}return d[g-1].object}return null}raycast(r,d){if(this.levels.length>0){vg.setFromMatrixPosition(this.matrixWorld);const y=r.ray.origin.distanceTo(vg);this.getObjectForDistance(y).raycast(r,d)}}update(r){const d=this.levels;if(d.length>1){vg.setFromMatrixPosition(r.matrixWorld),$_.setFromMatrixPosition(this.matrixWorld);const g=vg.distanceTo($_)/r.zoom;d[0].object.visible=!0;let y,_;for(y=1,_=d.length;y<_;y++){let R=d[y].distance;if(d[y].object.visible&&(R-=R*d[y].hysteresis),g>=R)d[y-1].object.visible=!1,d[y].object.visible=!0;else break}for(this._currentLevel=y-1;y<_;y++)d[y].object.visible=!1}}toJSON(r){const d=super.toJSON(r);this.autoUpdate===!1&&(d.object.autoUpdate=!1),d.object.levels=[];const g=this.levels;for(let y=0,_=g.length;y<_;y++){const R=g[y];d.object.levels.push({object:R.object.uuid,distance:R.distance,hysteresis:R.hysteresis})}return d}}const J_=new ut,W_=new Vi,Q_=new Vi,vL=new ut,ew=new ur,bg=new ut,V1=new Qa,xw=new ur,G1=new up;class X1 extends Bs{constructor(r,d){super(r,d),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=_c,this.bindMatrix=new ur,this.bindMatrixInverse=new ur,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const r=this.geometry;this.boundingBox===null&&(this.boundingBox=new Co),this.boundingBox.makeEmpty();const d=r.getAttribute("position");for(let g=0;g<d.count;g++)this.getVertexPosition(g,bg),this.boundingBox.expandByPoint(bg)}computeBoundingSphere(){const r=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Qa),this.boundingSphere.makeEmpty();const d=r.getAttribute("position");for(let g=0;g<d.count;g++)this.getVertexPosition(g,bg),this.boundingSphere.expandByPoint(bg)}copy(r,d){return super.copy(r,d),this.bindMode=r.bindMode,this.bindMatrix.copy(r.bindMatrix),this.bindMatrixInverse.copy(r.bindMatrixInverse),this.skeleton=r.skeleton,r.boundingBox!==null&&(this.boundingBox=r.boundingBox.clone()),r.boundingSphere!==null&&(this.boundingSphere=r.boundingSphere.clone()),this}raycast(r,d){const g=this.material,y=this.matrixWorld;g!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),V1.copy(this.boundingSphere),V1.applyMatrix4(y),r.ray.intersectsSphere(V1)!==!1&&(xw.copy(y).invert(),G1.copy(r.ray).applyMatrix4(xw),!(this.boundingBox!==null&&G1.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(r,d,G1)))}getVertexPosition(r,d){return super.getVertexPosition(r,d),this.applyBoneTransform(r,d),d}bind(r,d){this.skeleton=r,d===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),d=this.matrixWorld),this.bindMatrix.copy(d),this.bindMatrixInverse.copy(d).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const r=new Vi,d=this.geometry.attributes.skinWeight;for(let g=0,y=d.count;g<y;g++){r.fromBufferAttribute(d,g);const _=1/r.manhattanLength();_!==1/0?r.multiplyScalar(_):r.set(1,0,0,0),d.setXYZW(g,r.x,r.y,r.z,r.w)}}updateMatrixWorld(r){super.updateMatrixWorld(r),this.bindMode===_c?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===To?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(r,d){const g=this.skeleton,y=this.geometry;W_.fromBufferAttribute(y.attributes.skinIndex,r),Q_.fromBufferAttribute(y.attributes.skinWeight,r),J_.copy(d).applyMatrix4(this.bindMatrix),d.set(0,0,0);for(let _=0;_<4;_++){const R=Q_.getComponent(_);if(R!==0){const k=W_.getComponent(_);ew.multiplyMatrices(g.bones[k].matrixWorld,g.boneInverses[k]),d.addScaledVector(vL.copy(J_).applyMatrix4(ew),R)}}return d.applyMatrix4(this.bindMatrixInverse)}}class _g extends xs{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Cf extends Ks{constructor(r=null,d=1,g=1,y,_,R,k,X,K=gi,Q=gi,xe,ue){super(null,R,k,X,K,Q,y,_,xe,ue),this.isDataTexture=!0,this.image={data:r,width:d,height:g},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const rw=new ur,bL=new ur;class Tg{constructor(r=[],d=[]){this.uuid=b2(),this.bones=r.slice(0),this.boneInverses=d,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const r=this.bones,d=this.boneInverses;if(this.boneMatrices=new Float32Array(r.length*16),d.length===0)this.calculateInverses();else if(r.length!==d.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let g=0,y=this.bones.length;g<y;g++)this.boneInverses.push(new ur)}}calculateInverses(){this.boneInverses.length=0;for(let r=0,d=this.bones.length;r<d;r++){const g=new ur;this.bones[r]&&g.copy(this.bones[r].matrixWorld).invert(),this.boneInverses.push(g)}}pose(){for(let r=0,d=this.bones.length;r<d;r++){const g=this.bones[r];g&&g.matrixWorld.copy(this.boneInverses[r]).invert()}for(let r=0,d=this.bones.length;r<d;r++){const g=this.bones[r];g&&(g.parent&&g.parent.isBone?(g.matrix.copy(g.parent.matrixWorld).invert(),g.matrix.multiply(g.matrixWorld)):g.matrix.copy(g.matrixWorld),g.matrix.decompose(g.position,g.quaternion,g.scale))}}update(){const r=this.bones,d=this.boneInverses,g=this.boneMatrices,y=this.boneTexture;for(let _=0,R=r.length;_<R;_++){const k=r[_]?r[_].matrixWorld:bL;rw.multiplyMatrices(k,d[_]),rw.toArray(g,_*16)}y!==null&&(y.needsUpdate=!0)}clone(){return new Tg(this.bones,this.boneInverses)}computeBoneTexture(){let r=Math.sqrt(this.bones.length*4);r=Math.ceil(r/4)*4,r=Math.max(r,4);const d=new Float32Array(r*r*4);d.set(this.boneMatrices);const g=new Cf(d,r,r,xa,Ts);return g.needsUpdate=!0,this.boneMatrices=d,this.boneTexture=g,this}getBoneByName(r){for(let d=0,g=this.bones.length;d<g;d++){const y=this.bones[d];if(y.name===r)return y}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(r,d){this.uuid=r.uuid;for(let g=0,y=r.bones.length;g<y;g++){const _=r.bones[g];let R=d[_];R===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",_),R=new _g),this.bones.push(R),this.boneInverses.push(new ur().fromArray(r.boneInverses[g]))}return this.init(),this}toJSON(){const r={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};r.uuid=this.uuid;const d=this.bones,g=this.boneInverses;for(let y=0,_=d.length;y<_;y++){const R=d[y];r.bones.push(R.uuid);const k=g[y];r.boneInverses.push(k.toArray())}return r}}class Rf extends rs{constructor(r,d,g,y=1){super(r,d,g),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=y}copy(r){return super.copy(r),this.meshPerAttribute=r.meshPerAttribute,this}toJSON(){const r=super.toJSON();return r.meshPerAttribute=this.meshPerAttribute,r.isInstancedBufferAttribute=!0,r}}const Nf=new ur,uw=new ur,Ag=[],dw=new Co,_L=new ur,Cp=new Bs,Rp=new Qa;class gw extends Bs{constructor(r,d,g){super(r,d),this.isInstancedMesh=!0,this.instanceMatrix=new Rf(new Float32Array(g*16),16),this.instanceColor=null,this.count=g,this.boundingBox=null,this.boundingSphere=null;for(let y=0;y<g;y++)this.setMatrixAt(y,_L)}computeBoundingBox(){const r=this.geometry,d=this.count;this.boundingBox===null&&(this.boundingBox=new Co),r.boundingBox===null&&r.computeBoundingBox(),this.boundingBox.makeEmpty();for(let g=0;g<d;g++)this.getMatrixAt(g,Nf),dw.copy(r.boundingBox).applyMatrix4(Nf),this.boundingBox.union(dw)}computeBoundingSphere(){const r=this.geometry,d=this.count;this.boundingSphere===null&&(this.boundingSphere=new Qa),r.boundingSphere===null&&r.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let g=0;g<d;g++)this.getMatrixAt(g,Nf),Rp.copy(r.boundingSphere).applyMatrix4(Nf),this.boundingSphere.union(Rp)}copy(r,d){return super.copy(r,d),this.instanceMatrix.copy(r.instanceMatrix),r.instanceColor!==null&&(this.instanceColor=r.instanceColor.clone()),this.count=r.count,r.boundingBox!==null&&(this.boundingBox=r.boundingBox.clone()),r.boundingSphere!==null&&(this.boundingSphere=r.boundingSphere.clone()),this}getColorAt(r,d){d.fromArray(this.instanceColor.array,r*3)}getMatrixAt(r,d){d.fromArray(this.instanceMatrix.array,r*16)}raycast(r,d){const g=this.matrixWorld,y=this.count;if(Cp.geometry=this.geometry,Cp.material=this.material,Cp.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Rp.copy(this.boundingSphere),Rp.applyMatrix4(g),r.ray.intersectsSphere(Rp)!==!1))for(let _=0;_<y;_++){this.getMatrixAt(_,Nf),uw.multiplyMatrices(g,Nf),Cp.matrixWorld=uw,Cp.raycast(r,Ag);for(let R=0,k=Ag.length;R<k;R++){const X=Ag[R];X.instanceId=_,X.object=this,d.push(X)}Ag.length=0}}setColorAt(r,d){this.instanceColor===null&&(this.instanceColor=new Rf(new Float32Array(this.instanceMatrix.count*3),3)),d.toArray(this.instanceColor.array,r*3)}setMatrixAt(r,d){d.toArray(this.instanceMatrix.array,r*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function TL(I,r){return I.z-r.z}function AL(I,r){return r.z-I.z}class ML{constructor(){this.index=0,this.pool=[],this.list=[]}push(r,d){const g=this.pool,y=this.list;this.index>=g.length&&g.push({start:-1,count:-1,z:-1});const _=g[this.index];y.push(_),this.index++,_.start=r.start,_.count=r.count,_.z=d}reset(){this.list.length=0,this.index=0}}const Pf="batchId",Cu=new ur,vw=new ur,CL=new ur,bw=new ur,j1=new Wm,Mg=new Co,Vh=new Qa,Np=new ut,K1=new ML,xo=new Bs,Cg=null;function RL(I,r,d=0){const g=r.itemSize;if(I.isInterleavedBufferAttribute||I.array.constructor!==r.array.constructor){const y=I.count;for(let _=0;_<y;_++)for(let R=0;R<g;R++)r.setComponent(_+d,R,I.getComponent(_,R))}else r.array.set(I.array,d*g);r.needsUpdate=!0}class NL extends null{get maxGeometryCount(){return this._maxGeometryCount}constructor(r,d,g=d*2,y){super(new Ur,y),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=r,this._maxVertexCount=d,this._maxIndexCount=g,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(r),this._multiDrawStarts=new Int32Array(r),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let r=Math.sqrt(this._maxGeometryCount*4);r=Math.ceil(r/4)*4,r=Math.max(r,4);const d=new Float32Array(r*r*4),g=new Cf(d,r,r,xa,Ts);this._matricesTexture=g}_initializeGeometry(r){const d=this.geometry,g=this._maxVertexCount,y=this._maxGeometryCount,_=this._maxIndexCount;if(this._geometryInitialized===!1){for(const k in r.attributes){const X=r.getAttribute(k),{array:K,itemSize:Q,normalized:xe}=X,ue=new K.constructor(g*Q),ge=new X.constructor(ue,Q,xe);ge.setUsage(X.usage),d.setAttribute(k,ge)}if(r.getIndex()!==null){const k=g>65536?new Uint32Array(_):new Uint16Array(_);d.setIndex(new rs(k,1))}const R=y>65536?new Uint32Array(g):new Uint16Array(g);d.setAttribute(Pf,new rs(R,1)),this._geometryInitialized=!0}}_validateGeometry(r){if(r.getAttribute(Pf))throw new Error(`BatchedMesh: Geometry cannot use attribute "${Pf}"`);const d=this.geometry;if(!!r.getIndex()!=!!d.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const g in d.attributes){if(g===Pf)continue;if(!r.hasAttribute(g))throw new Error(`BatchedMesh: Added geometry missing "${g}". All geometries must have consistent attributes.`);const y=r.getAttribute(g),_=d.getAttribute(g);if(y.itemSize!==_.itemSize||y.normalized!==_.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(r){return this.customSort=r,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Co);const r=this._geometryCount,d=this.boundingBox,g=this._active;d.makeEmpty();for(let y=0;y<r;y++)g[y]!==!1&&(this.getMatrixAt(y,Cu),this.getBoundingBoxAt(y,Mg).applyMatrix4(Cu),d.union(Mg))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Qa);const r=this._geometryCount,d=this.boundingSphere,g=this._active;d.makeEmpty();for(let y=0;y<r;y++)g[y]!==!1&&(this.getMatrixAt(y,Cu),this.getBoundingSphereAt(y,Vh).applyMatrix4(Cu),d.union(Vh))}addGeometry(r,d=-1,g=-1){if(this._initializeGeometry(r),this._validateGeometry(r),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const y={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let _=null;const R=this._reservedRanges,k=this._drawRanges,X=this._bounds;this._geometryCount!==0&&(_=R[R.length-1]),d===-1?y.vertexCount=r.getAttribute("position").count:y.vertexCount=d,_===null?y.vertexStart=0:y.vertexStart=_.vertexStart+_.vertexCount;const K=r.getIndex(),Q=K!==null;if(Q&&(g===-1?y.indexCount=K.count:y.indexCount=g,_===null?y.indexStart=0:y.indexStart=_.indexStart+_.indexCount),y.indexStart!==-1&&y.indexStart+y.indexCount>this._maxIndexCount||y.vertexStart+y.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const xe=this._visibility,ue=this._active,ge=this._matricesTexture,_e=this._matricesTexture.image.data;xe.push(!0),ue.push(!0);const Re=this._geometryCount;this._geometryCount++,CL.toArray(_e,Re*16),ge.needsUpdate=!0,R.push(y),k.push({start:Q?y.indexStart:y.vertexStart,count:-1}),X.push({boxInitialized:!1,box:new Co,sphereInitialized:!1,sphere:new Qa});const be=this.geometry.getAttribute(Pf);for(let ve=0;ve<y.vertexCount;ve++)be.setX(y.vertexStart+ve,Re);return be.needsUpdate=!0,this.setGeometryAt(Re,r),Re}setGeometryAt(r,d){if(r>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(d);const g=this.geometry,y=g.getIndex()!==null,_=g.getIndex(),R=d.getIndex(),k=this._reservedRanges[r];if(y&&R.count>k.indexCount||d.attributes.position.count>k.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const X=k.vertexStart,K=k.vertexCount;for(const ge in g.attributes){if(ge===Pf)continue;const _e=d.getAttribute(ge),Re=g.getAttribute(ge);RL(_e,Re,X);const be=_e.itemSize;for(let ve=_e.count,Xe=K;ve<Xe;ve++){const Be=X+ve;for(let Ke=0;Ke<be;Ke++)Re.setComponent(Be,Ke,0)}Re.needsUpdate=!0}if(y){const ge=k.indexStart;for(let _e=0;_e<R.count;_e++)_.setX(ge+_e,X+R.getX(_e));for(let _e=R.count,Re=k.indexCount;_e<Re;_e++)_.setX(ge+_e,X);_.needsUpdate=!0}const Q=this._bounds[r];d.boundingBox!==null?(Q.box.copy(d.boundingBox),Q.boxInitialized=!0):Q.boxInitialized=!1,d.boundingSphere!==null?(Q.sphere.copy(d.boundingSphere),Q.sphereInitialized=!0):Q.sphereInitialized=!1;const xe=this._drawRanges[r],ue=d.getAttribute("position");return xe.count=y?R.count:ue.count,this._visibilityChanged=!0,r}deleteGeometry(r){const d=this._active;return r>=d.length||d[r]===!1?this:(d[r]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(r,d){if(this._active[r]===!1)return null;const y=this._bounds[r],_=y.box,R=this.geometry;if(y.boxInitialized===!1){_.makeEmpty();const k=R.index,X=R.attributes.position,K=this._drawRanges[r];for(let Q=K.start,xe=K.start+K.count;Q<xe;Q++){let ue=Q;k&&(ue=k.getX(ue)),_.expandByPoint(Np.fromBufferAttribute(X,ue))}y.boxInitialized=!0}return d.copy(_),d}getBoundingSphereAt(r,d){if(this._active[r]===!1)return null;const y=this._bounds[r],_=y.sphere,R=this.geometry;if(y.sphereInitialized===!1){_.makeEmpty(),this.getBoundingBoxAt(r,Mg),Mg.getCenter(_.center);const k=R.index,X=R.attributes.position,K=this._drawRanges[r];let Q=0;for(let xe=K.start,ue=K.start+K.count;xe<ue;xe++){let ge=xe;k&&(ge=k.getX(ge)),Np.fromBufferAttribute(X,ge),Q=Math.max(Q,_.center.distanceToSquared(Np))}_.radius=Math.sqrt(Q),y.sphereInitialized=!0}return d.copy(_),d}setMatrixAt(r,d){const g=this._active,y=this._matricesTexture,_=this._matricesTexture.image.data,R=this._geometryCount;return r>=R||g[r]===!1?this:(d.toArray(_,r*16),y.needsUpdate=!0,this)}getMatrixAt(r,d){const g=this._active,y=this._matricesTexture.image.data,_=this._geometryCount;return r>=_||g[r]===!1?null:d.fromArray(y,r*16)}setVisibleAt(r,d){const g=this._visibility,y=this._active,_=this._geometryCount;return r>=_||y[r]===!1||g[r]===d?this:(g[r]=d,this._visibilityChanged=!0,this)}getVisibleAt(r){const d=this._visibility,g=this._active,y=this._geometryCount;return r>=y||g[r]===!1?!1:d[r]}raycast(r,d){const g=this._visibility,y=this._active,_=this._drawRanges,R=this._geometryCount,k=this.matrixWorld,X=this.geometry;xo.material=this.material,xo.geometry.index=X.index,xo.geometry.attributes=X.attributes,xo.geometry.boundingBox===null&&(xo.geometry.boundingBox=new Co),xo.geometry.boundingSphere===null&&(xo.geometry.boundingSphere=new Qa);for(let K=0;K<R;K++){if(!g[K]||!y[K])continue;const Q=_[K];xo.geometry.setDrawRange(Q.start,Q.count),this.getMatrixAt(K,xo.matrixWorld).premultiply(k),this.getBoundingBoxAt(K,xo.geometry.boundingBox),this.getBoundingSphereAt(K,xo.geometry.boundingSphere),xo.raycast(r,Cg);for(let xe=0,ue=Cg.length;xe<ue;xe++){const ge=Cg[xe];ge.object=this,ge.batchId=K,d.push(ge)}Cg.length=0}xo.material=null,xo.geometry.index=null,xo.geometry.attributes={},xo.geometry.setDrawRange(0,1/0)}copy(r){return super.copy(r),this.geometry=r.geometry.clone(),this.perObjectFrustumCulled=r.perObjectFrustumCulled,this.sortObjects=r.sortObjects,this.boundingBox=r.boundingBox!==null?r.boundingBox.clone():null,this.boundingSphere=r.boundingSphere!==null?r.boundingSphere.clone():null,this._drawRanges=r._drawRanges.map(d=>({...d})),this._reservedRanges=r._reservedRanges.map(d=>({...d})),this._visibility=r._visibility.slice(),this._active=r._active.slice(),this._bounds=r._bounds.map(d=>({boxInitialized:d.boxInitialized,box:d.box.clone(),sphereInitialized:d.sphereInitialized,sphere:d.sphere.clone()})),this._maxGeometryCount=r._maxGeometryCount,this._maxVertexCount=r._maxVertexCount,this._maxIndexCount=r._maxIndexCount,this._geometryInitialized=r._geometryInitialized,this._geometryCount=r._geometryCount,this._multiDrawCounts=r._multiDrawCounts.slice(),this._multiDrawStarts=r._multiDrawStarts.slice(),this._matricesTexture=r._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(r,d,g,y,_){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const R=y.getIndex(),k=R===null?1:R.array.BYTES_PER_ELEMENT,X=this._active,K=this._visibility,Q=this._multiDrawStarts,xe=this._multiDrawCounts,ue=this._drawRanges,ge=this.perObjectFrustumCulled;ge&&(bw.multiplyMatrices(g.projectionMatrix,g.matrixWorldInverse).multiply(this.matrixWorld),j1.setFromProjectionMatrix(bw,r.coordinateSystem));let _e=0;if(this.sortObjects){vw.copy(this.matrixWorld).invert(),Np.setFromMatrixPosition(g.matrixWorld).applyMatrix4(vw);for(let ve=0,Xe=K.length;ve<Xe;ve++)if(K[ve]&&X[ve]){this.getMatrixAt(ve,Cu),this.getBoundingSphereAt(ve,Vh).applyMatrix4(Cu);let Be=!1;if(ge&&(Be=!j1.intersectsSphere(Vh)),!Be){const Ke=Np.distanceTo(Vh.center);K1.push(ue[ve],Ke)}}const Re=K1.list,be=this.customSort;be===null?Re.sort(_.transparent?AL:TL):be.call(this,Re,g);for(let ve=0,Xe=Re.length;ve<Xe;ve++){const Be=Re[ve];Q[_e]=Be.start*k,xe[_e]=Be.count,_e++}K1.reset()}else for(let Re=0,be=K.length;Re<be;Re++)if(K[Re]&&X[Re]){let ve=!1;if(ge&&(this.getMatrixAt(Re,Cu),this.getBoundingSphereAt(Re,Vh).applyMatrix4(Cu),ve=!j1.intersectsSphere(Vh)),!ve){const Xe=ue[Re];Q[_e]=Xe.start*k,xe[_e]=Xe.count,_e++}}this._multiDrawCount=_e,this._visibilityChanged=!1}onBeforeShadow(r,d,g,y,_,R){this.onBeforeRender(r,null,y,_,R)}}class $o extends T2{constructor(r){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new bx(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.map=r.map,this.linewidth=r.linewidth,this.linecap=r.linecap,this.linejoin=r.linejoin,this.fog=r.fog,this}}const _w=new ut,Tw=new ut,Aw=new ur,$1=new up,Rg=new Qa;class Uh extends xs{constructor(r=new Ur,d=new $o){super(),this.isLine=!0,this.type="Line",this.geometry=r,this.material=d,this.updateMorphTargets()}copy(r,d){return super.copy(r,d),this.material=Array.isArray(r.material)?r.material.slice():r.material,this.geometry=r.geometry,this}computeLineDistances(){const r=this.geometry;if(r.index===null){const d=r.attributes.position,g=[0];for(let y=1,_=d.count;y<_;y++)_w.fromBufferAttribute(d,y-1),Tw.fromBufferAttribute(d,y),g[y]=g[y-1],g[y]+=_w.distanceTo(Tw);r.setAttribute("lineDistance",new Ux(g,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(r,d){const g=this.geometry,y=this.matrixWorld,_=r.params.Line.threshold,R=g.drawRange;if(g.boundingSphere===null&&g.computeBoundingSphere(),Rg.copy(g.boundingSphere),Rg.applyMatrix4(y),Rg.radius+=_,r.ray.intersectsSphere(Rg)===!1)return;Aw.copy(y).invert(),$1.copy(r.ray).applyMatrix4(Aw);const k=_/((this.scale.x+this.scale.y+this.scale.z)/3),X=k*k,K=new ut,Q=new ut,xe=new ut,ue=new ut,ge=this.isLineSegments?2:1,_e=g.index,be=g.attributes.position;if(_e!==null){const ve=Math.max(0,R.start),Xe=Math.min(_e.count,R.start+R.count);for(let Be=ve,Ke=Xe-1;Be<Ke;Be+=ge){const bt=_e.getX(Be),rt=_e.getX(Be+1);if(K.fromBufferAttribute(be,bt),Q.fromBufferAttribute(be,rt),$1.distanceSqToSegment(K,Q,ue,xe)>X)continue;ue.applyMatrix4(this.matrixWorld);const Mt=r.ray.origin.distanceTo(ue);Mt<r.near||Mt>r.far||d.push({distance:Mt,point:xe.clone().applyMatrix4(this.matrixWorld),index:Be,face:null,faceIndex:null,object:this})}}else{const ve=Math.max(0,R.start),Xe=Math.min(be.count,R.start+R.count);for(let Be=ve,Ke=Xe-1;Be<Ke;Be+=ge){if(K.fromBufferAttribute(be,Be),Q.fromBufferAttribute(be,Be+1),$1.distanceSqToSegment(K,Q,ue,xe)>X)continue;ue.applyMatrix4(this.matrixWorld);const rt=r.ray.origin.distanceTo(ue);rt<r.near||rt>r.far||d.push({distance:rt,point:xe.clone().applyMatrix4(this.matrixWorld),index:Be,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const d=this.geometry.morphAttributes,g=Object.keys(d);if(g.length>0){const y=d[g[0]];if(y!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let _=0,R=y.length;_<R;_++){const k=y[_].name||String(_);this.morphTargetInfluences.push(0),this.morphTargetDictionary[k]=_}}}}}const Mw=new ut,Cw=new ut;class J1 extends Uh{constructor(r,d){super(r,d),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const r=this.geometry;if(r.index===null){const d=r.attributes.position,g=[];for(let y=0,_=d.count;y<_;y+=2)Mw.fromBufferAttribute(d,y),Cw.fromBufferAttribute(d,y+1),g[y]=y===0?0:g[y-1],g[y+1]=g[y]+Mw.distanceTo(Cw);r.setAttribute("lineDistance",new Ux(g,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class Rw extends Uh{constructor(r,d){super(r,d),this.isLineLoop=!0,this.type="LineLoop"}}class W1 extends T2{constructor(r){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new bx(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.map=r.map,this.alphaMap=r.alphaMap,this.size=r.size,this.sizeAttenuation=r.sizeAttenuation,this.fog=r.fog,this}}const Nw=new ur,Q1=new up,Ng=new Qa,Pg=new ut;class Pw extends xs{constructor(r=new Ur,d=new W1){super(),this.isPoints=!0,this.type="Points",this.geometry=r,this.material=d,this.updateMorphTargets()}copy(r,d){return super.copy(r,d),this.material=Array.isArray(r.material)?r.material.slice():r.material,this.geometry=r.geometry,this}raycast(r,d){const g=this.geometry,y=this.matrixWorld,_=r.params.Points.threshold,R=g.drawRange;if(g.boundingSphere===null&&g.computeBoundingSphere(),Ng.copy(g.boundingSphere),Ng.applyMatrix4(y),Ng.radius+=_,r.ray.intersectsSphere(Ng)===!1)return;Nw.copy(y).invert(),Q1.copy(r.ray).applyMatrix4(Nw);const k=_/((this.scale.x+this.scale.y+this.scale.z)/3),X=k*k,K=g.index,xe=g.attributes.position;if(K!==null){const ue=Math.max(0,R.start),ge=Math.min(K.count,R.start+R.count);for(let _e=ue,Re=ge;_e<Re;_e++){const be=K.getX(_e);Pg.fromBufferAttribute(xe,be),Bw(Pg,be,X,y,r,d,this)}}else{const ue=Math.max(0,R.start),ge=Math.min(xe.count,R.start+R.count);for(let _e=ue,Re=ge;_e<Re;_e++)Pg.fromBufferAttribute(xe,_e),Bw(Pg,_e,X,y,r,d,this)}}updateMorphTargets(){const d=this.geometry.morphAttributes,g=Object.keys(d);if(g.length>0){const y=d[g[0]];if(y!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let _=0,R=y.length;_<R;_++){const k=y[_].name||String(_);this.morphTargetInfluences.push(0),this.morphTargetDictionary[k]=_}}}}}function Bw(I,r,d,g,y,_,R){const k=Q1.distanceSqToPoint(I);if(k<d){const X=new ut;Q1.closestPointToPoint(I,X),X.applyMatrix4(g);const K=y.ray.origin.distanceTo(X);if(K<y.near||K>y.far)return;_.push({distance:K,distanceToRay:Math.sqrt(k),point:X,index:r,face:null,object:R})}}class T9 extends null{constructor(r,d,g,y,_,R,k,X,K){super(r,d,g,y,_,R,k,X,K),this.isVideoTexture=!0,this.minFilter=R!==void 0?R:ui,this.magFilter=_!==void 0?_:ui,this.generateMipmaps=!1;const Q=this;function xe(){Q.needsUpdate=!0,r.requestVideoFrameCallback(xe)}"requestVideoFrameCallback"in r&&r.requestVideoFrameCallback(xe)}clone(){return new this.constructor(this.image).copy(this)}update(){const r=this.image;"requestVideoFrameCallback"in r===!1&&r.readyState>=r.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class A9 extends null{constructor(r,d){super({width:r,height:d}),this.isFramebufferTexture=!0,this.magFilter=gi,this.minFilter=gi,this.generateMipmaps=!1,this.needsUpdate=!0}}class PL extends null{constructor(r,d,g,y,_,R,k,X,K,Q,xe,ue){super(null,R,k,X,K,Q,y,_,xe,ue),this.isCompressedTexture=!0,this.image={width:d,height:g},this.mipmaps=r,this.flipY=!1,this.generateMipmaps=!1}}class M9 extends null{constructor(r,d,g,y,_,R){super(r,d,g,_,R),this.isCompressedArrayTexture=!0,this.image.depth=y,this.wrapR=Gi}}class C9 extends null{constructor(r,d,g){super(void 0,r[0].width,r[0].height,d,g,_s),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=r}}class R9 extends null{constructor(r,d,g,y,_,R,k,X,K){super(r,d,g,y,_,R,k,X,K),this.isCanvasTexture=!0,this.needsUpdate=!0}}class el{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(r,d){const g=this.getUtoTmapping(r);return this.getPoint(g,d)}getPoints(r=5){const d=[];for(let g=0;g<=r;g++)d.push(this.getPoint(g/r));return d}getSpacedPoints(r=5){const d=[];for(let g=0;g<=r;g++)d.push(this.getPointAt(g/r));return d}getLength(){const r=this.getLengths();return r[r.length-1]}getLengths(r=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===r+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const d=[];let g,y=this.getPoint(0),_=0;d.push(0);for(let R=1;R<=r;R++)g=this.getPoint(R/r),_+=g.distanceTo(y),d.push(_),y=g;return this.cacheArcLengths=d,d}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(r,d){const g=this.getLengths();let y=0;const _=g.length;let R;d?R=d:R=r*g[_-1];let k=0,X=_-1,K;for(;k<=X;)if(y=Math.floor(k+(X-k)/2),K=g[y]-R,K<0)k=y+1;else if(K>0)X=y-1;else{X=y;break}if(y=X,g[y]===R)return y/(_-1);const Q=g[y],ue=g[y+1]-Q,ge=(R-Q)/ue;return(y+ge)/(_-1)}getTangent(r,d){let y=r-1e-4,_=r+1e-4;y<0&&(y=0),_>1&&(_=1);const R=this.getPoint(y),k=this.getPoint(_),X=d||(R.isVector2?new vn:new ut);return X.copy(k).sub(R).normalize(),X}getTangentAt(r,d){const g=this.getUtoTmapping(r);return this.getTangent(g,d)}computeFrenetFrames(r,d){const g=new ut,y=[],_=[],R=[],k=new ut,X=new ur;for(let ge=0;ge<=r;ge++){const _e=ge/r;y[ge]=this.getTangentAt(_e,new ut)}_[0]=new ut,R[0]=new ut;let K=Number.MAX_VALUE;const Q=Math.abs(y[0].x),xe=Math.abs(y[0].y),ue=Math.abs(y[0].z);Q<=K&&(K=Q,g.set(1,0,0)),xe<=K&&(K=xe,g.set(0,1,0)),ue<=K&&g.set(0,0,1),k.crossVectors(y[0],g).normalize(),_[0].crossVectors(y[0],k),R[0].crossVectors(y[0],_[0]);for(let ge=1;ge<=r;ge++){if(_[ge]=_[ge-1].clone(),R[ge]=R[ge-1].clone(),k.crossVectors(y[ge-1],y[ge]),k.length()>Number.EPSILON){k.normalize();const _e=Math.acos(As(y[ge-1].dot(y[ge]),-1,1));_[ge].applyMatrix4(X.makeRotationAxis(k,_e))}R[ge].crossVectors(y[ge],_[ge])}if(d===!0){let ge=Math.acos(As(_[0].dot(_[r]),-1,1));ge/=r,y[0].dot(k.crossVectors(_[0],_[r]))>0&&(ge=-ge);for(let _e=1;_e<=r;_e++)_[_e].applyMatrix4(X.makeRotationAxis(y[_e],ge*_e)),R[_e].crossVectors(y[_e],_[_e])}return{tangents:y,normals:_,binormals:R}}clone(){return new this.constructor().copy(this)}copy(r){return this.arcLengthDivisions=r.arcLengthDivisions,this}toJSON(){const r={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return r.arcLengthDivisions=this.arcLengthDivisions,r.type=this.type,r}fromJSON(r){return this.arcLengthDivisions=r.arcLengthDivisions,this}}class ev extends el{constructor(r=0,d=0,g=1,y=1,_=0,R=Math.PI*2,k=!1,X=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=r,this.aY=d,this.xRadius=g,this.yRadius=y,this.aStartAngle=_,this.aEndAngle=R,this.aClockwise=k,this.aRotation=X}getPoint(r,d){const g=d||new vn,y=Math.PI*2;let _=this.aEndAngle-this.aStartAngle;const R=Math.abs(_)<Number.EPSILON;for(;_<0;)_+=y;for(;_>y;)_-=y;_<Number.EPSILON&&(R?_=0:_=y),this.aClockwise===!0&&!R&&(_===y?_=-y:_=_-y);const k=this.aStartAngle+r*_;let X=this.aX+this.xRadius*Math.cos(k),K=this.aY+this.yRadius*Math.sin(k);if(this.aRotation!==0){const Q=Math.cos(this.aRotation),xe=Math.sin(this.aRotation),ue=X-this.aX,ge=K-this.aY;X=ue*Q-ge*xe+this.aX,K=ue*xe+ge*Q+this.aY}return g.set(X,K)}copy(r){return super.copy(r),this.aX=r.aX,this.aY=r.aY,this.xRadius=r.xRadius,this.yRadius=r.yRadius,this.aStartAngle=r.aStartAngle,this.aEndAngle=r.aEndAngle,this.aClockwise=r.aClockwise,this.aRotation=r.aRotation,this}toJSON(){const r=super.toJSON();return r.aX=this.aX,r.aY=this.aY,r.xRadius=this.xRadius,r.yRadius=this.yRadius,r.aStartAngle=this.aStartAngle,r.aEndAngle=this.aEndAngle,r.aClockwise=this.aClockwise,r.aRotation=this.aRotation,r}fromJSON(r){return super.fromJSON(r),this.aX=r.aX,this.aY=r.aY,this.xRadius=r.xRadius,this.yRadius=r.yRadius,this.aStartAngle=r.aStartAngle,this.aEndAngle=r.aEndAngle,this.aClockwise=r.aClockwise,this.aRotation=r.aRotation,this}}class BL extends ev{constructor(r,d,g,y,_,R){super(r,d,g,g,y,_,R),this.isArcCurve=!0,this.type="ArcCurve"}}function xv(){let I=0,r=0,d=0,g=0;function y(_,R,k,X){I=_,r=k,d=-3*_+3*R-2*k-X,g=2*_-2*R+k+X}return{initCatmullRom:function(_,R,k,X,K){y(R,k,K*(k-_),K*(X-R))},initNonuniformCatmullRom:function(_,R,k,X,K,Q,xe){let ue=(R-_)/K-(k-_)/(K+Q)+(k-R)/Q,ge=(k-R)/Q-(X-R)/(Q+xe)+(X-k)/xe;ue*=Q,ge*=Q,y(R,k,ue,ge)},calc:function(_){const R=_*_,k=R*_;return I+r*_+d*R+g*k}}}const Bg=new ut,rv=new xv,uv=new xv,dv=new xv;class zL extends el{constructor(r=[],d=!1,g="centripetal",y=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=r,this.closed=d,this.curveType=g,this.tension=y}getPoint(r,d=new ut){const g=d,y=this.points,_=y.length,R=(_-(this.closed?0:1))*r;let k=Math.floor(R),X=R-k;this.closed?k+=k>0?0:(Math.floor(Math.abs(k)/_)+1)*_:X===0&&k===_-1&&(k=_-2,X=1);let K,Q;this.closed||k>0?K=y[(k-1)%_]:(Bg.subVectors(y[0],y[1]).add(y[0]),K=Bg);const xe=y[k%_],ue=y[(k+1)%_];if(this.closed||k+2<_?Q=y[(k+2)%_]:(Bg.subVectors(y[_-1],y[_-2]).add(y[_-1]),Q=Bg),this.curveType==="centripetal"||this.curveType==="chordal"){const ge=this.curveType==="chordal"?.5:.25;let _e=Math.pow(K.distanceToSquared(xe),ge),Re=Math.pow(xe.distanceToSquared(ue),ge),be=Math.pow(ue.distanceToSquared(Q),ge);Re<1e-4&&(Re=1),_e<1e-4&&(_e=Re),be<1e-4&&(be=Re),rv.initNonuniformCatmullRom(K.x,xe.x,ue.x,Q.x,_e,Re,be),uv.initNonuniformCatmullRom(K.y,xe.y,ue.y,Q.y,_e,Re,be),dv.initNonuniformCatmullRom(K.z,xe.z,ue.z,Q.z,_e,Re,be)}else this.curveType==="catmullrom"&&(rv.initCatmullRom(K.x,xe.x,ue.x,Q.x,this.tension),uv.initCatmullRom(K.y,xe.y,ue.y,Q.y,this.tension),dv.initCatmullRom(K.z,xe.z,ue.z,Q.z,this.tension));return g.set(rv.calc(X),uv.calc(X),dv.calc(X)),g}copy(r){super.copy(r),this.points=[];for(let d=0,g=r.points.length;d<g;d++){const y=r.points[d];this.points.push(y.clone())}return this.closed=r.closed,this.curveType=r.curveType,this.tension=r.tension,this}toJSON(){const r=super.toJSON();r.points=[];for(let d=0,g=this.points.length;d<g;d++){const y=this.points[d];r.points.push(y.toArray())}return r.closed=this.closed,r.curveType=this.curveType,r.tension=this.tension,r}fromJSON(r){super.fromJSON(r),this.points=[];for(let d=0,g=r.points.length;d<g;d++){const y=r.points[d];this.points.push(new ut().fromArray(y))}return this.closed=r.closed,this.curveType=r.curveType,this.tension=r.tension,this}}function zw(I,r,d,g,y){const _=(g-r)*.5,R=(y-d)*.5,k=I*I,X=I*k;return(2*d-2*g+_+R)*X+(-3*d+3*g-2*_-R)*k+_*I+d}function VL(I,r){const d=1-I;return d*d*r}function UL(I,r){return 2*(1-I)*I*r}function GL(I,r){return I*I*r}function Pp(I,r,d,g){return VL(I,r)+UL(I,d)+GL(I,g)}function XL(I,r){const d=1-I;return d*d*d*r}function jL(I,r){const d=1-I;return 3*d*d*I*r}function KL(I,r){return 3*(1-I)*I*I*r}function $L(I,r){return I*I*I*r}function Bp(I,r,d,g,y){return XL(I,r)+jL(I,d)+KL(I,g)+$L(I,y)}class Vw extends el{constructor(r=new vn,d=new vn,g=new vn,y=new vn){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=r,this.v1=d,this.v2=g,this.v3=y}getPoint(r,d=new vn){const g=d,y=this.v0,_=this.v1,R=this.v2,k=this.v3;return g.set(Bp(r,y.x,_.x,R.x,k.x),Bp(r,y.y,_.y,R.y,k.y)),g}copy(r){return super.copy(r),this.v0.copy(r.v0),this.v1.copy(r.v1),this.v2.copy(r.v2),this.v3.copy(r.v3),this}toJSON(){const r=super.toJSON();return r.v0=this.v0.toArray(),r.v1=this.v1.toArray(),r.v2=this.v2.toArray(),r.v3=this.v3.toArray(),r}fromJSON(r){return super.fromJSON(r),this.v0.fromArray(r.v0),this.v1.fromArray(r.v1),this.v2.fromArray(r.v2),this.v3.fromArray(r.v3),this}}class JL extends el{constructor(r=new ut,d=new ut,g=new ut,y=new ut){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=r,this.v1=d,this.v2=g,this.v3=y}getPoint(r,d=new ut){const g=d,y=this.v0,_=this.v1,R=this.v2,k=this.v3;return g.set(Bp(r,y.x,_.x,R.x,k.x),Bp(r,y.y,_.y,R.y,k.y),Bp(r,y.z,_.z,R.z,k.z)),g}copy(r){return super.copy(r),this.v0.copy(r.v0),this.v1.copy(r.v1),this.v2.copy(r.v2),this.v3.copy(r.v3),this}toJSON(){const r=super.toJSON();return r.v0=this.v0.toArray(),r.v1=this.v1.toArray(),r.v2=this.v2.toArray(),r.v3=this.v3.toArray(),r}fromJSON(r){return super.fromJSON(r),this.v0.fromArray(r.v0),this.v1.fromArray(r.v1),this.v2.fromArray(r.v2),this.v3.fromArray(r.v3),this}}class Uw extends el{constructor(r=new vn,d=new vn){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=r,this.v2=d}getPoint(r,d=new vn){const g=d;return r===1?g.copy(this.v2):(g.copy(this.v2).sub(this.v1),g.multiplyScalar(r).add(this.v1)),g}getPointAt(r,d){return this.getPoint(r,d)}getTangent(r,d=new vn){return d.subVectors(this.v2,this.v1).normalize()}getTangentAt(r,d){return this.getTangent(r,d)}copy(r){return super.copy(r),this.v1.copy(r.v1),this.v2.copy(r.v2),this}toJSON(){const r=super.toJSON();return r.v1=this.v1.toArray(),r.v2=this.v2.toArray(),r}fromJSON(r){return super.fromJSON(r),this.v1.fromArray(r.v1),this.v2.fromArray(r.v2),this}}class WL extends el{constructor(r=new ut,d=new ut){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=r,this.v2=d}getPoint(r,d=new ut){const g=d;return r===1?g.copy(this.v2):(g.copy(this.v2).sub(this.v1),g.multiplyScalar(r).add(this.v1)),g}getPointAt(r,d){return this.getPoint(r,d)}getTangent(r,d=new ut){return d.subVectors(this.v2,this.v1).normalize()}getTangentAt(r,d){return this.getTangent(r,d)}copy(r){return super.copy(r),this.v1.copy(r.v1),this.v2.copy(r.v2),this}toJSON(){const r=super.toJSON();return r.v1=this.v1.toArray(),r.v2=this.v2.toArray(),r}fromJSON(r){return super.fromJSON(r),this.v1.fromArray(r.v1),this.v2.fromArray(r.v2),this}}class Gw extends el{constructor(r=new vn,d=new vn,g=new vn){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=r,this.v1=d,this.v2=g}getPoint(r,d=new vn){const g=d,y=this.v0,_=this.v1,R=this.v2;return g.set(Pp(r,y.x,_.x,R.x),Pp(r,y.y,_.y,R.y)),g}copy(r){return super.copy(r),this.v0.copy(r.v0),this.v1.copy(r.v1),this.v2.copy(r.v2),this}toJSON(){const r=super.toJSON();return r.v0=this.v0.toArray(),r.v1=this.v1.toArray(),r.v2=this.v2.toArray(),r}fromJSON(r){return super.fromJSON(r),this.v0.fromArray(r.v0),this.v1.fromArray(r.v1),this.v2.fromArray(r.v2),this}}class Xw extends el{constructor(r=new ut,d=new ut,g=new ut){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=r,this.v1=d,this.v2=g}getPoint(r,d=new ut){const g=d,y=this.v0,_=this.v1,R=this.v2;return g.set(Pp(r,y.x,_.x,R.x),Pp(r,y.y,_.y,R.y),Pp(r,y.z,_.z,R.z)),g}copy(r){return super.copy(r),this.v0.copy(r.v0),this.v1.copy(r.v1),this.v2.copy(r.v2),this}toJSON(){const r=super.toJSON();return r.v0=this.v0.toArray(),r.v1=this.v1.toArray(),r.v2=this.v2.toArray(),r}fromJSON(r){return super.fromJSON(r),this.v0.fromArray(r.v0),this.v1.fromArray(r.v1),this.v2.fromArray(r.v2),this}}class jw extends el{constructor(r=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=r}getPoint(r,d=new vn){const g=d,y=this.points,_=(y.length-1)*r,R=Math.floor(_),k=_-R,X=y[R===0?R:R-1],K=y[R],Q=y[R>y.length-2?y.length-1:R+1],xe=y[R>y.length-3?y.length-1:R+2];return g.set(zw(k,X.x,K.x,Q.x,xe.x),zw(k,X.y,K.y,Q.y,xe.y)),g}copy(r){super.copy(r),this.points=[];for(let d=0,g=r.points.length;d<g;d++){const y=r.points[d];this.points.push(y.clone())}return this}toJSON(){const r=super.toJSON();r.points=[];for(let d=0,g=this.points.length;d<g;d++){const y=this.points[d];r.points.push(y.toArray())}return r}fromJSON(r){super.fromJSON(r),this.points=[];for(let d=0,g=r.points.length;d<g;d++){const y=r.points[d];this.points.push(new vn().fromArray(y))}return this}}var zg=Object.freeze({__proto__:null,ArcCurve:BL,CatmullRomCurve3:zL,CubicBezierCurve:Vw,CubicBezierCurve3:JL,EllipseCurve:ev,LineCurve:Uw,LineCurve3:WL,QuadraticBezierCurve:Gw,QuadraticBezierCurve3:Xw,SplineCurve:jw});class QL extends el{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(r){this.curves.push(r)}closePath(){const r=this.curves[0].getPoint(0),d=this.curves[this.curves.length-1].getPoint(1);if(!r.equals(d)){const g=r.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new zg[g](d,r))}return this}getPoint(r,d){const g=r*this.getLength(),y=this.getCurveLengths();let _=0;for(;_<y.length;){if(y[_]>=g){const R=y[_]-g,k=this.curves[_],X=k.getLength(),K=X===0?0:1-R/X;return k.getPointAt(K,d)}_++}return null}getLength(){const r=this.getCurveLengths();return r[r.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const r=[];let d=0;for(let g=0,y=this.curves.length;g<y;g++)d+=this.curves[g].getLength(),r.push(d);return this.cacheLengths=r,r}getSpacedPoints(r=40){const d=[];for(let g=0;g<=r;g++)d.push(this.getPoint(g/r));return this.autoClose&&d.push(d[0]),d}getPoints(r=12){const d=[];let g;for(let y=0,_=this.curves;y<_.length;y++){const R=_[y],k=R.isEllipseCurve?r*2:R.isLineCurve||R.isLineCurve3?1:R.isSplineCurve?r*R.points.length:r,X=R.getPoints(k);for(let K=0;K<X.length;K++){const Q=X[K];g&&g.equals(Q)||(d.push(Q),g=Q)}}return this.autoClose&&d.length>1&&!d[d.length-1].equals(d[0])&&d.push(d[0]),d}copy(r){super.copy(r),this.curves=[];for(let d=0,g=r.curves.length;d<g;d++){const y=r.curves[d];this.curves.push(y.clone())}return this.autoClose=r.autoClose,this}toJSON(){const r=super.toJSON();r.autoClose=this.autoClose,r.curves=[];for(let d=0,g=this.curves.length;d<g;d++){const y=this.curves[d];r.curves.push(y.toJSON())}return r}fromJSON(r){super.fromJSON(r),this.autoClose=r.autoClose,this.curves=[];for(let d=0,g=r.curves.length;d<g;d++){const y=r.curves[d];this.curves.push(new zg[y.type]().fromJSON(y))}return this}}class Vg extends QL{constructor(r){super(),this.type="Path",this.currentPoint=new vn,r&&this.setFromPoints(r)}setFromPoints(r){this.moveTo(r[0].x,r[0].y);for(let d=1,g=r.length;d<g;d++)this.lineTo(r[d].x,r[d].y);return this}moveTo(r,d){return this.currentPoint.set(r,d),this}lineTo(r,d){const g=new Uw(this.currentPoint.clone(),new vn(r,d));return this.curves.push(g),this.currentPoint.set(r,d),this}quadraticCurveTo(r,d,g,y){const _=new Gw(this.currentPoint.clone(),new vn(r,d),new vn(g,y));return this.curves.push(_),this.currentPoint.set(g,y),this}bezierCurveTo(r,d,g,y,_,R){const k=new Vw(this.currentPoint.clone(),new vn(r,d),new vn(g,y),new vn(_,R));return this.curves.push(k),this.currentPoint.set(_,R),this}splineThru(r){const d=[this.currentPoint.clone()].concat(r),g=new jw(d);return this.curves.push(g),this.currentPoint.copy(r[r.length-1]),this}arc(r,d,g,y,_,R){const k=this.currentPoint.x,X=this.currentPoint.y;return this.absarc(r+k,d+X,g,y,_,R),this}absarc(r,d,g,y,_,R){return this.absellipse(r,d,g,g,y,_,R),this}ellipse(r,d,g,y,_,R,k,X){const K=this.currentPoint.x,Q=this.currentPoint.y;return this.absellipse(r+K,d+Q,g,y,_,R,k,X),this}absellipse(r,d,g,y,_,R,k,X){const K=new ev(r,d,g,y,_,R,k,X);if(this.curves.length>0){const xe=K.getPoint(0);xe.equals(this.currentPoint)||this.lineTo(xe.x,xe.y)}this.curves.push(K);const Q=K.getPoint(1);return this.currentPoint.copy(Q),this}copy(r){return super.copy(r),this.currentPoint.copy(r.currentPoint),this}toJSON(){const r=super.toJSON();return r.currentPoint=this.currentPoint.toArray(),r}fromJSON(r){return super.fromJSON(r),this.currentPoint.fromArray(r.currentPoint),this}}class Ug extends Ur{constructor(r=[new vn(0,-.5),new vn(.5,0),new vn(0,.5)],d=12,g=0,y=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:r,segments:d,phiStart:g,phiLength:y},d=Math.floor(d),y=As(y,0,Math.PI*2);const _=[],R=[],k=[],X=[],K=[],Q=1/d,xe=new ut,ue=new vn,ge=new ut,_e=new ut,Re=new ut;let be=0,ve=0;for(let Xe=0;Xe<=r.length-1;Xe++)switch(Xe){case 0:be=r[Xe+1].x-r[Xe].x,ve=r[Xe+1].y-r[Xe].y,ge.x=ve*1,ge.y=-be,ge.z=ve*0,Re.copy(ge),ge.normalize(),X.push(ge.x,ge.y,ge.z);break;case r.length-1:X.push(Re.x,Re.y,Re.z);break;default:be=r[Xe+1].x-r[Xe].x,ve=r[Xe+1].y-r[Xe].y,ge.x=ve*1,ge.y=-be,ge.z=ve*0,_e.copy(ge),ge.x+=Re.x,ge.y+=Re.y,ge.z+=Re.z,ge.normalize(),X.push(ge.x,ge.y,ge.z),Re.copy(_e)}for(let Xe=0;Xe<=d;Xe++){const Be=g+Xe*Q*y,Ke=Math.sin(Be),bt=Math.cos(Be);for(let rt=0;rt<=r.length-1;rt++){xe.x=r[rt].x*Ke,xe.y=r[rt].y,xe.z=r[rt].x*bt,R.push(xe.x,xe.y,xe.z),ue.x=Xe/d,ue.y=rt/(r.length-1),k.push(ue.x,ue.y);const xt=X[3*rt+0]*Ke,Mt=X[3*rt+1],$t=X[3*rt+0]*bt;K.push(xt,Mt,$t)}}for(let Xe=0;Xe<d;Xe++)for(let Be=0;Be<r.length-1;Be++){const Ke=Be+Xe*r.length,bt=Ke,rt=Ke+r.length,xt=Ke+r.length+1,Mt=Ke+1;_.push(bt,rt,Mt),_.push(xt,Mt,rt)}this.setIndex(_),this.setAttribute("position",new Ux(R,3)),this.setAttribute("uv",new Ux(k,2)),this.setAttribute("normal",new Ux(K,3))}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new Ug(r.points,r.segments,r.phiStart,r.phiLength)}}class gv extends Ug{constructor(r=1,d=1,g=4,y=8){const _=new Vg;_.absarc(0,-d/2,r,Math.PI*1.5,0),_.absarc(0,d/2,r,0,Math.PI*.5),super(_.getPoints(g),y),this.type="CapsuleGeometry",this.parameters={radius:r,length:d,capSegments:g,radialSegments:y}}static fromJSON(r){return new gv(r.radius,r.length,r.capSegments,r.radialSegments)}}class vv extends Ur{constructor(r=1,d=32,g=0,y=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:r,segments:d,thetaStart:g,thetaLength:y},d=Math.max(3,d);const _=[],R=[],k=[],X=[],K=new ut,Q=new vn;R.push(0,0,0),k.push(0,0,1),X.push(.5,.5);for(let xe=0,ue=3;xe<=d;xe++,ue+=3){const ge=g+xe/d*y;K.x=r*Math.cos(ge),K.y=r*Math.sin(ge),R.push(K.x,K.y,K.z),k.push(0,0,1),Q.x=(R[ue]/r+1)/2,Q.y=(R[ue+1]/r+1)/2,X.push(Q.x,Q.y)}for(let xe=1;xe<=d;xe++)_.push(xe,xe+1,0);this.setIndex(_),this.setAttribute("position",new Ux(R,3)),this.setAttribute("normal",new Ux(k,3)),this.setAttribute("uv",new Ux(X,2))}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new vv(r.radius,r.segments,r.thetaStart,r.thetaLength)}}class zp extends Ur{constructor(r=1,d=1,g=1,y=32,_=1,R=!1,k=0,X=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:r,radiusBottom:d,height:g,radialSegments:y,heightSegments:_,openEnded:R,thetaStart:k,thetaLength:X};const K=this;y=Math.floor(y),_=Math.floor(_);const Q=[],xe=[],ue=[],ge=[];let _e=0;const Re=[],be=g/2;let ve=0;Xe(),R===!1&&(r>0&&Be(!0),d>0&&Be(!1)),this.setIndex(Q),this.setAttribute("position",new Ux(xe,3)),this.setAttribute("normal",new Ux(ue,3)),this.setAttribute("uv",new Ux(ge,2));function Xe(){const Ke=new ut,bt=new ut;let rt=0;const xt=(d-r)/g;for(let Mt=0;Mt<=_;Mt++){const $t=[],$e=Mt/_,vt=$e*(d-r)+r;for(let M0=0;M0<=y;M0++){const V0=M0/y,Pt=V0*X+k,x0=Math.sin(Pt),Wt=Math.cos(Pt);bt.x=vt*x0,bt.y=-$e*g+be,bt.z=vt*Wt,xe.push(bt.x,bt.y,bt.z),Ke.set(x0,xt,Wt).normalize(),ue.push(Ke.x,Ke.y,Ke.z),ge.push(V0,1-$e),$t.push(_e++)}Re.push($t)}for(let Mt=0;Mt<y;Mt++)for(let $t=0;$t<_;$t++){const $e=Re[$t][Mt],vt=Re[$t+1][Mt],M0=Re[$t+1][Mt+1],V0=Re[$t][Mt+1];Q.push($e,vt,V0),Q.push(vt,M0,V0),rt+=6}K.addGroup(ve,rt,0),ve+=rt}function Be(Ke){const bt=_e,rt=new vn,xt=new ut;let Mt=0;const $t=Ke===!0?r:d,$e=Ke===!0?1:-1;for(let M0=1;M0<=y;M0++)xe.push(0,be*$e,0),ue.push(0,$e,0),ge.push(.5,.5),_e++;const vt=_e;for(let M0=0;M0<=y;M0++){const Pt=M0/y*X+k,x0=Math.cos(Pt),Wt=Math.sin(Pt);xt.x=$t*Wt,xt.y=be*$e,xt.z=$t*x0,xe.push(xt.x,xt.y,xt.z),ue.push(0,$e,0),rt.x=x0*.5+.5,rt.y=Wt*.5*$e+.5,ge.push(rt.x,rt.y),_e++}for(let M0=0;M0<y;M0++){const V0=bt+M0,Pt=vt+M0;Ke===!0?Q.push(Pt,Pt+1,V0):Q.push(Pt+1,Pt,V0),Mt+=3}K.addGroup(ve,Mt,Ke===!0?1:2),ve+=Mt}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new zp(r.radiusTop,r.radiusBottom,r.height,r.radialSegments,r.heightSegments,r.openEnded,r.thetaStart,r.thetaLength)}}class bv extends zp{constructor(r=1,d=1,g=32,y=1,_=!1,R=0,k=Math.PI*2){super(0,r,d,g,y,_,R,k),this.type="ConeGeometry",this.parameters={radius:r,height:d,radialSegments:g,heightSegments:y,openEnded:_,thetaStart:R,thetaLength:k}}static fromJSON(r){return new bv(r.radius,r.height,r.radialSegments,r.heightSegments,r.openEnded,r.thetaStart,r.thetaLength)}}class Gh extends Ur{constructor(r=[],d=[],g=1,y=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:r,indices:d,radius:g,detail:y};const _=[],R=[];k(y),K(g),Q(),this.setAttribute("position",new Ux(_,3)),this.setAttribute("normal",new Ux(_.slice(),3)),this.setAttribute("uv",new Ux(R,2)),y===0?this.computeVertexNormals():this.normalizeNormals();function k(Xe){const Be=new ut,Ke=new ut,bt=new ut;for(let rt=0;rt<d.length;rt+=3)ge(d[rt+0],Be),ge(d[rt+1],Ke),ge(d[rt+2],bt),X(Be,Ke,bt,Xe)}function X(Xe,Be,Ke,bt){const rt=bt+1,xt=[];for(let Mt=0;Mt<=rt;Mt++){xt[Mt]=[];const $t=Xe.clone().lerp(Ke,Mt/rt),$e=Be.clone().lerp(Ke,Mt/rt),vt=rt-Mt;for(let M0=0;M0<=vt;M0++)M0===0&&Mt===rt?xt[Mt][M0]=$t:xt[Mt][M0]=$t.clone().lerp($e,M0/vt)}for(let Mt=0;Mt<rt;Mt++)for(let $t=0;$t<2*(rt-Mt)-1;$t++){const $e=Math.floor($t/2);$t%2===0?(ue(xt[Mt][$e+1]),ue(xt[Mt+1][$e]),ue(xt[Mt][$e])):(ue(xt[Mt][$e+1]),ue(xt[Mt+1][$e+1]),ue(xt[Mt+1][$e]))}}function K(Xe){const Be=new ut;for(let Ke=0;Ke<_.length;Ke+=3)Be.x=_[Ke+0],Be.y=_[Ke+1],Be.z=_[Ke+2],Be.normalize().multiplyScalar(Xe),_[Ke+0]=Be.x,_[Ke+1]=Be.y,_[Ke+2]=Be.z}function Q(){const Xe=new ut;for(let Be=0;Be<_.length;Be+=3){Xe.x=_[Be+0],Xe.y=_[Be+1],Xe.z=_[Be+2];const Ke=be(Xe)/2/Math.PI+.5,bt=ve(Xe)/Math.PI+.5;R.push(Ke,1-bt)}_e(),xe()}function xe(){for(let Xe=0;Xe<R.length;Xe+=6){const Be=R[Xe+0],Ke=R[Xe+2],bt=R[Xe+4],rt=Math.max(Be,Ke,bt),xt=Math.min(Be,Ke,bt);rt>.9&&xt<.1&&(Be<.2&&(R[Xe+0]+=1),Ke<.2&&(R[Xe+2]+=1),bt<.2&&(R[Xe+4]+=1))}}function ue(Xe){_.push(Xe.x,Xe.y,Xe.z)}function ge(Xe,Be){const Ke=Xe*3;Be.x=r[Ke+0],Be.y=r[Ke+1],Be.z=r[Ke+2]}function _e(){const Xe=new ut,Be=new ut,Ke=new ut,bt=new ut,rt=new vn,xt=new vn,Mt=new vn;for(let $t=0,$e=0;$t<_.length;$t+=9,$e+=6){Xe.set(_[$t+0],_[$t+1],_[$t+2]),Be.set(_[$t+3],_[$t+4],_[$t+5]),Ke.set(_[$t+6],_[$t+7],_[$t+8]),rt.set(R[$e+0],R[$e+1]),xt.set(R[$e+2],R[$e+3]),Mt.set(R[$e+4],R[$e+5]),bt.copy(Xe).add(Be).add(Ke).divideScalar(3);const vt=be(bt);Re(rt,$e+0,Xe,vt),Re(xt,$e+2,Be,vt),Re(Mt,$e+4,Ke,vt)}}function Re(Xe,Be,Ke,bt){bt<0&&Xe.x===1&&(R[Be]=Xe.x-1),Ke.x===0&&Ke.z===0&&(R[Be]=bt/2/Math.PI+.5)}function be(Xe){return Math.atan2(Xe.z,-Xe.x)}function ve(Xe){return Math.atan2(-Xe.y,Math.sqrt(Xe.x*Xe.x+Xe.z*Xe.z))}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new Gh(r.vertices,r.indices,r.radius,r.details)}}class _v extends Gh{constructor(r=1,d=0){const g=(1+Math.sqrt(5))/2,y=1/g,_=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-y,-g,0,-y,g,0,y,-g,0,y,g,-y,-g,0,-y,g,0,y,-g,0,y,g,0,-g,0,-y,g,0,-y,-g,0,y,g,0,y],R=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(_,R,r,d),this.type="DodecahedronGeometry",this.parameters={radius:r,detail:d}}static fromJSON(r){return new _v(r.radius,r.detail)}}const Gg=new ut,Xg=new ut,Tv=new ut,jg=new G2;class eP extends Ur{constructor(r=null,d=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:r,thresholdAngle:d},r!==null){const y=Math.pow(10,4),_=Math.cos(bh*d),R=r.getIndex(),k=r.getAttribute("position"),X=R?R.count:k.count,K=[0,0,0],Q=["a","b","c"],xe=new Array(3),ue={},ge=[];for(let _e=0;_e<X;_e+=3){R?(K[0]=R.getX(_e),K[1]=R.getX(_e+1),K[2]=R.getX(_e+2)):(K[0]=_e,K[1]=_e+1,K[2]=_e+2);const{a:Re,b:be,c:ve}=jg;if(Re.fromBufferAttribute(k,K[0]),be.fromBufferAttribute(k,K[1]),ve.fromBufferAttribute(k,K[2]),jg.getNormal(Tv),xe[0]=`${Math.round(Re.x*y)},${Math.round(Re.y*y)},${Math.round(Re.z*y)}`,xe[1]=`${Math.round(be.x*y)},${Math.round(be.y*y)},${Math.round(be.z*y)}`,xe[2]=`${Math.round(ve.x*y)},${Math.round(ve.y*y)},${Math.round(ve.z*y)}`,!(xe[0]===xe[1]||xe[1]===xe[2]||xe[2]===xe[0]))for(let Xe=0;Xe<3;Xe++){const Be=(Xe+1)%3,Ke=xe[Xe],bt=xe[Be],rt=jg[Q[Xe]],xt=jg[Q[Be]],Mt=`${Ke}_${bt}`,$t=`${bt}_${Ke}`;$t in ue&&ue[$t]?(Tv.dot(ue[$t].normal)<=_&&(ge.push(rt.x,rt.y,rt.z),ge.push(xt.x,xt.y,xt.z)),ue[$t]=null):Mt in ue||(ue[Mt]={index0:K[Xe],index1:K[Be],normal:Tv.clone()})}}for(const _e in ue)if(ue[_e]){const{index0:Re,index1:be}=ue[_e];Gg.fromBufferAttribute(k,Re),Xg.fromBufferAttribute(k,be),ge.push(Gg.x,Gg.y,Gg.z),ge.push(Xg.x,Xg.y,Xg.z)}this.setAttribute("position",new Ux(ge,3))}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}}class Bf extends Vg{constructor(r){super(r),this.uuid=b2(),this.type="Shape",this.holes=[]}getPointsHoles(r){const d=[];for(let g=0,y=this.holes.length;g<y;g++)d[g]=this.holes[g].getPoints(r);return d}extractPoints(r){return{shape:this.getPoints(r),holes:this.getPointsHoles(r)}}copy(r){super.copy(r),this.holes=[];for(let d=0,g=r.holes.length;d<g;d++){const y=r.holes[d];this.holes.push(y.clone())}return this}toJSON(){const r=super.toJSON();r.uuid=this.uuid,r.holes=[];for(let d=0,g=this.holes.length;d<g;d++){const y=this.holes[d];r.holes.push(y.toJSON())}return r}fromJSON(r){super.fromJSON(r),this.uuid=r.uuid,this.holes=[];for(let d=0,g=r.holes.length;d<g;d++){const y=r.holes[d];this.holes.push(new Vg().fromJSON(y))}return this}}const xP={triangulate:function(I,r,d=2){const g=r&&r.length,y=g?r[0]*d:I.length;let _=Kw(I,0,y,d,!0);const R=[];if(!_||_.next===_.prev)return R;let k,X,K,Q,xe,ue,ge;if(g&&(_=vP(I,r,_,d)),I.length>80*d){k=K=I[0],X=Q=I[1];for(let _e=d;_e<y;_e+=d)xe=I[_e],ue=I[_e+1],xe<k&&(k=xe),ue<X&&(X=ue),xe>K&&(K=xe),ue>Q&&(Q=ue);ge=Math.max(K-k,Q-X),ge=ge!==0?32767/ge:0}return Vp(_,R,d,k,X,ge,0),R}};function Kw(I,r,d,g,y){let _,R;if(y===zP(I,r,d,g)>0)for(_=r;_<d;_+=g)R=Ww(_,I[_],I[_+1],R);else for(_=d-g;_>=r;_-=g)R=Ww(_,I[_],I[_+1],R);return R&&Kg(R,R.next)&&(Gp(R),R=R.next),R}function Xh(I,r){if(!I)return I;r||(r=I);let d=I,g;do if(g=!1,!d.steiner&&(Kg(d,d.next)||ds(d.prev,d,d.next)===0)){if(Gp(d),d=r=d.prev,d===d.next)break;g=!0}else d=d.next;while(g||d!==r);return r}function Vp(I,r,d,g,y,_,R){if(!I)return;!R&&_&&MP(I,g,y,_);let k=I,X,K;for(;I.prev!==I.next;){if(X=I.prev,K=I.next,_?uP(I,g,y,_):rP(I)){r.push(X.i/d|0),r.push(I.i/d|0),r.push(K.i/d|0),Gp(I),I=K.next,k=K.next;continue}if(I=K,I===k){R?R===1?(I=dP(Xh(I),r,d),Vp(I,r,d,g,y,_,2)):R===2&&gP(I,r,d,g,y,_):Vp(Xh(I),r,d,g,y,_,1);break}}}function rP(I){const r=I.prev,d=I,g=I.next;if(ds(r,d,g)>=0)return!1;const y=r.x,_=d.x,R=g.x,k=r.y,X=d.y,K=g.y,Q=y<_?y<R?y:R:_<R?_:R,xe=k<X?k<K?k:K:X<K?X:K,ue=y>_?y>R?y:R:_>R?_:R,ge=k>X?k>K?k:K:X>K?X:K;let _e=g.next;for(;_e!==r;){if(_e.x>=Q&&_e.x<=ue&&_e.y>=xe&&_e.y<=ge&&zf(y,k,_,X,R,K,_e.x,_e.y)&&ds(_e.prev,_e,_e.next)>=0)return!1;_e=_e.next}return!0}function uP(I,r,d,g){const y=I.prev,_=I,R=I.next;if(ds(y,_,R)>=0)return!1;const k=y.x,X=_.x,K=R.x,Q=y.y,xe=_.y,ue=R.y,ge=k<X?k<K?k:K:X<K?X:K,_e=Q<xe?Q<ue?Q:ue:xe<ue?xe:ue,Re=k>X?k>K?k:K:X>K?X:K,be=Q>xe?Q>ue?Q:ue:xe>ue?xe:ue,ve=Av(ge,_e,r,d,g),Xe=Av(Re,be,r,d,g);let Be=I.prevZ,Ke=I.nextZ;for(;Be&&Be.z>=ve&&Ke&&Ke.z<=Xe;){if(Be.x>=ge&&Be.x<=Re&&Be.y>=_e&&Be.y<=be&&Be!==y&&Be!==R&&zf(k,Q,X,xe,K,ue,Be.x,Be.y)&&ds(Be.prev,Be,Be.next)>=0||(Be=Be.prevZ,Ke.x>=ge&&Ke.x<=Re&&Ke.y>=_e&&Ke.y<=be&&Ke!==y&&Ke!==R&&zf(k,Q,X,xe,K,ue,Ke.x,Ke.y)&&ds(Ke.prev,Ke,Ke.next)>=0))return!1;Ke=Ke.nextZ}for(;Be&&Be.z>=ve;){if(Be.x>=ge&&Be.x<=Re&&Be.y>=_e&&Be.y<=be&&Be!==y&&Be!==R&&zf(k,Q,X,xe,K,ue,Be.x,Be.y)&&ds(Be.prev,Be,Be.next)>=0)return!1;Be=Be.prevZ}for(;Ke&&Ke.z<=Xe;){if(Ke.x>=ge&&Ke.x<=Re&&Ke.y>=_e&&Ke.y<=be&&Ke!==y&&Ke!==R&&zf(k,Q,X,xe,K,ue,Ke.x,Ke.y)&&ds(Ke.prev,Ke,Ke.next)>=0)return!1;Ke=Ke.nextZ}return!0}function dP(I,r,d){let g=I;do{const y=g.prev,_=g.next.next;!Kg(y,_)&&$w(y,g,g.next,_)&&Up(y,_)&&Up(_,y)&&(r.push(y.i/d|0),r.push(g.i/d|0),r.push(_.i/d|0),Gp(g),Gp(g.next),g=I=_),g=g.next}while(g!==I);return Xh(g)}function gP(I,r,d,g,y,_){let R=I;do{let k=R.next.next;for(;k!==R.prev;){if(R.i!==k.i&&NP(R,k)){let X=Jw(R,k);R=Xh(R,R.next),X=Xh(X,X.next),Vp(R,r,d,g,y,_,0),Vp(X,r,d,g,y,_,0);return}k=k.next}R=R.next}while(R!==I)}function vP(I,r,d,g){const y=[];let _,R,k,X,K;for(_=0,R=r.length;_<R;_++)k=r[_]*g,X=_<R-1?r[_+1]*g:I.length,K=Kw(I,k,X,g,!1),K===K.next&&(K.steiner=!0),y.push(RP(K));for(y.sort(bP),_=0;_<y.length;_++)d=_P(y[_],d);return d}function bP(I,r){return I.x-r.x}function _P(I,r){const d=TP(I,r);if(!d)return r;const g=Jw(d,I);return Xh(g,g.next),Xh(d,d.next)}function TP(I,r){let d=r,g=-1/0,y;const _=I.x,R=I.y;do{if(R<=d.y&&R>=d.next.y&&d.next.y!==d.y){const ue=d.x+(R-d.y)*(d.next.x-d.x)/(d.next.y-d.y);if(ue<=_&&ue>g&&(g=ue,y=d.x<d.next.x?d:d.next,ue===_))return y}d=d.next}while(d!==r);if(!y)return null;const k=y,X=y.x,K=y.y;let Q=1/0,xe;d=y;do _>=d.x&&d.x>=X&&_!==d.x&&zf(R<K?_:g,R,X,K,R<K?g:_,R,d.x,d.y)&&(xe=Math.abs(R-d.y)/(_-d.x),Up(d,I)&&(xe<Q||xe===Q&&(d.x>y.x||d.x===y.x&&AP(y,d)))&&(y=d,Q=xe)),d=d.next;while(d!==k);return y}function AP(I,r){return ds(I.prev,I,r.prev)<0&&ds(r.next,I,I.next)<0}function MP(I,r,d,g){let y=I;do y.z===0&&(y.z=Av(y.x,y.y,r,d,g)),y.prevZ=y.prev,y.nextZ=y.next,y=y.next;while(y!==I);y.prevZ.nextZ=null,y.prevZ=null,CP(y)}function CP(I){let r,d,g,y,_,R,k,X,K=1;do{for(d=I,I=null,_=null,R=0;d;){for(R++,g=d,k=0,r=0;r<K&&(k++,g=g.nextZ,!!g);r++);for(X=K;k>0||X>0&&g;)k!==0&&(X===0||!g||d.z<=g.z)?(y=d,d=d.nextZ,k--):(y=g,g=g.nextZ,X--),_?_.nextZ=y:I=y,y.prevZ=_,_=y;d=g}_.nextZ=null,K*=2}while(R>1);return I}function Av(I,r,d,g,y){return I=(I-d)*y|0,r=(r-g)*y|0,I=(I|I<<8)&16711935,I=(I|I<<4)&252645135,I=(I|I<<2)&858993459,I=(I|I<<1)&1431655765,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,I|r<<1}function RP(I){let r=I,d=I;do(r.x<d.x||r.x===d.x&&r.y<d.y)&&(d=r),r=r.next;while(r!==I);return d}function zf(I,r,d,g,y,_,R,k){return(y-R)*(r-k)>=(I-R)*(_-k)&&(I-R)*(g-k)>=(d-R)*(r-k)&&(d-R)*(_-k)>=(y-R)*(g-k)}function NP(I,r){return I.next.i!==r.i&&I.prev.i!==r.i&&!PP(I,r)&&(Up(I,r)&&Up(r,I)&&BP(I,r)&&(ds(I.prev,I,r.prev)||ds(I,r.prev,r))||Kg(I,r)&&ds(I.prev,I,I.next)>0&&ds(r.prev,r,r.next)>0)}function ds(I,r,d){return(r.y-I.y)*(d.x-r.x)-(r.x-I.x)*(d.y-r.y)}function Kg(I,r){return I.x===r.x&&I.y===r.y}function $w(I,r,d,g){const y=Jg(ds(I,r,d)),_=Jg(ds(I,r,g)),R=Jg(ds(d,g,I)),k=Jg(ds(d,g,r));return!!(y!==_&&R!==k||y===0&&$g(I,d,r)||_===0&&$g(I,g,r)||R===0&&$g(d,I,g)||k===0&&$g(d,r,g))}function $g(I,r,d){return r.x<=Math.max(I.x,d.x)&&r.x>=Math.min(I.x,d.x)&&r.y<=Math.max(I.y,d.y)&&r.y>=Math.min(I.y,d.y)}function Jg(I){return I>0?1:I<0?-1:0}function PP(I,r){let d=I;do{if(d.i!==I.i&&d.next.i!==I.i&&d.i!==r.i&&d.next.i!==r.i&&$w(d,d.next,I,r))return!0;d=d.next}while(d!==I);return!1}function Up(I,r){return ds(I.prev,I,I.next)<0?ds(I,r,I.next)>=0&&ds(I,I.prev,r)>=0:ds(I,r,I.prev)<0||ds(I,I.next,r)<0}function BP(I,r){let d=I,g=!1;const y=(I.x+r.x)/2,_=(I.y+r.y)/2;do d.y>_!=d.next.y>_&&d.next.y!==d.y&&y<(d.next.x-d.x)*(_-d.y)/(d.next.y-d.y)+d.x&&(g=!g),d=d.next;while(d!==I);return g}function Jw(I,r){const d=new Mv(I.i,I.x,I.y),g=new Mv(r.i,r.x,r.y),y=I.next,_=r.prev;return I.next=r,r.prev=I,d.next=y,y.prev=d,g.next=d,d.prev=g,_.next=g,g.prev=_,g}function Ww(I,r,d,g){const y=new Mv(I,r,d);return g?(y.next=g.next,y.prev=g,g.next.prev=y,g.next=y):(y.prev=y,y.next=y),y}function Gp(I){I.next.prev=I.prev,I.prev.next=I.next,I.prevZ&&(I.prevZ.nextZ=I.nextZ),I.nextZ&&(I.nextZ.prevZ=I.prevZ)}function Mv(I,r,d){this.i=I,this.x=r,this.y=d,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function zP(I,r,d,g){let y=0;for(let _=r,R=d-g;_<d;_+=g)y+=(I[R]-I[_])*(I[_+1]+I[R+1]),R=_;return y}class Kl{static area(r){const d=r.length;let g=0;for(let y=d-1,_=0;_<d;y=_++)g+=r[y].x*r[_].y-r[_].x*r[y].y;return g*.5}static isClockWise(r){return Kl.area(r)<0}static triangulateShape(r,d){const g=[],y=[],_=[];Qw(r),eS(g,r);let R=r.length;d.forEach(Qw);for(let X=0;X<d.length;X++)y.push(R),R+=d[X].length,eS(g,d[X]);const k=xP.triangulate(g,y);for(let X=0;X<k.length;X+=3)_.push(k.slice(X,X+3));return _}}function Qw(I){const r=I.length;r>2&&I[r-1].equals(I[0])&&I.pop()}function eS(I,r){for(let d=0;d<r.length;d++)I.push(r[d].x),I.push(r[d].y)}class Wg extends Ur{constructor(r=new Bf([new vn(.5,.5),new vn(-.5,.5),new vn(-.5,-.5),new vn(.5,-.5)]),d={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:r,options:d},r=Array.isArray(r)?r:[r];const g=this,y=[],_=[];for(let k=0,X=r.length;k<X;k++){const K=r[k];R(K)}this.setAttribute("position",new Ux(y,3)),this.setAttribute("uv",new Ux(_,2)),this.computeVertexNormals();function R(k){const X=[],K=d.curveSegments!==void 0?d.curveSegments:12,Q=d.steps!==void 0?d.steps:1,xe=d.depth!==void 0?d.depth:1;let ue=d.bevelEnabled!==void 0?d.bevelEnabled:!0,ge=d.bevelThickness!==void 0?d.bevelThickness:.2,_e=d.bevelSize!==void 0?d.bevelSize:ge-.1,Re=d.bevelOffset!==void 0?d.bevelOffset:0,be=d.bevelSegments!==void 0?d.bevelSegments:3;const ve=d.extrudePath,Xe=d.UVGenerator!==void 0?d.UVGenerator:VP;let Be,Ke=!1,bt,rt,xt,Mt;ve&&(Be=ve.getSpacedPoints(Q),Ke=!0,ue=!1,bt=ve.computeFrenetFrames(Q,!1),rt=new ut,xt=new ut,Mt=new ut),ue||(be=0,ge=0,_e=0,Re=0);const $t=k.extractPoints(K);let $e=$t.shape;const vt=$t.holes;if(!Kl.isClockWise($e)){$e=$e.reverse();for(let zt=0,Kn=vt.length;zt<Kn;zt++){const en=vt[zt];Kl.isClockWise(en)&&(vt[zt]=en.reverse())}}const V0=Kl.triangulateShape($e,vt),Pt=$e;for(let zt=0,Kn=vt.length;zt<Kn;zt++){const en=vt[zt];$e=$e.concat(en)}function x0(zt,Kn,en){return Kn||console.error("THREE.ExtrudeGeometry: vec does not exist"),zt.clone().addScaledVector(Kn,en)}const Wt=$e.length,an=V0.length;function W0(zt,Kn,en){let Vn,rn,jx;const _x=zt.x-Kn.x,Tt=zt.y-Kn.y,tt=en.x-zt.x,g0=en.y-zt.y,Cn=_x*_x+Tt*Tt,Tn=_x*g0-Tt*tt;if(Math.abs(Tn)>Number.EPSILON){const An=Math.sqrt(Cn),zx=Math.sqrt(tt*tt+g0*g0),xx=Kn.x-Tt/An,Ax=Kn.y+_x/An,sr=en.x-g0/zx,Pr=en.y+tt/zx,Mn=((sr-xx)*g0-(Pr-Ax)*tt)/(_x*g0-Tt*tt);Vn=xx+_x*Mn-zt.x,rn=Ax+Tt*Mn-zt.y;const di=Vn*Vn+rn*rn;if(di<=2)return new vn(Vn,rn);jx=Math.sqrt(di/2)}else{let An=!1;_x>Number.EPSILON?tt>Number.EPSILON&&(An=!0):_x<-Number.EPSILON?tt<-Number.EPSILON&&(An=!0):Math.sign(Tt)===Math.sign(g0)&&(An=!0),An?(Vn=-Tt,rn=_x,jx=Math.sqrt(Cn)):(Vn=_x,rn=Tt,jx=Math.sqrt(Cn/2))}return new vn(Vn/jx,rn/jx)}const j0=[];for(let zt=0,Kn=Pt.length,en=Kn-1,Vn=zt+1;zt<Kn;zt++,en++,Vn++)en===Kn&&(en=0),Vn===Kn&&(Vn=0),j0[zt]=W0(Pt[zt],Pt[en],Pt[Vn]);const un=[];let bn,ex=j0.concat();for(let zt=0,Kn=vt.length;zt<Kn;zt++){const en=vt[zt];bn=[];for(let Vn=0,rn=en.length,jx=rn-1,_x=Vn+1;Vn<rn;Vn++,jx++,_x++)jx===rn&&(jx=0),_x===rn&&(_x=0),bn[Vn]=W0(en[Vn],en[jx],en[_x]);un.push(bn),ex=ex.concat(bn)}for(let zt=0;zt<be;zt++){const Kn=zt/be,en=ge*Math.cos(Kn*Math.PI/2),Vn=_e*Math.sin(Kn*Math.PI/2)+Re;for(let rn=0,jx=Pt.length;rn<jx;rn++){const _x=x0(Pt[rn],j0[rn],Vn);Rx(_x.x,_x.y,-en)}for(let rn=0,jx=vt.length;rn<jx;rn++){const _x=vt[rn];bn=un[rn];for(let Tt=0,tt=_x.length;Tt<tt;Tt++){const g0=x0(_x[Tt],bn[Tt],Vn);Rx(g0.x,g0.y,-en)}}}const Cx=_e+Re;for(let zt=0;zt<Wt;zt++){const Kn=ue?x0($e[zt],ex[zt],Cx):$e[zt];Ke?(xt.copy(bt.normals[0]).multiplyScalar(Kn.x),rt.copy(bt.binormals[0]).multiplyScalar(Kn.y),Mt.copy(Be[0]).add(xt).add(rt),Rx(Mt.x,Mt.y,Mt.z)):Rx(Kn.x,Kn.y,0)}for(let zt=1;zt<=Q;zt++)for(let Kn=0;Kn<Wt;Kn++){const en=ue?x0($e[Kn],ex[Kn],Cx):$e[Kn];Ke?(xt.copy(bt.normals[zt]).multiplyScalar(en.x),rt.copy(bt.binormals[zt]).multiplyScalar(en.y),Mt.copy(Be[zt]).add(xt).add(rt),Rx(Mt.x,Mt.y,Mt.z)):Rx(en.x,en.y,xe/Q*zt)}for(let zt=be-1;zt>=0;zt--){const Kn=zt/be,en=ge*Math.cos(Kn*Math.PI/2),Vn=_e*Math.sin(Kn*Math.PI/2)+Re;for(let rn=0,jx=Pt.length;rn<jx;rn++){const _x=x0(Pt[rn],j0[rn],Vn);Rx(_x.x,_x.y,xe+en)}for(let rn=0,jx=vt.length;rn<jx;rn++){const _x=vt[rn];bn=un[rn];for(let Tt=0,tt=_x.length;Tt<tt;Tt++){const g0=x0(_x[Tt],bn[Tt],Vn);Ke?Rx(g0.x,g0.y+Be[Q-1].y,Be[Q-1].x+en):Rx(g0.x,g0.y,xe+en)}}}R0(),_n();function R0(){const zt=y.length/3;if(ue){let Kn=0,en=Wt*Kn;for(let Vn=0;Vn<an;Vn++){const rn=V0[Vn];Bx(rn[2]+en,rn[1]+en,rn[0]+en)}Kn=Q+be*2,en=Wt*Kn;for(let Vn=0;Vn<an;Vn++){const rn=V0[Vn];Bx(rn[0]+en,rn[1]+en,rn[2]+en)}}else{for(let Kn=0;Kn<an;Kn++){const en=V0[Kn];Bx(en[2],en[1],en[0])}for(let Kn=0;Kn<an;Kn++){const en=V0[Kn];Bx(en[0]+Wt*Q,en[1]+Wt*Q,en[2]+Wt*Q)}}g.addGroup(zt,y.length/3-zt,0)}function _n(){const zt=y.length/3;let Kn=0;ux(Pt,Kn),Kn+=Pt.length;for(let en=0,Vn=vt.length;en<Vn;en++){const rn=vt[en];ux(rn,Kn),Kn+=rn.length}g.addGroup(zt,y.length/3-zt,1)}function ux(zt,Kn){let en=zt.length;for(;--en>=0;){const Vn=en;let rn=en-1;rn<0&&(rn=zt.length-1);for(let jx=0,_x=Q+be*2;jx<_x;jx++){const Tt=Wt*jx,tt=Wt*(jx+1),g0=Kn+Vn+Tt,Cn=Kn+rn+Tt,Tn=Kn+rn+tt,An=Kn+Vn+tt;Px(g0,Cn,Tn,An)}}}function Rx(zt,Kn,en){X.push(zt),X.push(Kn),X.push(en)}function Bx(zt,Kn,en){xr(zt),xr(Kn),xr(en);const Vn=y.length/3,rn=Xe.generateTopUV(g,y,Vn-3,Vn-2,Vn-1);Xx(rn[0]),Xx(rn[1]),Xx(rn[2])}function Px(zt,Kn,en,Vn){xr(zt),xr(Kn),xr(Vn),xr(Kn),xr(en),xr(Vn);const rn=y.length/3,jx=Xe.generateSideWallUV(g,y,rn-6,rn-3,rn-2,rn-1);Xx(jx[0]),Xx(jx[1]),Xx(jx[3]),Xx(jx[1]),Xx(jx[2]),Xx(jx[3])}function xr(zt){y.push(X[zt*3+0]),y.push(X[zt*3+1]),y.push(X[zt*3+2])}function Xx(zt){_.push(zt.x),_.push(zt.y)}}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}toJSON(){const r=super.toJSON(),d=this.parameters.shapes,g=this.parameters.options;return UP(d,g,r)}static fromJSON(r,d){const g=[];for(let _=0,R=r.shapes.length;_<R;_++){const k=d[r.shapes[_]];g.push(k)}const y=r.options.extrudePath;return y!==void 0&&(r.options.extrudePath=new zg[y.type]().fromJSON(y)),new Wg(g,r.options)}}const VP={generateTopUV:function(I,r,d,g,y){const _=r[d*3],R=r[d*3+1],k=r[g*3],X=r[g*3+1],K=r[y*3],Q=r[y*3+1];return[new vn(_,R),new vn(k,X),new vn(K,Q)]},generateSideWallUV:function(I,r,d,g,y,_){const R=r[d*3],k=r[d*3+1],X=r[d*3+2],K=r[g*3],Q=r[g*3+1],xe=r[g*3+2],ue=r[y*3],ge=r[y*3+1],_e=r[y*3+2],Re=r[_*3],be=r[_*3+1],ve=r[_*3+2];return Math.abs(k-Q)<Math.abs(R-K)?[new vn(R,1-X),new vn(K,1-xe),new vn(ue,1-_e),new vn(Re,1-ve)]:[new vn(k,1-X),new vn(Q,1-xe),new vn(ge,1-_e),new vn(be,1-ve)]}};function UP(I,r,d){if(d.shapes=[],Array.isArray(I))for(let g=0,y=I.length;g<y;g++){const _=I[g];d.shapes.push(_.uuid)}else d.shapes.push(I.uuid);return d.options=Object.assign({},r),r.extrudePath!==void 0&&(d.options.extrudePath=r.extrudePath.toJSON()),d}class Cv extends Gh{constructor(r=1,d=0){const g=(1+Math.sqrt(5))/2,y=[-1,g,0,1,g,0,-1,-g,0,1,-g,0,0,-1,g,0,1,g,0,-1,-g,0,1,-g,g,0,-1,g,0,1,-g,0,-1,-g,0,1],_=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(y,_,r,d),this.type="IcosahedronGeometry",this.parameters={radius:r,detail:d}}static fromJSON(r){return new Cv(r.radius,r.detail)}}class Qg extends Gh{constructor(r=1,d=0){const g=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],y=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(g,y,r,d),this.type="OctahedronGeometry",this.parameters={radius:r,detail:d}}static fromJSON(r){return new Qg(r.radius,r.detail)}}class Rv extends Ur{constructor(r=.5,d=1,g=32,y=1,_=0,R=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:r,outerRadius:d,thetaSegments:g,phiSegments:y,thetaStart:_,thetaLength:R},g=Math.max(3,g),y=Math.max(1,y);const k=[],X=[],K=[],Q=[];let xe=r;const ue=(d-r)/y,ge=new ut,_e=new vn;for(let Re=0;Re<=y;Re++){for(let be=0;be<=g;be++){const ve=_+be/g*R;ge.x=xe*Math.cos(ve),ge.y=xe*Math.sin(ve),X.push(ge.x,ge.y,ge.z),K.push(0,0,1),_e.x=(ge.x/d+1)/2,_e.y=(ge.y/d+1)/2,Q.push(_e.x,_e.y)}xe+=ue}for(let Re=0;Re<y;Re++){const be=Re*(g+1);for(let ve=0;ve<g;ve++){const Xe=ve+be,Be=Xe,Ke=Xe+g+1,bt=Xe+g+2,rt=Xe+1;k.push(Be,Ke,rt),k.push(Ke,bt,rt)}}this.setIndex(k),this.setAttribute("position",new Ux(X,3)),this.setAttribute("normal",new Ux(K,3)),this.setAttribute("uv",new Ux(Q,2))}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new Rv(r.innerRadius,r.outerRadius,r.thetaSegments,r.phiSegments,r.thetaStart,r.thetaLength)}}class Nv extends Ur{constructor(r=new Bf([new vn(0,.5),new vn(-.5,-.5),new vn(.5,-.5)]),d=12){super(),this.type="ShapeGeometry",this.parameters={shapes:r,curveSegments:d};const g=[],y=[],_=[],R=[];let k=0,X=0;if(Array.isArray(r)===!1)K(r);else for(let Q=0;Q<r.length;Q++)K(r[Q]),this.addGroup(k,X,Q),k+=X,X=0;this.setIndex(g),this.setAttribute("position",new Ux(y,3)),this.setAttribute("normal",new Ux(_,3)),this.setAttribute("uv",new Ux(R,2));function K(Q){const xe=y.length/3,ue=Q.extractPoints(d);let ge=ue.shape;const _e=ue.holes;Kl.isClockWise(ge)===!1&&(ge=ge.reverse());for(let be=0,ve=_e.length;be<ve;be++){const Xe=_e[be];Kl.isClockWise(Xe)===!0&&(_e[be]=Xe.reverse())}const Re=Kl.triangulateShape(ge,_e);for(let be=0,ve=_e.length;be<ve;be++){const Xe=_e[be];ge=ge.concat(Xe)}for(let be=0,ve=ge.length;be<ve;be++){const Xe=ge[be];y.push(Xe.x,Xe.y,0),_.push(0,0,1),R.push(Xe.x,Xe.y)}for(let be=0,ve=Re.length;be<ve;be++){const Xe=Re[be],Be=Xe[0]+xe,Ke=Xe[1]+xe,bt=Xe[2]+xe;g.push(Be,Ke,bt),X+=3}}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}toJSON(){const r=super.toJSON(),d=this.parameters.shapes;return GP(d,r)}static fromJSON(r,d){const g=[];for(let y=0,_=r.shapes.length;y<_;y++){const R=d[r.shapes[y]];g.push(R)}return new Nv(g,r.curveSegments)}}function GP(I,r){if(r.shapes=[],Array.isArray(I))for(let d=0,g=I.length;d<g;d++){const y=I[d];r.shapes.push(y.uuid)}else r.shapes.push(I.uuid);return r}class ey extends Ur{constructor(r=1,d=32,g=16,y=0,_=Math.PI*2,R=0,k=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:r,widthSegments:d,heightSegments:g,phiStart:y,phiLength:_,thetaStart:R,thetaLength:k},d=Math.max(3,Math.floor(d)),g=Math.max(2,Math.floor(g));const X=Math.min(R+k,Math.PI);let K=0;const Q=[],xe=new ut,ue=new ut,ge=[],_e=[],Re=[],be=[];for(let ve=0;ve<=g;ve++){const Xe=[],Be=ve/g;let Ke=0;ve===0&&R===0?Ke=.5/d:ve===g&&X===Math.PI&&(Ke=-.5/d);for(let bt=0;bt<=d;bt++){const rt=bt/d;xe.x=-r*Math.cos(y+rt*_)*Math.sin(R+Be*k),xe.y=r*Math.cos(R+Be*k),xe.z=r*Math.sin(y+rt*_)*Math.sin(R+Be*k),_e.push(xe.x,xe.y,xe.z),ue.copy(xe).normalize(),Re.push(ue.x,ue.y,ue.z),be.push(rt+Ke,1-Be),Xe.push(K++)}Q.push(Xe)}for(let ve=0;ve<g;ve++)for(let Xe=0;Xe<d;Xe++){const Be=Q[ve][Xe+1],Ke=Q[ve][Xe],bt=Q[ve+1][Xe],rt=Q[ve+1][Xe+1];(ve!==0||R>0)&&ge.push(Be,Ke,rt),(ve!==g-1||X<Math.PI)&&ge.push(Ke,bt,rt)}this.setIndex(ge),this.setAttribute("position",new Ux(_e,3)),this.setAttribute("normal",new Ux(Re,3)),this.setAttribute("uv",new Ux(be,2))}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new ey(r.radius,r.widthSegments,r.heightSegments,r.phiStart,r.phiLength,r.thetaStart,r.thetaLength)}}class Pv extends Gh{constructor(r=1,d=0){const g=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],y=[2,1,0,0,3,2,1,3,0,2,3,1];super(g,y,r,d),this.type="TetrahedronGeometry",this.parameters={radius:r,detail:d}}static fromJSON(r){return new Pv(r.radius,r.detail)}}class Bv extends Ur{constructor(r=1,d=.4,g=12,y=48,_=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:r,tube:d,radialSegments:g,tubularSegments:y,arc:_},g=Math.floor(g),y=Math.floor(y);const R=[],k=[],X=[],K=[],Q=new ut,xe=new ut,ue=new ut;for(let ge=0;ge<=g;ge++)for(let _e=0;_e<=y;_e++){const Re=_e/y*_,be=ge/g*Math.PI*2;xe.x=(r+d*Math.cos(be))*Math.cos(Re),xe.y=(r+d*Math.cos(be))*Math.sin(Re),xe.z=d*Math.sin(be),k.push(xe.x,xe.y,xe.z),Q.x=r*Math.cos(Re),Q.y=r*Math.sin(Re),ue.subVectors(xe,Q).normalize(),X.push(ue.x,ue.y,ue.z),K.push(_e/y),K.push(ge/g)}for(let ge=1;ge<=g;ge++)for(let _e=1;_e<=y;_e++){const Re=(y+1)*ge+_e-1,be=(y+1)*(ge-1)+_e-1,ve=(y+1)*(ge-1)+_e,Xe=(y+1)*ge+_e;R.push(Re,be,Xe),R.push(be,ve,Xe)}this.setIndex(R),this.setAttribute("position",new Ux(k,3)),this.setAttribute("normal",new Ux(X,3)),this.setAttribute("uv",new Ux(K,2))}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new Bv(r.radius,r.tube,r.radialSegments,r.tubularSegments,r.arc)}}class zv extends Ur{constructor(r=1,d=.4,g=64,y=8,_=2,R=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:r,tube:d,tubularSegments:g,radialSegments:y,p:_,q:R},g=Math.floor(g),y=Math.floor(y);const k=[],X=[],K=[],Q=[],xe=new ut,ue=new ut,ge=new ut,_e=new ut,Re=new ut,be=new ut,ve=new ut;for(let Be=0;Be<=g;++Be){const Ke=Be/g*_*Math.PI*2;Xe(Ke,_,R,r,ge),Xe(Ke+.01,_,R,r,_e),be.subVectors(_e,ge),ve.addVectors(_e,ge),Re.crossVectors(be,ve),ve.crossVectors(Re,be),Re.normalize(),ve.normalize();for(let bt=0;bt<=y;++bt){const rt=bt/y*Math.PI*2,xt=-d*Math.cos(rt),Mt=d*Math.sin(rt);xe.x=ge.x+(xt*ve.x+Mt*Re.x),xe.y=ge.y+(xt*ve.y+Mt*Re.y),xe.z=ge.z+(xt*ve.z+Mt*Re.z),X.push(xe.x,xe.y,xe.z),ue.subVectors(xe,ge).normalize(),K.push(ue.x,ue.y,ue.z),Q.push(Be/g),Q.push(bt/y)}}for(let Be=1;Be<=g;Be++)for(let Ke=1;Ke<=y;Ke++){const bt=(y+1)*(Be-1)+(Ke-1),rt=(y+1)*Be+(Ke-1),xt=(y+1)*Be+Ke,Mt=(y+1)*(Be-1)+Ke;k.push(bt,rt,Mt),k.push(rt,xt,Mt)}this.setIndex(k),this.setAttribute("position",new Ux(X,3)),this.setAttribute("normal",new Ux(K,3)),this.setAttribute("uv",new Ux(Q,2));function Xe(Be,Ke,bt,rt,xt){const Mt=Math.cos(Be),$t=Math.sin(Be),$e=bt/Ke*Be,vt=Math.cos($e);xt.x=rt*(2+vt)*.5*Mt,xt.y=rt*(2+vt)*$t*.5,xt.z=rt*Math.sin($e)*.5}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}static fromJSON(r){return new zv(r.radius,r.tube,r.tubularSegments,r.radialSegments,r.p,r.q)}}class Vv extends Ur{constructor(r=new Xw(new ut(-1,-1,0),new ut(-1,1,0),new ut(1,1,0)),d=64,g=1,y=8,_=!1){super(),this.type="TubeGeometry",this.parameters={path:r,tubularSegments:d,radius:g,radialSegments:y,closed:_};const R=r.computeFrenetFrames(d,_);this.tangents=R.tangents,this.normals=R.normals,this.binormals=R.binormals;const k=new ut,X=new ut,K=new vn;let Q=new ut;const xe=[],ue=[],ge=[],_e=[];Re(),this.setIndex(_e),this.setAttribute("position",new Ux(xe,3)),this.setAttribute("normal",new Ux(ue,3)),this.setAttribute("uv",new Ux(ge,2));function Re(){for(let Be=0;Be<d;Be++)be(Be);be(_===!1?d:0),Xe(),ve()}function be(Be){Q=r.getPointAt(Be/d,Q);const Ke=R.normals[Be],bt=R.binormals[Be];for(let rt=0;rt<=y;rt++){const xt=rt/y*Math.PI*2,Mt=Math.sin(xt),$t=-Math.cos(xt);X.x=$t*Ke.x+Mt*bt.x,X.y=$t*Ke.y+Mt*bt.y,X.z=$t*Ke.z+Mt*bt.z,X.normalize(),ue.push(X.x,X.y,X.z),k.x=Q.x+g*X.x,k.y=Q.y+g*X.y,k.z=Q.z+g*X.z,xe.push(k.x,k.y,k.z)}}function ve(){for(let Be=1;Be<=d;Be++)for(let Ke=1;Ke<=y;Ke++){const bt=(y+1)*(Be-1)+(Ke-1),rt=(y+1)*Be+(Ke-1),xt=(y+1)*Be+Ke,Mt=(y+1)*(Be-1)+Ke;_e.push(bt,rt,Mt),_e.push(rt,xt,Mt)}}function Xe(){for(let Be=0;Be<=d;Be++)for(let Ke=0;Ke<=y;Ke++)K.x=Be/d,K.y=Ke/y,ge.push(K.x,K.y)}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}toJSON(){const r=super.toJSON();return r.path=this.parameters.path.toJSON(),r}static fromJSON(r){return new Vv(new zg[r.path.type]().fromJSON(r.path),r.tubularSegments,r.radius,r.radialSegments,r.closed)}}class XP extends Ur{constructor(r=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:r},r!==null){const d=[],g=new Set,y=new ut,_=new ut;if(r.index!==null){const R=r.attributes.position,k=r.index;let X=r.groups;X.length===0&&(X=[{start:0,count:k.count,materialIndex:0}]);for(let K=0,Q=X.length;K<Q;++K){const xe=X[K],ue=xe.start,ge=xe.count;for(let _e=ue,Re=ue+ge;_e<Re;_e+=3)for(let be=0;be<3;be++){const ve=k.getX(_e+be),Xe=k.getX(_e+(be+1)%3);y.fromBufferAttribute(R,ve),_.fromBufferAttribute(R,Xe),xS(y,_,g)===!0&&(d.push(y.x,y.y,y.z),d.push(_.x,_.y,_.z))}}}else{const R=r.attributes.position;for(let k=0,X=R.count/3;k<X;k++)for(let K=0;K<3;K++){const Q=3*k+K,xe=3*k+(K+1)%3;y.fromBufferAttribute(R,Q),_.fromBufferAttribute(R,xe),xS(y,_,g)===!0&&(d.push(y.x,y.y,y.z),d.push(_.x,_.y,_.z))}}this.setAttribute("position",new Ux(d,3))}}copy(r){return super.copy(r),this.parameters=Object.assign({},r.parameters),this}}function xS(I,r,d){const g=`${I.x},${I.y},${I.z}-${r.x},${r.y},${r.z}`,y=`${r.x},${r.y},${r.z}-${I.x},${I.y},${I.z}`;return d.has(g)===!0||d.has(y)===!0?!1:(d.add(g),d.add(y),!0)}var rS=Object.freeze({__proto__:null,BoxGeometry:ef,CapsuleGeometry:gv,CircleGeometry:vv,ConeGeometry:bv,CylinderGeometry:zp,DodecahedronGeometry:_v,EdgesGeometry:eP,ExtrudeGeometry:Wg,IcosahedronGeometry:Cv,LatheGeometry:Ug,OctahedronGeometry:Qg,PlaneGeometry:bp,PolyhedronGeometry:Gh,RingGeometry:Rv,ShapeGeometry:Nv,SphereGeometry:ey,TetrahedronGeometry:Pv,TorusGeometry:Bv,TorusKnotGeometry:zv,TubeGeometry:Vv,WireframeGeometry:XP});class jP extends null{constructor(r){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new bx(0),this.transparent=!0,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.fog=r.fog,this}}class KP extends null{constructor(r){super(r),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Vf extends T2{constructor(r){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new bx(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new bx(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rn,this.normalScale=new vn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.defines={STANDARD:""},this.color.copy(r.color),this.roughness=r.roughness,this.metalness=r.metalness,this.map=r.map,this.lightMap=r.lightMap,this.lightMapIntensity=r.lightMapIntensity,this.aoMap=r.aoMap,this.aoMapIntensity=r.aoMapIntensity,this.emissive.copy(r.emissive),this.emissiveMap=r.emissiveMap,this.emissiveIntensity=r.emissiveIntensity,this.bumpMap=r.bumpMap,this.bumpScale=r.bumpScale,this.normalMap=r.normalMap,this.normalMapType=r.normalMapType,this.normalScale.copy(r.normalScale),this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.roughnessMap=r.roughnessMap,this.metalnessMap=r.metalnessMap,this.alphaMap=r.alphaMap,this.envMap=r.envMap,this.envMapIntensity=r.envMapIntensity,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.wireframeLinecap=r.wireframeLinecap,this.wireframeLinejoin=r.wireframeLinejoin,this.flatShading=r.flatShading,this.fog=r.fog,this}}class xl extends Vf{constructor(r){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new vn(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return As(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(d){this.ior=(1+.4*d)/(1-.4*d)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new bx(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new bx(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new bx(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(r)}get anisotropy(){return this._anisotropy}set anisotropy(r){this._anisotropy>0!=r>0&&this.version++,this._anisotropy=r}get clearcoat(){return this._clearcoat}set clearcoat(r){this._clearcoat>0!=r>0&&this.version++,this._clearcoat=r}get iridescence(){return this._iridescence}set iridescence(r){this._iridescence>0!=r>0&&this.version++,this._iridescence=r}get sheen(){return this._sheen}set sheen(r){this._sheen>0!=r>0&&this.version++,this._sheen=r}get transmission(){return this._transmission}set transmission(r){this._transmission>0!=r>0&&this.version++,this._transmission=r}copy(r){return super.copy(r),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=r.anisotropy,this.anisotropyRotation=r.anisotropyRotation,this.anisotropyMap=r.anisotropyMap,this.clearcoat=r.clearcoat,this.clearcoatMap=r.clearcoatMap,this.clearcoatRoughness=r.clearcoatRoughness,this.clearcoatRoughnessMap=r.clearcoatRoughnessMap,this.clearcoatNormalMap=r.clearcoatNormalMap,this.clearcoatNormalScale.copy(r.clearcoatNormalScale),this.ior=r.ior,this.iridescence=r.iridescence,this.iridescenceMap=r.iridescenceMap,this.iridescenceIOR=r.iridescenceIOR,this.iridescenceThicknessRange=[...r.iridescenceThicknessRange],this.iridescenceThicknessMap=r.iridescenceThicknessMap,this.sheen=r.sheen,this.sheenColor.copy(r.sheenColor),this.sheenColorMap=r.sheenColorMap,this.sheenRoughness=r.sheenRoughness,this.sheenRoughnessMap=r.sheenRoughnessMap,this.transmission=r.transmission,this.transmissionMap=r.transmissionMap,this.thickness=r.thickness,this.thicknessMap=r.thicknessMap,this.attenuationDistance=r.attenuationDistance,this.attenuationColor.copy(r.attenuationColor),this.specularIntensity=r.specularIntensity,this.specularIntensityMap=r.specularIntensityMap,this.specularColor.copy(r.specularColor),this.specularColorMap=r.specularColorMap,this}}class $P extends null{constructor(r){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new bx(16777215),this.specular=new bx(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new bx(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rn,this.normalScale=new vn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=bc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.specular.copy(r.specular),this.shininess=r.shininess,this.map=r.map,this.lightMap=r.lightMap,this.lightMapIntensity=r.lightMapIntensity,this.aoMap=r.aoMap,this.aoMapIntensity=r.aoMapIntensity,this.emissive.copy(r.emissive),this.emissiveMap=r.emissiveMap,this.emissiveIntensity=r.emissiveIntensity,this.bumpMap=r.bumpMap,this.bumpScale=r.bumpScale,this.normalMap=r.normalMap,this.normalMapType=r.normalMapType,this.normalScale.copy(r.normalScale),this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.specularMap=r.specularMap,this.alphaMap=r.alphaMap,this.envMap=r.envMap,this.combine=r.combine,this.reflectivity=r.reflectivity,this.refractionRatio=r.refractionRatio,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.wireframeLinecap=r.wireframeLinecap,this.wireframeLinejoin=r.wireframeLinejoin,this.flatShading=r.flatShading,this.fog=r.fog,this}}class JP extends null{constructor(r){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new bx(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new bx(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rn,this.normalScale=new vn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.map=r.map,this.gradientMap=r.gradientMap,this.lightMap=r.lightMap,this.lightMapIntensity=r.lightMapIntensity,this.aoMap=r.aoMap,this.aoMapIntensity=r.aoMapIntensity,this.emissive.copy(r.emissive),this.emissiveMap=r.emissiveMap,this.emissiveIntensity=r.emissiveIntensity,this.bumpMap=r.bumpMap,this.bumpScale=r.bumpScale,this.normalMap=r.normalMap,this.normalMapType=r.normalMapType,this.normalScale.copy(r.normalScale),this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.alphaMap=r.alphaMap,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.wireframeLinecap=r.wireframeLinecap,this.wireframeLinejoin=r.wireframeLinejoin,this.fog=r.fog,this}}class WP extends null{constructor(r){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rn,this.normalScale=new vn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(r)}copy(r){return super.copy(r),this.bumpMap=r.bumpMap,this.bumpScale=r.bumpScale,this.normalMap=r.normalMap,this.normalMapType=r.normalMapType,this.normalScale.copy(r.normalScale),this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.flatShading=r.flatShading,this}}class QP extends null{constructor(r){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new bx(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new bx(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rn,this.normalScale=new vn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=bc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.color.copy(r.color),this.map=r.map,this.lightMap=r.lightMap,this.lightMapIntensity=r.lightMapIntensity,this.aoMap=r.aoMap,this.aoMapIntensity=r.aoMapIntensity,this.emissive.copy(r.emissive),this.emissiveMap=r.emissiveMap,this.emissiveIntensity=r.emissiveIntensity,this.bumpMap=r.bumpMap,this.bumpScale=r.bumpScale,this.normalMap=r.normalMap,this.normalMapType=r.normalMapType,this.normalScale.copy(r.normalScale),this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.specularMap=r.specularMap,this.alphaMap=r.alphaMap,this.envMap=r.envMap,this.combine=r.combine,this.reflectivity=r.reflectivity,this.refractionRatio=r.refractionRatio,this.wireframe=r.wireframe,this.wireframeLinewidth=r.wireframeLinewidth,this.wireframeLinecap=r.wireframeLinecap,this.wireframeLinejoin=r.wireframeLinejoin,this.flatShading=r.flatShading,this.fog=r.fog,this}}class e5 extends null{constructor(r){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new bx(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rn,this.normalScale=new vn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(r)}copy(r){return super.copy(r),this.defines={MATCAP:""},this.color.copy(r.color),this.matcap=r.matcap,this.map=r.map,this.bumpMap=r.bumpMap,this.bumpScale=r.bumpScale,this.normalMap=r.normalMap,this.normalMapType=r.normalMapType,this.normalScale.copy(r.normalScale),this.displacementMap=r.displacementMap,this.displacementScale=r.displacementScale,this.displacementBias=r.displacementBias,this.alphaMap=r.alphaMap,this.flatShading=r.flatShading,this.fog=r.fog,this}}class x5 extends null{constructor(r){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(r)}copy(r){return super.copy(r),this.scale=r.scale,this.dashSize=r.dashSize,this.gapSize=r.gapSize,this}}function jh(I,r,d){return!I||!d&&I.constructor===r?I:typeof r.BYTES_PER_ELEMENT=="number"?new r(I):Array.prototype.slice.call(I)}function uS(I){return ArrayBuffer.isView(I)&&!(I instanceof DataView)}function dS(I){function r(y,_){return I[y]-I[_]}const d=I.length,g=new Array(d);for(let y=0;y!==d;++y)g[y]=y;return g.sort(r),g}function Uv(I,r,d){const g=I.length,y=new I.constructor(g);for(let _=0,R=0;R!==g;++_){const k=d[_]*r;for(let X=0;X!==r;++X)y[R++]=I[k+X]}return y}function Gv(I,r,d,g){let y=1,_=I[0];for(;_!==void 0&&_[g]===void 0;)_=I[y++];if(_===void 0)return;let R=_[g];if(R!==void 0)if(Array.isArray(R))do R=_[g],R!==void 0&&(r.push(_.time),d.push.apply(d,R)),_=I[y++];while(_!==void 0);else if(R.toArray!==void 0)do R=_[g],R!==void 0&&(r.push(_.time),R.toArray(d,d.length)),_=I[y++];while(_!==void 0);else do R=_[g],R!==void 0&&(r.push(_.time),d.push(R)),_=I[y++];while(_!==void 0)}function r5(I,r,d,g,y=30){const _=I.clone();_.name=r;const R=[];for(let X=0;X<_.tracks.length;++X){const K=_.tracks[X],Q=K.getValueSize(),xe=[],ue=[];for(let ge=0;ge<K.times.length;++ge){const _e=K.times[ge]*y;if(!(_e<d||_e>=g)){xe.push(K.times[ge]);for(let Re=0;Re<Q;++Re)ue.push(K.values[ge*Q+Re])}}xe.length!==0&&(K.times=jh(xe,K.times.constructor),K.values=jh(ue,K.values.constructor),R.push(K))}_.tracks=R;let k=1/0;for(let X=0;X<_.tracks.length;++X)k>_.tracks[X].times[0]&&(k=_.tracks[X].times[0]);for(let X=0;X<_.tracks.length;++X)_.tracks[X].shift(-1*k);return _.resetDuration(),_}function u5(I,r=0,d=I,g=30){g<=0&&(g=30);const y=d.tracks.length,_=r/g;for(let R=0;R<y;++R){const k=d.tracks[R],X=k.ValueTypeName;if(X==="bool"||X==="string")continue;const K=I.tracks.find(function(ve){return ve.name===k.name&&ve.ValueTypeName===X});if(K===void 0)continue;let Q=0;const xe=k.getValueSize();k.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(Q=xe/3);let ue=0;const ge=K.getValueSize();K.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(ue=ge/3);const _e=k.times.length-1;let Re;if(_<=k.times[0]){const ve=Q,Xe=xe-Q;Re=k.values.slice(ve,Xe)}else if(_>=k.times[_e]){const ve=_e*xe+Q,Xe=ve+xe-Q;Re=k.values.slice(ve,Xe)}else{const ve=k.createInterpolant(),Xe=Q,Be=xe-Q;ve.evaluate(_),Re=ve.resultBuffer.slice(Xe,Be)}X==="quaternion"&&new Xa().fromArray(Re).normalize().conjugate().toArray(Re);const be=K.times.length;for(let ve=0;ve<be;++ve){const Xe=ve*ge+ue;if(X==="quaternion")Xa.multiplyQuaternionsFlat(K.values,Xe,Re,0,K.values,Xe);else{const Be=ge-ue*2;for(let Ke=0;Ke<Be;++Ke)K.values[Xe+Ke]-=Re[Ke]}}}return I.blendMode=Ge,I}const N9={convertArray:jh,isTypedArray:uS,getKeyframeOrder:dS,sortedArray:Uv,flattenJSON:Gv,subclip:r5,makeClipAdditive:u5};class Xp{constructor(r,d,g,y){this.parameterPositions=r,this._cachedIndex=0,this.resultBuffer=y!==void 0?y:new d.constructor(g),this.sampleValues=d,this.valueSize=g,this.settings=null,this.DefaultSettings_={}}evaluate(r){const d=this.parameterPositions;let g=this._cachedIndex,y=d[g],_=d[g-1];e:{t:{let R;n:{x:if(!(r<y)){for(let k=g+2;;){if(y===void 0){if(r<_)break x;return g=d.length,this._cachedIndex=g,this.copySampleValue_(g-1)}if(g===k)break;if(_=y,y=d[++g],r<y)break t}R=d.length;break n}if(!(r>=_)){const k=d[1];r<k&&(g=2,_=k);for(let X=g-2;;){if(_===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(g===X)break;if(y=_,_=d[--g-1],r>=_)break t}R=g,g=0;break n}break e}for(;g<R;){const k=g+R>>>1;r<d[k]?R=k:g=k+1}if(y=d[g],_=d[g-1],_===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(y===void 0)return g=d.length,this._cachedIndex=g,this.copySampleValue_(g-1)}this._cachedIndex=g,this.intervalChanged_(g,_,y)}return this.interpolate_(g,_,r,y)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(r){const d=this.resultBuffer,g=this.sampleValues,y=this.valueSize,_=r*y;for(let R=0;R!==y;++R)d[R]=g[_+R];return d}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class d5 extends Xp{constructor(r,d,g,y){super(r,d,g,y),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Rl,endingEnd:Rl}}intervalChanged_(r,d,g){const y=this.parameterPositions;let _=r-2,R=r+1,k=y[_],X=y[R];if(k===void 0)switch(this.getSettings_().endingStart){case Mc:_=r,k=2*d-g;break;case Ad:_=y.length-2,k=d+y[_]-y[_+1];break;default:_=r,k=g}if(X===void 0)switch(this.getSettings_().endingEnd){case Mc:R=r,X=2*g-d;break;case Ad:R=1,X=g+y[1]-y[0];break;default:R=r-1,X=d}const K=(g-d)*.5,Q=this.valueSize;this._weightPrev=K/(d-k),this._weightNext=K/(X-g),this._offsetPrev=_*Q,this._offsetNext=R*Q}interpolate_(r,d,g,y){const _=this.resultBuffer,R=this.sampleValues,k=this.valueSize,X=r*k,K=X-k,Q=this._offsetPrev,xe=this._offsetNext,ue=this._weightPrev,ge=this._weightNext,_e=(g-d)/(y-d),Re=_e*_e,be=Re*_e,ve=-ue*be+2*ue*Re-ue*_e,Xe=(1+ue)*be+(-1.5-2*ue)*Re+(-.5+ue)*_e+1,Be=(-1-ge)*be+(1.5+ge)*Re+.5*_e,Ke=ge*be-ge*Re;for(let bt=0;bt!==k;++bt)_[bt]=ve*R[Q+bt]+Xe*R[K+bt]+Be*R[X+bt]+Ke*R[xe+bt];return _}}class gS extends Xp{constructor(r,d,g,y){super(r,d,g,y)}interpolate_(r,d,g,y){const _=this.resultBuffer,R=this.sampleValues,k=this.valueSize,X=r*k,K=X-k,Q=(g-d)/(y-d),xe=1-Q;for(let ue=0;ue!==k;++ue)_[ue]=R[K+ue]*xe+R[X+ue]*Q;return _}}class g5 extends Xp{constructor(r,d,g,y){super(r,d,g,y)}interpolate_(r){return this.copySampleValue_(r-1)}}class rl{constructor(r,d,g,y){if(r===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(d===void 0||d.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+r);this.name=r,this.times=jh(d,this.TimeBufferType),this.values=jh(g,this.ValueBufferType),this.setInterpolation(y||this.DefaultInterpolation)}static toJSON(r){const d=r.constructor;let g;if(d.toJSON!==this.toJSON)g=d.toJSON(r);else{g={name:r.name,times:jh(r.times,Array),values:jh(r.values,Array)};const y=r.getInterpolation();y!==r.DefaultInterpolation&&(g.interpolation=y)}return g.type=r.ValueTypeName,g}InterpolantFactoryMethodDiscrete(r){return new g5(this.times,this.values,this.getValueSize(),r)}InterpolantFactoryMethodLinear(r){return new gS(this.times,this.values,this.getValueSize(),r)}InterpolantFactoryMethodSmooth(r){return new d5(this.times,this.values,this.getValueSize(),r)}setInterpolation(r){let d;switch(r){case Ja:d=this.InterpolantFactoryMethodDiscrete;break;case Ga:d=this.InterpolantFactoryMethodLinear;break;case Td:d=this.InterpolantFactoryMethodSmooth;break}if(d===void 0){const g="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(r!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(g);return console.warn("THREE.KeyframeTrack:",g),this}return this.createInterpolant=d,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ja;case this.InterpolantFactoryMethodLinear:return Ga;case this.InterpolantFactoryMethodSmooth:return Td}}getValueSize(){return this.values.length/this.times.length}shift(r){if(r!==0){const d=this.times;for(let g=0,y=d.length;g!==y;++g)d[g]+=r}return this}scale(r){if(r!==1){const d=this.times;for(let g=0,y=d.length;g!==y;++g)d[g]*=r}return this}trim(r,d){const g=this.times,y=g.length;let _=0,R=y-1;for(;_!==y&&g[_]<r;)++_;for(;R!==-1&&g[R]>d;)--R;if(++R,_!==0||R!==y){_>=R&&(R=Math.max(R,1),_=R-1);const k=this.getValueSize();this.times=g.slice(_,R),this.values=this.values.slice(_*k,R*k)}return this}validate(){let r=!0;const d=this.getValueSize();d-Math.floor(d)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),r=!1);const g=this.times,y=this.values,_=g.length;_===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),r=!1);let R=null;for(let k=0;k!==_;k++){const X=g[k];if(typeof X=="number"&&isNaN(X)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,k,X),r=!1;break}if(R!==null&&R>X){console.error("THREE.KeyframeTrack: Out of order keys.",this,k,X,R),r=!1;break}R=X}if(y!==void 0&&uS(y))for(let k=0,X=y.length;k!==X;++k){const K=y[k];if(isNaN(K)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,k,K),r=!1;break}}return r}optimize(){const r=this.times.slice(),d=this.values.slice(),g=this.getValueSize(),y=this.getInterpolation()===Td,_=r.length-1;let R=1;for(let k=1;k<_;++k){let X=!1;const K=r[k],Q=r[k+1];if(K!==Q&&(k!==1||K!==r[0]))if(y)X=!0;else{const xe=k*g,ue=xe-g,ge=xe+g;for(let _e=0;_e!==g;++_e){const Re=d[xe+_e];if(Re!==d[ue+_e]||Re!==d[ge+_e]){X=!0;break}}}if(X){if(k!==R){r[R]=r[k];const xe=k*g,ue=R*g;for(let ge=0;ge!==g;++ge)d[ue+ge]=d[xe+ge]}++R}}if(_>0){r[R]=r[_];for(let k=_*g,X=R*g,K=0;K!==g;++K)d[X+K]=d[k+K];++R}return R!==r.length?(this.times=r.slice(0,R),this.values=d.slice(0,R*g)):(this.times=r,this.values=d),this}clone(){const r=this.times.slice(),d=this.values.slice(),g=this.constructor,y=new g(this.name,r,d);return y.createInterpolant=this.createInterpolant,y}}rl.prototype.TimeBufferType=Float32Array,rl.prototype.ValueBufferType=Float32Array,rl.prototype.DefaultInterpolation=Ga;class Uf extends rl{}Uf.prototype.ValueTypeName="bool",Uf.prototype.ValueBufferType=Array,Uf.prototype.DefaultInterpolation=Ja,Uf.prototype.InterpolantFactoryMethodLinear=void 0,Uf.prototype.InterpolantFactoryMethodSmooth=void 0;class vS extends rl{}vS.prototype.ValueTypeName="color";class Gf extends rl{}Gf.prototype.ValueTypeName="number";class v5 extends Xp{constructor(r,d,g,y){super(r,d,g,y)}interpolate_(r,d,g,y){const _=this.resultBuffer,R=this.sampleValues,k=this.valueSize,X=(g-d)/(y-d);let K=r*k;for(let Q=K+k;K!==Q;K+=4)Xa.slerpFlat(_,0,R,K-k,R,K,X);return _}}class Kh extends rl{InterpolantFactoryMethodLinear(r){return new v5(this.times,this.values,this.getValueSize(),r)}}Kh.prototype.ValueTypeName="quaternion",Kh.prototype.DefaultInterpolation=Ga,Kh.prototype.InterpolantFactoryMethodSmooth=void 0;class Xf extends rl{}Xf.prototype.ValueTypeName="string",Xf.prototype.ValueBufferType=Array,Xf.prototype.DefaultInterpolation=Ja,Xf.prototype.InterpolantFactoryMethodLinear=void 0,Xf.prototype.InterpolantFactoryMethodSmooth=void 0;class jf extends rl{}jf.prototype.ValueTypeName="vector";class jp{constructor(r,d=-1,g,y=vh){this.name=r,this.tracks=g,this.duration=d,this.blendMode=y,this.uuid=b2(),this.duration<0&&this.resetDuration()}static parse(r){const d=[],g=r.tracks,y=1/(r.fps||1);for(let R=0,k=g.length;R!==k;++R)d.push(_5(g[R]).scale(y));const _=new this(r.name,r.duration,d,r.blendMode);return _.uuid=r.uuid,_}static toJSON(r){const d=[],g=r.tracks,y={name:r.name,duration:r.duration,tracks:d,uuid:r.uuid,blendMode:r.blendMode};for(let _=0,R=g.length;_!==R;++_)d.push(rl.toJSON(g[_]));return y}static CreateFromMorphTargetSequence(r,d,g,y){const _=d.length,R=[];for(let k=0;k<_;k++){let X=[],K=[];X.push((k+_-1)%_,k,(k+1)%_),K.push(0,1,0);const Q=dS(X);X=Uv(X,1,Q),K=Uv(K,1,Q),!y&&X[0]===0&&(X.push(_),K.push(K[0])),R.push(new Gf(".morphTargetInfluences["+d[k].name+"]",X,K).scale(1/g))}return new this(r,-1,R)}static findByName(r,d){let g=r;if(!Array.isArray(r)){const y=r;g=y.geometry&&y.geometry.animations||y.animations}for(let y=0;y<g.length;y++)if(g[y].name===d)return g[y];return null}static CreateClipsFromMorphTargetSequences(r,d,g){const y={},_=/^([\w-]*?)([\d]+)$/;for(let k=0,X=r.length;k<X;k++){const K=r[k],Q=K.name.match(_);if(Q&&Q.length>1){const xe=Q[1];let ue=y[xe];ue||(y[xe]=ue=[]),ue.push(K)}}const R=[];for(const k in y)R.push(this.CreateFromMorphTargetSequence(k,y[k],d,g));return R}static parseAnimation(r,d){if(!r)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const g=function(xe,ue,ge,_e,Re){if(ge.length!==0){const be=[],ve=[];Gv(ge,be,ve,_e),be.length!==0&&Re.push(new xe(ue,be,ve))}},y=[],_=r.name||"default",R=r.fps||30,k=r.blendMode;let X=r.length||-1;const K=r.hierarchy||[];for(let xe=0;xe<K.length;xe++){const ue=K[xe].keys;if(!(!ue||ue.length===0))if(ue[0].morphTargets){const ge={};let _e;for(_e=0;_e<ue.length;_e++)if(ue[_e].morphTargets)for(let Re=0;Re<ue[_e].morphTargets.length;Re++)ge[ue[_e].morphTargets[Re]]=-1;for(const Re in ge){const be=[],ve=[];for(let Xe=0;Xe!==ue[_e].morphTargets.length;++Xe){const Be=ue[_e];be.push(Be.time),ve.push(Be.morphTarget===Re?1:0)}y.push(new Gf(".morphTargetInfluence["+Re+"]",be,ve))}X=ge.length*R}else{const ge=".bones["+d[xe].name+"]";g(jf,ge+".position",ue,"pos",y),g(Kh,ge+".quaternion",ue,"rot",y),g(jf,ge+".scale",ue,"scl",y)}}return y.length===0?null:new this(_,X,y,k)}resetDuration(){const r=this.tracks;let d=0;for(let g=0,y=r.length;g!==y;++g){const _=this.tracks[g];d=Math.max(d,_.times[_.times.length-1])}return this.duration=d,this}trim(){for(let r=0;r<this.tracks.length;r++)this.tracks[r].trim(0,this.duration);return this}validate(){let r=!0;for(let d=0;d<this.tracks.length;d++)r=r&&this.tracks[d].validate();return r}optimize(){for(let r=0;r<this.tracks.length;r++)this.tracks[r].optimize();return this}clone(){const r=[];for(let d=0;d<this.tracks.length;d++)r.push(this.tracks[d].clone());return new this.constructor(this.name,this.duration,r,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function b5(I){switch(I.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Gf;case"vector":case"vector2":case"vector3":case"vector4":return jf;case"color":return vS;case"quaternion":return Kh;case"bool":case"boolean":return Uf;case"string":return Xf}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+I)}function _5(I){if(I.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const r=b5(I.type);if(I.times===void 0){const d=[],g=[];Gv(I.keys,d,g,"value"),I.times=d,I.values=g}return r.parse!==void 0?r.parse(I):new r(I.name,I.times,I.values,I.interpolation)}const Ru={enabled:!1,files:{},add:function(I,r){this.enabled!==!1&&(this.files[I]=r)},get:function(I){if(this.enabled!==!1)return this.files[I]},remove:function(I){delete this.files[I]},clear:function(){this.files={}}};class bS{constructor(r,d,g){const y=this;let _=!1,R=0,k=0,X;const K=[];this.onStart=void 0,this.onLoad=r,this.onProgress=d,this.onError=g,this.itemStart=function(Q){k++,_===!1&&y.onStart!==void 0&&y.onStart(Q,R,k),_=!0},this.itemEnd=function(Q){R++,y.onProgress!==void 0&&y.onProgress(Q,R,k),R===k&&(_=!1,y.onLoad!==void 0&&y.onLoad())},this.itemError=function(Q){y.onError!==void 0&&y.onError(Q)},this.resolveURL=function(Q){return X?X(Q):Q},this.setURLModifier=function(Q){return X=Q,this},this.addHandler=function(Q,xe){return K.push(Q,xe),this},this.removeHandler=function(Q){const xe=K.indexOf(Q);return xe!==-1&&K.splice(xe,2),this},this.getHandler=function(Q){for(let xe=0,ue=K.length;xe<ue;xe+=2){const ge=K[xe],_e=K[xe+1];if(ge.global&&(ge.lastIndex=0),ge.test(Q))return _e}return null}}}const T5=new bS;class Nu{constructor(r){this.manager=r!==void 0?r:T5,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(r,d){const g=this;return new Promise(function(y,_){g.load(r,y,d,_)})}parse(){}setCrossOrigin(r){return this.crossOrigin=r,this}setWithCredentials(r){return this.withCredentials=r,this}setPath(r){return this.path=r,this}setResourcePath(r){return this.resourcePath=r,this}setRequestHeader(r){return this.requestHeader=r,this}}Nu.DEFAULT_MATERIAL_NAME="__DEFAULT";const $l={};class A5 extends Error{constructor(r,d){super(r),this.response=d}}class Bc extends Nu{constructor(r){super(r)}load(r,d,g,y){r===void 0&&(r=""),this.path!==void 0&&(r=this.path+r),r=this.manager.resolveURL(r);const _=Ru.get(r);if(_!==void 0)return this.manager.itemStart(r),setTimeout(()=>{d&&d(_),this.manager.itemEnd(r)},0),_;if($l[r]!==void 0){$l[r].push({onLoad:d,onProgress:g,onError:y});return}$l[r]=[],$l[r].push({onLoad:d,onProgress:g,onError:y});const R=new Request(r,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),k=this.mimeType,X=this.responseType;fetch(R).then(K=>{if(K.status===200||K.status===0){if(K.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||K.body===void 0||K.body.getReader===void 0)return K;const Q=$l[r],xe=K.body.getReader(),ue=K.headers.get("Content-Length")||K.headers.get("X-File-Size"),ge=ue?parseInt(ue):0,_e=ge!==0;let Re=0;const be=new ReadableStream({start(ve){Xe();function Xe(){xe.read().then(({done:Be,value:Ke})=>{if(Be)ve.close();else{Re+=Ke.byteLength;const bt=new ProgressEvent("progress",{lengthComputable:_e,loaded:Re,total:ge});for(let rt=0,xt=Q.length;rt<xt;rt++){const Mt=Q[rt];Mt.onProgress&&Mt.onProgress(bt)}ve.enqueue(Ke),Xe()}})}}});return new Response(be)}else throw new A5(`fetch for "${K.url}" responded with ${K.status}: ${K.statusText}`,K)}).then(K=>{switch(X){case"arraybuffer":return K.arrayBuffer();case"blob":return K.blob();case"document":return K.text().then(Q=>new DOMParser().parseFromString(Q,k));case"json":return K.json();default:if(k===void 0)return K.text();{const xe=/charset="?([^;"\s]*)"?/i.exec(k),ue=xe&&xe[1]?xe[1].toLowerCase():void 0,ge=new TextDecoder(ue);return K.arrayBuffer().then(_e=>ge.decode(_e))}}}).then(K=>{Ru.add(r,K);const Q=$l[r];delete $l[r];for(let xe=0,ue=Q.length;xe<ue;xe++){const ge=Q[xe];ge.onLoad&&ge.onLoad(K)}}).catch(K=>{const Q=$l[r];if(Q===void 0)throw this.manager.itemError(r),K;delete $l[r];for(let xe=0,ue=Q.length;xe<ue;xe++){const ge=Q[xe];ge.onError&&ge.onError(K)}this.manager.itemError(r)}).finally(()=>{this.manager.itemEnd(r)}),this.manager.itemStart(r)}setResponseType(r){return this.responseType=r,this}setMimeType(r){return this.mimeType=r,this}}class P9 extends null{constructor(r){super(r)}load(r,d,g,y){const _=this,R=new Bc(this.manager);R.setPath(this.path),R.setRequestHeader(this.requestHeader),R.setWithCredentials(this.withCredentials),R.load(r,function(k){try{d(_.parse(JSON.parse(k)))}catch(X){y?y(X):console.error(X),_.manager.itemError(r)}},g,y)}parse(r){const d=[];for(let g=0;g<r.length;g++){const y=jp.parse(r[g]);d.push(y)}return d}}class B9 extends null{constructor(r){super(r)}load(r,d,g,y){const _=this,R=[],k=new PL,X=new Bc(this.manager);X.setPath(this.path),X.setResponseType("arraybuffer"),X.setRequestHeader(this.requestHeader),X.setWithCredentials(_.withCredentials);let K=0;function Q(xe){X.load(r[xe],function(ue){const ge=_.parse(ue,!0);R[xe]={width:ge.width,height:ge.height,format:ge.format,mipmaps:ge.mipmaps},K+=1,K===6&&(ge.mipmapCount===1&&(k.minFilter=ui),k.image=R,k.format=ge.format,k.needsUpdate=!0,d&&d(k))},g,y)}if(Array.isArray(r))for(let xe=0,ue=r.length;xe<ue;++xe)Q(xe);else X.load(r,function(xe){const ue=_.parse(xe,!0);if(ue.isCubemap){const ge=ue.mipmaps.length/ue.mipmapCount;for(let _e=0;_e<ge;_e++){R[_e]={mipmaps:[]};for(let Re=0;Re<ue.mipmapCount;Re++)R[_e].mipmaps.push(ue.mipmaps[_e*ue.mipmapCount+Re]),R[_e].format=ue.format,R[_e].width=ue.width,R[_e].height=ue.height}k.image=R}else k.image.width=ue.width,k.image.height=ue.height,k.mipmaps=ue.mipmaps;ue.mipmapCount===1&&(k.minFilter=ui),k.format=ue.format,k.needsUpdate=!0,d&&d(k)},g,y);return k}}class xy extends Nu{constructor(r){super(r)}load(r,d,g,y){this.path!==void 0&&(r=this.path+r),r=this.manager.resolveURL(r);const _=this,R=Ru.get(r);if(R!==void 0)return _.manager.itemStart(r),setTimeout(function(){d&&d(R),_.manager.itemEnd(r)},0),R;const k=xp("img");function X(){Q(),Ru.add(r,this),d&&d(this),_.manager.itemEnd(r)}function K(xe){Q(),y&&y(xe),_.manager.itemError(r),_.manager.itemEnd(r)}function Q(){k.removeEventListener("load",X,!1),k.removeEventListener("error",K,!1)}return k.addEventListener("load",X,!1),k.addEventListener("error",K,!1),r.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(k.crossOrigin=this.crossOrigin),_.manager.itemStart(r),k.src=r,k}}class z9 extends null{constructor(r){super(r)}load(r,d,g,y){const _=new $m;_.colorSpace=jn;const R=new xy(this.manager);R.setCrossOrigin(this.crossOrigin),R.setPath(this.path);let k=0;function X(K){R.load(r[K],function(Q){_.images[K]=Q,k++,k===6&&(_.needsUpdate=!0,d&&d(_))},void 0,y)}for(let K=0;K<r.length;++K)X(K);return _}}class M5 extends Nu{constructor(r){super(r)}load(r,d,g,y){const _=this,R=new Cf,k=new Bc(this.manager);return k.setResponseType("arraybuffer"),k.setRequestHeader(this.requestHeader),k.setPath(this.path),k.setWithCredentials(_.withCredentials),k.load(r,function(X){let K;try{K=_.parse(X)}catch(Q){if(y!==void 0)y(Q);else{console.error(Q);return}}K.image!==void 0?R.image=K.image:K.data!==void 0&&(R.image.width=K.width,R.image.height=K.height,R.image.data=K.data),R.wrapS=K.wrapS!==void 0?K.wrapS:Gi,R.wrapT=K.wrapT!==void 0?K.wrapT:Gi,R.magFilter=K.magFilter!==void 0?K.magFilter:ui,R.minFilter=K.minFilter!==void 0?K.minFilter:ui,R.anisotropy=K.anisotropy!==void 0?K.anisotropy:1,K.colorSpace!==void 0?R.colorSpace=K.colorSpace:K.encoding!==void 0&&(R.encoding=K.encoding),K.flipY!==void 0&&(R.flipY=K.flipY),K.format!==void 0&&(R.format=K.format),K.type!==void 0&&(R.type=K.type),K.mipmaps!==void 0&&(R.mipmaps=K.mipmaps,R.minFilter=Us),K.mipmapCount===1&&(R.minFilter=ui),K.generateMipmaps!==void 0&&(R.generateMipmaps=K.generateMipmaps),R.needsUpdate=!0,d&&d(R,K)},g,y),R}}class C5 extends Nu{constructor(r){super(r)}load(r,d,g,y){const _=new Ks,R=new xy(this.manager);return R.setCrossOrigin(this.crossOrigin),R.setPath(this.path),R.load(r,function(k){_.image=k,_.needsUpdate=!0,d!==void 0&&d(_)},g,y),_}}class ry extends xs{constructor(r,d=1){super(),this.isLight=!0,this.type="Light",this.color=new bx(r),this.intensity=d}dispose(){}copy(r,d){return super.copy(r,d),this.color.copy(r.color),this.intensity=r.intensity,this}toJSON(r){const d=super.toJSON(r);return d.object.color=this.color.getHex(),d.object.intensity=this.intensity,this.groundColor!==void 0&&(d.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(d.object.distance=this.distance),this.angle!==void 0&&(d.object.angle=this.angle),this.decay!==void 0&&(d.object.decay=this.decay),this.penumbra!==void 0&&(d.object.penumbra=this.penumbra),this.shadow!==void 0&&(d.object.shadow=this.shadow.toJSON()),d}}class R5 extends null{constructor(r,d,g){super(r,g),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(xs.DEFAULT_UP),this.updateMatrix(),this.groundColor=new bx(d)}copy(r,d){return super.copy(r,d),this.groundColor.copy(r.groundColor),this}}const Xv=new ur,_S=new ut,TS=new ut;class jv{constructor(r){this.camera=r,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new vn(512,512),this.map=null,this.mapPass=null,this.matrix=new ur,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Wm,this._frameExtents=new vn(1,1),this._viewportCount=1,this._viewports=[new Vi(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(r){const d=this.camera,g=this.matrix;_S.setFromMatrixPosition(r.matrixWorld),d.position.copy(_S),TS.setFromMatrixPosition(r.target.matrixWorld),d.lookAt(TS),d.updateMatrixWorld(),Xv.multiplyMatrices(d.projectionMatrix,d.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Xv),g.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),g.multiply(Xv)}getViewport(r){return this._viewports[r]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(r){return this.camera=r.camera.clone(),this.bias=r.bias,this.radius=r.radius,this.mapSize.copy(r.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const r={};return this.bias!==0&&(r.bias=this.bias),this.normalBias!==0&&(r.normalBias=this.normalBias),this.radius!==1&&(r.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(r.mapSize=this.mapSize.toArray()),r.camera=this.camera.toJSON(!1).object,delete r.camera.matrix,r}}class N5 extends jv{constructor(){super(new ua(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(r){const d=this.camera,g=Cd*2*r.angle*this.focus,y=this.mapSize.width/this.mapSize.height,_=r.distance||d.far;(g!==d.fov||y!==d.aspect||_!==d.far)&&(d.fov=g,d.aspect=y,d.far=_,d.updateProjectionMatrix()),super.updateMatrices(r)}copy(r){return super.copy(r),this.focus=r.focus,this}}class AS extends ry{constructor(r,d,g=0,y=Math.PI/3,_=0,R=2){super(r,d),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(xs.DEFAULT_UP),this.updateMatrix(),this.target=new xs,this.distance=g,this.angle=y,this.penumbra=_,this.decay=R,this.map=null,this.shadow=new N5}get power(){return this.intensity*Math.PI}set power(r){this.intensity=r/Math.PI}dispose(){this.shadow.dispose()}copy(r,d){return super.copy(r,d),this.distance=r.distance,this.angle=r.angle,this.penumbra=r.penumbra,this.decay=r.decay,this.target=r.target.clone(),this.shadow=r.shadow.clone(),this}}const MS=new ur,Kp=new ut,Kv=new ut;class P5 extends jv{constructor(){super(new ua(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new vn(4,2),this._viewportCount=6,this._viewports=[new Vi(2,1,1,1),new Vi(0,1,1,1),new Vi(3,1,1,1),new Vi(1,1,1,1),new Vi(3,0,1,1),new Vi(1,0,1,1)],this._cubeDirections=[new ut(1,0,0),new ut(-1,0,0),new ut(0,0,1),new ut(0,0,-1),new ut(0,1,0),new ut(0,-1,0)],this._cubeUps=[new ut(0,1,0),new ut(0,1,0),new ut(0,1,0),new ut(0,1,0),new ut(0,0,1),new ut(0,0,-1)]}updateMatrices(r,d=0){const g=this.camera,y=this.matrix,_=r.distance||g.far;_!==g.far&&(g.far=_,g.updateProjectionMatrix()),Kp.setFromMatrixPosition(r.matrixWorld),g.position.copy(Kp),Kv.copy(g.position),Kv.add(this._cubeDirections[d]),g.up.copy(this._cubeUps[d]),g.lookAt(Kv),g.updateMatrixWorld(),y.makeTranslation(-Kp.x,-Kp.y,-Kp.z),MS.multiplyMatrices(g.projectionMatrix,g.matrixWorldInverse),this._frustum.setFromProjectionMatrix(MS)}}class $v extends ry{constructor(r,d,g=0,y=2){super(r,d),this.isPointLight=!0,this.type="PointLight",this.distance=g,this.decay=y,this.shadow=new P5}get power(){return this.intensity*4*Math.PI}set power(r){this.intensity=r/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(r,d){return super.copy(r,d),this.distance=r.distance,this.decay=r.decay,this.shadow=r.shadow.clone(),this}}class B5 extends jv{constructor(){super(new _p(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class CS extends ry{constructor(r,d){super(r,d),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(xs.DEFAULT_UP),this.updateMatrix(),this.target=new xs,this.shadow=new B5}dispose(){this.shadow.dispose()}copy(r){return super.copy(r),this.target=r.target.clone(),this.shadow=r.shadow.clone(),this}}class RS extends ry{constructor(r,d){super(r,d),this.isAmbientLight=!0,this.type="AmbientLight"}}class z5 extends null{constructor(r,d,g=10,y=10){super(r,d),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=g,this.height=y}get power(){return this.intensity*this.width*this.height*Math.PI}set power(r){this.intensity=r/(this.width*this.height*Math.PI)}copy(r){return super.copy(r),this.width=r.width,this.height=r.height,this}toJSON(r){const d=super.toJSON(r);return d.object.width=this.width,d.object.height=this.height,d}}class V5{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let r=0;r<9;r++)this.coefficients.push(new ut)}set(r){for(let d=0;d<9;d++)this.coefficients[d].copy(r[d]);return this}zero(){for(let r=0;r<9;r++)this.coefficients[r].set(0,0,0);return this}getAt(r,d){const g=r.x,y=r.y,_=r.z,R=this.coefficients;return d.copy(R[0]).multiplyScalar(.282095),d.addScaledVector(R[1],.488603*y),d.addScaledVector(R[2],.488603*_),d.addScaledVector(R[3],.488603*g),d.addScaledVector(R[4],1.092548*(g*y)),d.addScaledVector(R[5],1.092548*(y*_)),d.addScaledVector(R[6],.315392*(3*_*_-1)),d.addScaledVector(R[7],1.092548*(g*_)),d.addScaledVector(R[8],.546274*(g*g-y*y)),d}getIrradianceAt(r,d){const g=r.x,y=r.y,_=r.z,R=this.coefficients;return d.copy(R[0]).multiplyScalar(.886227),d.addScaledVector(R[1],2*.511664*y),d.addScaledVector(R[2],2*.511664*_),d.addScaledVector(R[3],2*.511664*g),d.addScaledVector(R[4],2*.429043*g*y),d.addScaledVector(R[5],2*.429043*y*_),d.addScaledVector(R[6],.743125*_*_-.247708),d.addScaledVector(R[7],2*.429043*g*_),d.addScaledVector(R[8],.429043*(g*g-y*y)),d}add(r){for(let d=0;d<9;d++)this.coefficients[d].add(r.coefficients[d]);return this}addScaledSH(r,d){for(let g=0;g<9;g++)this.coefficients[g].addScaledVector(r.coefficients[g],d);return this}scale(r){for(let d=0;d<9;d++)this.coefficients[d].multiplyScalar(r);return this}lerp(r,d){for(let g=0;g<9;g++)this.coefficients[g].lerp(r.coefficients[g],d);return this}equals(r){for(let d=0;d<9;d++)if(!this.coefficients[d].equals(r.coefficients[d]))return!1;return!0}copy(r){return this.set(r.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(r,d=0){const g=this.coefficients;for(let y=0;y<9;y++)g[y].fromArray(r,d+y*3);return this}toArray(r=[],d=0){const g=this.coefficients;for(let y=0;y<9;y++)g[y].toArray(r,d+y*3);return r}static getBasisAt(r,d){const g=r.x,y=r.y,_=r.z;d[0]=.282095,d[1]=.488603*y,d[2]=.488603*_,d[3]=.488603*g,d[4]=1.092548*g*y,d[5]=1.092548*y*_,d[6]=.315392*(3*_*_-1),d[7]=1.092548*g*_,d[8]=.546274*(g*g-y*y)}}class U5 extends null{constructor(r=new V5,d=1){super(void 0,d),this.isLightProbe=!0,this.sh=r}copy(r){return super.copy(r),this.sh.copy(r.sh),this}fromJSON(r){return this.intensity=r.intensity,this.sh.fromArray(r.sh),this}toJSON(r){const d=super.toJSON(r);return d.object.sh=this.sh.toArray(),d}}class Jv extends null{constructor(r){super(r),this.textures={}}load(r,d,g,y){const _=this,R=new Bc(_.manager);R.setPath(_.path),R.setRequestHeader(_.requestHeader),R.setWithCredentials(_.withCredentials),R.load(r,function(k){try{d(_.parse(JSON.parse(k)))}catch(X){y?y(X):console.error(X),_.manager.itemError(r)}},g,y)}parse(r){const d=this.textures;function g(_){return d[_]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",_),d[_]}const y=Jv.createMaterialFromType(r.type);if(r.uuid!==void 0&&(y.uuid=r.uuid),r.name!==void 0&&(y.name=r.name),r.color!==void 0&&y.color!==void 0&&y.color.setHex(r.color),r.roughness!==void 0&&(y.roughness=r.roughness),r.metalness!==void 0&&(y.metalness=r.metalness),r.sheen!==void 0&&(y.sheen=r.sheen),r.sheenColor!==void 0&&(y.sheenColor=new bx().setHex(r.sheenColor)),r.sheenRoughness!==void 0&&(y.sheenRoughness=r.sheenRoughness),r.emissive!==void 0&&y.emissive!==void 0&&y.emissive.setHex(r.emissive),r.specular!==void 0&&y.specular!==void 0&&y.specular.setHex(r.specular),r.specularIntensity!==void 0&&(y.specularIntensity=r.specularIntensity),r.specularColor!==void 0&&y.specularColor!==void 0&&y.specularColor.setHex(r.specularColor),r.shininess!==void 0&&(y.shininess=r.shininess),r.clearcoat!==void 0&&(y.clearcoat=r.clearcoat),r.clearcoatRoughness!==void 0&&(y.clearcoatRoughness=r.clearcoatRoughness),r.iridescence!==void 0&&(y.iridescence=r.iridescence),r.iridescenceIOR!==void 0&&(y.iridescenceIOR=r.iridescenceIOR),r.iridescenceThicknessRange!==void 0&&(y.iridescenceThicknessRange=r.iridescenceThicknessRange),r.transmission!==void 0&&(y.transmission=r.transmission),r.thickness!==void 0&&(y.thickness=r.thickness),r.attenuationDistance!==void 0&&(y.attenuationDistance=r.attenuationDistance),r.attenuationColor!==void 0&&y.attenuationColor!==void 0&&y.attenuationColor.setHex(r.attenuationColor),r.anisotropy!==void 0&&(y.anisotropy=r.anisotropy),r.anisotropyRotation!==void 0&&(y.anisotropyRotation=r.anisotropyRotation),r.fog!==void 0&&(y.fog=r.fog),r.flatShading!==void 0&&(y.flatShading=r.flatShading),r.blending!==void 0&&(y.blending=r.blending),r.combine!==void 0&&(y.combine=r.combine),r.side!==void 0&&(y.side=r.side),r.shadowSide!==void 0&&(y.shadowSide=r.shadowSide),r.opacity!==void 0&&(y.opacity=r.opacity),r.transparent!==void 0&&(y.transparent=r.transparent),r.alphaTest!==void 0&&(y.alphaTest=r.alphaTest),r.alphaHash!==void 0&&(y.alphaHash=r.alphaHash),r.depthFunc!==void 0&&(y.depthFunc=r.depthFunc),r.depthTest!==void 0&&(y.depthTest=r.depthTest),r.depthWrite!==void 0&&(y.depthWrite=r.depthWrite),r.colorWrite!==void 0&&(y.colorWrite=r.colorWrite),r.blendSrc!==void 0&&(y.blendSrc=r.blendSrc),r.blendDst!==void 0&&(y.blendDst=r.blendDst),r.blendEquation!==void 0&&(y.blendEquation=r.blendEquation),r.blendSrcAlpha!==void 0&&(y.blendSrcAlpha=r.blendSrcAlpha),r.blendDstAlpha!==void 0&&(y.blendDstAlpha=r.blendDstAlpha),r.blendEquationAlpha!==void 0&&(y.blendEquationAlpha=r.blendEquationAlpha),r.blendColor!==void 0&&y.blendColor!==void 0&&y.blendColor.setHex(r.blendColor),r.blendAlpha!==void 0&&(y.blendAlpha=r.blendAlpha),r.stencilWriteMask!==void 0&&(y.stencilWriteMask=r.stencilWriteMask),r.stencilFunc!==void 0&&(y.stencilFunc=r.stencilFunc),r.stencilRef!==void 0&&(y.stencilRef=r.stencilRef),r.stencilFuncMask!==void 0&&(y.stencilFuncMask=r.stencilFuncMask),r.stencilFail!==void 0&&(y.stencilFail=r.stencilFail),r.stencilZFail!==void 0&&(y.stencilZFail=r.stencilZFail),r.stencilZPass!==void 0&&(y.stencilZPass=r.stencilZPass),r.stencilWrite!==void 0&&(y.stencilWrite=r.stencilWrite),r.wireframe!==void 0&&(y.wireframe=r.wireframe),r.wireframeLinewidth!==void 0&&(y.wireframeLinewidth=r.wireframeLinewidth),r.wireframeLinecap!==void 0&&(y.wireframeLinecap=r.wireframeLinecap),r.wireframeLinejoin!==void 0&&(y.wireframeLinejoin=r.wireframeLinejoin),r.rotation!==void 0&&(y.rotation=r.rotation),r.linewidth!==void 0&&(y.linewidth=r.linewidth),r.dashSize!==void 0&&(y.dashSize=r.dashSize),r.gapSize!==void 0&&(y.gapSize=r.gapSize),r.scale!==void 0&&(y.scale=r.scale),r.polygonOffset!==void 0&&(y.polygonOffset=r.polygonOffset),r.polygonOffsetFactor!==void 0&&(y.polygonOffsetFactor=r.polygonOffsetFactor),r.polygonOffsetUnits!==void 0&&(y.polygonOffsetUnits=r.polygonOffsetUnits),r.dithering!==void 0&&(y.dithering=r.dithering),r.alphaToCoverage!==void 0&&(y.alphaToCoverage=r.alphaToCoverage),r.premultipliedAlpha!==void 0&&(y.premultipliedAlpha=r.premultipliedAlpha),r.forceSinglePass!==void 0&&(y.forceSinglePass=r.forceSinglePass),r.visible!==void 0&&(y.visible=r.visible),r.toneMapped!==void 0&&(y.toneMapped=r.toneMapped),r.userData!==void 0&&(y.userData=r.userData),r.vertexColors!==void 0&&(typeof r.vertexColors=="number"?y.vertexColors=r.vertexColors>0:y.vertexColors=r.vertexColors),r.uniforms!==void 0)for(const _ in r.uniforms){const R=r.uniforms[_];switch(y.uniforms[_]={},R.type){case"t":y.uniforms[_].value=g(R.value);break;case"c":y.uniforms[_].value=new bx().setHex(R.value);break;case"v2":y.uniforms[_].value=new vn().fromArray(R.value);break;case"v3":y.uniforms[_].value=new ut().fromArray(R.value);break;case"v4":y.uniforms[_].value=new Vi().fromArray(R.value);break;case"m3":y.uniforms[_].value=new Xr().fromArray(R.value);break;case"m4":y.uniforms[_].value=new ur().fromArray(R.value);break;default:y.uniforms[_].value=R.value}}if(r.defines!==void 0&&(y.defines=r.defines),r.vertexShader!==void 0&&(y.vertexShader=r.vertexShader),r.fragmentShader!==void 0&&(y.fragmentShader=r.fragmentShader),r.glslVersion!==void 0&&(y.glslVersion=r.glslVersion),r.extensions!==void 0)for(const _ in r.extensions)y.extensions[_]=r.extensions[_];if(r.lights!==void 0&&(y.lights=r.lights),r.clipping!==void 0&&(y.clipping=r.clipping),r.size!==void 0&&(y.size=r.size),r.sizeAttenuation!==void 0&&(y.sizeAttenuation=r.sizeAttenuation),r.map!==void 0&&(y.map=g(r.map)),r.matcap!==void 0&&(y.matcap=g(r.matcap)),r.alphaMap!==void 0&&(y.alphaMap=g(r.alphaMap)),r.bumpMap!==void 0&&(y.bumpMap=g(r.bumpMap)),r.bumpScale!==void 0&&(y.bumpScale=r.bumpScale),r.normalMap!==void 0&&(y.normalMap=g(r.normalMap)),r.normalMapType!==void 0&&(y.normalMapType=r.normalMapType),r.normalScale!==void 0){let _=r.normalScale;Array.isArray(_)===!1&&(_=[_,_]),y.normalScale=new vn().fromArray(_)}return r.displacementMap!==void 0&&(y.displacementMap=g(r.displacementMap)),r.displacementScale!==void 0&&(y.displacementScale=r.displacementScale),r.displacementBias!==void 0&&(y.displacementBias=r.displacementBias),r.roughnessMap!==void 0&&(y.roughnessMap=g(r.roughnessMap)),r.metalnessMap!==void 0&&(y.metalnessMap=g(r.metalnessMap)),r.emissiveMap!==void 0&&(y.emissiveMap=g(r.emissiveMap)),r.emissiveIntensity!==void 0&&(y.emissiveIntensity=r.emissiveIntensity),r.specularMap!==void 0&&(y.specularMap=g(r.specularMap)),r.specularIntensityMap!==void 0&&(y.specularIntensityMap=g(r.specularIntensityMap)),r.specularColorMap!==void 0&&(y.specularColorMap=g(r.specularColorMap)),r.envMap!==void 0&&(y.envMap=g(r.envMap)),r.envMapIntensity!==void 0&&(y.envMapIntensity=r.envMapIntensity),r.reflectivity!==void 0&&(y.reflectivity=r.reflectivity),r.refractionRatio!==void 0&&(y.refractionRatio=r.refractionRatio),r.lightMap!==void 0&&(y.lightMap=g(r.lightMap)),r.lightMapIntensity!==void 0&&(y.lightMapIntensity=r.lightMapIntensity),r.aoMap!==void 0&&(y.aoMap=g(r.aoMap)),r.aoMapIntensity!==void 0&&(y.aoMapIntensity=r.aoMapIntensity),r.gradientMap!==void 0&&(y.gradientMap=g(r.gradientMap)),r.clearcoatMap!==void 0&&(y.clearcoatMap=g(r.clearcoatMap)),r.clearcoatRoughnessMap!==void 0&&(y.clearcoatRoughnessMap=g(r.clearcoatRoughnessMap)),r.clearcoatNormalMap!==void 0&&(y.clearcoatNormalMap=g(r.clearcoatNormalMap)),r.clearcoatNormalScale!==void 0&&(y.clearcoatNormalScale=new vn().fromArray(r.clearcoatNormalScale)),r.iridescenceMap!==void 0&&(y.iridescenceMap=g(r.iridescenceMap)),r.iridescenceThicknessMap!==void 0&&(y.iridescenceThicknessMap=g(r.iridescenceThicknessMap)),r.transmissionMap!==void 0&&(y.transmissionMap=g(r.transmissionMap)),r.thicknessMap!==void 0&&(y.thicknessMap=g(r.thicknessMap)),r.anisotropyMap!==void 0&&(y.anisotropyMap=g(r.anisotropyMap)),r.sheenColorMap!==void 0&&(y.sheenColorMap=g(r.sheenColorMap)),r.sheenRoughnessMap!==void 0&&(y.sheenRoughnessMap=g(r.sheenRoughnessMap)),y}setTextures(r){return this.textures=r,this}static createMaterialFromType(r){const d={ShadowMaterial:jP,SpriteMaterial:X_,RawShaderMaterial:KP,ShaderMaterial:Xl,PointsMaterial:W1,MeshPhysicalMaterial:xl,MeshStandardMaterial:Vf,MeshPhongMaterial:$P,MeshToonMaterial:JP,MeshNormalMaterial:WP,MeshLambertMaterial:QP,MeshDepthMaterial:U_,MeshDistanceMaterial:G_,MeshBasicMaterial:X2,MeshMatcapMaterial:e5,LineDashedMaterial:x5,LineBasicMaterial:$o,Material:T2};return new d[r]}}class $h{static decodeText(r){if(typeof TextDecoder<"u")return new TextDecoder().decode(r);let d="";for(let g=0,y=r.length;g<y;g++)d+=String.fromCharCode(r[g]);try{return decodeURIComponent(escape(d))}catch{return d}}static extractUrlBase(r){const d=r.lastIndexOf("/");return d===-1?"./":r.slice(0,d+1)}static resolveURL(r,d){return typeof r!="string"||r===""?"":(/^https?:\/\//i.test(d)&&/^\//.test(r)&&(d=d.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(r)||/^data:.*,.*$/i.test(r)||/^blob:.*$/i.test(r)?r:d+r)}}class G5 extends null{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(r){return super.copy(r),this.instanceCount=r.instanceCount,this}toJSON(){const r=super.toJSON();return r.instanceCount=this.instanceCount,r.isInstancedBufferGeometry=!0,r}}class X5 extends null{constructor(r){super(r)}load(r,d,g,y){const _=this,R=new Bc(_.manager);R.setPath(_.path),R.setRequestHeader(_.requestHeader),R.setWithCredentials(_.withCredentials),R.load(r,function(k){try{d(_.parse(JSON.parse(k)))}catch(X){y?y(X):console.error(X),_.manager.itemError(r)}},g,y)}parse(r){const d={},g={};function y(ge,_e){if(d[_e]!==void 0)return d[_e];const be=ge.interleavedBuffers[_e],ve=_(ge,be.buffer),Xe=Rd(be.type,ve),Be=new B1(Xe,be.stride);return Be.uuid=be.uuid,d[_e]=Be,Be}function _(ge,_e){if(g[_e]!==void 0)return g[_e];const be=ge.arrayBuffers[_e],ve=new Uint32Array(be).buffer;return g[_e]=ve,ve}const R=r.isInstancedBufferGeometry?new G5:new Ur,k=r.data.index;if(k!==void 0){const ge=Rd(k.type,k.array);R.setIndex(new rs(ge,1))}const X=r.data.attributes;for(const ge in X){const _e=X[ge];let Re;if(_e.isInterleavedBufferAttribute){const be=y(r.data,_e.data);Re=new zh(be,_e.itemSize,_e.offset,_e.normalized)}else{const be=Rd(_e.type,_e.array),ve=_e.isInstancedBufferAttribute?Rf:rs;Re=new ve(be,_e.itemSize,_e.normalized)}_e.name!==void 0&&(Re.name=_e.name),_e.usage!==void 0&&Re.setUsage(_e.usage),R.setAttribute(ge,Re)}const K=r.data.morphAttributes;if(K)for(const ge in K){const _e=K[ge],Re=[];for(let be=0,ve=_e.length;be<ve;be++){const Xe=_e[be];let Be;if(Xe.isInterleavedBufferAttribute){const Ke=y(r.data,Xe.data);Be=new zh(Ke,Xe.itemSize,Xe.offset,Xe.normalized)}else{const Ke=Rd(Xe.type,Xe.array);Be=new rs(Ke,Xe.itemSize,Xe.normalized)}Xe.name!==void 0&&(Be.name=Xe.name),Re.push(Be)}R.morphAttributes[ge]=Re}r.data.morphTargetsRelative&&(R.morphTargetsRelative=!0);const xe=r.data.groups||r.data.drawcalls||r.data.offsets;if(xe!==void 0)for(let ge=0,_e=xe.length;ge!==_e;++ge){const Re=xe[ge];R.addGroup(Re.start,Re.count,Re.materialIndex)}const ue=r.data.boundingSphere;if(ue!==void 0){const ge=new ut;ue.center!==void 0&&ge.fromArray(ue.center),R.boundingSphere=new Qa(ge,ue.radius)}return r.name&&(R.name=r.name),r.userData&&(R.userData=r.userData),R}}class V9 extends null{constructor(r){super(r)}load(r,d,g,y){const _=this,R=this.path===""?$h.extractUrlBase(r):this.path;this.resourcePath=this.resourcePath||R;const k=new Bc(this.manager);k.setPath(this.path),k.setRequestHeader(this.requestHeader),k.setWithCredentials(this.withCredentials),k.load(r,function(X){let K=null;try{K=JSON.parse(X)}catch(xe){y!==void 0&&y(xe),console.error("THREE:ObjectLoader: Can't parse "+r+".",xe.message);return}const Q=K.metadata;if(Q===void 0||Q.type===void 0||Q.type.toLowerCase()==="geometry"){y!==void 0&&y(new Error("THREE.ObjectLoader: Can't load "+r)),console.error("THREE.ObjectLoader: Can't load "+r);return}_.parse(K,d)},g,y)}async loadAsync(r,d){const g=this,y=this.path===""?$h.extractUrlBase(r):this.path;this.resourcePath=this.resourcePath||y;const _=new Bc(this.manager);_.setPath(this.path),_.setRequestHeader(this.requestHeader),_.setWithCredentials(this.withCredentials);const R=await _.loadAsync(r,d),k=JSON.parse(R),X=k.metadata;if(X===void 0||X.type===void 0||X.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+r);return await g.parseAsync(k)}parse(r,d){const g=this.parseAnimations(r.animations),y=this.parseShapes(r.shapes),_=this.parseGeometries(r.geometries,y),R=this.parseImages(r.images,function(){d!==void 0&&d(K)}),k=this.parseTextures(r.textures,R),X=this.parseMaterials(r.materials,k),K=this.parseObject(r.object,_,X,k,g),Q=this.parseSkeletons(r.skeletons,K);if(this.bindSkeletons(K,Q),d!==void 0){let xe=!1;for(const ue in R)if(R[ue].data instanceof HTMLImageElement){xe=!0;break}xe===!1&&d(K)}return K}async parseAsync(r){const d=this.parseAnimations(r.animations),g=this.parseShapes(r.shapes),y=this.parseGeometries(r.geometries,g),_=await this.parseImagesAsync(r.images),R=this.parseTextures(r.textures,_),k=this.parseMaterials(r.materials,R),X=this.parseObject(r.object,y,k,R,d),K=this.parseSkeletons(r.skeletons,X);return this.bindSkeletons(X,K),X}parseShapes(r){const d={};if(r!==void 0)for(let g=0,y=r.length;g<y;g++){const _=new Bf().fromJSON(r[g]);d[_.uuid]=_}return d}parseSkeletons(r,d){const g={},y={};if(d.traverse(function(_){_.isBone&&(y[_.uuid]=_)}),r!==void 0)for(let _=0,R=r.length;_<R;_++){const k=new Tg().fromJSON(r[_],y);g[k.uuid]=k}return g}parseGeometries(r,d){const g={};if(r!==void 0){const y=new X5;for(let _=0,R=r.length;_<R;_++){let k;const X=r[_];switch(X.type){case"BufferGeometry":case"InstancedBufferGeometry":k=y.parse(X);break;default:X.type in rS?k=rS[X.type].fromJSON(X,d):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${X.type}"`)}k.uuid=X.uuid,X.name!==void 0&&(k.name=X.name),X.userData!==void 0&&(k.userData=X.userData),g[X.uuid]=k}}return g}parseMaterials(r,d){const g={},y={};if(r!==void 0){const _=new Jv;_.setTextures(d);for(let R=0,k=r.length;R<k;R++){const X=r[R];g[X.uuid]===void 0&&(g[X.uuid]=_.parse(X)),y[X.uuid]=g[X.uuid]}}return y}parseAnimations(r){const d={};if(r!==void 0)for(let g=0;g<r.length;g++){const y=r[g],_=jp.parse(y);d[_.uuid]=_}return d}parseImages(r,d){const g=this,y={};let _;function R(X){return g.manager.itemStart(X),_.load(X,function(){g.manager.itemEnd(X)},void 0,function(){g.manager.itemError(X),g.manager.itemEnd(X)})}function k(X){if(typeof X=="string"){const K=X,Q=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(K)?K:g.resourcePath+K;return R(Q)}else return X.data?{data:Rd(X.type,X.data),width:X.width,height:X.height}:null}if(r!==void 0&&r.length>0){const X=new bS(d);_=new xy(X),_.setCrossOrigin(this.crossOrigin);for(let K=0,Q=r.length;K<Q;K++){const xe=r[K],ue=xe.url;if(Array.isArray(ue)){const ge=[];for(let _e=0,Re=ue.length;_e<Re;_e++){const be=ue[_e],ve=k(be);ve!==null&&(ve instanceof HTMLImageElement?ge.push(ve):ge.push(new Cf(ve.data,ve.width,ve.height)))}y[xe.uuid]=new Bd(ge)}else{const ge=k(xe.url);y[xe.uuid]=new Bd(ge)}}}return y}async parseImagesAsync(r){const d=this,g={};let y;async function _(R){if(typeof R=="string"){const k=R,X=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(k)?k:d.resourcePath+k;return await y.loadAsync(X)}else return R.data?{data:Rd(R.type,R.data),width:R.width,height:R.height}:null}if(r!==void 0&&r.length>0){y=new xy(this.manager),y.setCrossOrigin(this.crossOrigin);for(let R=0,k=r.length;R<k;R++){const X=r[R],K=X.url;if(Array.isArray(K)){const Q=[];for(let xe=0,ue=K.length;xe<ue;xe++){const ge=K[xe],_e=await _(ge);_e!==null&&(_e instanceof HTMLImageElement?Q.push(_e):Q.push(new Cf(_e.data,_e.width,_e.height)))}g[X.uuid]=new Bd(Q)}else{const Q=await _(X.url);g[X.uuid]=new Bd(Q)}}}return g}parseTextures(r,d){function g(_,R){return typeof _=="number"?_:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",_),R[_])}const y={};if(r!==void 0)for(let _=0,R=r.length;_<R;_++){const k=r[_];k.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',k.uuid),d[k.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",k.image);const X=d[k.image],K=X.data;let Q;Array.isArray(K)?(Q=new $m,K.length===6&&(Q.needsUpdate=!0)):(K&&K.data?Q=new Cf:Q=new Ks,K&&(Q.needsUpdate=!0)),Q.source=X,Q.uuid=k.uuid,k.name!==void 0&&(Q.name=k.name),k.mapping!==void 0&&(Q.mapping=g(k.mapping,j5)),k.channel!==void 0&&(Q.channel=k.channel),k.offset!==void 0&&Q.offset.fromArray(k.offset),k.repeat!==void 0&&Q.repeat.fromArray(k.repeat),k.center!==void 0&&Q.center.fromArray(k.center),k.rotation!==void 0&&(Q.rotation=k.rotation),k.wrap!==void 0&&(Q.wrapS=g(k.wrap[0],NS),Q.wrapT=g(k.wrap[1],NS)),k.format!==void 0&&(Q.format=k.format),k.internalFormat!==void 0&&(Q.internalFormat=k.internalFormat),k.type!==void 0&&(Q.type=k.type),k.colorSpace!==void 0&&(Q.colorSpace=k.colorSpace),k.encoding!==void 0&&(Q.encoding=k.encoding),k.minFilter!==void 0&&(Q.minFilter=g(k.minFilter,PS)),k.magFilter!==void 0&&(Q.magFilter=g(k.magFilter,PS)),k.anisotropy!==void 0&&(Q.anisotropy=k.anisotropy),k.flipY!==void 0&&(Q.flipY=k.flipY),k.generateMipmaps!==void 0&&(Q.generateMipmaps=k.generateMipmaps),k.premultiplyAlpha!==void 0&&(Q.premultiplyAlpha=k.premultiplyAlpha),k.unpackAlignment!==void 0&&(Q.unpackAlignment=k.unpackAlignment),k.compareFunction!==void 0&&(Q.compareFunction=k.compareFunction),k.userData!==void 0&&(Q.userData=k.userData),y[k.uuid]=Q}return y}parseObject(r,d,g,y,_){let R;function k(ue){return d[ue]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",ue),d[ue]}function X(ue){if(ue!==void 0){if(Array.isArray(ue)){const ge=[];for(let _e=0,Re=ue.length;_e<Re;_e++){const be=ue[_e];g[be]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",be),ge.push(g[be])}return ge}return g[ue]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",ue),g[ue]}}function K(ue){return y[ue]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",ue),y[ue]}let Q,xe;switch(r.type){case"Scene":R=new Y_,r.background!==void 0&&(Number.isInteger(r.background)?R.background=new bx(r.background):R.background=K(r.background)),r.environment!==void 0&&(R.environment=K(r.environment)),r.fog!==void 0&&(r.fog.type==="Fog"?R.fog=new k1(r.fog.color,r.fog.near,r.fog.far):r.fog.type==="FogExp2"&&(R.fog=new P1(r.fog.color,r.fog.density)),r.fog.name!==""&&(R.fog.name=r.fog.name)),r.backgroundBlurriness!==void 0&&(R.backgroundBlurriness=r.backgroundBlurriness),r.backgroundIntensity!==void 0&&(R.backgroundIntensity=r.backgroundIntensity);break;case"PerspectiveCamera":R=new ua(r.fov,r.aspect,r.near,r.far),r.focus!==void 0&&(R.focus=r.focus),r.zoom!==void 0&&(R.zoom=r.zoom),r.filmGauge!==void 0&&(R.filmGauge=r.filmGauge),r.filmOffset!==void 0&&(R.filmOffset=r.filmOffset),r.view!==void 0&&(R.view=Object.assign({},r.view));break;case"OrthographicCamera":R=new _p(r.left,r.right,r.top,r.bottom,r.near,r.far),r.zoom!==void 0&&(R.zoom=r.zoom),r.view!==void 0&&(R.view=Object.assign({},r.view));break;case"AmbientLight":R=new RS(r.color,r.intensity);break;case"DirectionalLight":R=new CS(r.color,r.intensity);break;case"PointLight":R=new $v(r.color,r.intensity,r.distance,r.decay);break;case"RectAreaLight":R=new z5(r.color,r.intensity,r.width,r.height);break;case"SpotLight":R=new AS(r.color,r.intensity,r.distance,r.angle,r.penumbra,r.decay);break;case"HemisphereLight":R=new R5(r.color,r.groundColor,r.intensity);break;case"LightProbe":R=new U5().fromJSON(r);break;case"SkinnedMesh":Q=k(r.geometry),xe=X(r.material),R=new X1(Q,xe),r.bindMode!==void 0&&(R.bindMode=r.bindMode),r.bindMatrix!==void 0&&R.bindMatrix.fromArray(r.bindMatrix),r.skeleton!==void 0&&(R.skeleton=r.skeleton);break;case"Mesh":Q=k(r.geometry),xe=X(r.material),R=new Bs(Q,xe);break;case"InstancedMesh":Q=k(r.geometry),xe=X(r.material);const ue=r.count,ge=r.instanceMatrix,_e=r.instanceColor;R=new gw(Q,xe,ue),R.instanceMatrix=new Rf(new Float32Array(ge.array),16),_e!==void 0&&(R.instanceColor=new Rf(new Float32Array(_e.array),_e.itemSize));break;case"BatchedMesh":Q=k(r.geometry),xe=X(r.material),R=new NL(r.maxGeometryCount,r.maxVertexCount,r.maxIndexCount,xe),R.geometry=Q,R.perObjectFrustumCulled=r.perObjectFrustumCulled,R.sortObjects=r.sortObjects,R._drawRanges=r.drawRanges,R._reservedRanges=r.reservedRanges,R._visibility=r.visibility,R._active=r.active,R._bounds=r.bounds.map(Re=>{const be=new Co;be.min.fromArray(Re.boxMin),be.max.fromArray(Re.boxMax);const ve=new Qa;return ve.radius=Re.sphereRadius,ve.center.fromArray(Re.sphereCenter),{boxInitialized:Re.boxInitialized,box:be,sphereInitialized:Re.sphereInitialized,sphere:ve}}),R._maxGeometryCount=r.maxGeometryCount,R._maxVertexCount=r.maxVertexCount,R._maxIndexCount=r.maxIndexCount,R._geometryInitialized=r.geometryInitialized,R._geometryCount=r.geometryCount,R._matricesTexture=K(r.matricesTexture.uuid);break;case"LOD":R=new gL;break;case"Line":R=new Uh(k(r.geometry),X(r.material));break;case"LineLoop":R=new Rw(k(r.geometry),X(r.material));break;case"LineSegments":R=new J1(k(r.geometry),X(r.material));break;case"PointCloud":case"Points":R=new Pw(k(r.geometry),X(r.material));break;case"Sprite":R=new dL(X(r.material));break;case"Group":R=new jl;break;case"Bone":R=new _g;break;default:R=new xs}if(R.uuid=r.uuid,r.name!==void 0&&(R.name=r.name),r.matrix!==void 0?(R.matrix.fromArray(r.matrix),r.matrixAutoUpdate!==void 0&&(R.matrixAutoUpdate=r.matrixAutoUpdate),R.matrixAutoUpdate&&R.matrix.decompose(R.position,R.quaternion,R.scale)):(r.position!==void 0&&R.position.fromArray(r.position),r.rotation!==void 0&&R.rotation.fromArray(r.rotation),r.quaternion!==void 0&&R.quaternion.fromArray(r.quaternion),r.scale!==void 0&&R.scale.fromArray(r.scale)),r.up!==void 0&&R.up.fromArray(r.up),r.castShadow!==void 0&&(R.castShadow=r.castShadow),r.receiveShadow!==void 0&&(R.receiveShadow=r.receiveShadow),r.shadow&&(r.shadow.bias!==void 0&&(R.shadow.bias=r.shadow.bias),r.shadow.normalBias!==void 0&&(R.shadow.normalBias=r.shadow.normalBias),r.shadow.radius!==void 0&&(R.shadow.radius=r.shadow.radius),r.shadow.mapSize!==void 0&&R.shadow.mapSize.fromArray(r.shadow.mapSize),r.shadow.camera!==void 0&&(R.shadow.camera=this.parseObject(r.shadow.camera))),r.visible!==void 0&&(R.visible=r.visible),r.frustumCulled!==void 0&&(R.frustumCulled=r.frustumCulled),r.renderOrder!==void 0&&(R.renderOrder=r.renderOrder),r.userData!==void 0&&(R.userData=r.userData),r.layers!==void 0&&(R.layers.mask=r.layers),r.children!==void 0){const ue=r.children;for(let ge=0;ge<ue.length;ge++)R.add(this.parseObject(ue[ge],d,g,y,_))}if(r.animations!==void 0){const ue=r.animations;for(let ge=0;ge<ue.length;ge++){const _e=ue[ge];R.animations.push(_[_e])}}if(r.type==="LOD"){r.autoUpdate!==void 0&&(R.autoUpdate=r.autoUpdate);const ue=r.levels;for(let ge=0;ge<ue.length;ge++){const _e=ue[ge],Re=R.getObjectByProperty("uuid",_e.object);Re!==void 0&&R.addLevel(Re,_e.distance,_e.hysteresis)}}return R}bindSkeletons(r,d){Object.keys(d).length!==0&&r.traverse(function(g){if(g.isSkinnedMesh===!0&&g.skeleton!==void 0){const y=d[g.skeleton];y===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",g.skeleton):g.bind(y,g.bindMatrix)}})}}const j5={UVMapping:_l,CubeReflectionMapping:_s,CubeRefractionMapping:e2,EquirectangularReflectionMapping:Qs,EquirectangularRefractionMapping:Ps,CubeUVReflectionMapping:P2},NS={RepeatWrapping:Ri,ClampToEdgeWrapping:Gi,MirroredRepeatWrapping:ea},PS={NearestFilter:gi,NearestMipmapNearestFilter:Tc,NearestMipmapLinearFilter:x2,LinearFilter:ui,LinearMipmapNearestFilter:Xo,LinearMipmapLinearFilter:Us};class K5 extends Nu{constructor(r){super(r),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(r){return this.options=r,this}load(r,d,g,y){r===void 0&&(r=""),this.path!==void 0&&(r=this.path+r),r=this.manager.resolveURL(r);const _=this,R=Ru.get(r);if(R!==void 0){if(_.manager.itemStart(r),R.then){R.then(K=>{d&&d(K),_.manager.itemEnd(r)}).catch(K=>{y&&y(K)});return}return setTimeout(function(){d&&d(R),_.manager.itemEnd(r)},0),R}const k={};k.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",k.headers=this.requestHeader;const X=fetch(r,k).then(function(K){return K.blob()}).then(function(K){return createImageBitmap(K,Object.assign(_.options,{colorSpaceConversion:"none"}))}).then(function(K){return Ru.add(r,K),d&&d(K),_.manager.itemEnd(r),K}).catch(function(K){y&&y(K),Ru.remove(r),_.manager.itemError(r),_.manager.itemEnd(r)});Ru.add(r,X),_.manager.itemStart(r)}}let uy;class BS{static getContext(){return uy===void 0&&(uy=new(window.AudioContext||window.webkitAudioContext)),uy}static setContext(r){uy=r}}class G9 extends null{constructor(r){super(r)}load(r,d,g,y){const _=this,R=new Bc(this.manager);R.setResponseType("arraybuffer"),R.setPath(this.path),R.setRequestHeader(this.requestHeader),R.setWithCredentials(this.withCredentials),R.load(r,function(X){try{const K=X.slice(0);BS.getContext().decodeAudioData(K,function(xe){d(xe)}).catch(k)}catch(K){k(K)}},g,y);function k(X){y?y(X):console.error(X),_.manager.itemError(r)}}}const zS=new ur,VS=new ur,Jh=new ur;class X9{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new ua,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new ua,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(r){const d=this._cache;if(d.focus!==r.focus||d.fov!==r.fov||d.aspect!==r.aspect*this.aspect||d.near!==r.near||d.far!==r.far||d.zoom!==r.zoom||d.eyeSep!==this.eyeSep){d.focus=r.focus,d.fov=r.fov,d.aspect=r.aspect*this.aspect,d.near=r.near,d.far=r.far,d.zoom=r.zoom,d.eyeSep=this.eyeSep,Jh.copy(r.projectionMatrix);const y=d.eyeSep/2,_=y*d.near/d.focus,R=d.near*Math.tan(bh*d.fov*.5)/d.zoom;let k,X;VS.elements[12]=-y,zS.elements[12]=y,k=-R*d.aspect+_,X=R*d.aspect+_,Jh.elements[0]=2*d.near/(X-k),Jh.elements[8]=(X+k)/(X-k),this.cameraL.projectionMatrix.copy(Jh),k=-R*d.aspect-_,X=R*d.aspect-_,Jh.elements[0]=2*d.near/(X-k),Jh.elements[8]=(X+k)/(X-k),this.cameraR.projectionMatrix.copy(Jh)}this.cameraL.matrixWorld.copy(r.matrixWorld).multiply(VS),this.cameraR.matrixWorld.copy(r.matrixWorld).multiply(zS)}}class $5{constructor(r=!0){this.autoStart=r,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=US(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let r=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const d=US();r=(d-this.oldTime)/1e3,this.oldTime=d,this.elapsedTime+=r}return r}}function US(){return(typeof performance>"u"?Date:performance).now()}const Wh=new ut,GS=new Xa,J5=new ut,Qh=new ut;class j9 extends null{constructor(){super(),this.type="AudioListener",this.context=BS.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new $5}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(r){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=r,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(r){return this.gain.gain.setTargetAtTime(r,this.context.currentTime,.01),this}updateMatrixWorld(r){super.updateMatrixWorld(r);const d=this.context.listener,g=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Wh,GS,J5),Qh.set(0,0,-1).applyQuaternion(GS),d.positionX){const y=this.context.currentTime+this.timeDelta;d.positionX.linearRampToValueAtTime(Wh.x,y),d.positionY.linearRampToValueAtTime(Wh.y,y),d.positionZ.linearRampToValueAtTime(Wh.z,y),d.forwardX.linearRampToValueAtTime(Qh.x,y),d.forwardY.linearRampToValueAtTime(Qh.y,y),d.forwardZ.linearRampToValueAtTime(Qh.z,y),d.upX.linearRampToValueAtTime(g.x,y),d.upY.linearRampToValueAtTime(g.y,y),d.upZ.linearRampToValueAtTime(g.z,y)}else d.setPosition(Wh.x,Wh.y,Wh.z),d.setOrientation(Qh.x,Qh.y,Qh.z,g.x,g.y,g.z)}}class K9 extends null{constructor(r){super(),this.type="Audio",this.listener=r,this.context=r.context,this.gain=this.context.createGain(),this.gain.connect(r.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(r){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=r,this.connect(),this}setMediaElementSource(r){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(r),this.connect(),this}setMediaStreamSource(r){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(r),this.connect(),this}setBuffer(r){return this.buffer=r,this.sourceType="buffer",this.autoplay&&this.play(),this}play(r=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+r;const d=this.context.createBufferSource();return d.buffer=this.buffer,d.loop=this.loop,d.loopStart=this.loopStart,d.loopEnd=this.loopEnd,d.onended=this.onEnded.bind(this),d.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=d,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let r=1,d=this.filters.length;r<d;r++)this.filters[r-1].connect(this.filters[r]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let r=1,d=this.filters.length;r<d;r++)this.filters[r-1].disconnect(this.filters[r]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(r){return r||(r=[]),this._connected===!0?(this.disconnect(),this.filters=r.slice(),this.connect()):this.filters=r.slice(),this}setDetune(r){return this.detune=r,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(r){return this.setFilters(r?[r]:[])}setPlaybackRate(r){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=r,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(r){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=r,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(r){return this.loopStart=r,this}setLoopEnd(r){return this.loopEnd=r,this}getVolume(){return this.gain.gain.value}setVolume(r){return this.gain.gain.setTargetAtTime(r,this.context.currentTime,.01),this}}const ed=new ut,XS=new Xa,W5=new ut,xd=new ut;class $9 extends null{constructor(r){super(r),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(r){return this.panner.refDistance=r,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(r){return this.panner.rolloffFactor=r,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(r){return this.panner.distanceModel=r,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(r){return this.panner.maxDistance=r,this}setDirectionalCone(r,d,g){return this.panner.coneInnerAngle=r,this.panner.coneOuterAngle=d,this.panner.coneOuterGain=g,this}updateMatrixWorld(r){if(super.updateMatrixWorld(r),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(ed,XS,W5),xd.set(0,0,1).applyQuaternion(XS);const d=this.panner;if(d.positionX){const g=this.context.currentTime+this.listener.timeDelta;d.positionX.linearRampToValueAtTime(ed.x,g),d.positionY.linearRampToValueAtTime(ed.y,g),d.positionZ.linearRampToValueAtTime(ed.z,g),d.orientationX.linearRampToValueAtTime(xd.x,g),d.orientationY.linearRampToValueAtTime(xd.y,g),d.orientationZ.linearRampToValueAtTime(xd.z,g)}else d.setPosition(ed.x,ed.y,ed.z),d.setOrientation(xd.x,xd.y,xd.z)}}class J9{constructor(r,d=2048){this.analyser=r.context.createAnalyser(),this.analyser.fftSize=d,this.data=new Uint8Array(this.analyser.frequencyBinCount),r.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let r=0;const d=this.getFrequencyData();for(let g=0;g<d.length;g++)r+=d[g];return r/d.length}}class Q5{constructor(r,d,g){this.binding=r,this.valueSize=g;let y,_,R;switch(d){case"quaternion":y=this._slerp,_=this._slerpAdditive,R=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(g*6),this._workIndex=5;break;case"string":case"bool":y=this._select,_=this._select,R=this._setAdditiveIdentityOther,this.buffer=new Array(g*5);break;default:y=this._lerp,_=this._lerpAdditive,R=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(g*5)}this._mixBufferRegion=y,this._mixBufferRegionAdditive=_,this._setIdentity=R,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(r,d){const g=this.buffer,y=this.valueSize,_=r*y+y;let R=this.cumulativeWeight;if(R===0){for(let k=0;k!==y;++k)g[_+k]=g[k];R=d}else{R+=d;const k=d/R;this._mixBufferRegion(g,_,0,k,y)}this.cumulativeWeight=R}accumulateAdditive(r){const d=this.buffer,g=this.valueSize,y=g*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(d,y,0,r,g),this.cumulativeWeightAdditive+=r}apply(r){const d=this.valueSize,g=this.buffer,y=r*d+d,_=this.cumulativeWeight,R=this.cumulativeWeightAdditive,k=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,_<1){const X=d*this._origIndex;this._mixBufferRegion(g,y,X,1-_,d)}R>0&&this._mixBufferRegionAdditive(g,y,this._addIndex*d,1,d);for(let X=d,K=d+d;X!==K;++X)if(g[X]!==g[X+d]){k.setValue(g,y);break}}saveOriginalState(){const r=this.binding,d=this.buffer,g=this.valueSize,y=g*this._origIndex;r.getValue(d,y);for(let _=g,R=y;_!==R;++_)d[_]=d[y+_%g];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const r=this.valueSize*3;this.binding.setValue(this.buffer,r)}_setAdditiveIdentityNumeric(){const r=this._addIndex*this.valueSize,d=r+this.valueSize;for(let g=r;g<d;g++)this.buffer[g]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const r=this._origIndex*this.valueSize,d=this._addIndex*this.valueSize;for(let g=0;g<this.valueSize;g++)this.buffer[d+g]=this.buffer[r+g]}_select(r,d,g,y,_){if(y>=.5)for(let R=0;R!==_;++R)r[d+R]=r[g+R]}_slerp(r,d,g,y){Xa.slerpFlat(r,d,r,d,r,g,y)}_slerpAdditive(r,d,g,y,_){const R=this._workIndex*_;Xa.multiplyQuaternionsFlat(r,R,r,d,r,g),Xa.slerpFlat(r,d,r,d,r,R,y)}_lerp(r,d,g,y,_){const R=1-y;for(let k=0;k!==_;++k){const X=d+k;r[X]=r[X]*R+r[g+k]*y}}_lerpAdditive(r,d,g,y,_){for(let R=0;R!==_;++R){const k=d+R;r[k]=r[k]+r[g+R]*y}}}const Wv="\\[\\]\\.:\\/",eO=new RegExp("["+Wv+"]","g"),Qv="[^"+Wv+"]",xO="[^"+Wv.replace("\\.","")+"]",rO=/((?:WC+[\/:])*)/.source.replace("WC",Qv),uO=/(WCOD+)?/.source.replace("WCOD",xO),dO=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Qv),gO=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Qv),vO=new RegExp("^"+rO+uO+dO+gO+"$"),bO=["material","materials","bones","map"];class _O{constructor(r,d,g){const y=g||vi.parseTrackName(d);this._targetGroup=r,this._bindings=r.subscribe_(d,y)}getValue(r,d){this.bind();const g=this._targetGroup.nCachedObjects_,y=this._bindings[g];y!==void 0&&y.getValue(r,d)}setValue(r,d){const g=this._bindings;for(let y=this._targetGroup.nCachedObjects_,_=g.length;y!==_;++y)g[y].setValue(r,d)}bind(){const r=this._bindings;for(let d=this._targetGroup.nCachedObjects_,g=r.length;d!==g;++d)r[d].bind()}unbind(){const r=this._bindings;for(let d=this._targetGroup.nCachedObjects_,g=r.length;d!==g;++d)r[d].unbind()}}class vi{constructor(r,d,g){this.path=d,this.parsedPath=g||vi.parseTrackName(d),this.node=vi.findNode(r,this.parsedPath.nodeName),this.rootNode=r,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(r,d,g){return r&&r.isAnimationObjectGroup?new vi.Composite(r,d,g):new vi(r,d,g)}static sanitizeNodeName(r){return r.replace(/\s/g,"_").replace(eO,"")}static parseTrackName(r){const d=vO.exec(r);if(d===null)throw new Error("PropertyBinding: Cannot parse trackName: "+r);const g={nodeName:d[2],objectName:d[3],objectIndex:d[4],propertyName:d[5],propertyIndex:d[6]},y=g.nodeName&&g.nodeName.lastIndexOf(".");if(y!==void 0&&y!==-1){const _=g.nodeName.substring(y+1);bO.indexOf(_)!==-1&&(g.nodeName=g.nodeName.substring(0,y),g.objectName=_)}if(g.propertyName===null||g.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+r);return g}static findNode(r,d){if(d===void 0||d===""||d==="."||d===-1||d===r.name||d===r.uuid)return r;if(r.skeleton){const g=r.skeleton.getBoneByName(d);if(g!==void 0)return g}if(r.children){const g=function(_){for(let R=0;R<_.length;R++){const k=_[R];if(k.name===d||k.uuid===d)return k;const X=g(k.children);if(X)return X}return null},y=g(r.children);if(y)return y}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(r,d){r[d]=this.targetObject[this.propertyName]}_getValue_array(r,d){const g=this.resolvedProperty;for(let y=0,_=g.length;y!==_;++y)r[d++]=g[y]}_getValue_arrayElement(r,d){r[d]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(r,d){this.resolvedProperty.toArray(r,d)}_setValue_direct(r,d){this.targetObject[this.propertyName]=r[d]}_setValue_direct_setNeedsUpdate(r,d){this.targetObject[this.propertyName]=r[d],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(r,d){this.targetObject[this.propertyName]=r[d],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(r,d){const g=this.resolvedProperty;for(let y=0,_=g.length;y!==_;++y)g[y]=r[d++]}_setValue_array_setNeedsUpdate(r,d){const g=this.resolvedProperty;for(let y=0,_=g.length;y!==_;++y)g[y]=r[d++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(r,d){const g=this.resolvedProperty;for(let y=0,_=g.length;y!==_;++y)g[y]=r[d++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(r,d){this.resolvedProperty[this.propertyIndex]=r[d]}_setValue_arrayElement_setNeedsUpdate(r,d){this.resolvedProperty[this.propertyIndex]=r[d],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(r,d){this.resolvedProperty[this.propertyIndex]=r[d],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(r,d){this.resolvedProperty.fromArray(r,d)}_setValue_fromArray_setNeedsUpdate(r,d){this.resolvedProperty.fromArray(r,d),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(r,d){this.resolvedProperty.fromArray(r,d),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(r,d){this.bind(),this.getValue(r,d)}_setValue_unbound(r,d){this.bind(),this.setValue(r,d)}bind(){let r=this.node;const d=this.parsedPath,g=d.objectName,y=d.propertyName;let _=d.propertyIndex;if(r||(r=vi.findNode(this.rootNode,d.nodeName),this.node=r),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!r){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(g){let K=d.objectIndex;switch(g){case"materials":if(!r.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!r.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}r=r.material.materials;break;case"bones":if(!r.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}r=r.skeleton.bones;for(let Q=0;Q<r.length;Q++)if(r[Q].name===K){K=Q;break}break;case"map":if("map"in r){r=r.map;break}if(!r.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!r.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}r=r.material.map;break;default:if(r[g]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}r=r[g]}if(K!==void 0){if(r[K]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,r);return}r=r[K]}}const R=r[y];if(R===void 0){const K=d.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+K+"."+y+" but it wasn't found.",r);return}let k=this.Versioning.None;this.targetObject=r,r.needsUpdate!==void 0?k=this.Versioning.NeedsUpdate:r.matrixWorldNeedsUpdate!==void 0&&(k=this.Versioning.MatrixWorldNeedsUpdate);let X=this.BindingType.Direct;if(_!==void 0){if(y==="morphTargetInfluences"){if(!r.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!r.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}r.morphTargetDictionary[_]!==void 0&&(_=r.morphTargetDictionary[_])}X=this.BindingType.ArrayElement,this.resolvedProperty=R,this.propertyIndex=_}else R.fromArray!==void 0&&R.toArray!==void 0?(X=this.BindingType.HasFromToArray,this.resolvedProperty=R):Array.isArray(R)?(X=this.BindingType.EntireArray,this.resolvedProperty=R):this.propertyName=y;this.getValue=this.GetterByBindingType[X],this.setValue=this.SetterByBindingTypeAndVersioning[X][k]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}vi.Composite=_O,vi.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},vi.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},vi.prototype.GetterByBindingType=[vi.prototype._getValue_direct,vi.prototype._getValue_array,vi.prototype._getValue_arrayElement,vi.prototype._getValue_toArray],vi.prototype.SetterByBindingTypeAndVersioning=[[vi.prototype._setValue_direct,vi.prototype._setValue_direct_setNeedsUpdate,vi.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[vi.prototype._setValue_array,vi.prototype._setValue_array_setNeedsUpdate,vi.prototype._setValue_array_setMatrixWorldNeedsUpdate],[vi.prototype._setValue_arrayElement,vi.prototype._setValue_arrayElement_setNeedsUpdate,vi.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[vi.prototype._setValue_fromArray,vi.prototype._setValue_fromArray_setNeedsUpdate,vi.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class W9{constructor(){this.isAnimationObjectGroup=!0,this.uuid=b2(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const r={};this._indicesByUUID=r;for(let g=0,y=arguments.length;g!==y;++g)r[arguments[g].uuid]=g;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const d=this;this.stats={objects:{get total(){return d._objects.length},get inUse(){return this.total-d.nCachedObjects_}},get bindingsPerObject(){return d._bindings.length}}}add(){const r=this._objects,d=this._indicesByUUID,g=this._paths,y=this._parsedPaths,_=this._bindings,R=_.length;let k,X=r.length,K=this.nCachedObjects_;for(let Q=0,xe=arguments.length;Q!==xe;++Q){const ue=arguments[Q],ge=ue.uuid;let _e=d[ge];if(_e===void 0){_e=X++,d[ge]=_e,r.push(ue);for(let Re=0,be=R;Re!==be;++Re)_[Re].push(new vi(ue,g[Re],y[Re]))}else if(_e<K){k=r[_e];const Re=--K,be=r[Re];d[be.uuid]=_e,r[_e]=be,d[ge]=Re,r[Re]=ue;for(let ve=0,Xe=R;ve!==Xe;++ve){const Be=_[ve],Ke=Be[Re];let bt=Be[_e];Be[_e]=Ke,bt===void 0&&(bt=new vi(ue,g[ve],y[ve])),Be[Re]=bt}}else r[_e]!==k&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=K}remove(){const r=this._objects,d=this._indicesByUUID,g=this._bindings,y=g.length;let _=this.nCachedObjects_;for(let R=0,k=arguments.length;R!==k;++R){const X=arguments[R],K=X.uuid,Q=d[K];if(Q!==void 0&&Q>=_){const xe=_++,ue=r[xe];d[ue.uuid]=Q,r[Q]=ue,d[K]=xe,r[xe]=X;for(let ge=0,_e=y;ge!==_e;++ge){const Re=g[ge],be=Re[xe],ve=Re[Q];Re[Q]=be,Re[xe]=ve}}}this.nCachedObjects_=_}uncache(){const r=this._objects,d=this._indicesByUUID,g=this._bindings,y=g.length;let _=this.nCachedObjects_,R=r.length;for(let k=0,X=arguments.length;k!==X;++k){const K=arguments[k],Q=K.uuid,xe=d[Q];if(xe!==void 0)if(delete d[Q],xe<_){const ue=--_,ge=r[ue],_e=--R,Re=r[_e];d[ge.uuid]=xe,r[xe]=ge,d[Re.uuid]=ue,r[ue]=Re,r.pop();for(let be=0,ve=y;be!==ve;++be){const Xe=g[be],Be=Xe[ue],Ke=Xe[_e];Xe[xe]=Be,Xe[ue]=Ke,Xe.pop()}}else{const ue=--R,ge=r[ue];ue>0&&(d[ge.uuid]=xe),r[xe]=ge,r.pop();for(let _e=0,Re=y;_e!==Re;++_e){const be=g[_e];be[xe]=be[ue],be.pop()}}}this.nCachedObjects_=_}subscribe_(r,d){const g=this._bindingsIndicesByPath;let y=g[r];const _=this._bindings;if(y!==void 0)return _[y];const R=this._paths,k=this._parsedPaths,X=this._objects,K=X.length,Q=this.nCachedObjects_,xe=new Array(K);y=_.length,g[r]=y,R.push(r),k.push(d),_.push(xe);for(let ue=Q,ge=X.length;ue!==ge;++ue){const _e=X[ue];xe[ue]=new vi(_e,r,d)}return xe}unsubscribe_(r){const d=this._bindingsIndicesByPath,g=d[r];if(g!==void 0){const y=this._paths,_=this._parsedPaths,R=this._bindings,k=R.length-1,X=R[k],K=r[k];d[K]=g,R[g]=X,R.pop(),_[g]=_[k],_.pop(),y[g]=y[k],y.pop()}}}class TO{constructor(r,d,g=null,y=d.blendMode){this._mixer=r,this._clip=d,this._localRoot=g,this.blendMode=y;const _=d.tracks,R=_.length,k=new Array(R),X={endingStart:Rl,endingEnd:Rl};for(let K=0;K!==R;++K){const Q=_[K].createInterpolant(null);k[K]=Q,Q.settings=X}this._interpolantSettings=X,this._interpolants=k,this._propertyBindings=new Array(R),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=bd,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(r){return this._startTime=r,this}setLoop(r,d){return this.loop=r,this.repetitions=d,this}setEffectiveWeight(r){return this.weight=r,this._effectiveWeight=this.enabled?r:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(r){return this._scheduleFading(r,0,1)}fadeOut(r){return this._scheduleFading(r,1,0)}crossFadeFrom(r,d,g){if(r.fadeOut(d),this.fadeIn(d),g){const y=this._clip.duration,_=r._clip.duration,R=_/y,k=y/_;r.warp(1,R,d),this.warp(k,1,d)}return this}crossFadeTo(r,d,g){return r.crossFadeFrom(this,d,g)}stopFading(){const r=this._weightInterpolant;return r!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(r)),this}setEffectiveTimeScale(r){return this.timeScale=r,this._effectiveTimeScale=this.paused?0:r,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(r){return this.timeScale=this._clip.duration/r,this.stopWarping()}syncWith(r){return this.time=r.time,this.timeScale=r.timeScale,this.stopWarping()}halt(r){return this.warp(this._effectiveTimeScale,0,r)}warp(r,d,g){const y=this._mixer,_=y.time,R=this.timeScale;let k=this._timeScaleInterpolant;k===null&&(k=y._lendControlInterpolant(),this._timeScaleInterpolant=k);const X=k.parameterPositions,K=k.sampleValues;return X[0]=_,X[1]=_+g,K[0]=r/R,K[1]=d/R,this}stopWarping(){const r=this._timeScaleInterpolant;return r!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(r)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(r,d,g,y){if(!this.enabled){this._updateWeight(r);return}const _=this._startTime;if(_!==null){const X=(r-_)*g;X<0||g===0?d=0:(this._startTime=null,d=g*X)}d*=this._updateTimeScale(r);const R=this._updateTime(d),k=this._updateWeight(r);if(k>0){const X=this._interpolants,K=this._propertyBindings;switch(this.blendMode){case Ge:for(let Q=0,xe=X.length;Q!==xe;++Q)X[Q].evaluate(R),K[Q].accumulateAdditive(k);break;case vh:default:for(let Q=0,xe=X.length;Q!==xe;++Q)X[Q].evaluate(R),K[Q].accumulate(y,k)}}}_updateWeight(r){let d=0;if(this.enabled){d=this.weight;const g=this._weightInterpolant;if(g!==null){const y=g.evaluate(r)[0];d*=y,r>g.parameterPositions[1]&&(this.stopFading(),y===0&&(this.enabled=!1))}}return this._effectiveWeight=d,d}_updateTimeScale(r){let d=0;if(!this.paused){d=this.timeScale;const g=this._timeScaleInterpolant;if(g!==null){const y=g.evaluate(r)[0];d*=y,r>g.parameterPositions[1]&&(this.stopWarping(),d===0?this.paused=!0:this.timeScale=d)}}return this._effectiveTimeScale=d,d}_updateTime(r){const d=this._clip.duration,g=this.loop;let y=this.time+r,_=this._loopCount;const R=g===_d;if(r===0)return _===-1?y:R&&(_&1)===1?d-y:y;if(g===gh){_===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(y>=d)y=d;else if(y<0)y=0;else{this.time=y;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=y,this._mixer.dispatchEvent({type:"finished",action:this,direction:r<0?-1:1})}}else{if(_===-1&&(r>=0?(_=0,this._setEndings(!0,this.repetitions===0,R)):this._setEndings(this.repetitions===0,!0,R)),y>=d||y<0){const k=Math.floor(y/d);y-=d*k,_+=Math.abs(k);const X=this.repetitions-_;if(X<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,y=r>0?d:0,this.time=y,this._mixer.dispatchEvent({type:"finished",action:this,direction:r>0?1:-1});else{if(X===1){const K=r<0;this._setEndings(K,!K,R)}else this._setEndings(!1,!1,R);this._loopCount=_,this.time=y,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:k})}}else this.time=y;if(R&&(_&1)===1)return d-y}return y}_setEndings(r,d,g){const y=this._interpolantSettings;g?(y.endingStart=Mc,y.endingEnd=Mc):(r?y.endingStart=this.zeroSlopeAtStart?Mc:Rl:y.endingStart=Ad,d?y.endingEnd=this.zeroSlopeAtEnd?Mc:Rl:y.endingEnd=Ad)}_scheduleFading(r,d,g){const y=this._mixer,_=y.time;let R=this._weightInterpolant;R===null&&(R=y._lendControlInterpolant(),this._weightInterpolant=R);const k=R.parameterPositions,X=R.sampleValues;return k[0]=_,X[0]=d,k[1]=_+r,X[1]=g,this}}const AO=new Float32Array(1);class Q9 extends null{constructor(r){super(),this._root=r,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(r,d){const g=r._localRoot||this._root,y=r._clip.tracks,_=y.length,R=r._propertyBindings,k=r._interpolants,X=g.uuid,K=this._bindingsByRootAndName;let Q=K[X];Q===void 0&&(Q={},K[X]=Q);for(let xe=0;xe!==_;++xe){const ue=y[xe],ge=ue.name;let _e=Q[ge];if(_e!==void 0)++_e.referenceCount,R[xe]=_e;else{if(_e=R[xe],_e!==void 0){_e._cacheIndex===null&&(++_e.referenceCount,this._addInactiveBinding(_e,X,ge));continue}const Re=d&&d._propertyBindings[xe].binding.parsedPath;_e=new Q5(vi.create(g,ge,Re),ue.ValueTypeName,ue.getValueSize()),++_e.referenceCount,this._addInactiveBinding(_e,X,ge),R[xe]=_e}k[xe].resultBuffer=_e.buffer}}_activateAction(r){if(!this._isActiveAction(r)){if(r._cacheIndex===null){const g=(r._localRoot||this._root).uuid,y=r._clip.uuid,_=this._actionsByClip[y];this._bindAction(r,_&&_.knownActions[0]),this._addInactiveAction(r,y,g)}const d=r._propertyBindings;for(let g=0,y=d.length;g!==y;++g){const _=d[g];_.useCount++===0&&(this._lendBinding(_),_.saveOriginalState())}this._lendAction(r)}}_deactivateAction(r){if(this._isActiveAction(r)){const d=r._propertyBindings;for(let g=0,y=d.length;g!==y;++g){const _=d[g];--_.useCount===0&&(_.restoreOriginalState(),this._takeBackBinding(_))}this._takeBackAction(r)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const r=this;this.stats={actions:{get total(){return r._actions.length},get inUse(){return r._nActiveActions}},bindings:{get total(){return r._bindings.length},get inUse(){return r._nActiveBindings}},controlInterpolants:{get total(){return r._controlInterpolants.length},get inUse(){return r._nActiveControlInterpolants}}}}_isActiveAction(r){const d=r._cacheIndex;return d!==null&&d<this._nActiveActions}_addInactiveAction(r,d,g){const y=this._actions,_=this._actionsByClip;let R=_[d];if(R===void 0)R={knownActions:[r],actionByRoot:{}},r._byClipCacheIndex=0,_[d]=R;else{const k=R.knownActions;r._byClipCacheIndex=k.length,k.push(r)}r._cacheIndex=y.length,y.push(r),R.actionByRoot[g]=r}_removeInactiveAction(r){const d=this._actions,g=d[d.length-1],y=r._cacheIndex;g._cacheIndex=y,d[y]=g,d.pop(),r._cacheIndex=null;const _=r._clip.uuid,R=this._actionsByClip,k=R[_],X=k.knownActions,K=X[X.length-1],Q=r._byClipCacheIndex;K._byClipCacheIndex=Q,X[Q]=K,X.pop(),r._byClipCacheIndex=null;const xe=k.actionByRoot,ue=(r._localRoot||this._root).uuid;delete xe[ue],X.length===0&&delete R[_],this._removeInactiveBindingsForAction(r)}_removeInactiveBindingsForAction(r){const d=r._propertyBindings;for(let g=0,y=d.length;g!==y;++g){const _=d[g];--_.referenceCount===0&&this._removeInactiveBinding(_)}}_lendAction(r){const d=this._actions,g=r._cacheIndex,y=this._nActiveActions++,_=d[y];r._cacheIndex=y,d[y]=r,_._cacheIndex=g,d[g]=_}_takeBackAction(r){const d=this._actions,g=r._cacheIndex,y=--this._nActiveActions,_=d[y];r._cacheIndex=y,d[y]=r,_._cacheIndex=g,d[g]=_}_addInactiveBinding(r,d,g){const y=this._bindingsByRootAndName,_=this._bindings;let R=y[d];R===void 0&&(R={},y[d]=R),R[g]=r,r._cacheIndex=_.length,_.push(r)}_removeInactiveBinding(r){const d=this._bindings,g=r.binding,y=g.rootNode.uuid,_=g.path,R=this._bindingsByRootAndName,k=R[y],X=d[d.length-1],K=r._cacheIndex;X._cacheIndex=K,d[K]=X,d.pop(),delete k[_],Object.keys(k).length===0&&delete R[y]}_lendBinding(r){const d=this._bindings,g=r._cacheIndex,y=this._nActiveBindings++,_=d[y];r._cacheIndex=y,d[y]=r,_._cacheIndex=g,d[g]=_}_takeBackBinding(r){const d=this._bindings,g=r._cacheIndex,y=--this._nActiveBindings,_=d[y];r._cacheIndex=y,d[y]=r,_._cacheIndex=g,d[g]=_}_lendControlInterpolant(){const r=this._controlInterpolants,d=this._nActiveControlInterpolants++;let g=r[d];return g===void 0&&(g=new gS(new Float32Array(2),new Float32Array(2),1,AO),g.__cacheIndex=d,r[d]=g),g}_takeBackControlInterpolant(r){const d=this._controlInterpolants,g=r.__cacheIndex,y=--this._nActiveControlInterpolants,_=d[y];r.__cacheIndex=y,d[y]=r,_.__cacheIndex=g,d[g]=_}clipAction(r,d,g){const y=d||this._root,_=y.uuid;let R=typeof r=="string"?jp.findByName(y,r):r;const k=R!==null?R.uuid:r,X=this._actionsByClip[k];let K=null;if(g===void 0&&(R!==null?g=R.blendMode:g=vh),X!==void 0){const xe=X.actionByRoot[_];if(xe!==void 0&&xe.blendMode===g)return xe;K=X.knownActions[0],R===null&&(R=K._clip)}if(R===null)return null;const Q=new TO(this,R,d,g);return this._bindAction(Q,K),this._addInactiveAction(Q,k,_),Q}existingAction(r,d){const g=d||this._root,y=g.uuid,_=typeof r=="string"?jp.findByName(g,r):r,R=_?_.uuid:r,k=this._actionsByClip[R];return k!==void 0&&k.actionByRoot[y]||null}stopAllAction(){const r=this._actions,d=this._nActiveActions;for(let g=d-1;g>=0;--g)r[g].stop();return this}update(r){r*=this.timeScale;const d=this._actions,g=this._nActiveActions,y=this.time+=r,_=Math.sign(r),R=this._accuIndex^=1;for(let K=0;K!==g;++K)d[K]._update(y,r,_,R);const k=this._bindings,X=this._nActiveBindings;for(let K=0;K!==X;++K)k[K].apply(R);return this}setTime(r){this.time=0;for(let d=0;d<this._actions.length;d++)this._actions[d].time=0;return this.update(r)}getRoot(){return this._root}uncacheClip(r){const d=this._actions,g=r.uuid,y=this._actionsByClip,_=y[g];if(_!==void 0){const R=_.knownActions;for(let k=0,X=R.length;k!==X;++k){const K=R[k];this._deactivateAction(K);const Q=K._cacheIndex,xe=d[d.length-1];K._cacheIndex=null,K._byClipCacheIndex=null,xe._cacheIndex=Q,d[Q]=xe,d.pop(),this._removeInactiveBindingsForAction(K)}delete y[g]}}uncacheRoot(r){const d=r.uuid,g=this._actionsByClip;for(const R in g){const k=g[R].actionByRoot,X=k[d];X!==void 0&&(this._deactivateAction(X),this._removeInactiveAction(X))}const y=this._bindingsByRootAndName,_=y[d];if(_!==void 0)for(const R in _){const k=_[R];k.restoreOriginalState(),this._removeInactiveBinding(k)}}uncacheAction(r,d){const g=this.existingAction(r,d);g!==null&&(this._deactivateAction(g),this._removeInactiveAction(g))}}class jS{constructor(r){this.value=r}clone(){return new jS(this.value.clone===void 0?this.value:this.value.clone())}}let MO=0;class e8 extends null{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:MO++}),this.name="",this.usage=xm,this.uniforms=[]}add(r){return this.uniforms.push(r),this}remove(r){const d=this.uniforms.indexOf(r);return d!==-1&&this.uniforms.splice(d,1),this}setName(r){return this.name=r,this}setUsage(r){return this.usage=r,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(r){this.name=r.name,this.usage=r.usage;const d=r.uniforms;this.uniforms.length=0;for(let g=0,y=d.length;g<y;g++){const _=Array.isArray(d[g])?d[g]:[d[g]];for(let R=0;R<_.length;R++)this.uniforms.push(_[R].clone())}return this}clone(){return new this.constructor().copy(this)}}class x8 extends null{constructor(r,d,g=1){super(r,d),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=g}copy(r){return super.copy(r),this.meshPerAttribute=r.meshPerAttribute,this}clone(r){const d=super.clone(r);return d.meshPerAttribute=this.meshPerAttribute,d}toJSON(r){const d=super.toJSON(r);return d.isInstancedInterleavedBuffer=!0,d.meshPerAttribute=this.meshPerAttribute,d}}class r8{constructor(r,d,g,y,_){this.isGLBufferAttribute=!0,this.name="",this.buffer=r,this.type=d,this.itemSize=g,this.elementSize=y,this.count=_,this.version=0}set needsUpdate(r){r===!0&&this.version++}setBuffer(r){return this.buffer=r,this}setType(r,d){return this.type=r,this.elementSize=d,this}setItemSize(r){return this.itemSize=r,this}setCount(r){return this.count=r,this}}class u8{constructor(r,d,g=0,y=1/0){this.ray=new up(r,d),this.near=g,this.far=y,this.camera=null,this.layers=new Jy,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(r,d){this.ray.set(r,d)}setFromCamera(r,d){d.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(d.matrixWorld),this.ray.direction.set(r.x,r.y,.5).unproject(d).sub(this.ray.origin).normalize(),this.camera=d):d.isOrthographicCamera?(this.ray.origin.set(r.x,r.y,(d.near+d.far)/(d.near-d.far)).unproject(d),this.ray.direction.set(0,0,-1).transformDirection(d.matrixWorld),this.camera=d):console.error("THREE.Raycaster: Unsupported camera type: "+d.type)}intersectObject(r,d=!0,g=[]){return eb(r,this,g,d),g.sort(KS),g}intersectObjects(r,d=!0,g=[]){for(let y=0,_=r.length;y<_;y++)eb(r[y],this,g,d);return g.sort(KS),g}}function KS(I,r){return I.distance-r.distance}function eb(I,r,d,g){if(I.layers.test(r.layers)&&I.raycast(r,d),g===!0){const y=I.children;for(let _=0,R=y.length;_<R;_++)eb(y[_],r,d,!0)}}class d8{constructor(r=1,d=0,g=0){return this.radius=r,this.phi=d,this.theta=g,this}set(r,d,g){return this.radius=r,this.phi=d,this.theta=g,this}copy(r){return this.radius=r.radius,this.phi=r.phi,this.theta=r.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(r){return this.setFromCartesianCoords(r.x,r.y,r.z)}setFromCartesianCoords(r,d,g){return this.radius=Math.sqrt(r*r+d*d+g*g),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(r,g),this.phi=Math.acos(As(d/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class g8{constructor(r=1,d=0,g=0){return this.radius=r,this.theta=d,this.y=g,this}set(r,d,g){return this.radius=r,this.theta=d,this.y=g,this}copy(r){return this.radius=r.radius,this.theta=r.theta,this.y=r.y,this}setFromVector3(r){return this.setFromCartesianCoords(r.x,r.y,r.z)}setFromCartesianCoords(r,d,g){return this.radius=Math.sqrt(r*r+g*g),this.theta=Math.atan2(r,g),this.y=d,this}clone(){return new this.constructor().copy(this)}}const $S=new vn;class v8{constructor(r=new vn(1/0,1/0),d=new vn(-1/0,-1/0)){this.isBox2=!0,this.min=r,this.max=d}set(r,d){return this.min.copy(r),this.max.copy(d),this}setFromPoints(r){this.makeEmpty();for(let d=0,g=r.length;d<g;d++)this.expandByPoint(r[d]);return this}setFromCenterAndSize(r,d){const g=$S.copy(d).multiplyScalar(.5);return this.min.copy(r).sub(g),this.max.copy(r).add(g),this}clone(){return new this.constructor().copy(this)}copy(r){return this.min.copy(r.min),this.max.copy(r.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(r){return this.isEmpty()?r.set(0,0):r.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(r){return this.isEmpty()?r.set(0,0):r.subVectors(this.max,this.min)}expandByPoint(r){return this.min.min(r),this.max.max(r),this}expandByVector(r){return this.min.sub(r),this.max.add(r),this}expandByScalar(r){return this.min.addScalar(-r),this.max.addScalar(r),this}containsPoint(r){return!(r.x<this.min.x||r.x>this.max.x||r.y<this.min.y||r.y>this.max.y)}containsBox(r){return this.min.x<=r.min.x&&r.max.x<=this.max.x&&this.min.y<=r.min.y&&r.max.y<=this.max.y}getParameter(r,d){return d.set((r.x-this.min.x)/(this.max.x-this.min.x),(r.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(r){return!(r.max.x<this.min.x||r.min.x>this.max.x||r.max.y<this.min.y||r.min.y>this.max.y)}clampPoint(r,d){return d.copy(r).clamp(this.min,this.max)}distanceToPoint(r){return this.clampPoint(r,$S).distanceTo(r)}intersect(r){return this.min.max(r.min),this.max.min(r.max),this.isEmpty()&&this.makeEmpty(),this}union(r){return this.min.min(r.min),this.max.max(r.max),this}translate(r){return this.min.add(r),this.max.add(r),this}equals(r){return r.min.equals(this.min)&&r.max.equals(this.max)}}const JS=new ut,dy=new ut;class b8{constructor(r=new ut,d=new ut){this.start=r,this.end=d}set(r,d){return this.start.copy(r),this.end.copy(d),this}copy(r){return this.start.copy(r.start),this.end.copy(r.end),this}getCenter(r){return r.addVectors(this.start,this.end).multiplyScalar(.5)}delta(r){return r.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(r,d){return this.delta(d).multiplyScalar(r).add(this.start)}closestPointToPointParameter(r,d){JS.subVectors(r,this.start),dy.subVectors(this.end,this.start);const g=dy.dot(dy);let _=dy.dot(JS)/g;return d&&(_=As(_,0,1)),_}closestPointToPoint(r,d,g){const y=this.closestPointToPointParameter(r,d);return this.delta(g).multiplyScalar(y).add(this.start)}applyMatrix4(r){return this.start.applyMatrix4(r),this.end.applyMatrix4(r),this}equals(r){return r.start.equals(this.start)&&r.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const WS=new ut;class _8 extends null{constructor(r,d){super(),this.light=r,this.matrix=r.matrixWorld,this.matrixAutoUpdate=!1,this.color=d,this.type="SpotLightHelper";const g=new Ur,y=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let R=0,k=1,X=32;R<X;R++,k++){const K=R/X*Math.PI*2,Q=k/X*Math.PI*2;y.push(Math.cos(K),Math.sin(K),1,Math.cos(Q),Math.sin(Q),1)}g.setAttribute("position",new Ux(y,3));const _=new $o({fog:!1,toneMapped:!1});this.cone=new J1(g,_),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const r=this.light.distance?this.light.distance:1e3,d=r*Math.tan(this.light.angle);this.cone.scale.set(d,d,r),WS.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(WS),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Pu=new ut,gy=new ur,xb=new ur;class T8 extends null{constructor(r){const d=QS(r),g=new Ur,y=[],_=[],R=new bx(0,0,1),k=new bx(0,1,0);for(let K=0;K<d.length;K++){const Q=d[K];Q.parent&&Q.parent.isBone&&(y.push(0,0,0),y.push(0,0,0),_.push(R.r,R.g,R.b),_.push(k.r,k.g,k.b))}g.setAttribute("position",new Ux(y,3)),g.setAttribute("color",new Ux(_,3));const X=new $o({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(g,X),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=r,this.bones=d,this.matrix=r.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(r){const d=this.bones,g=this.geometry,y=g.getAttribute("position");xb.copy(this.root.matrixWorld).invert();for(let _=0,R=0;_<d.length;_++){const k=d[_];k.parent&&k.parent.isBone&&(gy.multiplyMatrices(xb,k.matrixWorld),Pu.setFromMatrixPosition(gy),y.setXYZ(R,Pu.x,Pu.y,Pu.z),gy.multiplyMatrices(xb,k.parent.matrixWorld),Pu.setFromMatrixPosition(gy),y.setXYZ(R+1,Pu.x,Pu.y,Pu.z),R+=2)}g.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(r)}dispose(){this.geometry.dispose(),this.material.dispose()}}function QS(I){const r=[];I.isBone===!0&&r.push(I);for(let d=0;d<I.children.length;d++)r.push.apply(r,QS(I.children[d]));return r}class A8 extends null{constructor(r,d,g){const y=new ey(d,4,2),_=new X2({wireframe:!0,fog:!1,toneMapped:!1});super(y,_),this.light=r,this.color=g,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const CO=new ut,eT=new bx,xT=new bx;class M8 extends null{constructor(r,d,g){super(),this.light=r,this.matrix=r.matrixWorld,this.matrixAutoUpdate=!1,this.color=g,this.type="HemisphereLightHelper";const y=new Qg(d);y.rotateY(Math.PI*.5),this.material=new X2({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const _=y.getAttribute("position"),R=new Float32Array(_.count*3);y.setAttribute("color",new rs(R,3)),this.add(new Bs(y,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const r=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const d=r.geometry.getAttribute("color");eT.copy(this.light.color),xT.copy(this.light.groundColor);for(let g=0,y=d.count;g<y;g++){const _=g<y/2?eT:xT;d.setXYZ(g,_.r,_.g,_.b)}d.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),r.lookAt(CO.setFromMatrixPosition(this.light.matrixWorld).negate())}}class C8 extends null{constructor(r=10,d=10,g=4473924,y=8947848){g=new bx(g),y=new bx(y);const _=d/2,R=r/d,k=r/2,X=[],K=[];for(let ue=0,ge=0,_e=-k;ue<=d;ue++,_e+=R){X.push(-k,0,_e,k,0,_e),X.push(_e,0,-k,_e,0,k);const Re=ue===_?g:y;Re.toArray(K,ge),ge+=3,Re.toArray(K,ge),ge+=3,Re.toArray(K,ge),ge+=3,Re.toArray(K,ge),ge+=3}const Q=new Ur;Q.setAttribute("position",new Ux(X,3)),Q.setAttribute("color",new Ux(K,3));const xe=new $o({vertexColors:!0,toneMapped:!1});super(Q,xe),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class R8 extends null{constructor(r=10,d=16,g=8,y=64,_=4473924,R=8947848){_=new bx(_),R=new bx(R);const k=[],X=[];if(d>1)for(let xe=0;xe<d;xe++){const ue=xe/d*(Math.PI*2),ge=Math.sin(ue)*r,_e=Math.cos(ue)*r;k.push(0,0,0),k.push(ge,0,_e);const Re=xe&1?_:R;X.push(Re.r,Re.g,Re.b),X.push(Re.r,Re.g,Re.b)}for(let xe=0;xe<g;xe++){const ue=xe&1?_:R,ge=r-r/g*xe;for(let _e=0;_e<y;_e++){let Re=_e/y*(Math.PI*2),be=Math.sin(Re)*ge,ve=Math.cos(Re)*ge;k.push(be,0,ve),X.push(ue.r,ue.g,ue.b),Re=(_e+1)/y*(Math.PI*2),be=Math.sin(Re)*ge,ve=Math.cos(Re)*ge,k.push(be,0,ve),X.push(ue.r,ue.g,ue.b)}}const K=new Ur;K.setAttribute("position",new Ux(k,3)),K.setAttribute("color",new Ux(X,3));const Q=new $o({vertexColors:!0,toneMapped:!1});super(K,Q),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const rT=new ut,vy=new ut,uT=new ut;class N8 extends null{constructor(r,d,g){super(),this.light=r,this.matrix=r.matrixWorld,this.matrixAutoUpdate=!1,this.color=g,this.type="DirectionalLightHelper",d===void 0&&(d=1);let y=new Ur;y.setAttribute("position",new Ux([-d,d,0,d,d,0,d,-d,0,-d,-d,0,-d,d,0],3));const _=new $o({fog:!1,toneMapped:!1});this.lightPlane=new Uh(y,_),this.add(this.lightPlane),y=new Ur,y.setAttribute("position",new Ux([0,0,0,0,0,1],3)),this.targetLine=new Uh(y,_),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),rT.setFromMatrixPosition(this.light.matrixWorld),vy.setFromMatrixPosition(this.light.target.matrixWorld),uT.subVectors(vy,rT),this.lightPlane.lookAt(vy),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(vy),this.targetLine.scale.z=uT.length()}}const by=new ut,Ms=new g1;class P8 extends null{constructor(r){const d=new Ur,g=new $o({color:16777215,vertexColors:!0,toneMapped:!1}),y=[],_=[],R={};k("n1","n2"),k("n2","n4"),k("n4","n3"),k("n3","n1"),k("f1","f2"),k("f2","f4"),k("f4","f3"),k("f3","f1"),k("n1","f1"),k("n2","f2"),k("n3","f3"),k("n4","f4"),k("p","n1"),k("p","n2"),k("p","n3"),k("p","n4"),k("u1","u2"),k("u2","u3"),k("u3","u1"),k("c","t"),k("p","c"),k("cn1","cn2"),k("cn3","cn4"),k("cf1","cf2"),k("cf3","cf4");function k(_e,Re){X(_e),X(Re)}function X(_e){y.push(0,0,0),_.push(0,0,0),R[_e]===void 0&&(R[_e]=[]),R[_e].push(y.length/3-1)}d.setAttribute("position",new Ux(y,3)),d.setAttribute("color",new Ux(_,3)),super(d,g),this.type="CameraHelper",this.camera=r,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=r.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=R,this.update();const K=new bx(16755200),Q=new bx(16711680),xe=new bx(43775),ue=new bx(16777215),ge=new bx(3355443);this.setColors(K,Q,xe,ue,ge)}setColors(r,d,g,y,_){const k=this.geometry.getAttribute("color");k.setXYZ(0,r.r,r.g,r.b),k.setXYZ(1,r.r,r.g,r.b),k.setXYZ(2,r.r,r.g,r.b),k.setXYZ(3,r.r,r.g,r.b),k.setXYZ(4,r.r,r.g,r.b),k.setXYZ(5,r.r,r.g,r.b),k.setXYZ(6,r.r,r.g,r.b),k.setXYZ(7,r.r,r.g,r.b),k.setXYZ(8,r.r,r.g,r.b),k.setXYZ(9,r.r,r.g,r.b),k.setXYZ(10,r.r,r.g,r.b),k.setXYZ(11,r.r,r.g,r.b),k.setXYZ(12,r.r,r.g,r.b),k.setXYZ(13,r.r,r.g,r.b),k.setXYZ(14,r.r,r.g,r.b),k.setXYZ(15,r.r,r.g,r.b),k.setXYZ(16,r.r,r.g,r.b),k.setXYZ(17,r.r,r.g,r.b),k.setXYZ(18,r.r,r.g,r.b),k.setXYZ(19,r.r,r.g,r.b),k.setXYZ(20,r.r,r.g,r.b),k.setXYZ(21,r.r,r.g,r.b),k.setXYZ(22,r.r,r.g,r.b),k.setXYZ(23,r.r,r.g,r.b),k.setXYZ(24,d.r,d.g,d.b),k.setXYZ(25,d.r,d.g,d.b),k.setXYZ(26,d.r,d.g,d.b),k.setXYZ(27,d.r,d.g,d.b),k.setXYZ(28,d.r,d.g,d.b),k.setXYZ(29,d.r,d.g,d.b),k.setXYZ(30,d.r,d.g,d.b),k.setXYZ(31,d.r,d.g,d.b),k.setXYZ(32,g.r,g.g,g.b),k.setXYZ(33,g.r,g.g,g.b),k.setXYZ(34,g.r,g.g,g.b),k.setXYZ(35,g.r,g.g,g.b),k.setXYZ(36,g.r,g.g,g.b),k.setXYZ(37,g.r,g.g,g.b),k.setXYZ(38,y.r,y.g,y.b),k.setXYZ(39,y.r,y.g,y.b),k.setXYZ(40,_.r,_.g,_.b),k.setXYZ(41,_.r,_.g,_.b),k.setXYZ(42,_.r,_.g,_.b),k.setXYZ(43,_.r,_.g,_.b),k.setXYZ(44,_.r,_.g,_.b),k.setXYZ(45,_.r,_.g,_.b),k.setXYZ(46,_.r,_.g,_.b),k.setXYZ(47,_.r,_.g,_.b),k.setXYZ(48,_.r,_.g,_.b),k.setXYZ(49,_.r,_.g,_.b),k.needsUpdate=!0}update(){const r=this.geometry,d=this.pointMap,g=1,y=1;Ms.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),zs("c",d,r,Ms,0,0,-1),zs("t",d,r,Ms,0,0,1),zs("n1",d,r,Ms,-g,-y,-1),zs("n2",d,r,Ms,g,-y,-1),zs("n3",d,r,Ms,-g,y,-1),zs("n4",d,r,Ms,g,y,-1),zs("f1",d,r,Ms,-g,-y,1),zs("f2",d,r,Ms,g,-y,1),zs("f3",d,r,Ms,-g,y,1),zs("f4",d,r,Ms,g,y,1),zs("u1",d,r,Ms,g*.7,y*1.1,-1),zs("u2",d,r,Ms,-g*.7,y*1.1,-1),zs("u3",d,r,Ms,0,y*2,-1),zs("cf1",d,r,Ms,-g,0,1),zs("cf2",d,r,Ms,g,0,1),zs("cf3",d,r,Ms,0,-y,1),zs("cf4",d,r,Ms,0,y,1),zs("cn1",d,r,Ms,-g,0,-1),zs("cn2",d,r,Ms,g,0,-1),zs("cn3",d,r,Ms,0,-y,-1),zs("cn4",d,r,Ms,0,y,-1),r.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function zs(I,r,d,g,y,_,R){by.set(y,_,R).unproject(g);const k=r[I];if(k!==void 0){const X=d.getAttribute("position");for(let K=0,Q=k.length;K<Q;K++)X.setXYZ(k[K],by.x,by.y,by.z)}}const _y=new Co;class B8 extends null{constructor(r,d=16776960){const g=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),y=new Float32Array(8*3),_=new Ur;_.setIndex(new rs(g,1)),_.setAttribute("position",new rs(y,3)),super(_,new $o({color:d,toneMapped:!1})),this.object=r,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(r){if(r!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_y.setFromObject(this.object),_y.isEmpty())return;const d=_y.min,g=_y.max,y=this.geometry.attributes.position,_=y.array;_[0]=g.x,_[1]=g.y,_[2]=g.z,_[3]=d.x,_[4]=g.y,_[5]=g.z,_[6]=d.x,_[7]=d.y,_[8]=g.z,_[9]=g.x,_[10]=d.y,_[11]=g.z,_[12]=g.x,_[13]=g.y,_[14]=d.z,_[15]=d.x,_[16]=g.y,_[17]=d.z,_[18]=d.x,_[19]=d.y,_[20]=d.z,_[21]=g.x,_[22]=d.y,_[23]=d.z,y.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(r){return this.object=r,this.update(),this}copy(r,d){return super.copy(r,d),this.object=r.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class z8 extends null{constructor(r,d=16776960){const g=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),y=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],_=new Ur;_.setIndex(new rs(g,1)),_.setAttribute("position",new Ux(y,3)),super(_,new $o({color:d,toneMapped:!1})),this.box=r,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(r){const d=this.box;d.isEmpty()||(d.getCenter(this.position),d.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(r))}dispose(){this.geometry.dispose(),this.material.dispose()}}class V8 extends null{constructor(r,d=1,g=16776960){const y=g,_=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],R=new Ur;R.setAttribute("position",new Ux(_,3)),R.computeBoundingSphere(),super(R,new $o({color:y,toneMapped:!1})),this.type="PlaneHelper",this.plane=r,this.size=d;const k=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],X=new Ur;X.setAttribute("position",new Ux(k,3)),X.computeBoundingSphere(),this.add(new Bs(X,new X2({color:y,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(r){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(r)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const dT=new ut;let Ty,rb;class G8 extends null{constructor(r=new ut(0,0,1),d=new ut(0,0,0),g=1,y=16776960,_=g*.2,R=_*.2){super(),this.type="ArrowHelper",Ty===void 0&&(Ty=new Ur,Ty.setAttribute("position",new Ux([0,0,0,0,1,0],3)),rb=new zp(0,.5,1,5,1),rb.translate(0,-.5,0)),this.position.copy(d),this.line=new Uh(Ty,new $o({color:y,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Bs(rb,new X2({color:y,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(r),this.setLength(g,_,R)}setDirection(r){if(r.y>.99999)this.quaternion.set(0,0,0,1);else if(r.y<-.99999)this.quaternion.set(1,0,0,0);else{dT.set(r.z,0,-r.x).normalize();const d=Math.acos(r.y);this.quaternion.setFromAxisAngle(dT,d)}}setLength(r,d=r*.2,g=d*.2){this.line.scale.set(1,Math.max(1e-4,r-d),1),this.line.updateMatrix(),this.cone.scale.set(g,d,g),this.cone.position.y=r,this.cone.updateMatrix()}setColor(r){this.line.material.color.set(r),this.cone.material.color.set(r)}copy(r){return super.copy(r,!1),this.line.copy(r.line),this.cone.copy(r.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class X8 extends null{constructor(r=1){const d=[0,0,0,r,0,0,0,0,0,0,r,0,0,0,0,0,0,r],g=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],y=new Ur;y.setAttribute("position",new Ux(d,3)),y.setAttribute("color",new Ux(g,3));const _=new $o({vertexColors:!0,toneMapped:!1});super(y,_),this.type="AxesHelper"}setColors(r,d,g){const y=new bx,_=this.geometry.attributes.color.array;return y.set(r),y.toArray(_,0),y.toArray(_,3),y.set(d),y.toArray(_,6),y.toArray(_,9),y.set(g),y.toArray(_,12),y.toArray(_,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class RO{constructor(){this.type="ShapePath",this.color=new bx,this.subPaths=[],this.currentPath=null}moveTo(r,d){return this.currentPath=new Vg,this.subPaths.push(this.currentPath),this.currentPath.moveTo(r,d),this}lineTo(r,d){return this.currentPath.lineTo(r,d),this}quadraticCurveTo(r,d,g,y){return this.currentPath.quadraticCurveTo(r,d,g,y),this}bezierCurveTo(r,d,g,y,_,R){return this.currentPath.bezierCurveTo(r,d,g,y,_,R),this}splineThru(r){return this.currentPath.splineThru(r),this}toShapes(r){function d(ve){const Xe=[];for(let Be=0,Ke=ve.length;Be<Ke;Be++){const bt=ve[Be],rt=new Bf;rt.curves=bt.curves,Xe.push(rt)}return Xe}function g(ve,Xe){const Be=Xe.length;let Ke=!1;for(let bt=Be-1,rt=0;rt<Be;bt=rt++){let xt=Xe[bt],Mt=Xe[rt],$t=Mt.x-xt.x,$e=Mt.y-xt.y;if(Math.abs($e)>Number.EPSILON){if($e<0&&(xt=Xe[rt],$t=-$t,Mt=Xe[bt],$e=-$e),ve.y<xt.y||ve.y>Mt.y)continue;if(ve.y===xt.y){if(ve.x===xt.x)return!0}else{const vt=$e*(ve.x-xt.x)-$t*(ve.y-xt.y);if(vt===0)return!0;if(vt<0)continue;Ke=!Ke}}else{if(ve.y!==xt.y)continue;if(Mt.x<=ve.x&&ve.x<=xt.x||xt.x<=ve.x&&ve.x<=Mt.x)return!0}}return Ke}const y=Kl.isClockWise,_=this.subPaths;if(_.length===0)return[];let R,k,X;const K=[];if(_.length===1)return k=_[0],X=new Bf,X.curves=k.curves,K.push(X),K;let Q=!y(_[0].getPoints());Q=r?!Q:Q;const xe=[],ue=[];let ge=[],_e=0,Re;ue[_e]=void 0,ge[_e]=[];for(let ve=0,Xe=_.length;ve<Xe;ve++)k=_[ve],Re=k.getPoints(),R=y(Re),R=r?!R:R,R?(!Q&&ue[_e]&&_e++,ue[_e]={s:new Bf,p:Re},ue[_e].s.curves=k.curves,Q&&_e++,ge[_e]=[]):ge[_e].push({h:k,p:Re[0]});if(!ue[0])return d(_);if(ue.length>1){let ve=!1,Xe=0;for(let Be=0,Ke=ue.length;Be<Ke;Be++)xe[Be]=[];for(let Be=0,Ke=ue.length;Be<Ke;Be++){const bt=ge[Be];for(let rt=0;rt<bt.length;rt++){const xt=bt[rt];let Mt=!0;for(let $t=0;$t<ue.length;$t++)g(xt.p,ue[$t].p)&&(Be!==$t&&Xe++,Mt?(Mt=!1,xe[$t].push(xt)):ve=!0);Mt&&xe[Be].push(xt)}}Xe>0&&ve===!1&&(ge=xe)}let be;for(let ve=0,Xe=ue.length;ve<Xe;ve++){X=ue[ve].s,K.push(X),be=ge[ve];for(let Be=0,Ke=be.length;Be<Ke;Be++)X.holes.push(be[Be].h)}return K}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Rs}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Rs);class NO extends A0{constructor(r,d,g){super({container:r,mode:d,layerCount:2,mirror:g});const y=this.canvas.layers[1];this.renderer=new q_({canvas:y,alpha:!0,preserveDrawingBuffer:!0}),this.renderer.setClearColor(0,0),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(y.clientWidth,y.clientHeight),this.renderer.outputColorSpace=jn,this.canvas.on("resize",()=>{this.renderer.setSize(y.clientWidth,y.clientHeight)}),this.scene=new Y_,this.scene.background=null,this.camera=new ua(this.cameraAngle,1,.02,20)}updateScene(){this.scene&&this.renderer.render(this.scene,this.camera)}setupCamera(r,d){super.setupCamera(r,d),this.camera instanceof ua&&(this.camera.aspect=this.cameraRatio,this.camera.fov=this.cameraAngle/Math.PI*180,this.camera.updateProjectionMatrix())}setupVideo(r,d){super.setupVideo(r,d),this.camera instanceof _p&&(this.camera.right=this.videoSize.width,this.camera.bottom=this.videoSize.height,this.camera.updateProjectionMatrix())}disposeObject(r){const d=(g,y)=>Array.isArray(g)&&g.every(_=>_ instanceof y);r.removeFromParent(),r.traverse(g=>{g instanceof Bs&&(g.geometry instanceof Ur&&g.geometry.dispose(),g.material instanceof T2&&g.material.dispose(),d(g.material,T2)&&g.material.forEach(y=>{y.dispose();for(const _ in y){const R=y[_];R instanceof Ks&&R.dispose()}}))})}}class PO extends xi{}class BO extends NO{}class zO extends PO{}class j8 extends null{}class K8 extends null{}class $8 extends null{constructor(r,d=!1){super(),this.node=r,this.shapeScale=d}async update(r,d){if(!this.loaded)return;const g=r.faces&&r.faces.length>0?r.faces[0].transform:void 0;if(!g)return this.node.visible=!1,super.update(r,d);const y=new A.Vector3(...g.translation),_=new A.Vector3().setScalar(g.scale),R=new A.Vector3(...g.shapeScale).multiplyScalar(g.scale),k=new A.Quaternion(...g.rotation);return this.node.visible=!0,this.node.setRotationFromQuaternion(k),this.node.position.copy(y),this.node.scale.copy(this.shapeScale?R:_),super.update(r,d)}}class J8 extends null{constructor(r,d=0,g=!1){super(),this.node=r,this.facePoint=d,this.shapeScale=g}async update(r,d){if(!this.loaded)return;if(!this.node)return super.update(r,d);const{transform:g=void 0,metric:y=void 0}=r.faces&&r.faces.length>0?r.faces[0]:{};if(!g||!y)return this.node.visible=!1,super.update(r,d);const _=new A.Vector3(...y[this.facePoint]),R=new A.Vector3().setScalar(g.scale),k=new A.Vector3(...g.shapeScale).multiplyScalar(g.scale),X=new A.Quaternion(...g.rotation);return this.node.visible=!0,this.node.setRotationFromQuaternion(X),this.node.position.copy(_),this.node.scale.copy(this.shapeScale?k:R),super.update(r,d)}}class W8 extends null{constructor(r){super(),this.mesh=r,this.pointCont=F.length}async load(r){this.loaded||(await super.load(r),await this.setMesh(this.mesh))}async update(r,d){if(!this.loaded)return;if(!this.mesh)return super.update(r,d);const g=r.faces&&r.faces.length>0?r.faces[0].metric:void 0;if(!g)return this.mesh.visible=!1,super.update(r,d);this.mesh.visible=!0;let y=this.mesh.geometry.getAttribute("position");return g.slice(0,this.pointCont).forEach((_,R)=>y.setXYZ(R,_[0],_[1],_[2])),this.mesh.geometry.computeVertexNormals(),y.needsUpdate=!0,super.update(r,d)}async setMesh(r){if(delete this.mesh,this.mesh=r,!this.loaded||!r)return;const d=new A.BufferGeometry;d.setIndex(B),d.setAttribute("position",new A.Float32BufferAttribute(F.flat(),3)),d.setAttribute("uv",new A.Float32BufferAttribute(L.flat(),2)),d.computeVertexNormals(),r.geometry=d}}const Q8=null;class VO extends zO{constructor(r,d={spineCurve:.5,neckAdjust:.01,headRatio:.32,shouldersD:[0,-.01,.005]}){super(),this.node=r,this.tune=d,this.avatarLength=1,this.alignScore=.9,this.alignVisibility=.9}async load(r){this.loaded||(await super.load(r),await this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(r){var d;if(delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,this.node=r,!this.loaded||!r)return;r.traverse(xt=>{!this.skeleton&&xt instanceof X1&&(this.skeleton=xt.skeleton)});const g=(d=this.skeleton)==null?void 0:d.bones;if(!g)return;const y=xt=>g.find(Mt=>Mt.name.toLowerCase().endsWith(xt)),_={hips:y("hips"),spine:y("spine"),spine1:y("spine1"),spine2:y("spine2"),neck:y("neck"),head:y("head"),headEnd:y("headtop_end"),shoulderL:y("leftshoulder"),shoulderR:y("rightshoulder"),armL:y("leftarm"),armR:y("rightarm"),forearmL:y("leftforearm"),forearmR:y("rightforearm"),handL:y("lefthand"),handR:y("righthand"),uplegL:y("leftupleg"),uplegR:y("rightupleg"),legL:y("leftleg"),legR:y("rightleg"),footL:y("leftfoot"),footR:y("rightfoot"),toeL:y("lefttoebase"),toeR:y("righttoebase")};this.skeletonNodes=_;const R=_.hips.getWorldPosition(new ut),k=_.armL.getWorldPosition(new ut),X=_.armR.getWorldPosition(new ut),K=k.clone().lerp(X,.5).sub(R).length(),Q=k.clone().sub(R),xe=X.clone().sub(R).clone().cross(Q).normalize(),ue=_.spine.getWorldPosition(new ut).sub(R),ge=ue.dot(xe),_e=ue.clone().sub(xe.clone().multiplyScalar(ge)).length(),Re=_.spine1.getWorldPosition(new ut).sub(R),be=Re.dot(xe),ve=Re.clone().sub(xe.clone().multiplyScalar(be)).length(),Xe=_.spine2.getWorldPosition(new ut).sub(R),Be=Xe.dot(xe),Ke=Xe.clone().sub(xe.clone().multiplyScalar(Be)).length(),bt=_.head.getWorldPosition(new ut),rt=_.headEnd.getWorldPosition(new ut).clone().sub(bt).length();this.avatarLength=K,this.spineCurve={hips:[R.x,R.y],spine:[_e/K,ge/K],spine1:[ve/K,be/K],spine2:[Ke/K,Be/K],head:[rt/K,0]},r.traverse(xt=>{xt.frustumCulled=!1})}async update(r,d){var g;const y=r.poses&&r.poses.length>0?r.poses[0].points:void 0,{node:_,skeletonNodes:R,spineCurve:k}=this;if(!_)return super.update(r,d);if(!R||!k||!y)return _.visible=!1,super.update(r,d);const X=this.estimateBones(y,k);return _.visible=!0,(g=this.skeleton)==null||g.pose(),this.updateSpine(X),this.updateHandL(X,y),this.updateHandR(X,y),this.updateLegL(X,y),this.updateLegR(X,y),super.update(r,d)}updateSpine(r){var d;const{skeletonNodes:g}=this;if(!g)return;this.alignBone(r.hips,g.hips,!1),this.alignBone(r.spine,g.spine),this.alignBone(r.spine1,g.spine1),this.alignBone(r.spine2,g.spine2),this.alignBone(r.neck,g.neck,!1),this.alignBone(r.head,g.head,!1);const y=(d=this.skeleton)==null?void 0:d.bones.find(_=>_.name.endsWith("HeadEnd"));if(y){const{head:_,headEnd:R}=r,k=R.position.clone().sub(_.position).length();g.head.scale.setScalar(1.05*k/y.position.length())}this.alignBone(r.shoulderL,g.shoulderL,!1),this.alignBone(r.shoulderR,g.shoulderR,!1)}updateHandL(r,d){const{skeletonNodes:g}=this;if(!g)return;const{alignScore:y,alignVisibility:_}=this;this.alignBone(r.armL,g.armL),!(d.elbowL.score<y&&d.elbowL.visibility<_)&&(this.alignBone(r.forearmL,g.forearmL),this.alignBone(r.handL,g.handL),g.handL.scale.setScalar(.95))}updateHandR(r,d){const{skeletonNodes:g}=this;if(!g)return;const{alignScore:y,alignVisibility:_}=this;this.alignBone(r.armR,g.armR),!(d.elbowR.score<y&&d.elbowR.visibility<_)&&(this.alignBone(r.forearmR,g.forearmR),this.alignBone(r.handR,g.handR),g.handR.scale.setScalar(.95))}updateLegL(r,d){const{skeletonNodes:g}=this;if(!g)return;const{alignScore:y,alignVisibility:_}=this;d.hipL.score<y&&d.hipL.visibility<_||(this.alignBone(r.uplegL,g.uplegL,!1),!(d.kneeL.score<y&&d.kneeL.visibility<_)&&(this.alignBone(r.legL,g.legL),!(d.ankleL.score<y&&d.ankleL.visibility<_)&&(this.alignBone(r.footL,g.footL),this.alignBone(r.toeL,g.toeL))))}updateLegR(r,d){const{skeletonNodes:g}=this;if(!g)return;const{alignScore:y,alignVisibility:_}=this;d.hipR.score<y&&d.hipR.visibility<_||(this.alignBone(r.uplegR,g.uplegR,!1),!(d.kneeR.score<y&&d.kneeR.visibility<_)&&(this.alignBone(r.legR,g.legR),!(d.ankleR.score<y&&d.ankleR.visibility<_)&&(this.alignBone(r.footR,g.footR),this.alignBone(r.toeR,g.toeR))))}estimateBones(r,d){var g;const y=new ut(...r.hipL.metric),_=new ut(...r.hipR.metric),R=y.clone().lerp(_,.5),k=y.clone().sub(_).normalize(),X=k.clone().negate(),K=new ut(...r.shoulderL.metric),Q=new ut(...r.shoulderR.metric),xe=new ut(...r.elbowL.metric),ue=new ut(...r.elbowR.metric),ge=K.clone().lerp(Q,.5),_e=K.clone().sub(Q).normalize(),Re=K.clone().sub(R),be=Q.clone().sub(R).clone().cross(Re).normalize();if(this.tune.shouldersD){const Uu=_e.clone().multiplyScalar(this.tune.shouldersD[0]),zc=ge.clone().sub(R).normalize().multiplyScalar(this.tune.shouldersD[1]).add(be.clone().multiplyScalar((g=this.tune)==null?void 0:g.shouldersD[2]));K.add(zc).add(Uu),Q.add(zc).add(Uu.clone().negate())}const ve=K.clone().lerp(Q,.5),Xe=ve.clone().sub(R).normalize(),Be=xe.clone().sub(K).normalize(),Ke=ue.clone().sub(Q).normalize();let bt;if(this.tune.neckAdjust){const Uu=Math.abs(_e.x);bt=Xe.clone().multiplyScalar(Uu*(Xe.dot(Be)*-this.tune.neckAdjust+Xe.dot(Ke)*-this.tune.neckAdjust)),ve.add(bt)}const rt=ve.clone().sub(R).length(),xt=this.tune.shoulderOffset||.2,Mt=ve.clone().lerp(K,xt),$t=ve.clone().lerp(Q,xt),$e=new ut(...r.earL.metric),vt=new ut(...r.earR.metric),M0=$e.clone().lerp(vt,.5),V0=new ut(...r.nose.metric),Pt=M0.clone().sub(V0).normalize(),x0=$e.clone().sub(vt).normalize(),Wt=x0.clone().cross(Pt).add(Pt.clone().multiplyScalar(.05)).normalize(),an=this.tune.headRatio||.32,W0=d.head[0]*rt,j0=M0.clone().add(Wt.clone().cross(x0).multiplyScalar(.025)),un=j0.clone().add(Wt.clone().multiplyScalar(-an*W0)),bn=j0.clone().add(Wt.clone().multiplyScalar((1-an)*W0)),ex=un.clone().lerp(bn,2),Cx=_e.clone().lerp(x0,.5),R0=bt?K.clone().add(bt):K.clone(),_n=bt?Q.clone().add(bt):Q.clone(),ux=y.clone().lerp(R0,d.spine[0]),Rx=_.clone().lerp(_n,d.spine[0]),Bx=ux.clone().lerp(Rx,.5),Px=ux.clone().sub(Rx),xr=y.clone().lerp(R0,d.spine1[0]),Xx=_.clone().lerp(_n,d.spine1[0]),zt=xr.clone().lerp(Xx,.5),Kn=xr.clone().sub(Xx),en=y.clone().lerp(R0,d.spine2[0]),Vn=_.clone().lerp(_n,d.spine2[0]),rn=en.clone().lerp(Vn,.5),jx=xr.clone().sub(Vn);if(this.tune.spineCurve){const Uu=K.clone().sub(R),zc=Q.clone().sub(R).clone().cross(Uu).normalize(),Wf=this.tune.spineCurve*rt;Bx.add(zc.clone().multiplyScalar(d.spine[1]*Wf)),zt.add(zc.clone().multiplyScalar(d.spine1[1]*Wf)),rn.add(zc.clone().multiplyScalar(d.spine2[1]*Wf))}const _x=new ut(...r.wristL.metric),Tt=_x.clone().sub(xe).normalize().clone().sub(Be).negate(),tt=be.clone(),g0=Tt.clone().lerp(tt,.5),Cn=new ut(...r.indexL.metric),Tn=new ut(...r.pinkyL.metric),An=Cn.clone().lerp(Tn,.5),zx=Tn.clone().sub(Cn),xx=new ut(...r.wristR.metric),Ax=xx.clone().sub(ue).normalize().clone().sub(Ke),sr=be.clone().negate(),Pr=Ax.clone().lerp(sr,.5),Mn=new ut(...r.indexR.metric),di=new ut(...r.pinkyR.metric),jr=Mn.clone().lerp(di,.5),Tr=Mn.clone().sub(di),Kx=new ut(...r.kneeL.metric),Nx=new ut(...r.ankleL.metric),Mr=new ut(...r.footIndexL.metric),_i=new ut(...r.heelL.metric),Ki=Nx.clone().sub(Kx).normalize(),Jr=Mr.clone().sub(_i).normalize(),Ti=Ki.clone().cross(Jr).normalize(),Bt=_i.clone().lerp(Mr,.8),Gn=X.clone().lerp(Ti,.2),Xn=X.clone().lerp(Ti,.6),Vx=new ut(...r.kneeR.metric),Qx=new ut(...r.ankleR.metric),bi=new ut(...r.footIndexR.metric),Ni=new ut(...r.heelR.metric),va=Qx.clone().sub(Vx).normalize(),Jo=bi.clone().sub(Ni).normalize(),Ai=va.clone().cross(Jo).normalize(),Na=Ni.clone().lerp(bi,.8),$2=X.clone().lerp(Ai,.2),Ay=X.clone().lerp(Ai,.6);return{hips:this.estimateBone(R,Bx,k),spine:this.estimateBone(Bx,zt,Px),spine1:this.estimateBone(zt,rn,Kn),spine2:this.estimateBone(rn,ve,jx),neck:this.estimateBone(ve,un,Cx),head:this.estimateBone(un,bn,x0),headEnd:this.estimateBone(bn,ex,x0),shoulderL:this.estimateBone(Mt,K,tt),armL:this.estimateBone(K,xe,g0),forearmL:this.estimateBone(xe,_x,Tt),handL:this.estimateBone(_x,An,zx),shoulderR:this.estimateBone($t,Q,sr),armR:this.estimateBone(Q,ue,Pr),forearmR:this.estimateBone(ue,xx,Ax),handR:this.estimateBone(xx,jr,Tr),uplegL:this.estimateBone(y,Kx,Gn),legL:this.estimateBone(Kx,Nx,Xn),footL:this.estimateBone(Nx,Bt,Ti),toeL:this.estimateBone(Bt,Mr,Ti),uplegR:this.estimateBone(_,Vx,$2),legR:this.estimateBone(Vx,Qx,Ay),footR:this.estimateBone(Qx,Na,Ai),toeR:this.estimateBone(Na,bi,Ai)}}estimateBone(r,d,g){const y=d.clone().sub(r).normalize(),_=g.clone().normalize().cross(y).normalize(),R=y.clone().cross(_);return{position:r.clone(),rotation:new Xa().setFromRotationMatrix(new ur().makeBasis(R,y,_))}}alignBone(r,d,g=!0){let y=r.rotation.clone(),_=r.position.clone();d.parent&&(y=d.parent.getWorldQuaternion(new Xa).invert().multiply(y),_.applyMatrix4(d.parent.matrixWorld.clone().invert()),g&&d.parent instanceof _g&&(d.parent.scale.setScalar(_.length()/d.position.length()),d.parent.updateWorldMatrix(!0,!0),_=r.position.clone().applyMatrix4(d.parent.matrixWorld.clone().invert()))),d.setRotationFromQuaternion(y),d.position.copy(_),d.updateWorldMatrix(!0,!0)}}class UO extends VO{constructor(r,d,g={spineCurve:.5,neckAdjust:.01,headRatio:.32,shouldersD:[0,-.01,.005]}){super(r,g),this.outfit=d}setNode(r){super.setNode(r);const{outfit:d,node:g}=this;!d||!g||g.traverse(y=>{if(!(y instanceof Bs))return;const _=R=>R?.some(k=>typeof k=="string"?y.name===k:k.test(y.name));if(_(d.occluders)){y.material.colorWrite=!1,y.renderOrder=-1;return}if(_(d.hidden)){y.visible=!1;return}})}setOutfit(r,d){this.outfit=d,this.setNode(r)}}class e7 extends null{constructor(r,d,g,y,_={spineCurve:.5,neckAdjust:.01,headRatio:.32,shouldersD:[0,-.01,.005]}){super(r,_),this.translation=d,this.rotation=g,this.scale=y}async update(r,d){await super.update(r,d);const g=r.poses&&r.poses.length>0?r.poses[0].points:void 0,{node:y,translation:_,rotation:R,scale:k}=this;if(!y||!g)return;const X=new A.Vector3(...g.hipL.metric),K=new A.Vector3(...g.hipR.metric),Q=X.clone().lerp(K,.5);y.position.copy(_?Q.add(_):Q),R&&y.setRotationFromQuaternion(R),k&&y.scale.setScalar(k)}updateSpine(r){const{skeletonNodes:d}=this;d&&(this.alignBone(r.hips,d.hips),this.alignBone(r.spine,d.spine),this.alignBone(r.spine1,d.spine1),this.alignBone(r.spine2,d.spine2),this.alignBone(r.neck,d.neck),this.alignBone(r.head,d.head),this.alignBone(r.shoulderL,d.shoulderL),this.alignBone(r.shoulderR,d.shoulderR))}alignBone(r,d){let g=r.rotation.clone();d.parent&&(g=d.parent.getWorldQuaternion(new A.Quaternion).invert().multiply(g)),d.setRotationFromQuaternion(g),d.updateWorldMatrix(!0,!0)}}class x7 extends null{constructor(r,d=-1){super(),this.node=r,this.renderOrder=d}async load(r){if(!this.loaded)return this.node.traverse(d=>{d instanceof A.Mesh&&(d.material.colorWrite=!1),d.renderOrder=this.renderOrder}),super.load(r)}}function r7(I,r,d=!0){if(!r||!r.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!I.hasAttribute("position")||!I.hasAttribute("normal")||!I.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function g(R){if(R.normalized||R.isInterleavedBufferAttribute){const k=new Float32Array(R.count*R.itemSize);for(let X=0,K=0;X<R.count;X++)k[K++]=R.getX(X),k[K++]=R.getY(X),R.itemSize>2&&(k[K++]=R.getZ(X));return k}return R.array instanceof Float32Array?R.array:new Float32Array(R.array)}const y=I.index?I.toNonIndexed():I,_=r.generateTangents(g(y.attributes.position),g(y.attributes.normal),g(y.attributes.uv));if(d)for(let R=3;R<_.length;R+=4)_[R]*=-1;return y.setAttribute("tangent",new BufferAttribute(_,4)),I!==y&&I.copy(y),I}function u7(I,r=!1){const d=I[0].index!==null,g=new Set(Object.keys(I[0].attributes)),y=new Set(Object.keys(I[0].morphAttributes)),_={},R={},k=I[0].morphTargetsRelative,X=new BufferGeometry;let K=0;for(let Q=0;Q<I.length;++Q){const xe=I[Q];let ue=0;if(d!==(xe.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+Q+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const ge in xe.attributes){if(!g.has(ge))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+Q+'. All geometries must have compatible attributes; make sure "'+ge+'" attribute exists among all geometries, or in none of them.'),null;_[ge]===void 0&&(_[ge]=[]),_[ge].push(xe.attributes[ge]),ue++}if(ue!==g.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+Q+". Make sure all geometries have the same number of attributes."),null;if(k!==xe.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+Q+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const ge in xe.morphAttributes){if(!y.has(ge))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+Q+".  .morphAttributes must be consistent throughout all geometries."),null;R[ge]===void 0&&(R[ge]=[]),R[ge].push(xe.morphAttributes[ge])}if(r){let ge;if(d)ge=xe.index.count;else if(xe.attributes.position!==void 0)ge=xe.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+Q+". The geometry must have either an index or a position attribute"),null;X.addGroup(K,ge,Q),K+=ge}}if(d){let Q=0;const xe=[];for(let ue=0;ue<I.length;++ue){const ge=I[ue].index;for(let _e=0;_e<ge.count;++_e)xe.push(ge.getX(_e)+Q);Q+=I[ue].attributes.position.count}X.setIndex(xe)}for(const Q in _){const xe=gT(_[Q]);if(!xe)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+Q+" attribute."),null;X.setAttribute(Q,xe)}for(const Q in R){const xe=R[Q][0].length;if(xe===0)break;X.morphAttributes=X.morphAttributes||{},X.morphAttributes[Q]=[];for(let ue=0;ue<xe;++ue){const ge=[];for(let Re=0;Re<R[Q].length;++Re)ge.push(R[Q][Re][ue]);const _e=gT(ge);if(!_e)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+Q+" morphAttribute."),null;X.morphAttributes[Q].push(_e)}}return X}function gT(I){let r,d,g,y=-1,_=0;for(let K=0;K<I.length;++K){const Q=I[K];if(r===void 0&&(r=Q.array.constructor),r!==Q.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(d===void 0&&(d=Q.itemSize),d!==Q.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(g===void 0&&(g=Q.normalized),g!==Q.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(y===-1&&(y=Q.gpuType),y!==Q.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;_+=Q.count*d}const R=new r(_),k=new BufferAttribute(R,d,g);let X=0;for(let K=0;K<I.length;++K){const Q=I[K];if(Q.isInterleavedBufferAttribute){const xe=X/d;for(let ue=0,ge=Q.count;ue<ge;ue++)for(let _e=0;_e<d;_e++){const Re=Q.getComponent(ue,_e);k.setComponent(ue+xe,_e,Re)}}else R.set(Q.array,X);X+=Q.count*d}return y!==void 0&&(k.gpuType=y),k}function d7(I){return I.isInstancedInterleavedBufferAttribute||I.isInterleavedBufferAttribute?ub(I):I.isInstancedBufferAttribute?new InstancedBufferAttribute().copy(I):new BufferAttribute().copy(I)}function g7(I){let r,d=0,g=0;for(let K=0,Q=I.length;K<Q;++K){const xe=I[K];if(r===void 0&&(r=xe.array.constructor),r!==xe.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;d+=xe.array.length,g+=xe.itemSize}const y=new InterleavedBuffer(new r(d),g);let _=0;const R=[],k=["getX","getY","getZ","getW"],X=["setX","setY","setZ","setW"];for(let K=0,Q=I.length;K<Q;K++){const xe=I[K],ue=xe.itemSize,ge=xe.count,_e=new InterleavedBufferAttribute(y,ue,_,xe.normalized);R.push(_e),_+=ue;for(let Re=0;Re<ge;Re++)for(let be=0;be<ue;be++)_e[X[be]](Re,xe[k[be]](Re))}return R}function ub(I){const r=I.data.array.constructor,d=I.count,g=I.itemSize,y=I.normalized,_=new r(d*g);let R;I.isInstancedInterleavedBufferAttribute?R=new InstancedBufferAttribute(_,g,y,I.meshPerAttribute):R=new BufferAttribute(_,g,y);for(let k=0;k<d;k++)R.setX(k,I.getX(k)),g>=2&&R.setY(k,I.getY(k)),g>=3&&R.setZ(k,I.getZ(k)),g>=4&&R.setW(k,I.getW(k));return R}function v7(I){const r=I.attributes,d=I.morphTargets,g=new Map;for(const y in r){const _=r[y];_.isInterleavedBufferAttribute&&(g.has(_)||g.set(_,ub(_)),r[y]=g.get(_))}for(const y in d){const _=d[y];_.isInterleavedBufferAttribute&&(g.has(_)||g.set(_,ub(_)),d[y]=g.get(_))}}function b7(I){let r=0;for(const g in I.attributes){const y=I.getAttribute(g);r+=y.count*y.itemSize*y.array.BYTES_PER_ELEMENT}const d=I.getIndex();return r+=d?d.count*d.itemSize*d.array.BYTES_PER_ELEMENT:0,r}function _7(I,r=1e-4){r=Math.max(r,Number.EPSILON);const d={},g=I.getIndex(),y=I.getAttribute("position"),_=g?g.count:y.count;let R=0;const k=Object.keys(I.attributes),X={},K={},Q=[],xe=["getX","getY","getZ","getW"],ue=["setX","setY","setZ","setW"];for(let Xe=0,Be=k.length;Xe<Be;Xe++){const Ke=k[Xe],bt=I.attributes[Ke];X[Ke]=new BufferAttribute(new bt.array.constructor(bt.count*bt.itemSize),bt.itemSize,bt.normalized);const rt=I.morphAttributes[Ke];rt&&(K[Ke]=new BufferAttribute(new rt.array.constructor(rt.count*rt.itemSize),rt.itemSize,rt.normalized))}const ge=r*.5,_e=Math.log10(1/r),Re=Math.pow(10,_e),be=ge*Re;for(let Xe=0;Xe<_;Xe++){const Be=g?g.getX(Xe):Xe;let Ke="";for(let bt=0,rt=k.length;bt<rt;bt++){const xt=k[bt],Mt=I.getAttribute(xt),$t=Mt.itemSize;for(let $e=0;$e<$t;$e++)Ke+=`${~~(Mt[xe[$e]](Be)*Re+be)},`}if(Ke in d)Q.push(d[Ke]);else{for(let bt=0,rt=k.length;bt<rt;bt++){const xt=k[bt],Mt=I.getAttribute(xt),$t=I.morphAttributes[xt],$e=Mt.itemSize,vt=X[xt],M0=K[xt];for(let V0=0;V0<$e;V0++){const Pt=xe[V0],x0=ue[V0];if(vt[x0](R,Mt[Pt](Be)),$t)for(let Wt=0,an=$t.length;Wt<an;Wt++)M0[Wt][x0](R,$t[Wt][Pt](Be))}}d[Ke]=R,Q.push(R),R++}}const ve=I.clone();for(const Xe in I.attributes){const Be=X[Xe];if(ve.setAttribute(Xe,new BufferAttribute(Be.array.slice(0,R*Be.itemSize),Be.itemSize,Be.normalized)),Xe in K)for(let Ke=0;Ke<K[Xe].length;Ke++){const bt=K[Xe][Ke];ve.morphAttributes[Xe][Ke]=new BufferAttribute(bt.array.slice(0,R*bt.itemSize),bt.itemSize,bt.normalized)}}return ve.setIndex(Q),ve}function vT(I,r){if(r===Ve)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),I;if(r===Kt||r===gt){let d=I.getIndex();if(d===null){const R=[],k=I.getAttribute("position");if(k!==void 0){for(let X=0;X<k.count;X++)R.push(X);I.setIndex(R),d=I.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),I}const g=d.count-2,y=[];if(r===Kt)for(let R=1;R<=g;R++)y.push(d.getX(0)),y.push(d.getX(R)),y.push(d.getX(R+1));else for(let R=0;R<g;R++)R%2===0?(y.push(d.getX(R)),y.push(d.getX(R+1)),y.push(d.getX(R+2))):(y.push(d.getX(R+2)),y.push(d.getX(R+1)),y.push(d.getX(R)));y.length/3!==g&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const _=I.clone();return _.setIndex(y),_.clearGroups(),_}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),I}function T7(I){const r=new Vector3,d=new Vector3,g=new Vector3,y=new Vector3,_=new Vector3,R=new Vector3,k=new Vector3,X=new Vector3,K=new Vector3;function Q(j0,un,bn,ex,Cx,R0,_n,ux){r.fromBufferAttribute(un,Cx),d.fromBufferAttribute(un,R0),g.fromBufferAttribute(un,_n);const Rx=j0.morphTargetInfluences;if(bn&&Rx){k.set(0,0,0),X.set(0,0,0),K.set(0,0,0);for(let Bx=0,Px=bn.length;Bx<Px;Bx++){const xr=Rx[Bx],Xx=bn[Bx];xr!==0&&(y.fromBufferAttribute(Xx,Cx),_.fromBufferAttribute(Xx,R0),R.fromBufferAttribute(Xx,_n),ex?(k.addScaledVector(y,xr),X.addScaledVector(_,xr),K.addScaledVector(R,xr)):(k.addScaledVector(y.sub(r),xr),X.addScaledVector(_.sub(d),xr),K.addScaledVector(R.sub(g),xr)))}r.add(k),d.add(X),g.add(K)}j0.isSkinnedMesh&&(j0.applyBoneTransform(Cx,r),j0.applyBoneTransform(R0,d),j0.applyBoneTransform(_n,g)),ux[Cx*3+0]=r.x,ux[Cx*3+1]=r.y,ux[Cx*3+2]=r.z,ux[R0*3+0]=d.x,ux[R0*3+1]=d.y,ux[R0*3+2]=d.z,ux[_n*3+0]=g.x,ux[_n*3+1]=g.y,ux[_n*3+2]=g.z}const xe=I.geometry,ue=I.material;let ge,_e,Re;const be=xe.index,ve=xe.attributes.position,Xe=xe.morphAttributes.position,Be=xe.morphTargetsRelative,Ke=xe.attributes.normal,bt=xe.morphAttributes.position,rt=xe.groups,xt=xe.drawRange;let Mt,$t,$e,vt,M0,V0,Pt;const x0=new Float32Array(ve.count*ve.itemSize),Wt=new Float32Array(Ke.count*Ke.itemSize);if(be!==null)if(Array.isArray(ue))for(Mt=0,$e=rt.length;Mt<$e;Mt++)for(M0=rt[Mt],V0=Math.max(M0.start,xt.start),Pt=Math.min(M0.start+M0.count,xt.start+xt.count),$t=V0,vt=Pt;$t<vt;$t+=3)ge=be.getX($t),_e=be.getX($t+1),Re=be.getX($t+2),Q(I,ve,Xe,Be,ge,_e,Re,x0),Q(I,Ke,bt,Be,ge,_e,Re,Wt);else for(V0=Math.max(0,xt.start),Pt=Math.min(be.count,xt.start+xt.count),Mt=V0,$e=Pt;Mt<$e;Mt+=3)ge=be.getX(Mt),_e=be.getX(Mt+1),Re=be.getX(Mt+2),Q(I,ve,Xe,Be,ge,_e,Re,x0),Q(I,Ke,bt,Be,ge,_e,Re,Wt);else if(Array.isArray(ue))for(Mt=0,$e=rt.length;Mt<$e;Mt++)for(M0=rt[Mt],V0=Math.max(M0.start,xt.start),Pt=Math.min(M0.start+M0.count,xt.start+xt.count),$t=V0,vt=Pt;$t<vt;$t+=3)ge=$t,_e=$t+1,Re=$t+2,Q(I,ve,Xe,Be,ge,_e,Re,x0),Q(I,Ke,bt,Be,ge,_e,Re,Wt);else for(V0=Math.max(0,xt.start),Pt=Math.min(ve.count,xt.start+xt.count),Mt=V0,$e=Pt;Mt<$e;Mt+=3)ge=Mt,_e=Mt+1,Re=Mt+2,Q(I,ve,Xe,Be,ge,_e,Re,x0),Q(I,Ke,bt,Be,ge,_e,Re,Wt);const an=new Float32BufferAttribute(x0,3),W0=new Float32BufferAttribute(Wt,3);return{positionAttribute:ve,normalAttribute:Ke,morphedPositionAttribute:an,morphedNormalAttribute:W0}}function A7(I){if(I.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),I;let r=I.groups;if(r=r.sort((R,k)=>R.materialIndex!==k.materialIndex?R.materialIndex-k.materialIndex:R.start-k.start),I.getIndex()===null){const R=I.getAttribute("position"),k=[];for(let X=0;X<R.count;X+=3)k.push(X,X+1,X+2);I.setIndex(k)}const d=I.getIndex(),g=[];for(let R=0;R<r.length;R++){const k=r[R],X=k.start,K=X+k.count;for(let Q=X;Q<K;Q++)g.push(d.getX(Q))}I.dispose(),I.setIndex(g);let y=0;for(let R=0;R<r.length;R++){const k=r[R];k.start=y,y+=k.count}let _=r[0];I.groups=[_];for(let R=1;R<r.length;R++){const k=r[R];_.materialIndex===k.materialIndex?_.count+=k.count:(_=k,I.groups.push(_))}return I}function M7(I,r=Math.PI/3){const d=Math.cos(r),g=(1+1e-10)*100,y=[new Vector3,new Vector3,new Vector3],_=new Vector3,R=new Vector3,k=new Vector3,X=new Vector3;function K(Re){const be=~~(Re.x*g),ve=~~(Re.y*g),Xe=~~(Re.z*g);return`${be},${ve},${Xe}`}const Q=I.index?I.toNonIndexed():I,xe=Q.attributes.position,ue={};for(let Re=0,be=xe.count/3;Re<be;Re++){const ve=3*Re,Xe=y[0].fromBufferAttribute(xe,ve+0),Be=y[1].fromBufferAttribute(xe,ve+1),Ke=y[2].fromBufferAttribute(xe,ve+2);_.subVectors(Ke,Be),R.subVectors(Xe,Be);const bt=new Vector3().crossVectors(_,R).normalize();for(let rt=0;rt<3;rt++){const xt=y[rt],Mt=K(xt);Mt in ue||(ue[Mt]=[]),ue[Mt].push(bt)}}const ge=new Float32Array(xe.count*3),_e=new BufferAttribute(ge,3,!1);for(let Re=0,be=xe.count/3;Re<be;Re++){const ve=3*Re,Xe=y[0].fromBufferAttribute(xe,ve+0),Be=y[1].fromBufferAttribute(xe,ve+1),Ke=y[2].fromBufferAttribute(xe,ve+2);_.subVectors(Ke,Be),R.subVectors(Xe,Be),k.crossVectors(_,R).normalize();for(let bt=0;bt<3;bt++){const rt=y[bt],xt=K(rt),Mt=ue[xt];X.set(0,0,0);for(let $t=0,$e=Mt.length;$t<$e;$t++){const vt=Mt[$t];k.dot(vt)>d&&X.add(vt)}X.normalize(),_e.setXYZ(ve+bt,X.x,X.y,X.z)}}return Q.setAttribute("normal",_e),Q}class GO extends Nu{constructor(r){super(r),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(d){return new JO(d)}),this.register(function(d){return new vD(d)}),this.register(function(d){return new bD(d)}),this.register(function(d){return new _D(d)}),this.register(function(d){return new QO(d)}),this.register(function(d){return new eD(d)}),this.register(function(d){return new xD(d)}),this.register(function(d){return new rD(d)}),this.register(function(d){return new $O(d)}),this.register(function(d){return new uD(d)}),this.register(function(d){return new WO(d)}),this.register(function(d){return new gD(d)}),this.register(function(d){return new dD(d)}),this.register(function(d){return new jO(d)}),this.register(function(d){return new TD(d)}),this.register(function(d){return new AD(d)})}load(r,d,g,y){const _=this;let R;if(this.resourcePath!=="")R=this.resourcePath;else if(this.path!==""){const K=$h.extractUrlBase(r);R=$h.resolveURL(K,this.path)}else R=$h.extractUrlBase(r);this.manager.itemStart(r);const k=function(K){y?y(K):console.error(K),_.manager.itemError(r),_.manager.itemEnd(r)},X=new Bc(this.manager);X.setPath(this.path),X.setResponseType("arraybuffer"),X.setRequestHeader(this.requestHeader),X.setWithCredentials(this.withCredentials),X.load(r,function(K){try{_.parse(K,R,function(Q){d(Q),_.manager.itemEnd(r)},k)}catch(Q){k(Q)}},g,k)}setDRACOLoader(r){return this.dracoLoader=r,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(r){return this.ktx2Loader=r,this}setMeshoptDecoder(r){return this.meshoptDecoder=r,this}register(r){return this.pluginCallbacks.indexOf(r)===-1&&this.pluginCallbacks.push(r),this}unregister(r){return this.pluginCallbacks.indexOf(r)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(r),1),this}parse(r,d,g,y){let _;const R={},k={},X=new TextDecoder;if(typeof r=="string")_=JSON.parse(r);else if(r instanceof ArrayBuffer)if(X.decode(new Uint8Array(r,0,4))===bT){try{R[ri.KHR_BINARY_GLTF]=new MD(r)}catch(xe){y&&y(xe);return}_=JSON.parse(R[ri.KHR_BINARY_GLTF].content)}else _=JSON.parse(X.decode(r));else _=r;if(_.asset===void 0||_.asset.version[0]<2){y&&y(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const K=new JD(_,{path:d||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});K.fileLoader.setRequestHeader(this.requestHeader);for(let Q=0;Q<this.pluginCallbacks.length;Q++){const xe=this.pluginCallbacks[Q](K);xe.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),k[xe.name]=xe,R[xe.name]=!0}if(_.extensionsUsed)for(let Q=0;Q<_.extensionsUsed.length;++Q){const xe=_.extensionsUsed[Q],ue=_.extensionsRequired||[];switch(xe){case ri.KHR_MATERIALS_UNLIT:R[xe]=new KO;break;case ri.KHR_DRACO_MESH_COMPRESSION:R[xe]=new CD(_,this.dracoLoader);break;case ri.KHR_TEXTURE_TRANSFORM:R[xe]=new RD;break;case ri.KHR_MESH_QUANTIZATION:R[xe]=new ND;break;default:ue.indexOf(xe)>=0&&k[xe]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+xe+'".')}}K.setExtensions(R),K.setPlugins(k),K.parse(g,y)}parseAsync(r,d){const g=this;return new Promise(function(y,_){g.parse(r,d,y,_)})}}function XO(){let I={};return{get:function(r){return I[r]},add:function(r,d){I[r]=d},remove:function(r){delete I[r]},removeAll:function(){I={}}}}const ri={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class jO{constructor(r){this.parser=r,this.name=ri.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const r=this.parser,d=this.parser.json.nodes||[];for(let g=0,y=d.length;g<y;g++){const _=d[g];_.extensions&&_.extensions[this.name]&&_.extensions[this.name].light!==void 0&&r._addNodeRef(this.cache,_.extensions[this.name].light)}}_loadLight(r){const d=this.parser,g="light:"+r;let y=d.cache.get(g);if(y)return y;const _=d.json,X=((_.extensions&&_.extensions[this.name]||{}).lights||[])[r];let K;const Q=new bx(16777215);X.color!==void 0&&Q.setRGB(X.color[0],X.color[1],X.color[2],vx);const xe=X.range!==void 0?X.range:0;switch(X.type){case"directional":K=new CS(Q),K.target.position.set(0,0,-1),K.add(K.target);break;case"point":K=new $v(Q),K.distance=xe;break;case"spot":K=new AS(Q),K.distance=xe,X.spot=X.spot||{},X.spot.innerConeAngle=X.spot.innerConeAngle!==void 0?X.spot.innerConeAngle:0,X.spot.outerConeAngle=X.spot.outerConeAngle!==void 0?X.spot.outerConeAngle:Math.PI/4,K.angle=X.spot.outerConeAngle,K.penumbra=1-X.spot.innerConeAngle/X.spot.outerConeAngle,K.target.position.set(0,0,-1),K.add(K.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+X.type)}return K.position.set(0,0,0),K.decay=2,zu(K,X),X.intensity!==void 0&&(K.intensity=X.intensity),K.name=d.createUniqueName(X.name||"light_"+r),y=Promise.resolve(K),d.cache.add(g,y),y}getDependency(r,d){if(r==="light")return this._loadLight(d)}createNodeAttachment(r){const d=this,g=this.parser,_=g.json.nodes[r],k=(_.extensions&&_.extensions[this.name]||{}).light;return k===void 0?null:this._loadLight(k).then(function(X){return g._getNodeRef(d.cache,k,X)})}}class KO{constructor(){this.name=ri.KHR_MATERIALS_UNLIT}getMaterialType(){return X2}extendParams(r,d,g){const y=[];r.color=new bx(1,1,1),r.opacity=1;const _=d.pbrMetallicRoughness;if(_){if(Array.isArray(_.baseColorFactor)){const R=_.baseColorFactor;r.color.setRGB(R[0],R[1],R[2],vx),r.opacity=R[3]}_.baseColorTexture!==void 0&&y.push(g.assignTexture(r,"map",_.baseColorTexture,jn))}return Promise.all(y)}}class $O{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(r,d){const y=this.parser.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=y.extensions[this.name].emissiveStrength;return _!==void 0&&(d.emissiveIntensity=_),Promise.resolve()}}class JO{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_CLEARCOAT}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];if(R.clearcoatFactor!==void 0&&(d.clearcoat=R.clearcoatFactor),R.clearcoatTexture!==void 0&&_.push(g.assignTexture(d,"clearcoatMap",R.clearcoatTexture)),R.clearcoatRoughnessFactor!==void 0&&(d.clearcoatRoughness=R.clearcoatRoughnessFactor),R.clearcoatRoughnessTexture!==void 0&&_.push(g.assignTexture(d,"clearcoatRoughnessMap",R.clearcoatRoughnessTexture)),R.clearcoatNormalTexture!==void 0&&(_.push(g.assignTexture(d,"clearcoatNormalMap",R.clearcoatNormalTexture)),R.clearcoatNormalTexture.scale!==void 0)){const k=R.clearcoatNormalTexture.scale;d.clearcoatNormalScale=new vn(k,k)}return Promise.all(_)}}class WO{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_IRIDESCENCE}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];return R.iridescenceFactor!==void 0&&(d.iridescence=R.iridescenceFactor),R.iridescenceTexture!==void 0&&_.push(g.assignTexture(d,"iridescenceMap",R.iridescenceTexture)),R.iridescenceIor!==void 0&&(d.iridescenceIOR=R.iridescenceIor),d.iridescenceThicknessRange===void 0&&(d.iridescenceThicknessRange=[100,400]),R.iridescenceThicknessMinimum!==void 0&&(d.iridescenceThicknessRange[0]=R.iridescenceThicknessMinimum),R.iridescenceThicknessMaximum!==void 0&&(d.iridescenceThicknessRange[1]=R.iridescenceThicknessMaximum),R.iridescenceThicknessTexture!==void 0&&_.push(g.assignTexture(d,"iridescenceThicknessMap",R.iridescenceThicknessTexture)),Promise.all(_)}}class QO{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_SHEEN}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[];d.sheenColor=new bx(0,0,0),d.sheenRoughness=0,d.sheen=1;const R=y.extensions[this.name];if(R.sheenColorFactor!==void 0){const k=R.sheenColorFactor;d.sheenColor.setRGB(k[0],k[1],k[2],vx)}return R.sheenRoughnessFactor!==void 0&&(d.sheenRoughness=R.sheenRoughnessFactor),R.sheenColorTexture!==void 0&&_.push(g.assignTexture(d,"sheenColorMap",R.sheenColorTexture,jn)),R.sheenRoughnessTexture!==void 0&&_.push(g.assignTexture(d,"sheenRoughnessMap",R.sheenRoughnessTexture)),Promise.all(_)}}class eD{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_TRANSMISSION}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];return R.transmissionFactor!==void 0&&(d.transmission=R.transmissionFactor),R.transmissionTexture!==void 0&&_.push(g.assignTexture(d,"transmissionMap",R.transmissionTexture)),Promise.all(_)}}class xD{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_VOLUME}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];d.thickness=R.thicknessFactor!==void 0?R.thicknessFactor:0,R.thicknessTexture!==void 0&&_.push(g.assignTexture(d,"thicknessMap",R.thicknessTexture)),d.attenuationDistance=R.attenuationDistance||1/0;const k=R.attenuationColor||[1,1,1];return d.attenuationColor=new bx().setRGB(k[0],k[1],k[2],vx),Promise.all(_)}}class rD{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_IOR}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const y=this.parser.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=y.extensions[this.name];return d.ior=_.ior!==void 0?_.ior:1.5,Promise.resolve()}}class uD{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_SPECULAR}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];d.specularIntensity=R.specularFactor!==void 0?R.specularFactor:1,R.specularTexture!==void 0&&_.push(g.assignTexture(d,"specularIntensityMap",R.specularTexture));const k=R.specularColorFactor||[1,1,1];return d.specularColor=new bx().setRGB(k[0],k[1],k[2],vx),R.specularColorTexture!==void 0&&_.push(g.assignTexture(d,"specularColorMap",R.specularColorTexture,jn)),Promise.all(_)}}class dD{constructor(r){this.parser=r,this.name=ri.EXT_MATERIALS_BUMP}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];return d.bumpScale=R.bumpFactor!==void 0?R.bumpFactor:1,R.bumpTexture!==void 0&&_.push(g.assignTexture(d,"bumpMap",R.bumpTexture)),Promise.all(_)}}class gD{constructor(r){this.parser=r,this.name=ri.KHR_MATERIALS_ANISOTROPY}getMaterialType(r){const g=this.parser.json.materials[r];return!g.extensions||!g.extensions[this.name]?null:xl}extendMaterialParams(r,d){const g=this.parser,y=g.json.materials[r];if(!y.extensions||!y.extensions[this.name])return Promise.resolve();const _=[],R=y.extensions[this.name];return R.anisotropyStrength!==void 0&&(d.anisotropy=R.anisotropyStrength),R.anisotropyRotation!==void 0&&(d.anisotropyRotation=R.anisotropyRotation),R.anisotropyTexture!==void 0&&_.push(g.assignTexture(d,"anisotropyMap",R.anisotropyTexture)),Promise.all(_)}}class vD{constructor(r){this.parser=r,this.name=ri.KHR_TEXTURE_BASISU}loadTexture(r){const d=this.parser,g=d.json,y=g.textures[r];if(!y.extensions||!y.extensions[this.name])return null;const _=y.extensions[this.name],R=d.options.ktx2Loader;if(!R){if(g.extensionsRequired&&g.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return d.loadTextureImage(r,_.source,R)}}class bD{constructor(r){this.parser=r,this.name=ri.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(r){const d=this.name,g=this.parser,y=g.json,_=y.textures[r];if(!_.extensions||!_.extensions[d])return null;const R=_.extensions[d],k=y.images[R.source];let X=g.textureLoader;if(k.uri){const K=g.options.manager.getHandler(k.uri);K!==null&&(X=K)}return this.detectSupport().then(function(K){if(K)return g.loadTextureImage(r,R.source,X);if(y.extensionsRequired&&y.extensionsRequired.indexOf(d)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return g.loadTexture(r)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(r){const d=new Image;d.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",d.onload=d.onerror=function(){r(d.height===1)}})),this.isSupported}}class _D{constructor(r){this.parser=r,this.name=ri.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(r){const d=this.name,g=this.parser,y=g.json,_=y.textures[r];if(!_.extensions||!_.extensions[d])return null;const R=_.extensions[d],k=y.images[R.source];let X=g.textureLoader;if(k.uri){const K=g.options.manager.getHandler(k.uri);K!==null&&(X=K)}return this.detectSupport().then(function(K){if(K)return g.loadTextureImage(r,R.source,X);if(y.extensionsRequired&&y.extensionsRequired.indexOf(d)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return g.loadTexture(r)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(r){const d=new Image;d.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",d.onload=d.onerror=function(){r(d.height===1)}})),this.isSupported}}class TD{constructor(r){this.name=ri.EXT_MESHOPT_COMPRESSION,this.parser=r}loadBufferView(r){const d=this.parser.json,g=d.bufferViews[r];if(g.extensions&&g.extensions[this.name]){const y=g.extensions[this.name],_=this.parser.getDependency("buffer",y.buffer),R=this.parser.options.meshoptDecoder;if(!R||!R.supported){if(d.extensionsRequired&&d.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return _.then(function(k){const X=y.byteOffset||0,K=y.byteLength||0,Q=y.count,xe=y.byteStride,ue=new Uint8Array(k,X,K);return R.decodeGltfBufferAsync?R.decodeGltfBufferAsync(Q,xe,ue,y.mode,y.filter).then(function(ge){return ge.buffer}):R.ready.then(function(){const ge=new ArrayBuffer(Q*xe);return R.decodeGltfBuffer(new Uint8Array(ge),Q,xe,ue,y.mode,y.filter),ge})})}else return null}}class AD{constructor(r){this.name=ri.EXT_MESH_GPU_INSTANCING,this.parser=r}createNodeMesh(r){const d=this.parser.json,g=d.nodes[r];if(!g.extensions||!g.extensions[this.name]||g.mesh===void 0)return null;const y=d.meshes[g.mesh];for(const K of y.primitives)if(K.mode!==K2.TRIANGLES&&K.mode!==K2.TRIANGLE_STRIP&&K.mode!==K2.TRIANGLE_FAN&&K.mode!==void 0)return null;const R=g.extensions[this.name].attributes,k=[],X={};for(const K in R)k.push(this.parser.getDependency("accessor",R[K]).then(Q=>(X[K]=Q,X[K])));return k.length<1?null:(k.push(this.parser.createNodeMesh(r)),Promise.all(k).then(K=>{const Q=K.pop(),xe=Q.isGroup?Q.children:[Q],ue=K[0].count,ge=[];for(const _e of xe){const Re=new ur,be=new ut,ve=new Xa,Xe=new ut(1,1,1),Be=new gw(_e.geometry,_e.material,ue);for(let Ke=0;Ke<ue;Ke++)X.TRANSLATION&&be.fromBufferAttribute(X.TRANSLATION,Ke),X.ROTATION&&ve.fromBufferAttribute(X.ROTATION,Ke),X.SCALE&&Xe.fromBufferAttribute(X.SCALE,Ke),Be.setMatrixAt(Ke,Re.compose(be,ve,Xe));for(const Ke in X)if(Ke==="_COLOR_0"){const bt=X[Ke];Be.instanceColor=new Rf(bt.array,bt.itemSize,bt.normalized)}else Ke!=="TRANSLATION"&&Ke!=="ROTATION"&&Ke!=="SCALE"&&_e.geometry.setAttribute(Ke,X[Ke]);xs.prototype.copy.call(Be,_e),this.parser.assignFinalMaterial(Be),ge.push(Be)}return Q.isGroup?(Q.clear(),Q.add(...ge),Q):ge[0]}))}}const bT="glTF",$p=12,_T={JSON:1313821514,BIN:5130562};class MD{constructor(r){this.name=ri.KHR_BINARY_GLTF,this.content=null,this.body=null;const d=new DataView(r,0,$p),g=new TextDecoder;if(this.header={magic:g.decode(new Uint8Array(r.slice(0,4))),version:d.getUint32(4,!0),length:d.getUint32(8,!0)},this.header.magic!==bT)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const y=this.header.length-$p,_=new DataView(r,$p);let R=0;for(;R<y;){const k=_.getUint32(R,!0);R+=4;const X=_.getUint32(R,!0);if(R+=4,X===_T.JSON){const K=new Uint8Array(r,$p+R,k);this.content=g.decode(K)}else if(X===_T.BIN){const K=$p+R;this.body=r.slice(K,K+k)}R+=k}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class CD{constructor(r,d){if(!d)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ri.KHR_DRACO_MESH_COMPRESSION,this.json=r,this.dracoLoader=d,this.dracoLoader.preload()}decodePrimitive(r,d){const g=this.json,y=this.dracoLoader,_=r.extensions[this.name].bufferView,R=r.extensions[this.name].attributes,k={},X={},K={};for(const Q in R){const xe=gb[Q]||Q.toLowerCase();k[xe]=R[Q]}for(const Q in r.attributes){const xe=gb[Q]||Q.toLowerCase();if(R[Q]!==void 0){const ue=g.accessors[r.attributes[Q]],ge=Kf[ue.componentType];K[xe]=ge.name,X[xe]=ue.normalized===!0}}return d.getDependency("bufferView",_).then(function(Q){return new Promise(function(xe,ue){y.decodeDracoFile(Q,function(ge){for(const _e in ge.attributes){const Re=ge.attributes[_e],be=X[_e];be!==void 0&&(Re.normalized=be)}xe(ge)},k,K,vx,ue)})})}}class RD{constructor(){this.name=ri.KHR_TEXTURE_TRANSFORM}extendTexture(r,d){return(d.texCoord===void 0||d.texCoord===r.channel)&&d.offset===void 0&&d.rotation===void 0&&d.scale===void 0||(r=r.clone(),d.texCoord!==void 0&&(r.channel=d.texCoord),d.offset!==void 0&&r.offset.fromArray(d.offset),d.rotation!==void 0&&(r.rotation=d.rotation),d.scale!==void 0&&r.repeat.fromArray(d.scale),r.needsUpdate=!0),r}}class ND{constructor(){this.name=ri.KHR_MESH_QUANTIZATION}}class TT extends Xp{constructor(r,d,g,y){super(r,d,g,y)}copySampleValue_(r){const d=this.resultBuffer,g=this.sampleValues,y=this.valueSize,_=r*y*3+y;for(let R=0;R!==y;R++)d[R]=g[_+R];return d}interpolate_(r,d,g,y){const _=this.resultBuffer,R=this.sampleValues,k=this.valueSize,X=k*2,K=k*3,Q=y-d,xe=(g-d)/Q,ue=xe*xe,ge=ue*xe,_e=r*K,Re=_e-K,be=-2*ge+3*ue,ve=ge-ue,Xe=1-be,Be=ve-ue+xe;for(let Ke=0;Ke!==k;Ke++){const bt=R[Re+Ke+k],rt=R[Re+Ke+X]*Q,xt=R[_e+Ke+k],Mt=R[_e+Ke]*Q;_[Ke]=Xe*bt+Be*rt+be*xt+ve*Mt}return _}}const PD=new Xa;class BD extends TT{interpolate_(r,d,g,y){const _=super.interpolate_(r,d,g,y);return PD.fromArray(_).normalize().toArray(_),_}}const K2={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Kf={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},AT={9728:gi,9729:ui,9984:Tc,9985:Xo,9986:x2,9987:Us},MT={33071:Gi,33648:ea,10497:Ri},db={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},gb={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Bu={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},zD={CUBICSPLINE:void 0,LINEAR:Ga,STEP:Ja},vb={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function VD(I){return I.DefaultMaterial===void 0&&(I.DefaultMaterial=new Vf({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ta})),I.DefaultMaterial}function rd(I,r,d){for(const g in d.extensions)I[g]===void 0&&(r.userData.gltfExtensions=r.userData.gltfExtensions||{},r.userData.gltfExtensions[g]=d.extensions[g])}function zu(I,r){r.extras!==void 0&&(typeof r.extras=="object"?Object.assign(I.userData,r.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+r.extras))}function GD(I,r,d){let g=!1,y=!1,_=!1;for(let K=0,Q=r.length;K<Q;K++){const xe=r[K];if(xe.POSITION!==void 0&&(g=!0),xe.NORMAL!==void 0&&(y=!0),xe.COLOR_0!==void 0&&(_=!0),g&&y&&_)break}if(!g&&!y&&!_)return Promise.resolve(I);const R=[],k=[],X=[];for(let K=0,Q=r.length;K<Q;K++){const xe=r[K];if(g){const ue=xe.POSITION!==void 0?d.getDependency("accessor",xe.POSITION):I.attributes.position;R.push(ue)}if(y){const ue=xe.NORMAL!==void 0?d.getDependency("accessor",xe.NORMAL):I.attributes.normal;k.push(ue)}if(_){const ue=xe.COLOR_0!==void 0?d.getDependency("accessor",xe.COLOR_0):I.attributes.color;X.push(ue)}}return Promise.all([Promise.all(R),Promise.all(k),Promise.all(X)]).then(function(K){const Q=K[0],xe=K[1],ue=K[2];return g&&(I.morphAttributes.position=Q),y&&(I.morphAttributes.normal=xe),_&&(I.morphAttributes.color=ue),I.morphTargetsRelative=!0,I})}function XD(I,r){if(I.updateMorphTargets(),r.weights!==void 0)for(let d=0,g=r.weights.length;d<g;d++)I.morphTargetInfluences[d]=r.weights[d];if(r.extras&&Array.isArray(r.extras.targetNames)){const d=r.extras.targetNames;if(I.morphTargetInfluences.length===d.length){I.morphTargetDictionary={};for(let g=0,y=d.length;g<y;g++)I.morphTargetDictionary[d[g]]=g}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function jD(I){let r;const d=I.extensions&&I.extensions[ri.KHR_DRACO_MESH_COMPRESSION];if(d?r="draco:"+d.bufferView+":"+d.indices+":"+bb(d.attributes):r=I.indices+":"+bb(I.attributes)+":"+I.mode,I.targets!==void 0)for(let g=0,y=I.targets.length;g<y;g++)r+=":"+bb(I.targets[g]);return r}function bb(I){let r="";const d=Object.keys(I).sort();for(let g=0,y=d.length;g<y;g++)r+=d[g]+":"+I[d[g]]+";";return r}function _b(I){switch(I){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function KD(I){return I.search(/\.jpe?g($|\?)/i)>0||I.search(/^data\:image\/jpeg/)===0?"image/jpeg":I.search(/\.webp($|\?)/i)>0||I.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const $D=new ur;class JD{constructor(r={},d={}){this.json=r,this.extensions={},this.plugins={},this.options=d,this.cache=new XO,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let g=!1,y=!1,_=-1;typeof navigator<"u"&&(g=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,y=navigator.userAgent.indexOf("Firefox")>-1,_=y?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||g||y&&_<98?this.textureLoader=new C5(this.options.manager):this.textureLoader=new K5(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Bc(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(r){this.extensions=r}setPlugins(r){this.plugins=r}parse(r,d){const g=this,y=this.json,_=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(R){return R._markDefs&&R._markDefs()}),Promise.all(this._invokeAll(function(R){return R.beforeRoot&&R.beforeRoot()})).then(function(){return Promise.all([g.getDependencies("scene"),g.getDependencies("animation"),g.getDependencies("camera")])}).then(function(R){const k={scene:R[0][y.scene||0],scenes:R[0],animations:R[1],cameras:R[2],asset:y.asset,parser:g,userData:{}};return rd(_,k,y),zu(k,y),Promise.all(g._invokeAll(function(X){return X.afterRoot&&X.afterRoot(k)})).then(function(){r(k)})}).catch(d)}_markDefs(){const r=this.json.nodes||[],d=this.json.skins||[],g=this.json.meshes||[];for(let y=0,_=d.length;y<_;y++){const R=d[y].joints;for(let k=0,X=R.length;k<X;k++)r[R[k]].isBone=!0}for(let y=0,_=r.length;y<_;y++){const R=r[y];R.mesh!==void 0&&(this._addNodeRef(this.meshCache,R.mesh),R.skin!==void 0&&(g[R.mesh].isSkinnedMesh=!0)),R.camera!==void 0&&this._addNodeRef(this.cameraCache,R.camera)}}_addNodeRef(r,d){d!==void 0&&(r.refs[d]===void 0&&(r.refs[d]=r.uses[d]=0),r.refs[d]++)}_getNodeRef(r,d,g){if(r.refs[d]<=1)return g;const y=g.clone(),_=(R,k)=>{const X=this.associations.get(R);X!=null&&this.associations.set(k,X);for(const[K,Q]of R.children.entries())_(Q,k.children[K])};return _(g,y),y.name+="_instance_"+r.uses[d]++,y}_invokeOne(r){const d=Object.values(this.plugins);d.push(this);for(let g=0;g<d.length;g++){const y=r(d[g]);if(y)return y}return null}_invokeAll(r){const d=Object.values(this.plugins);d.unshift(this);const g=[];for(let y=0;y<d.length;y++){const _=r(d[y]);_&&g.push(_)}return g}getDependency(r,d){const g=r+":"+d;let y=this.cache.get(g);if(!y){switch(r){case"scene":y=this.loadScene(d);break;case"node":y=this._invokeOne(function(_){return _.loadNode&&_.loadNode(d)});break;case"mesh":y=this._invokeOne(function(_){return _.loadMesh&&_.loadMesh(d)});break;case"accessor":y=this.loadAccessor(d);break;case"bufferView":y=this._invokeOne(function(_){return _.loadBufferView&&_.loadBufferView(d)});break;case"buffer":y=this.loadBuffer(d);break;case"material":y=this._invokeOne(function(_){return _.loadMaterial&&_.loadMaterial(d)});break;case"texture":y=this._invokeOne(function(_){return _.loadTexture&&_.loadTexture(d)});break;case"skin":y=this.loadSkin(d);break;case"animation":y=this._invokeOne(function(_){return _.loadAnimation&&_.loadAnimation(d)});break;case"camera":y=this.loadCamera(d);break;default:if(y=this._invokeOne(function(_){return _!=this&&_.getDependency&&_.getDependency(r,d)}),!y)throw new Error("Unknown type: "+r);break}this.cache.add(g,y)}return y}getDependencies(r){let d=this.cache.get(r);if(!d){const g=this,y=this.json[r+(r==="mesh"?"es":"s")]||[];d=Promise.all(y.map(function(_,R){return g.getDependency(r,R)})),this.cache.add(r,d)}return d}loadBuffer(r){const d=this.json.buffers[r],g=this.fileLoader;if(d.type&&d.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+d.type+" buffer type is not supported.");if(d.uri===void 0&&r===0)return Promise.resolve(this.extensions[ri.KHR_BINARY_GLTF].body);const y=this.options;return new Promise(function(_,R){g.load($h.resolveURL(d.uri,y.path),_,void 0,function(){R(new Error('THREE.GLTFLoader: Failed to load buffer "'+d.uri+'".'))})})}loadBufferView(r){const d=this.json.bufferViews[r];return this.getDependency("buffer",d.buffer).then(function(g){const y=d.byteLength||0,_=d.byteOffset||0;return g.slice(_,_+y)})}loadAccessor(r){const d=this,g=this.json,y=this.json.accessors[r];if(y.bufferView===void 0&&y.sparse===void 0){const R=db[y.type],k=Kf[y.componentType],X=y.normalized===!0,K=new k(y.count*R);return Promise.resolve(new rs(K,R,X))}const _=[];return y.bufferView!==void 0?_.push(this.getDependency("bufferView",y.bufferView)):_.push(null),y.sparse!==void 0&&(_.push(this.getDependency("bufferView",y.sparse.indices.bufferView)),_.push(this.getDependency("bufferView",y.sparse.values.bufferView))),Promise.all(_).then(function(R){const k=R[0],X=db[y.type],K=Kf[y.componentType],Q=K.BYTES_PER_ELEMENT,xe=Q*X,ue=y.byteOffset||0,ge=y.bufferView!==void 0?g.bufferViews[y.bufferView].byteStride:void 0,_e=y.normalized===!0;let Re,be;if(ge&&ge!==xe){const ve=Math.floor(ue/ge),Xe="InterleavedBuffer:"+y.bufferView+":"+y.componentType+":"+ve+":"+y.count;let Be=d.cache.get(Xe);Be||(Re=new K(k,ve*ge,y.count*ge/Q),Be=new B1(Re,ge/Q),d.cache.add(Xe,Be)),be=new zh(Be,X,ue%ge/Q,_e)}else k===null?Re=new K(y.count*X):Re=new K(k,ue,y.count*X),be=new rs(Re,X,_e);if(y.sparse!==void 0){const ve=db.SCALAR,Xe=Kf[y.sparse.indices.componentType],Be=y.sparse.indices.byteOffset||0,Ke=y.sparse.values.byteOffset||0,bt=new Xe(R[1],Be,y.sparse.count*ve),rt=new K(R[2],Ke,y.sparse.count*X);k!==null&&(be=new rs(be.array.slice(),be.itemSize,be.normalized));for(let xt=0,Mt=bt.length;xt<Mt;xt++){const $t=bt[xt];if(be.setX($t,rt[xt*X]),X>=2&&be.setY($t,rt[xt*X+1]),X>=3&&be.setZ($t,rt[xt*X+2]),X>=4&&be.setW($t,rt[xt*X+3]),X>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return be})}loadTexture(r){const d=this.json,g=this.options,_=d.textures[r].source,R=d.images[_];let k=this.textureLoader;if(R.uri){const X=g.manager.getHandler(R.uri);X!==null&&(k=X)}return this.loadTextureImage(r,_,k)}loadTextureImage(r,d,g){const y=this,_=this.json,R=_.textures[r],k=_.images[d],X=(k.uri||k.bufferView)+":"+R.sampler;if(this.textureCache[X])return this.textureCache[X];const K=this.loadImageSource(d,g).then(function(Q){Q.flipY=!1,Q.name=R.name||k.name||"",Q.name===""&&typeof k.uri=="string"&&k.uri.startsWith("data:image/")===!1&&(Q.name=k.uri);const ue=(_.samplers||{})[R.sampler]||{};return Q.magFilter=AT[ue.magFilter]||ui,Q.minFilter=AT[ue.minFilter]||Us,Q.wrapS=MT[ue.wrapS]||Ri,Q.wrapT=MT[ue.wrapT]||Ri,y.associations.set(Q,{textures:r}),Q}).catch(function(){return null});return this.textureCache[X]=K,K}loadImageSource(r,d){const g=this,y=this.json,_=this.options;if(this.sourceCache[r]!==void 0)return this.sourceCache[r].then(xe=>xe.clone());const R=y.images[r],k=self.URL||self.webkitURL;let X=R.uri||"",K=!1;if(R.bufferView!==void 0)X=g.getDependency("bufferView",R.bufferView).then(function(xe){K=!0;const ue=new Blob([xe],{type:R.mimeType});return X=k.createObjectURL(ue),X});else if(R.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+r+" is missing URI and bufferView");const Q=Promise.resolve(X).then(function(xe){return new Promise(function(ue,ge){let _e=ue;d.isImageBitmapLoader===!0&&(_e=function(Re){const be=new Ks(Re);be.needsUpdate=!0,ue(be)}),d.load($h.resolveURL(xe,_.path),_e,void 0,ge)})}).then(function(xe){return K===!0&&k.revokeObjectURL(X),xe.userData.mimeType=R.mimeType||KD(R.uri),xe}).catch(function(xe){throw console.error("THREE.GLTFLoader: Couldn't load texture",X),xe});return this.sourceCache[r]=Q,Q}assignTexture(r,d,g,y){const _=this;return this.getDependency("texture",g.index).then(function(R){if(!R)return null;if(g.texCoord!==void 0&&g.texCoord>0&&(R=R.clone(),R.channel=g.texCoord),_.extensions[ri.KHR_TEXTURE_TRANSFORM]){const k=g.extensions!==void 0?g.extensions[ri.KHR_TEXTURE_TRANSFORM]:void 0;if(k){const X=_.associations.get(R);R=_.extensions[ri.KHR_TEXTURE_TRANSFORM].extendTexture(R,k),_.associations.set(R,X)}}return y!==void 0&&(R.colorSpace=y),r[d]=R,R})}assignFinalMaterial(r){const d=r.geometry;let g=r.material;const y=d.attributes.tangent===void 0,_=d.attributes.color!==void 0,R=d.attributes.normal===void 0;if(r.isPoints){const k="PointsMaterial:"+g.uuid;let X=this.cache.get(k);X||(X=new W1,T2.prototype.copy.call(X,g),X.color.copy(g.color),X.map=g.map,X.sizeAttenuation=!1,this.cache.add(k,X)),g=X}else if(r.isLine){const k="LineBasicMaterial:"+g.uuid;let X=this.cache.get(k);X||(X=new $o,T2.prototype.copy.call(X,g),X.color.copy(g.color),X.map=g.map,this.cache.add(k,X)),g=X}if(y||_||R){let k="ClonedMaterial:"+g.uuid+":";y&&(k+="derivative-tangents:"),_&&(k+="vertex-colors:"),R&&(k+="flat-shading:");let X=this.cache.get(k);X||(X=g.clone(),_&&(X.vertexColors=!0),R&&(X.flatShading=!0),y&&(X.normalScale&&(X.normalScale.y*=-1),X.clearcoatNormalScale&&(X.clearcoatNormalScale.y*=-1)),this.cache.add(k,X),this.associations.set(X,this.associations.get(g))),g=X}r.material=g}getMaterialType(){return Vf}loadMaterial(r){const d=this,g=this.json,y=this.extensions,_=g.materials[r];let R;const k={},X=_.extensions||{},K=[];if(X[ri.KHR_MATERIALS_UNLIT]){const xe=y[ri.KHR_MATERIALS_UNLIT];R=xe.getMaterialType(),K.push(xe.extendParams(k,_,d))}else{const xe=_.pbrMetallicRoughness||{};if(k.color=new bx(1,1,1),k.opacity=1,Array.isArray(xe.baseColorFactor)){const ue=xe.baseColorFactor;k.color.setRGB(ue[0],ue[1],ue[2],vx),k.opacity=ue[3]}xe.baseColorTexture!==void 0&&K.push(d.assignTexture(k,"map",xe.baseColorTexture,jn)),k.metalness=xe.metallicFactor!==void 0?xe.metallicFactor:1,k.roughness=xe.roughnessFactor!==void 0?xe.roughnessFactor:1,xe.metallicRoughnessTexture!==void 0&&(K.push(d.assignTexture(k,"metalnessMap",xe.metallicRoughnessTexture)),K.push(d.assignTexture(k,"roughnessMap",xe.metallicRoughnessTexture))),R=this._invokeOne(function(ue){return ue.getMaterialType&&ue.getMaterialType(r)}),K.push(Promise.all(this._invokeAll(function(ue){return ue.extendMaterialParams&&ue.extendMaterialParams(r,k)})))}_.doubleSided===!0&&(k.side=Ba);const Q=_.alphaMode||vb.OPAQUE;if(Q===vb.BLEND?(k.transparent=!0,k.depthWrite=!1):(k.transparent=!1,Q===vb.MASK&&(k.alphaTest=_.alphaCutoff!==void 0?_.alphaCutoff:.5)),_.normalTexture!==void 0&&R!==X2&&(K.push(d.assignTexture(k,"normalMap",_.normalTexture)),k.normalScale=new vn(1,1),_.normalTexture.scale!==void 0)){const xe=_.normalTexture.scale;k.normalScale.set(xe,xe)}if(_.occlusionTexture!==void 0&&R!==X2&&(K.push(d.assignTexture(k,"aoMap",_.occlusionTexture)),_.occlusionTexture.strength!==void 0&&(k.aoMapIntensity=_.occlusionTexture.strength)),_.emissiveFactor!==void 0&&R!==X2){const xe=_.emissiveFactor;k.emissive=new bx().setRGB(xe[0],xe[1],xe[2],vx)}return _.emissiveTexture!==void 0&&R!==X2&&K.push(d.assignTexture(k,"emissiveMap",_.emissiveTexture,jn)),Promise.all(K).then(function(){const xe=new R(k);return _.name&&(xe.name=_.name),zu(xe,_),d.associations.set(xe,{materials:r}),_.extensions&&rd(y,xe,_),xe})}createUniqueName(r){const d=vi.sanitizeNodeName(r||"");return d in this.nodeNamesUsed?d+"_"+ ++this.nodeNamesUsed[d]:(this.nodeNamesUsed[d]=0,d)}loadGeometries(r){const d=this,g=this.extensions,y=this.primitiveCache;function _(k){return g[ri.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(k,d).then(function(X){return CT(X,k,d)})}const R=[];for(let k=0,X=r.length;k<X;k++){const K=r[k],Q=jD(K),xe=y[Q];if(xe)R.push(xe.promise);else{let ue;K.extensions&&K.extensions[ri.KHR_DRACO_MESH_COMPRESSION]?ue=_(K):ue=CT(new Ur,K,d),y[Q]={primitive:K,promise:ue},R.push(ue)}}return Promise.all(R)}loadMesh(r){const d=this,g=this.json,y=this.extensions,_=g.meshes[r],R=_.primitives,k=[];for(let X=0,K=R.length;X<K;X++){const Q=R[X].material===void 0?VD(this.cache):this.getDependency("material",R[X].material);k.push(Q)}return k.push(d.loadGeometries(R)),Promise.all(k).then(function(X){const K=X.slice(0,X.length-1),Q=X[X.length-1],xe=[];for(let ge=0,_e=Q.length;ge<_e;ge++){const Re=Q[ge],be=R[ge];let ve;const Xe=K[ge];if(be.mode===K2.TRIANGLES||be.mode===K2.TRIANGLE_STRIP||be.mode===K2.TRIANGLE_FAN||be.mode===void 0)ve=_.isSkinnedMesh===!0?new X1(Re,Xe):new Bs(Re,Xe),ve.isSkinnedMesh===!0&&ve.normalizeSkinWeights(),be.mode===K2.TRIANGLE_STRIP?ve.geometry=vT(ve.geometry,gt):be.mode===K2.TRIANGLE_FAN&&(ve.geometry=vT(ve.geometry,Kt));else if(be.mode===K2.LINES)ve=new J1(Re,Xe);else if(be.mode===K2.LINE_STRIP)ve=new Uh(Re,Xe);else if(be.mode===K2.LINE_LOOP)ve=new Rw(Re,Xe);else if(be.mode===K2.POINTS)ve=new Pw(Re,Xe);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+be.mode);Object.keys(ve.geometry.morphAttributes).length>0&&XD(ve,_),ve.name=d.createUniqueName(_.name||"mesh_"+r),zu(ve,_),be.extensions&&rd(y,ve,be),d.assignFinalMaterial(ve),xe.push(ve)}for(let ge=0,_e=xe.length;ge<_e;ge++)d.associations.set(xe[ge],{meshes:r,primitives:ge});if(xe.length===1)return _.extensions&&rd(y,xe[0],_),xe[0];const ue=new jl;_.extensions&&rd(y,ue,_),d.associations.set(ue,{meshes:r});for(let ge=0,_e=xe.length;ge<_e;ge++)ue.add(xe[ge]);return ue})}loadCamera(r){let d;const g=this.json.cameras[r],y=g[g.type];if(!y){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return g.type==="perspective"?d=new ua(ME.radToDeg(y.yfov),y.aspectRatio||1,y.znear||1,y.zfar||2e6):g.type==="orthographic"&&(d=new _p(-y.xmag,y.xmag,y.ymag,-y.ymag,y.znear,y.zfar)),g.name&&(d.name=this.createUniqueName(g.name)),zu(d,g),Promise.resolve(d)}loadSkin(r){const d=this.json.skins[r],g=[];for(let y=0,_=d.joints.length;y<_;y++)g.push(this._loadNodeShallow(d.joints[y]));return d.inverseBindMatrices!==void 0?g.push(this.getDependency("accessor",d.inverseBindMatrices)):g.push(null),Promise.all(g).then(function(y){const _=y.pop(),R=y,k=[],X=[];for(let K=0,Q=R.length;K<Q;K++){const xe=R[K];if(xe){k.push(xe);const ue=new ur;_!==null&&ue.fromArray(_.array,K*16),X.push(ue)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',d.joints[K])}return new Tg(k,X)})}loadAnimation(r){const d=this.json,g=this,y=d.animations[r],_=y.name?y.name:"animation_"+r,R=[],k=[],X=[],K=[],Q=[];for(let xe=0,ue=y.channels.length;xe<ue;xe++){const ge=y.channels[xe],_e=y.samplers[ge.sampler],Re=ge.target,be=Re.node,ve=y.parameters!==void 0?y.parameters[_e.input]:_e.input,Xe=y.parameters!==void 0?y.parameters[_e.output]:_e.output;Re.node!==void 0&&(R.push(this.getDependency("node",be)),k.push(this.getDependency("accessor",ve)),X.push(this.getDependency("accessor",Xe)),K.push(_e),Q.push(Re))}return Promise.all([Promise.all(R),Promise.all(k),Promise.all(X),Promise.all(K),Promise.all(Q)]).then(function(xe){const ue=xe[0],ge=xe[1],_e=xe[2],Re=xe[3],be=xe[4],ve=[];for(let Xe=0,Be=ue.length;Xe<Be;Xe++){const Ke=ue[Xe],bt=ge[Xe],rt=_e[Xe],xt=Re[Xe],Mt=be[Xe];if(Ke===void 0)continue;Ke.updateMatrix&&Ke.updateMatrix();const $t=g._createAnimationTracks(Ke,bt,rt,xt,Mt);if($t)for(let $e=0;$e<$t.length;$e++)ve.push($t[$e])}return new jp(_,void 0,ve)})}createNodeMesh(r){const d=this.json,g=this,y=d.nodes[r];return y.mesh===void 0?null:g.getDependency("mesh",y.mesh).then(function(_){const R=g._getNodeRef(g.meshCache,y.mesh,_);return y.weights!==void 0&&R.traverse(function(k){if(k.isMesh)for(let X=0,K=y.weights.length;X<K;X++)k.morphTargetInfluences[X]=y.weights[X]}),R})}loadNode(r){const d=this.json,g=this,y=d.nodes[r],_=g._loadNodeShallow(r),R=[],k=y.children||[];for(let K=0,Q=k.length;K<Q;K++)R.push(g.getDependency("node",k[K]));const X=y.skin===void 0?Promise.resolve(null):g.getDependency("skin",y.skin);return Promise.all([_,Promise.all(R),X]).then(function(K){const Q=K[0],xe=K[1],ue=K[2];ue!==null&&Q.traverse(function(ge){ge.isSkinnedMesh&&ge.bind(ue,$D)});for(let ge=0,_e=xe.length;ge<_e;ge++)Q.add(xe[ge]);return Q})}_loadNodeShallow(r){const d=this.json,g=this.extensions,y=this;if(this.nodeCache[r]!==void 0)return this.nodeCache[r];const _=d.nodes[r],R=_.name?y.createUniqueName(_.name):"",k=[],X=y._invokeOne(function(K){return K.createNodeMesh&&K.createNodeMesh(r)});return X&&k.push(X),_.camera!==void 0&&k.push(y.getDependency("camera",_.camera).then(function(K){return y._getNodeRef(y.cameraCache,_.camera,K)})),y._invokeAll(function(K){return K.createNodeAttachment&&K.createNodeAttachment(r)}).forEach(function(K){k.push(K)}),this.nodeCache[r]=Promise.all(k).then(function(K){let Q;if(_.isBone===!0?Q=new _g:K.length>1?Q=new jl:K.length===1?Q=K[0]:Q=new xs,Q!==K[0])for(let xe=0,ue=K.length;xe<ue;xe++)Q.add(K[xe]);if(_.name&&(Q.userData.name=_.name,Q.name=R),zu(Q,_),_.extensions&&rd(g,Q,_),_.matrix!==void 0){const xe=new ur;xe.fromArray(_.matrix),Q.applyMatrix4(xe)}else _.translation!==void 0&&Q.position.fromArray(_.translation),_.rotation!==void 0&&Q.quaternion.fromArray(_.rotation),_.scale!==void 0&&Q.scale.fromArray(_.scale);return y.associations.has(Q)||y.associations.set(Q,{}),y.associations.get(Q).nodes=r,Q}),this.nodeCache[r]}loadScene(r){const d=this.extensions,g=this.json.scenes[r],y=this,_=new jl;g.name&&(_.name=y.createUniqueName(g.name)),zu(_,g),g.extensions&&rd(d,_,g);const R=g.nodes||[],k=[];for(let X=0,K=R.length;X<K;X++)k.push(y.getDependency("node",R[X]));return Promise.all(k).then(function(X){for(let Q=0,xe=X.length;Q<xe;Q++)_.add(X[Q]);const K=Q=>{const xe=new Map;for(const[ue,ge]of y.associations)(ue instanceof T2||ue instanceof Ks)&&xe.set(ue,ge);return Q.traverse(ue=>{const ge=y.associations.get(ue);ge!=null&&xe.set(ue,ge)}),xe};return y.associations=K(_),_})}_createAnimationTracks(r,d,g,y,_){const R=[],k=r.name?r.name:r.uuid,X=[];Bu[_.path]===Bu.weights?r.traverse(function(ue){ue.morphTargetInfluences&&X.push(ue.name?ue.name:ue.uuid)}):X.push(k);let K;switch(Bu[_.path]){case Bu.weights:K=Gf;break;case Bu.rotation:K=Kh;break;case Bu.position:case Bu.scale:K=jf;break;default:switch(g.itemSize){case 1:K=Gf;break;case 2:case 3:default:K=jf;break}break}const Q=y.interpolation!==void 0?zD[y.interpolation]:Ga,xe=this._getArrayFromAccessor(g);for(let ue=0,ge=X.length;ue<ge;ue++){const _e=new K(X[ue]+"."+Bu[_.path],d.array,xe,Q);y.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(_e),R.push(_e)}return R}_getArrayFromAccessor(r){let d=r.array;if(r.normalized){const g=_b(d.constructor),y=new Float32Array(d.length);for(let _=0,R=d.length;_<R;_++)y[_]=d[_]*g;d=y}return d}_createCubicSplineTrackInterpolant(r){r.createInterpolant=function(g){const y=this instanceof Kh?BD:TT;return new y(this.times,this.values,this.getValueSize()/3,g)},r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function WD(I,r,d){const g=r.attributes,y=new Co;if(g.POSITION!==void 0){const k=d.json.accessors[g.POSITION],X=k.min,K=k.max;if(X!==void 0&&K!==void 0){if(y.set(new ut(X[0],X[1],X[2]),new ut(K[0],K[1],K[2])),k.normalized){const Q=_b(Kf[k.componentType]);y.min.multiplyScalar(Q),y.max.multiplyScalar(Q)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const _=r.targets;if(_!==void 0){const k=new ut,X=new ut;for(let K=0,Q=_.length;K<Q;K++){const xe=_[K];if(xe.POSITION!==void 0){const ue=d.json.accessors[xe.POSITION],ge=ue.min,_e=ue.max;if(ge!==void 0&&_e!==void 0){if(X.setX(Math.max(Math.abs(ge[0]),Math.abs(_e[0]))),X.setY(Math.max(Math.abs(ge[1]),Math.abs(_e[1]))),X.setZ(Math.max(Math.abs(ge[2]),Math.abs(_e[2]))),ue.normalized){const Re=_b(Kf[ue.componentType]);X.multiplyScalar(Re)}k.max(X)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}y.expandByVector(k)}I.boundingBox=y;const R=new Qa;y.getCenter(R.center),R.radius=y.min.distanceTo(y.max)/2,I.boundingSphere=R}function CT(I,r,d){const g=r.attributes,y=[];function _(R,k){return d.getDependency("accessor",R).then(function(X){I.setAttribute(k,X)})}for(const R in g){const k=gb[R]||R.toLowerCase();k in I.attributes||y.push(_(g[R],k))}if(r.indices!==void 0&&!I.index){const R=d.getDependency("accessor",r.indices).then(function(k){I.setIndex(k)});y.push(R)}return Ci.workingColorSpace!==vx&&"COLOR_0"in g&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ci.workingColorSpace}" not supported.`),zu(I,r),WD(I,r,d),Promise.all(y).then(function(){return r.targets!==void 0?GD(I,r.targets,d):I})}class QD extends M5{constructor(r){super(r),this.type=Xi}parse(r){const R=function(Mt,$t){switch(Mt){case 1:throw new Error("THREE.RGBELoader: Read Error: "+($t||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+($t||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+($t||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+($t||""))}},Q=`
`,xe=function(Mt,$t,$e){$t=$t||1024;let M0=Mt.pos,V0=-1,Pt=0,x0="",Wt=String.fromCharCode.apply(null,new Uint16Array(Mt.subarray(M0,M0+128)));for(;0>(V0=Wt.indexOf(Q))&&Pt<$t&&M0<Mt.byteLength;)x0+=Wt,Pt+=Wt.length,M0+=128,Wt+=String.fromCharCode.apply(null,new Uint16Array(Mt.subarray(M0,M0+128)));return-1<V0?($e!==!1&&(Mt.pos+=Pt+V0+1),x0+Wt.slice(0,V0)):!1},ue=function(Mt){const $t=/^#\?(\S+)/,$e=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,vt=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,M0=/^\s*FORMAT=(\S+)\s*$/,V0=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,Pt={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let x0,Wt;for((Mt.pos>=Mt.byteLength||!(x0=xe(Mt)))&&R(1,"no header found"),(Wt=x0.match($t))||R(3,"bad initial token"),Pt.valid|=1,Pt.programtype=Wt[1],Pt.string+=x0+`
`;x0=xe(Mt),x0!==!1;){if(Pt.string+=x0+`
`,x0.charAt(0)==="#"){Pt.comments+=x0+`
`;continue}if((Wt=x0.match($e))&&(Pt.gamma=parseFloat(Wt[1])),(Wt=x0.match(vt))&&(Pt.exposure=parseFloat(Wt[1])),(Wt=x0.match(M0))&&(Pt.valid|=2,Pt.format=Wt[1]),(Wt=x0.match(V0))&&(Pt.valid|=4,Pt.height=parseInt(Wt[1],10),Pt.width=parseInt(Wt[2],10)),Pt.valid&2&&Pt.valid&4)break}return Pt.valid&2||R(3,"missing format specifier"),Pt.valid&4||R(3,"missing image size specifier"),Pt},ge=function(Mt,$t,$e){const vt=$t;if(vt<8||vt>32767||Mt[0]!==2||Mt[1]!==2||Mt[2]&128)return new Uint8Array(Mt);vt!==(Mt[2]<<8|Mt[3])&&R(3,"wrong scanline width");const M0=new Uint8Array(4*$t*$e);M0.length||R(4,"unable to allocate buffer space");let V0=0,Pt=0;const x0=4*vt,Wt=new Uint8Array(4),an=new Uint8Array(x0);let W0=$e;for(;W0>0&&Pt<Mt.byteLength;){Pt+4>Mt.byteLength&&R(1),Wt[0]=Mt[Pt++],Wt[1]=Mt[Pt++],Wt[2]=Mt[Pt++],Wt[3]=Mt[Pt++],(Wt[0]!=2||Wt[1]!=2||(Wt[2]<<8|Wt[3])!=vt)&&R(3,"bad rgbe scanline format");let j0=0,un;for(;j0<x0&&Pt<Mt.byteLength;){un=Mt[Pt++];const ex=un>128;if(ex&&(un-=128),(un===0||j0+un>x0)&&R(3,"bad scanline data"),ex){const Cx=Mt[Pt++];for(let R0=0;R0<un;R0++)an[j0++]=Cx}else an.set(Mt.subarray(Pt,Pt+un),j0),j0+=un,Pt+=un}const bn=vt;for(let ex=0;ex<bn;ex++){let Cx=0;M0[V0]=an[ex+Cx],Cx+=vt,M0[V0+1]=an[ex+Cx],Cx+=vt,M0[V0+2]=an[ex+Cx],Cx+=vt,M0[V0+3]=an[ex+Cx],V0+=4}W0--}return M0},_e=function(Mt,$t,$e,vt){const M0=Mt[$t+3],V0=Math.pow(2,M0-128)/255;$e[vt+0]=Mt[$t+0]*V0,$e[vt+1]=Mt[$t+1]*V0,$e[vt+2]=Mt[$t+2]*V0,$e[vt+3]=1},Re=function(Mt,$t,$e,vt){const M0=Mt[$t+3],V0=Math.pow(2,M0-128)/255;$e[vt+0]=Nm.toHalfFloat(Math.min(Mt[$t+0]*V0,65504)),$e[vt+1]=Nm.toHalfFloat(Math.min(Mt[$t+1]*V0,65504)),$e[vt+2]=Nm.toHalfFloat(Math.min(Mt[$t+2]*V0,65504)),$e[vt+3]=Nm.toHalfFloat(1)},be=new Uint8Array(r);be.pos=0;const ve=ue(be),Xe=ve.width,Be=ve.height,Ke=ge(be.subarray(be.pos),Xe,Be);let bt,rt,xt;switch(this.type){case Ts:xt=Ke.length/4;const Mt=new Float32Array(xt*4);for(let $e=0;$e<xt;$e++)_e(Ke,$e*4,Mt,$e*4);bt=Mt,rt=Ts;break;case Xi:xt=Ke.length/4;const $t=new Uint16Array(xt*4);for(let $e=0;$e<xt;$e++)Re(Ke,$e*4,$t,$e*4);bt=$t,rt=Xi;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:Xe,height:Be,data:bt,header:ve.string,gamma:ve.gamma,exposure:ve.exposure,type:rt}}setDataType(r){return this.type=r,this}load(r,d,g,y){function _(R,k){switch(R.type){case Ts:case Xi:R.colorSpace=vx,R.minFilter=ui,R.magFilter=ui,R.generateMipmaps=!1,R.flipY=!0;break}d&&d(R,k)}return super.load(r,_,g,y)}}class e6 extends Nu{constructor(r){super(r)}load(r,d,g,y){const _=this,R=new Bc(this.manager);R.setPath(this.path),R.setRequestHeader(this.requestHeader),R.setWithCredentials(this.withCredentials),R.load(r,function(k){const X=_.parse(JSON.parse(k));d&&d(X)},g,y)}parse(r){return new x6(r)}}class x6{constructor(r){this.isFont=!0,this.type="Font",this.data=r}generateShapes(r,d=100){const g=[],y=r6(r,d,this.data);for(let _=0,R=y.length;_<R;_++)g.push(...y[_].toShapes());return g}}function r6(I,r,d){const g=Array.from(I),y=r/d.resolution,_=(d.boundingBox.yMax-d.boundingBox.yMin+d.underlineThickness)*y,R=[];let k=0,X=0;for(let K=0;K<g.length;K++){const Q=g[K];if(Q===`
`)k=0,X-=_;else{const xe=u6(Q,y,k,X,d);k+=xe.offsetX,R.push(xe.path)}}return R}function u6(I,r,d,g,y){const _=y.glyphs[I]||y.glyphs["?"];if(!_){console.error('THREE.Font: character "'+I+'" does not exists in font family '+y.familyName+".");return}const R=new RO;let k,X,K,Q,xe,ue,ge,_e;if(_.o){const Re=_._cachedOutline||(_._cachedOutline=_.o.split(" "));for(let be=0,ve=Re.length;be<ve;)switch(Re[be++]){case"m":k=Re[be++]*r+d,X=Re[be++]*r+g,R.moveTo(k,X);break;case"l":k=Re[be++]*r+d,X=Re[be++]*r+g,R.lineTo(k,X);break;case"q":K=Re[be++]*r+d,Q=Re[be++]*r+g,xe=Re[be++]*r+d,ue=Re[be++]*r+g,R.quadraticCurveTo(xe,ue,K,Q);break;case"b":K=Re[be++]*r+d,Q=Re[be++]*r+g,xe=Re[be++]*r+d,ue=Re[be++]*r+g,ge=Re[be++]*r+d,_e=Re[be++]*r+g,R.bezierCurveTo(xe,ue,ge,_e,K,Q);break}}return{offsetX:_.ha*r,path:R}}class d6 extends Wg{constructor(r,d={}){const g=d.font;if(g===void 0)super();else{const y=g.generateShapes(r,d.size);d.depth=d.height!==void 0?d.height:50,d.bevelThickness===void 0&&(d.bevelThickness=10),d.bevelSize===void 0&&(d.bevelSize=8),d.bevelEnabled===void 0&&(d.bevelEnabled=!1),super(y,d)}this.type="TextGeometry"}}class g6 extends BO{constructor(r,d,g,y="onesie.glb",_){super(r,d,g),this.url=y,this.outfit=_,this.lightInt=.75,this.ambientInt=1.25,this.handsUp=!1,this.plugin=new UO(void 0,_),this.addPlugin(this.plugin)}async load(){if(!(this.loaded||!this.scene))return await this.setupScene(this.scene),super.load()}async setupScene(r){await this.setModel(this.url),this.light=new $v(16777215,this.lightInt),this.ambient=new RS(16777215,this.ambientInt),r.add(this.light),r.add(this.ambient);const d=await new QD().loadAsync("environment.hdr");d.mapping=Qs,r.environment=d;const g=await new e6().loadAsync("font.json"),y=new d6("HOORAY!!!",{font:g,size:5,height:2,bevelSize:.3,bevelThickness:1,bevelSegments:10,bevelEnabled:!0});y.scale(.01,.01,.01),y.computeBoundingBox();const _=y.boundingBox;_&&y.translate(..._.max.sub(_.min).multiplyScalar(-.5).toArray()),y.rotateY(Math.PI);const R=new Bs(y,[new Vf({color:3922843,flatShading:!0}),new Vf({color:3922843})]);this.textModel=new jl,this.textModel.visible=!1,this.textModel.add(R),this.scene?.add(this.textModel)}async setModel(r){return this.setOutfit(r,this.outfit)}async setOutfit(r,d){this.model&&this.disposeObject(this.model),delete this.model,this.url=r,this.outfit=d;const g=await new GO().loadAsync(r);this.model=g.scene,this.scene?.add(this.model),this.plugin.setOutfit(this.model,d)}async update(r,d){const g=r.poses&&r.poses.length>0?r.poses[0]:void 0;if(!g)return this.handsUp=!1,super.update(r,d);const{points:y}=g,_=new ut(...y.hipL.metric),R=new ut(...y.hipR.metric),k=new ut(...y.shoulderL.metric),X=new ut(...y.shoulderR.metric),K=new ut(...y.elbowL.metric),Q=new ut(...y.elbowR.metric),xe=new ut(...y.wristL.metric),ue=new ut(...y.wristR.metric),ge=k.clone().sub(_).normalize(),_e=X.clone().sub(R).normalize(),Re=K.clone().sub(k).normalize(),be=Q.clone().sub(X).normalize(),ve=xe.clone().sub(K).normalize(),Xe=ue.clone().sub(Q).normalize(),Be=ge.dot(Re),Ke=_e.dot(be),bt=ve.dot(Re),rt=Xe.dot(be),xt=Math.min(Be,Ke,bt,rt);xt>.8&&(this.handsUp=!0),xt<.7&&(this.handsUp=!1);const{textModel:Mt}=this;if(Mt){const $t=xe.clone().lerp(ue,.5);Mt.position.copy($t),Mt.visible=this.handsUp}await super.update(r,d)}}const $f=new Ji,v6=(location.hostname==="experience.interality.ai","soRRAb9uymVYV5sFdkyIzSud_OPowOKv");let Jf=new URLSearchParams(window.location.search).has("rear");const Jl={onesie:{file:"shirt1rme.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Head$/,/Eye/,/Teeth/,/Bottom/,/Footwear/,/Glasses/]}},jacket:{file:"jacket.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Bottom/,/Footwear/,/Glasses/]}}};let Vu="onesie",ud=Jl.onesie.avatar;function RT(){const I=document.createElement("div");I.className="spinner-container",I.id="spinner";const r=document.createElement("div");r.className="spinner";for(let d=0;d<6;d++){const g=document.createElement("div");g.className="spinner-dot",r.appendChild(g)}return I.appendChild(r),I}async function b6(){const I=document.getElementById("root");if(!I)return;const r=new g6(I,"crop",!Jf,Jl[Vu].file,ud?void 0:Jl[Vu].outfit),d=document.getElementById("camera-switch");d&&(d.onclick=async()=>{d.disabled=!0,Jf=!Jf,await $f.setup({size:{width:1920,height:1080},rear:Jf}),await $f.start(),r.setMirror(!Jf),d.disabled=!1});const g=document.getElementById("outfit-switch");g.checked=ud,g.onchange=async()=>{X.forEach(Q=>{Q.disabled=!0}),g.disabled=!0;const K=RT();document.body.appendChild(K),ud=g.checked,await r.setOutfit(Jl[Vu].file,ud?void 0:Jl[Vu].outfit),document.body.removeChild(K),X.forEach(Q=>{Q.disabled=!1}),g.disabled=!1};const _=navigator.userAgent.indexOf("Safari")>-1&&navigator.userAgent.indexOf("Chrome")<=-1?"mp4":"webm",R=new rr(r,"video/"+_),k=document.getElementById("record");k&&(k.onclick=()=>{R?.start(),setTimeout(async()=>{const K=await R?.stop();if(!K)return;const Q=URL.createObjectURL(K),xe=document.createElement("a");xe.hidden=!0,xe.href=Q,xe.download="capture."+_,xe.click(),xe.remove(),URL.revokeObjectURL(Q)},1e4)});const X=document.getElementsByName("model");X.forEach(K=>{K.onchange=async()=>{if(K.checked&&Jl[K.value]){X.forEach(xe=>{xe.disabled=!0}),g.disabled=!0;const Q=RT();document.body.appendChild(Q),Vu=K.value,ud=Jl[Vu].avatar,await r.setOutfit(Jl[Vu].file,ud?void 0:Jl[Vu].outfit),g.checked=ud,document.body.removeChild(Q),X.forEach(xe=>{xe.disabled=!1}),g.disabled=!1}}}),await Promise.all([$f.addRenderer(r),$f.init({token:v6})]),await $f.setup({size:{width:1920,height:1080},rear:Jf}),await $f.start(),document.getElementById("dots")?.remove()}b6()})()})();
